// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armappservice

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// WebClient contains the methods for the Web group.
// Don't use this type directly, use NewWebClient() instead.
type WebClient struct {
	internal       *arm.Client
	subscriptionID string
}

// NewWebClient creates a new instance of WebClient with the specified values.
//   - subscriptionID - The ID of the target subscription. The value must be an UUID.
//   - credential - used to authorize requests. Usually a credential from azidentity.
//   - options - Contains optional client configuration. Pass nil to accept the default values.
func NewWebClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) (*WebClient, error) {
	cl, err := arm.NewClient(moduleName, moduleVersion, credential, options)
	if err != nil {
		return nil, err
	}
	client := &WebClient{
		subscriptionID: subscriptionID,
		internal:       cl,
	}
	return client, nil
}

// NewCertificateOrdersClient creates a new instance of [CertificateOrdersClient].
func (client *WebClient) NewCertificateOrdersClient() *CertificateOrdersClient {
	return &CertificateOrdersClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewCertificateRegistrationProviderClient creates a new instance of [CertificateRegistrationProviderClient].
func (client *WebClient) NewCertificateRegistrationProviderClient() *CertificateRegistrationProviderClient {
	return &CertificateRegistrationProviderClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewCertificatesClient creates a new instance of [CertificatesClient].
func (client *WebClient) NewCertificatesClient() *CertificatesClient {
	return &CertificatesClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewDeletedWebAppsClient creates a new instance of [DeletedWebAppsClient].
func (client *WebClient) NewDeletedWebAppsClient() *DeletedWebAppsClient {
	return &DeletedWebAppsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewDiagnosticsClient creates a new instance of [DiagnosticsClient].
func (client *WebClient) NewDiagnosticsClient() *DiagnosticsClient {
	return &DiagnosticsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewDomainsClient creates a new instance of [DomainsClient].
func (client *WebClient) NewDomainsClient() *DomainsClient {
	return &DomainsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewEnvironmentsClient creates a new instance of [EnvironmentsClient].
func (client *WebClient) NewEnvironmentsClient() *EnvironmentsClient {
	return &EnvironmentsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewGetUsagesInLocationClient creates a new instance of [GetUsagesInLocationClient].
func (client *WebClient) NewGetUsagesInLocationClient() *GetUsagesInLocationClient {
	return &GetUsagesInLocationClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewGlobalClient creates a new instance of [GlobalClient].
func (client *WebClient) NewGlobalClient() *GlobalClient {
	return &GlobalClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewKubeEnvironmentsClient creates a new instance of [KubeEnvironmentsClient].
func (client *WebClient) NewKubeEnvironmentsClient() *KubeEnvironmentsClient {
	return &KubeEnvironmentsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewPlansClient creates a new instance of [PlansClient].
func (client *WebClient) NewPlansClient() *PlansClient {
	return &PlansClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewProviderClient creates a new instance of [ProviderClient].
func (client *WebClient) NewProviderClient() *ProviderClient {
	return &ProviderClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewRecommendationsClient creates a new instance of [RecommendationsClient].
func (client *WebClient) NewRecommendationsClient() *RecommendationsClient {
	return &RecommendationsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewResourceHealthMetadataClient creates a new instance of [ResourceHealthMetadataClient].
func (client *WebClient) NewResourceHealthMetadataClient() *ResourceHealthMetadataClient {
	return &ResourceHealthMetadataClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewSiteCertificatesClient creates a new instance of [SiteCertificatesClient].
func (client *WebClient) NewSiteCertificatesClient() *SiteCertificatesClient {
	return &SiteCertificatesClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewSourceControlsClient creates a new instance of [SourceControlsClient].
func (client *WebClient) NewSourceControlsClient() *SourceControlsClient {
	return &SourceControlsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewStaticSitesClient creates a new instance of [StaticSitesClient].
func (client *WebClient) NewStaticSitesClient() *StaticSitesClient {
	return &StaticSitesClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewTopLevelDomainsClient creates a new instance of [TopLevelDomainsClient].
func (client *WebClient) NewTopLevelDomainsClient() *TopLevelDomainsClient {
	return &TopLevelDomainsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewUsersClient creates a new instance of [UsersClient].
func (client *WebClient) NewUsersClient() *UsersClient {
	return &UsersClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWebAppsClient creates a new instance of [WebAppsClient].
func (client *WebClient) NewWebAppsClient() *WebAppsClient {
	return &WebAppsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowRunActionRepetitionsClient creates a new instance of [WorkflowRunActionRepetitionsClient].
func (client *WebClient) NewWorkflowRunActionRepetitionsClient() *WorkflowRunActionRepetitionsClient {
	return &WorkflowRunActionRepetitionsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowRunActionRepetitionsRequestHistoriesClient creates a new instance of [WorkflowRunActionRepetitionsRequestHistoriesClient].
func (client *WebClient) NewWorkflowRunActionRepetitionsRequestHistoriesClient() *WorkflowRunActionRepetitionsRequestHistoriesClient {
	return &WorkflowRunActionRepetitionsRequestHistoriesClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowRunActionScopeRepetitionsClient creates a new instance of [WorkflowRunActionScopeRepetitionsClient].
func (client *WebClient) NewWorkflowRunActionScopeRepetitionsClient() *WorkflowRunActionScopeRepetitionsClient {
	return &WorkflowRunActionScopeRepetitionsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowRunActionsClient creates a new instance of [WorkflowRunActionsClient].
func (client *WebClient) NewWorkflowRunActionsClient() *WorkflowRunActionsClient {
	return &WorkflowRunActionsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowRunsClient creates a new instance of [WorkflowRunsClient].
func (client *WebClient) NewWorkflowRunsClient() *WorkflowRunsClient {
	return &WorkflowRunsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowTriggerHistoriesClient creates a new instance of [WorkflowTriggerHistoriesClient].
func (client *WebClient) NewWorkflowTriggerHistoriesClient() *WorkflowTriggerHistoriesClient {
	return &WorkflowTriggerHistoriesClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowTriggersClient creates a new instance of [WorkflowTriggersClient].
func (client *WebClient) NewWorkflowTriggersClient() *WorkflowTriggersClient {
	return &WorkflowTriggersClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowVersionsClient creates a new instance of [WorkflowVersionsClient].
func (client *WebClient) NewWorkflowVersionsClient() *WorkflowVersionsClient {
	return &WorkflowVersionsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// NewWorkflowsClient creates a new instance of [WorkflowsClient].
func (client *WebClient) NewWorkflowsClient() *WorkflowsClient {
	return &WorkflowsClient{
		internal:       client.internal,
		subscriptionID: client.subscriptionID,
	}
}

// CheckNameAvailability - Check if a resource name is available.
//
// Description for Check if a resource name is available.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - request - The request body
//   - options - WebClientCheckNameAvailabilityOptions contains the optional parameters for the WebClient.CheckNameAvailability
//     method.
func (client *WebClient) CheckNameAvailability(ctx context.Context, request ResourceNameAvailabilityRequest, options *WebClientCheckNameAvailabilityOptions) (WebClientCheckNameAvailabilityResponse, error) {
	var err error
	const operationName = "WebClient.CheckNameAvailability"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkNameAvailabilityCreateRequest(ctx, request, options)
	if err != nil {
		return WebClientCheckNameAvailabilityResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientCheckNameAvailabilityResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebClientCheckNameAvailabilityResponse{}, err
	}
	resp, err := client.checkNameAvailabilityHandleResponse(httpResp)
	return resp, err
}

// checkNameAvailabilityCreateRequest creates the CheckNameAvailability request.
func (client *WebClient) checkNameAvailabilityCreateRequest(ctx context.Context, request ResourceNameAvailabilityRequest, _ *WebClientCheckNameAvailabilityOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/checknameavailability"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// checkNameAvailabilityHandleResponse handles the CheckNameAvailability response.
func (client *WebClient) checkNameAvailabilityHandleResponse(resp *http.Response) (WebClientCheckNameAvailabilityResponse, error) {
	result := WebClientCheckNameAvailabilityResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResourceNameAvailability); err != nil {
		return WebClientCheckNameAvailabilityResponse{}, err
	}
	return result, nil
}

// GetSubscriptionDeploymentLocations - Gets list of available geo regions plus ministamps
//
// Description for Gets list of available geo regions plus ministamps
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - options - WebClientGetSubscriptionDeploymentLocationsOptions contains the optional parameters for the WebClient.GetSubscriptionDeploymentLocations
//     method.
func (client *WebClient) GetSubscriptionDeploymentLocations(ctx context.Context, options *WebClientGetSubscriptionDeploymentLocationsOptions) (WebClientGetSubscriptionDeploymentLocationsResponse, error) {
	var err error
	const operationName = "WebClient.GetSubscriptionDeploymentLocations"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSubscriptionDeploymentLocationsCreateRequest(ctx, options)
	if err != nil {
		return WebClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	resp, err := client.getSubscriptionDeploymentLocationsHandleResponse(httpResp)
	return resp, err
}

// getSubscriptionDeploymentLocationsCreateRequest creates the GetSubscriptionDeploymentLocations request.
func (client *WebClient) getSubscriptionDeploymentLocationsCreateRequest(ctx context.Context, _ *WebClientGetSubscriptionDeploymentLocationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/deploymentLocations"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSubscriptionDeploymentLocationsHandleResponse handles the GetSubscriptionDeploymentLocations response.
func (client *WebClient) getSubscriptionDeploymentLocationsHandleResponse(resp *http.Response) (WebClientGetSubscriptionDeploymentLocationsResponse, error) {
	result := WebClientGetSubscriptionDeploymentLocationsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentLocations); err != nil {
		return WebClientGetSubscriptionDeploymentLocationsResponse{}, err
	}
	return result, nil
}

// NewListAseRegionsPager - Get a list of available ASE regions and its supported Skus.
//
// Description for get a list of available ASE regions and its supported Skus.
//
// Generated from API version 2025-03-01
//   - options - WebClientListAseRegionsOptions contains the optional parameters for the WebClient.NewListAseRegionsPager method.
func (client *WebClient) NewListAseRegionsPager(options *WebClientListAseRegionsOptions) *runtime.Pager[WebClientListAseRegionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebClientListAseRegionsResponse]{
		More: func(page WebClientListAseRegionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebClientListAseRegionsResponse) (WebClientListAseRegionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebClient.NewListAseRegionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listAseRegionsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return WebClientListAseRegionsResponse{}, err
			}
			return client.listAseRegionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listAseRegionsCreateRequest creates the ListAseRegions request.
func (client *WebClient) listAseRegionsCreateRequest(ctx context.Context, _ *WebClientListAseRegionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/aseRegions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAseRegionsHandleResponse handles the ListAseRegions response.
func (client *WebClient) listAseRegionsHandleResponse(resp *http.Response) (WebClientListAseRegionsResponse, error) {
	result := WebClientListAseRegionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AseRegionCollection); err != nil {
		return WebClientListAseRegionsResponse{}, err
	}
	return result, nil
}

// NewListBillingMetersPager - Gets a list of meters for a given location.
//
// Description for Gets a list of meters for a given location.
//
// Generated from API version 2025-03-01
//   - options - WebClientListBillingMetersOptions contains the optional parameters for the WebClient.NewListBillingMetersPager
//     method.
func (client *WebClient) NewListBillingMetersPager(options *WebClientListBillingMetersOptions) *runtime.Pager[WebClientListBillingMetersResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebClientListBillingMetersResponse]{
		More: func(page WebClientListBillingMetersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebClientListBillingMetersResponse) (WebClientListBillingMetersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebClient.NewListBillingMetersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listBillingMetersCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return WebClientListBillingMetersResponse{}, err
			}
			return client.listBillingMetersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listBillingMetersCreateRequest creates the ListBillingMeters request.
func (client *WebClient) listBillingMetersCreateRequest(ctx context.Context, options *WebClientListBillingMetersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/billingMeters"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	if options != nil && options.BillingLocation != nil {
		reqQP.Set("billingLocation", *options.BillingLocation)
	}
	if options != nil && options.OSType != nil {
		reqQP.Set("osType", *options.OSType)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listBillingMetersHandleResponse handles the ListBillingMeters response.
func (client *WebClient) listBillingMetersHandleResponse(resp *http.Response) (WebClientListBillingMetersResponse, error) {
	result := WebClientListBillingMetersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BillingMeterCollection); err != nil {
		return WebClientListBillingMetersResponse{}, err
	}
	return result, nil
}

// NewListCustomHostNameSitesPager - Get custom hostnames under this subscription
//
// # Get custom hostnames under this subscription
//
// Generated from API version 2025-03-01
//   - options - WebClientListCustomHostNameSitesOptions contains the optional parameters for the WebClient.NewListCustomHostNameSitesPager
//     method.
func (client *WebClient) NewListCustomHostNameSitesPager(options *WebClientListCustomHostNameSitesOptions) *runtime.Pager[WebClientListCustomHostNameSitesResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebClientListCustomHostNameSitesResponse]{
		More: func(page WebClientListCustomHostNameSitesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebClientListCustomHostNameSitesResponse) (WebClientListCustomHostNameSitesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebClient.NewListCustomHostNameSitesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listCustomHostNameSitesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return WebClientListCustomHostNameSitesResponse{}, err
			}
			return client.listCustomHostNameSitesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listCustomHostNameSitesCreateRequest creates the ListCustomHostNameSites request.
func (client *WebClient) listCustomHostNameSitesCreateRequest(ctx context.Context, options *WebClientListCustomHostNameSitesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/customhostnameSites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	if options != nil && options.Hostname != nil {
		reqQP.Set("hostname", *options.Hostname)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listCustomHostNameSitesHandleResponse handles the ListCustomHostNameSites response.
func (client *WebClient) listCustomHostNameSitesHandleResponse(resp *http.Response) (WebClientListCustomHostNameSitesResponse, error) {
	result := WebClientListCustomHostNameSitesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameSitesCollection); err != nil {
		return WebClientListCustomHostNameSitesResponse{}, err
	}
	return result, nil
}

// NewListGeoRegionsPager - Get a list of available geographical regions.
//
// Description for Get a list of available geographical regions.
//
// Generated from API version 2025-03-01
//   - options - WebClientListGeoRegionsOptions contains the optional parameters for the WebClient.NewListGeoRegionsPager method.
func (client *WebClient) NewListGeoRegionsPager(options *WebClientListGeoRegionsOptions) *runtime.Pager[WebClientListGeoRegionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebClientListGeoRegionsResponse]{
		More: func(page WebClientListGeoRegionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebClientListGeoRegionsResponse) (WebClientListGeoRegionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebClient.NewListGeoRegionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listGeoRegionsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return WebClientListGeoRegionsResponse{}, err
			}
			return client.listGeoRegionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listGeoRegionsCreateRequest creates the ListGeoRegions request.
func (client *WebClient) listGeoRegionsCreateRequest(ctx context.Context, options *WebClientListGeoRegionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/geoRegions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	if options != nil && options.CustomModeWorkersEnabled != nil {
		reqQP.Set("customModeWorkersEnabled", strconv.FormatBool(*options.CustomModeWorkersEnabled))
	}
	if options != nil && options.LinuxDynamicWorkersEnabled != nil {
		reqQP.Set("linuxDynamicWorkersEnabled", strconv.FormatBool(*options.LinuxDynamicWorkersEnabled))
	}
	if options != nil && options.LinuxWorkersEnabled != nil {
		reqQP.Set("linuxWorkersEnabled", strconv.FormatBool(*options.LinuxWorkersEnabled))
	}
	if options != nil && options.SKU != nil {
		reqQP.Set("sku", string(*options.SKU))
	}
	if options != nil && options.XenonWorkersEnabled != nil {
		reqQP.Set("xenonWorkersEnabled", strconv.FormatBool(*options.XenonWorkersEnabled))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listGeoRegionsHandleResponse handles the ListGeoRegions response.
func (client *WebClient) listGeoRegionsHandleResponse(resp *http.Response) (WebClientListGeoRegionsResponse, error) {
	result := WebClientListGeoRegionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.GeoRegionCollection); err != nil {
		return WebClientListGeoRegionsResponse{}, err
	}
	return result, nil
}

// NewListPremierAddOnOffersPager - List all premier add-on offers.
//
// Description for List all premier add-on offers.
//
// Generated from API version 2025-03-01
//   - options - WebClientListPremierAddOnOffersOptions contains the optional parameters for the WebClient.NewListPremierAddOnOffersPager
//     method.
func (client *WebClient) NewListPremierAddOnOffersPager(options *WebClientListPremierAddOnOffersOptions) *runtime.Pager[WebClientListPremierAddOnOffersResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebClientListPremierAddOnOffersResponse]{
		More: func(page WebClientListPremierAddOnOffersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebClientListPremierAddOnOffersResponse) (WebClientListPremierAddOnOffersResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebClient.NewListPremierAddOnOffersPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPremierAddOnOffersCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return WebClientListPremierAddOnOffersResponse{}, err
			}
			return client.listPremierAddOnOffersHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listPremierAddOnOffersCreateRequest creates the ListPremierAddOnOffers request.
func (client *WebClient) listPremierAddOnOffersCreateRequest(ctx context.Context, _ *WebClientListPremierAddOnOffersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/premieraddonoffers"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listPremierAddOnOffersHandleResponse handles the ListPremierAddOnOffers response.
func (client *WebClient) listPremierAddOnOffersHandleResponse(resp *http.Response) (WebClientListPremierAddOnOffersResponse, error) {
	result := WebClientListPremierAddOnOffersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOnOfferCollection); err != nil {
		return WebClientListPremierAddOnOffersResponse{}, err
	}
	return result, nil
}

// ListSKUs - List all SKUs.
//
// Description for List all SKUs.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - options - WebClientListSKUsOptions contains the optional parameters for the WebClient.ListSKUs method.
func (client *WebClient) ListSKUs(ctx context.Context, options *WebClientListSKUsOptions) (WebClientListSKUsResponse, error) {
	var err error
	const operationName = "WebClient.ListSKUs"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listSKUsCreateRequest(ctx, options)
	if err != nil {
		return WebClientListSKUsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientListSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebClientListSKUsResponse{}, err
	}
	resp, err := client.listSKUsHandleResponse(httpResp)
	return resp, err
}

// listSKUsCreateRequest creates the ListSKUs request.
func (client *WebClient) listSKUsCreateRequest(ctx context.Context, _ *WebClientListSKUsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/skus"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSKUsHandleResponse handles the ListSKUs response.
func (client *WebClient) listSKUsHandleResponse(resp *http.Response) (WebClientListSKUsResponse, error) {
	result := WebClientListSKUsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SKUInfos); err != nil {
		return WebClientListSKUsResponse{}, err
	}
	return result, nil
}

// NewListSiteIdentifiersAssignedToHostNamePager - List all apps that are assigned to a hostname.
//
// Description for List all apps that are assigned to a hostname.
//
// Generated from API version 2025-03-01
//   - nameIdentifier - The request body
//   - options - WebClientListSiteIdentifiersAssignedToHostNameOptions contains the optional parameters for the WebClient.NewListSiteIdentifiersAssignedToHostNamePager
//     method.
func (client *WebClient) NewListSiteIdentifiersAssignedToHostNamePager(nameIdentifier NameIdentifier, options *WebClientListSiteIdentifiersAssignedToHostNameOptions) *runtime.Pager[WebClientListSiteIdentifiersAssignedToHostNameResponse] {
	return runtime.NewPager(runtime.PagingHandler[WebClientListSiteIdentifiersAssignedToHostNameResponse]{
		More: func(page WebClientListSiteIdentifiersAssignedToHostNameResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *WebClientListSiteIdentifiersAssignedToHostNameResponse) (WebClientListSiteIdentifiersAssignedToHostNameResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "WebClient.NewListSiteIdentifiersAssignedToHostNamePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSiteIdentifiersAssignedToHostNameCreateRequest(ctx, nameIdentifier, options)
			}, nil)
			if err != nil {
				return WebClientListSiteIdentifiersAssignedToHostNameResponse{}, err
			}
			return client.listSiteIdentifiersAssignedToHostNameHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// listSiteIdentifiersAssignedToHostNameCreateRequest creates the ListSiteIdentifiersAssignedToHostName request.
func (client *WebClient) listSiteIdentifiersAssignedToHostNameCreateRequest(ctx context.Context, nameIdentifier NameIdentifier, _ *WebClientListSiteIdentifiersAssignedToHostNameOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/listSitesAssignedToHostName"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, nameIdentifier); err != nil {
		return nil, err
	}
	return req, nil
}

// listSiteIdentifiersAssignedToHostNameHandleResponse handles the ListSiteIdentifiersAssignedToHostName response.
func (client *WebClient) listSiteIdentifiersAssignedToHostNameHandleResponse(resp *http.Response) (WebClientListSiteIdentifiersAssignedToHostNameResponse, error) {
	result := WebClientListSiteIdentifiersAssignedToHostNameResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return WebClientListSiteIdentifiersAssignedToHostNameResponse{}, err
	}
	return result, nil
}

// Move - Move resources between resource groups.
//
// Description for Move resources between resource groups.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - moveResourceEnvelope - Object that represents the resource to move.
//   - options - WebClientMoveOptions contains the optional parameters for the WebClient.Move method.
func (client *WebClient) Move(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *WebClientMoveOptions) (WebClientMoveResponse, error) {
	var err error
	const operationName = "WebClient.Move"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.moveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return WebClientMoveResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientMoveResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebClientMoveResponse{}, err
	}
	return WebClientMoveResponse{}, nil
}

// moveCreateRequest creates the Move request.
func (client *WebClient) moveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, _ *WebClientMoveOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/moveResources"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, moveResourceEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// RegionalCheckNameAvailability - Check if a resource name is available for DNL sites.
//
// Check if a resource name is available for DNL sites.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - location - The location name.
//   - request - The request body
//   - options - WebClientRegionalCheckNameAvailabilityOptions contains the optional parameters for the WebClient.RegionalCheckNameAvailability
//     method.
func (client *WebClient) RegionalCheckNameAvailability(ctx context.Context, location string, request DnlResourceNameAvailabilityRequest, options *WebClientRegionalCheckNameAvailabilityOptions) (WebClientRegionalCheckNameAvailabilityResponse, error) {
	var err error
	const operationName = "WebClient.RegionalCheckNameAvailability"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.regionalCheckNameAvailabilityCreateRequest(ctx, location, request, options)
	if err != nil {
		return WebClientRegionalCheckNameAvailabilityResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientRegionalCheckNameAvailabilityResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebClientRegionalCheckNameAvailabilityResponse{}, err
	}
	resp, err := client.regionalCheckNameAvailabilityHandleResponse(httpResp)
	return resp, err
}

// regionalCheckNameAvailabilityCreateRequest creates the RegionalCheckNameAvailability request.
func (client *WebClient) regionalCheckNameAvailabilityCreateRequest(ctx context.Context, location string, request DnlResourceNameAvailabilityRequest, _ *WebClientRegionalCheckNameAvailabilityOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/locations/{location}/checknameavailability"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if location == "" {
		return nil, errors.New("parameter location cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{location}", url.PathEscape(location))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, request); err != nil {
		return nil, err
	}
	return req, nil
}

// regionalCheckNameAvailabilityHandleResponse handles the RegionalCheckNameAvailability response.
func (client *WebClient) regionalCheckNameAvailabilityHandleResponse(resp *http.Response) (WebClientRegionalCheckNameAvailabilityResponse, error) {
	result := WebClientRegionalCheckNameAvailabilityResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DnlResourceNameAvailability); err != nil {
		return WebClientRegionalCheckNameAvailabilityResponse{}, err
	}
	return result, nil
}

// Validate - Validate if a resource can be created.
//
// Description for Validate if a resource can be created.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - validateRequest - Request with the resources to validate.
//   - options - WebClientValidateOptions contains the optional parameters for the WebClient.Validate method.
func (client *WebClient) Validate(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, options *WebClientValidateOptions) (WebClientValidateResponse, error) {
	var err error
	const operationName = "WebClient.Validate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateCreateRequest(ctx, resourceGroupName, validateRequest, options)
	if err != nil {
		return WebClientValidateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientValidateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebClientValidateResponse{}, err
	}
	resp, err := client.validateHandleResponse(httpResp)
	return resp, err
}

// validateCreateRequest creates the Validate request.
func (client *WebClient) validateCreateRequest(ctx context.Context, resourceGroupName string, validateRequest ValidateRequest, _ *WebClientValidateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/validate"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, validateRequest); err != nil {
		return nil, err
	}
	return req, nil
}

// validateHandleResponse handles the Validate response.
func (client *WebClient) validateHandleResponse(resp *http.Response) (WebClientValidateResponse, error) {
	result := WebClientValidateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ValidateResponse); err != nil {
		return WebClientValidateResponse{}, err
	}
	return result, nil
}

// ValidateMove - Validate whether a resource can be moved.
//
// Description for Validate whether a resource can be moved.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - resourceGroupName - The name of the resource group. The name is case insensitive.
//   - moveResourceEnvelope - Object that represents the resource to move.
//   - options - WebClientValidateMoveOptions contains the optional parameters for the WebClient.ValidateMove method.
func (client *WebClient) ValidateMove(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, options *WebClientValidateMoveOptions) (WebClientValidateMoveResponse, error) {
	var err error
	const operationName = "WebClient.ValidateMove"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.validateMoveCreateRequest(ctx, resourceGroupName, moveResourceEnvelope, options)
	if err != nil {
		return WebClientValidateMoveResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientValidateMoveResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return WebClientValidateMoveResponse{}, err
	}
	return WebClientValidateMoveResponse{}, nil
}

// validateMoveCreateRequest creates the ValidateMove request.
func (client *WebClient) validateMoveCreateRequest(ctx context.Context, resourceGroupName string, moveResourceEnvelope CsmMoveResourceEnvelope, _ *WebClientValidateMoveOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/validateMoveResources"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, moveResourceEnvelope); err != nil {
		return nil, err
	}
	return req, nil
}

// VerifyHostingEnvironmentVnet - Verifies if this VNET is compatible with an App Service Environment by analyzing the Network
// Security Group rules.
//
// Description for Verifies if this VNET is compatible with an App Service Environment by analyzing the Network Security Group
// rules.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2025-03-01
//   - parameters - The request body
//   - options - WebClientVerifyHostingEnvironmentVnetOptions contains the optional parameters for the WebClient.VerifyHostingEnvironmentVnet
//     method.
func (client *WebClient) VerifyHostingEnvironmentVnet(ctx context.Context, parameters VnetParameters, options *WebClientVerifyHostingEnvironmentVnetOptions) (WebClientVerifyHostingEnvironmentVnetResponse, error) {
	var err error
	const operationName = "WebClient.VerifyHostingEnvironmentVnet"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.verifyHostingEnvironmentVnetCreateRequest(ctx, parameters, options)
	if err != nil {
		return WebClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return WebClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return WebClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	resp, err := client.verifyHostingEnvironmentVnetHandleResponse(httpResp)
	return resp, err
}

// verifyHostingEnvironmentVnetCreateRequest creates the VerifyHostingEnvironmentVnet request.
func (client *WebClient) verifyHostingEnvironmentVnetCreateRequest(ctx context.Context, parameters VnetParameters, _ *WebClientVerifyHostingEnvironmentVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/verifyHostingEnvironmentVnet"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.internal.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2025-03-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// verifyHostingEnvironmentVnetHandleResponse handles the VerifyHostingEnvironmentVnet response.
func (client *WebClient) verifyHostingEnvironmentVnetHandleResponse(resp *http.Response) (WebClientVerifyHostingEnvironmentVnetResponse, error) {
	result := WebClientVerifyHostingEnvironmentVnetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetValidationFailureDetails); err != nil {
		return WebClientVerifyHostingEnvironmentVnetResponse{}, err
	}
	return result, nil
}
