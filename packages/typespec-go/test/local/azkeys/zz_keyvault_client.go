// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package azkeys

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// KeyVaultClient - The key vault client performs cryptographic key operations and vault operations
// against the Key Vault service.
// Don't use this type directly, use a constructor function instead.
type KeyVaultClient struct {
	internal     *azcore.Client
	vaultBaseUrl string
}

// BackupKey - Requests that a backup of the specified key be downloaded to the client.
//
// The Key Backup operation exports a key from Azure Key Vault in a protected
// form. Note that this operation does NOT return key material in a form that can
// be used outside the Azure Key Vault system, the returned key material is either
// protected to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of
// this operation is to allow a client to GENERATE a key in one Azure Key Vault
// instance, BACKUP the key, and then RESTORE it into another Azure Key Vault
// instance. The BACKUP operation may be used to export, in protected form, any
// key type from Azure Key Vault. Individual versions of a key cannot be backed
// up. BACKUP / RESTORE can be performed within geographical boundaries only;
// meaning that a BACKUP from one geographical area cannot be restored to another
// geographical area. For example, a backup from the US geographical area cannot
// be restored in an EU geographical area. This operation requires the key/backup
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - options - KeyVaultClientBackupKeyOptions contains the optional parameters for the KeyVaultClient.BackupKey method.
func (client *KeyVaultClient) BackupKey(ctx context.Context, keyName string, options *KeyVaultClientBackupKeyOptions) (KeyVaultClientBackupKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.BackupKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.backupKeyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientBackupKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientBackupKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientBackupKeyResponse{}, err
	}
	resp, err := client.backupKeyHandleResponse(httpResp)
	return resp, err
}

// backupKeyCreateRequest creates the BackupKey request.
func (client *KeyVaultClient) backupKeyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientBackupKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/backup"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupKeyHandleResponse handles the BackupKey response.
func (client *KeyVaultClient) backupKeyHandleResponse(resp *http.Response) (KeyVaultClientBackupKeyResponse, error) {
	result := KeyVaultClientBackupKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupKeyResult); err != nil {
		return KeyVaultClientBackupKeyResponse{}, err
	}
	return result, nil
}

// CreateKey - Creates a new key, stores it, then returns key parameters and attributes to the
// client.
//
// The create key operation can be used to create any key type in Azure Key Vault.
// If the named key already exists, Azure Key Vault creates a new version of the
// key. It requires the keys/create permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name for the new key. The system will generate the version name for the new
//     key. The value you provide may be copied globally for the purpose of running
//     the service. The value provided should not include personally identifiable or
//     sensitive information.
//   - parameters - The parameters to create a key.
//   - options - KeyVaultClientCreateKeyOptions contains the optional parameters for the KeyVaultClient.CreateKey method.
func (client *KeyVaultClient) CreateKey(ctx context.Context, keyName string, parameters KeyCreateParameters, options *KeyVaultClientCreateKeyOptions) (KeyVaultClientCreateKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.CreateKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createKeyCreateRequest(ctx, keyName, parameters, options)
	if err != nil {
		return KeyVaultClientCreateKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientCreateKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientCreateKeyResponse{}, err
	}
	resp, err := client.createKeyHandleResponse(httpResp)
	return resp, err
}

// createKeyCreateRequest creates the CreateKey request.
func (client *KeyVaultClient) createKeyCreateRequest(ctx context.Context, keyName string, parameters KeyCreateParameters, _ *KeyVaultClientCreateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/create"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// createKeyHandleResponse handles the CreateKey response.
func (client *KeyVaultClient) createKeyHandleResponse(resp *http.Response) (KeyVaultClientCreateKeyResponse, error) {
	result := KeyVaultClientCreateKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientCreateKeyResponse{}, err
	}
	return result, nil
}

// Decrypt - Decrypts a single block of encrypted data.
//
// The DECRYPT operation decrypts a well-formed block of ciphertext using the
// target encryption key and specified algorithm. This operation is the reverse of
// the ENCRYPT operation; only a single block of data may be decrypted, the size
// of this block is dependent on the target key and the algorithm to be used. The
// DECRYPT operation applies to asymmetric and symmetric keys stored in Azure Key
// Vault since it uses the private portion of the key. This operation requires the
// keys/decrypt permission. Microsoft recommends not to use CBC algorithms for
// decryption without first ensuring the integrity of the ciphertext using an
// HMAC, for example. See
// https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode
// for more information.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the decryption operation.
//   - options - KeyVaultClientDecryptOptions contains the optional parameters for the KeyVaultClient.Decrypt method.
func (client *KeyVaultClient) Decrypt(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientDecryptOptions) (KeyVaultClientDecryptResponse, error) {
	var err error
	const operationName = "KeyVaultClient.Decrypt"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.decryptCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientDecryptResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDecryptResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientDecryptResponse{}, err
	}
	resp, err := client.decryptHandleResponse(httpResp)
	return resp, err
}

// decryptCreateRequest creates the Decrypt request.
func (client *KeyVaultClient) decryptCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, _ *KeyVaultClientDecryptOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/decrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// decryptHandleResponse handles the Decrypt response.
func (client *KeyVaultClient) decryptHandleResponse(resp *http.Response) (KeyVaultClientDecryptResponse, error) {
	result := KeyVaultClientDecryptResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return KeyVaultClientDecryptResponse{}, err
	}
	return result, nil
}

// DeleteKey - Deletes a key of any type from storage in Azure Key Vault.
//
// The delete key operation cannot be used to remove individual versions of a key.
// This operation removes the cryptographic material associated with the key,
// which means the key is not usable for Sign/Verify, Wrap/Unwrap or
// Encrypt/Decrypt operations. This operation requires the keys/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key to delete.
//   - options - KeyVaultClientDeleteKeyOptions contains the optional parameters for the KeyVaultClient.DeleteKey method.
func (client *KeyVaultClient) DeleteKey(ctx context.Context, keyName string, options *KeyVaultClientDeleteKeyOptions) (KeyVaultClientDeleteKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.DeleteKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.deleteKeyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientDeleteKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientDeleteKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientDeleteKeyResponse{}, err
	}
	resp, err := client.deleteKeyHandleResponse(httpResp)
	return resp, err
}

// deleteKeyCreateRequest creates the DeleteKey request.
func (client *KeyVaultClient) deleteKeyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientDeleteKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteKeyHandleResponse handles the DeleteKey response.
func (client *KeyVaultClient) deleteKeyHandleResponse(resp *http.Response) (KeyVaultClientDeleteKeyResponse, error) {
	result := KeyVaultClientDeleteKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedKeyBundle); err != nil {
		return KeyVaultClientDeleteKeyResponse{}, err
	}
	return result, nil
}

// Encrypt - Encrypts an arbitrary sequence of bytes using an encryption key that is stored
// in a key vault.
//
// The ENCRYPT operation encrypts an arbitrary sequence of bytes using an
// encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
// operation only supports a single block of data, the size of which is dependent
// on the target key and the encryption algorithm to be used. The ENCRYPT
// operation is only strictly necessary for symmetric keys stored in Azure Key
// Vault since protection with an asymmetric key can be performed using public
// portion of the key. This operation is supported for asymmetric keys as a
// convenience for callers that have a key-reference but do not have access to the
// public key material. This operation requires the keys/encrypt permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the encryption operation.
//   - options - KeyVaultClientEncryptOptions contains the optional parameters for the KeyVaultClient.Encrypt method.
func (client *KeyVaultClient) Encrypt(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientEncryptOptions) (KeyVaultClientEncryptResponse, error) {
	var err error
	const operationName = "KeyVaultClient.Encrypt"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.encryptCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientEncryptResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientEncryptResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientEncryptResponse{}, err
	}
	resp, err := client.encryptHandleResponse(httpResp)
	return resp, err
}

// encryptCreateRequest creates the Encrypt request.
func (client *KeyVaultClient) encryptCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, _ *KeyVaultClientEncryptOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/encrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// encryptHandleResponse handles the Encrypt response.
func (client *KeyVaultClient) encryptHandleResponse(resp *http.Response) (KeyVaultClientEncryptResponse, error) {
	result := KeyVaultClientEncryptResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return KeyVaultClientEncryptResponse{}, err
	}
	return result, nil
}

// GetDeletedKey - Gets the public part of a deleted key.
//
// The Get Deleted Key operation is applicable for soft-delete enabled vaults.
// While the operation can be invoked on any vault, it will return an error if
// invoked on a non soft-delete enabled vault. This operation requires the
// keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - options - KeyVaultClientGetDeletedKeyOptions contains the optional parameters for the KeyVaultClient.GetDeletedKey method.
func (client *KeyVaultClient) GetDeletedKey(ctx context.Context, keyName string, options *KeyVaultClientGetDeletedKeyOptions) (KeyVaultClientGetDeletedKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.GetDeletedKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDeletedKeyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientGetDeletedKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetDeletedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientGetDeletedKeyResponse{}, err
	}
	resp, err := client.getDeletedKeyHandleResponse(httpResp)
	return resp, err
}

// getDeletedKeyCreateRequest creates the GetDeletedKey request.
func (client *KeyVaultClient) getDeletedKeyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientGetDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedKeyHandleResponse handles the GetDeletedKey response.
func (client *KeyVaultClient) getDeletedKeyHandleResponse(resp *http.Response) (KeyVaultClientGetDeletedKeyResponse, error) {
	result := KeyVaultClientGetDeletedKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedKeyBundle); err != nil {
		return KeyVaultClientGetDeletedKeyResponse{}, err
	}
	return result, nil
}

// NewGetDeletedKeysPager - Lists the deleted keys in the specified vault.
//
// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
// contain the public part of a deleted key. This operation includes
// deletion-specific information. The Get Deleted Keys operation is applicable for
// vaults enabled for soft-delete. While the operation can be invoked on any
// vault, it will return an error if invoked on a non soft-delete enabled vault.
// This operation requires the keys/list permission.
//
// Generated from API version 7.6-preview.1
//   - options - KeyVaultClientGetDeletedKeysOptions contains the optional parameters for the KeyVaultClient.NewGetDeletedKeysPager
//     method.
func (client *KeyVaultClient) NewGetDeletedKeysPager(options *KeyVaultClientGetDeletedKeysOptions) *runtime.Pager[KeyVaultClientGetDeletedKeysResponse] {
	return runtime.NewPager(runtime.PagingHandler[KeyVaultClientGetDeletedKeysResponse]{
		More: func(page KeyVaultClientGetDeletedKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *KeyVaultClientGetDeletedKeysResponse) (KeyVaultClientGetDeletedKeysResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "KeyVaultClient.NewGetDeletedKeysPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getDeletedKeysCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return KeyVaultClientGetDeletedKeysResponse{}, err
			}
			return client.getDeletedKeysHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getDeletedKeysCreateRequest creates the GetDeletedKeys request.
func (client *KeyVaultClient) getDeletedKeysCreateRequest(ctx context.Context, options *KeyVaultClientGetDeletedKeysOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedkeys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedKeysHandleResponse handles the GetDeletedKeys response.
func (client *KeyVaultClient) getDeletedKeysHandleResponse(resp *http.Response) (KeyVaultClientGetDeletedKeysResponse, error) {
	result := KeyVaultClientGetDeletedKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedKeyListResult); err != nil {
		return KeyVaultClientGetDeletedKeysResponse{}, err
	}
	return result, nil
}

// GetKey - Gets the public part of a stored key.
//
// The get key operation is applicable to all key types. If the requested key is
// symmetric, then no key material is released in the response. This operation
// requires the keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key to get.
//   - keyVersion - Adding the version parameter retrieves a specific version of a key. This URI
//     fragment is optional. If not specified, the latest version of the key is
//     returned.
//   - options - KeyVaultClientGetKeyOptions contains the optional parameters for the KeyVaultClient.GetKey method.
func (client *KeyVaultClient) GetKey(ctx context.Context, keyName string, keyVersion string, options *KeyVaultClientGetKeyOptions) (KeyVaultClientGetKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.GetKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getKeyCreateRequest(ctx, keyName, keyVersion, options)
	if err != nil {
		return KeyVaultClientGetKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientGetKeyResponse{}, err
	}
	resp, err := client.getKeyHandleResponse(httpResp)
	return resp, err
}

// getKeyCreateRequest creates the GetKey request.
func (client *KeyVaultClient) getKeyCreateRequest(ctx context.Context, keyName string, keyVersion string, _ *KeyVaultClientGetKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyHandleResponse handles the GetKey response.
func (client *KeyVaultClient) getKeyHandleResponse(resp *http.Response) (KeyVaultClientGetKeyResponse, error) {
	result := KeyVaultClientGetKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientGetKeyResponse{}, err
	}
	return result, nil
}

// GetKeyRotationPolicy - Lists the policy for a key.
//
// The GetKeyRotationPolicy operation returns the specified key policy resources
// in the specified key vault. This operation requires the keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key in a given key vault.
//   - options - KeyVaultClientGetKeyRotationPolicyOptions contains the optional parameters for the KeyVaultClient.GetKeyRotationPolicy
//     method.
func (client *KeyVaultClient) GetKeyRotationPolicy(ctx context.Context, keyName string, options *KeyVaultClientGetKeyRotationPolicyOptions) (KeyVaultClientGetKeyRotationPolicyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.GetKeyRotationPolicy"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getKeyRotationPolicyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientGetKeyRotationPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetKeyRotationPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientGetKeyRotationPolicyResponse{}, err
	}
	resp, err := client.getKeyRotationPolicyHandleResponse(httpResp)
	return resp, err
}

// getKeyRotationPolicyCreateRequest creates the GetKeyRotationPolicy request.
func (client *KeyVaultClient) getKeyRotationPolicyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientGetKeyRotationPolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/rotationpolicy"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyRotationPolicyHandleResponse handles the GetKeyRotationPolicy response.
func (client *KeyVaultClient) getKeyRotationPolicyHandleResponse(resp *http.Response) (KeyVaultClientGetKeyRotationPolicyResponse, error) {
	result := KeyVaultClientGetKeyRotationPolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyRotationPolicy); err != nil {
		return KeyVaultClientGetKeyRotationPolicyResponse{}, err
	}
	return result, nil
}

// NewGetKeyVersionsPager - Retrieves a list of individual key versions with the same key name.
//
// The full key identifier, attributes, and tags are provided in the response.
// This operation requires the keys/list permission.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - options - KeyVaultClientGetKeyVersionsOptions contains the optional parameters for the KeyVaultClient.NewGetKeyVersionsPager
//     method.
func (client *KeyVaultClient) NewGetKeyVersionsPager(keyName string, options *KeyVaultClientGetKeyVersionsOptions) *runtime.Pager[KeyVaultClientGetKeyVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[KeyVaultClientGetKeyVersionsResponse]{
		More: func(page KeyVaultClientGetKeyVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *KeyVaultClientGetKeyVersionsResponse) (KeyVaultClientGetKeyVersionsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "KeyVaultClient.NewGetKeyVersionsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getKeyVersionsCreateRequest(ctx, keyName, options)
			}, nil)
			if err != nil {
				return KeyVaultClientGetKeyVersionsResponse{}, err
			}
			return client.getKeyVersionsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getKeyVersionsCreateRequest creates the GetKeyVersions request.
func (client *KeyVaultClient) getKeyVersionsCreateRequest(ctx context.Context, keyName string, options *KeyVaultClientGetKeyVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/versions"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyVersionsHandleResponse handles the GetKeyVersions response.
func (client *KeyVaultClient) getKeyVersionsHandleResponse(resp *http.Response) (KeyVaultClientGetKeyVersionsResponse, error) {
	result := KeyVaultClientGetKeyVersionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		return KeyVaultClientGetKeyVersionsResponse{}, err
	}
	return result, nil
}

// NewGetKeysPager - List keys in the specified vault.
//
// Retrieves a list of the keys in the Key Vault as JSON Web Key structures that
// contain the public part of a stored key. The LIST operation is applicable to
// all key types, however only the base key identifier, attributes, and tags are
// provided in the response. Individual versions of a key are not listed in the
// response. This operation requires the keys/list permission.
//
// Generated from API version 7.6-preview.1
//   - options - KeyVaultClientGetKeysOptions contains the optional parameters for the KeyVaultClient.NewGetKeysPager method.
func (client *KeyVaultClient) NewGetKeysPager(options *KeyVaultClientGetKeysOptions) *runtime.Pager[KeyVaultClientGetKeysResponse] {
	return runtime.NewPager(runtime.PagingHandler[KeyVaultClientGetKeysResponse]{
		More: func(page KeyVaultClientGetKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *KeyVaultClientGetKeysResponse) (KeyVaultClientGetKeysResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "KeyVaultClient.NewGetKeysPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getKeysCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return KeyVaultClientGetKeysResponse{}, err
			}
			return client.getKeysHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getKeysCreateRequest creates the GetKeys request.
func (client *KeyVaultClient) getKeysCreateRequest(ctx context.Context, options *KeyVaultClientGetKeysOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeysHandleResponse handles the GetKeys response.
func (client *KeyVaultClient) getKeysHandleResponse(resp *http.Response) (KeyVaultClientGetKeysResponse, error) {
	result := KeyVaultClientGetKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		return KeyVaultClientGetKeysResponse{}, err
	}
	return result, nil
}

// GetRandomBytes - Get the requested number of bytes containing random values.
//
// Get the requested number of bytes containing random values from a managed HSM.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - parameters - The request object to get random bytes.
//   - options - KeyVaultClientGetRandomBytesOptions contains the optional parameters for the KeyVaultClient.GetRandomBytes method.
func (client *KeyVaultClient) GetRandomBytes(ctx context.Context, parameters GetRandomBytesRequest, options *KeyVaultClientGetRandomBytesOptions) (KeyVaultClientGetRandomBytesResponse, error) {
	var err error
	const operationName = "KeyVaultClient.GetRandomBytes"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getRandomBytesCreateRequest(ctx, parameters, options)
	if err != nil {
		return KeyVaultClientGetRandomBytesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientGetRandomBytesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientGetRandomBytesResponse{}, err
	}
	resp, err := client.getRandomBytesHandleResponse(httpResp)
	return resp, err
}

// getRandomBytesCreateRequest creates the GetRandomBytes request.
func (client *KeyVaultClient) getRandomBytesCreateRequest(ctx context.Context, parameters GetRandomBytesRequest, _ *KeyVaultClientGetRandomBytesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/rng"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// getRandomBytesHandleResponse handles the GetRandomBytes response.
func (client *KeyVaultClient) getRandomBytesHandleResponse(resp *http.Response) (KeyVaultClientGetRandomBytesResponse, error) {
	result := KeyVaultClientGetRandomBytesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RandomBytes); err != nil {
		return KeyVaultClientGetRandomBytesResponse{}, err
	}
	return result, nil
}

// ImportKey - Imports an externally created key, stores it, and returns key parameters and
// attributes to the client.
//
// The import key operation may be used to import any key type into an Azure Key
// Vault. If the named key already exists, Azure Key Vault creates a new version
// of the key. This operation requires the keys/import permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - Name for the imported key. The value you provide may be copied globally for the
//     purpose of running the service. The value provided should not include
//     personally identifiable or sensitive information.
//   - parameters - The parameters to import a key.
//   - options - KeyVaultClientImportKeyOptions contains the optional parameters for the KeyVaultClient.ImportKey method.
func (client *KeyVaultClient) ImportKey(ctx context.Context, keyName string, parameters KeyImportParameters, options *KeyVaultClientImportKeyOptions) (KeyVaultClientImportKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.ImportKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.importKeyCreateRequest(ctx, keyName, parameters, options)
	if err != nil {
		return KeyVaultClientImportKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientImportKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientImportKeyResponse{}, err
	}
	resp, err := client.importKeyHandleResponse(httpResp)
	return resp, err
}

// importKeyCreateRequest creates the ImportKey request.
func (client *KeyVaultClient) importKeyCreateRequest(ctx context.Context, keyName string, parameters KeyImportParameters, _ *KeyVaultClientImportKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// importKeyHandleResponse handles the ImportKey response.
func (client *KeyVaultClient) importKeyHandleResponse(resp *http.Response) (KeyVaultClientImportKeyResponse, error) {
	result := KeyVaultClientImportKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientImportKeyResponse{}, err
	}
	return result, nil
}

// PurgeDeletedKey - Permanently deletes the specified key.
//
// The Purge Deleted Key operation is applicable for soft-delete enabled vaults.
// While the operation can be invoked on any vault, it will return an error if
// invoked on a non soft-delete enabled vault. This operation requires the
// keys/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key
//   - options - KeyVaultClientPurgeDeletedKeyOptions contains the optional parameters for the KeyVaultClient.PurgeDeletedKey
//     method.
func (client *KeyVaultClient) PurgeDeletedKey(ctx context.Context, keyName string, options *KeyVaultClientPurgeDeletedKeyOptions) (KeyVaultClientPurgeDeletedKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.PurgeDeletedKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.purgeDeletedKeyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientPurgeDeletedKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientPurgeDeletedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientPurgeDeletedKeyResponse{}, err
	}
	return KeyVaultClientPurgeDeletedKeyResponse{}, nil
}

// purgeDeletedKeyCreateRequest creates the PurgeDeletedKey request.
func (client *KeyVaultClient) purgeDeletedKeyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientPurgeDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RecoverDeletedKey - Recovers the deleted key to its latest version.
//
// The Recover Deleted Key operation is applicable for deleted keys in soft-delete
// enabled vaults. It recovers the deleted key back to its latest version under
// /keys. An attempt to recover an non-deleted key will return an error. Consider
// this the inverse of the delete operation on soft-delete enabled vaults. This
// operation requires the keys/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the deleted key.
//   - options - KeyVaultClientRecoverDeletedKeyOptions contains the optional parameters for the KeyVaultClient.RecoverDeletedKey
//     method.
func (client *KeyVaultClient) RecoverDeletedKey(ctx context.Context, keyName string, options *KeyVaultClientRecoverDeletedKeyOptions) (KeyVaultClientRecoverDeletedKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.RecoverDeletedKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.recoverDeletedKeyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientRecoverDeletedKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRecoverDeletedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientRecoverDeletedKeyResponse{}, err
	}
	resp, err := client.recoverDeletedKeyHandleResponse(httpResp)
	return resp, err
}

// recoverDeletedKeyCreateRequest creates the RecoverDeletedKey request.
func (client *KeyVaultClient) recoverDeletedKeyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientRecoverDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/deletedkeys/{key-name}/recover"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedKeyHandleResponse handles the RecoverDeletedKey response.
func (client *KeyVaultClient) recoverDeletedKeyHandleResponse(resp *http.Response) (KeyVaultClientRecoverDeletedKeyResponse, error) {
	result := KeyVaultClientRecoverDeletedKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientRecoverDeletedKeyResponse{}, err
	}
	return result, nil
}

// Release - Releases a key.
//
// The release key operation is applicable to all key types. The target key must
// be marked exportable. This operation requires the keys/release permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key to get.
//   - keyVersion - Adding the version parameter retrieves a specific version of a key.
//   - parameters - The parameters for the key release operation.
//   - options - KeyVaultClientReleaseOptions contains the optional parameters for the KeyVaultClient.Release method.
func (client *KeyVaultClient) Release(ctx context.Context, keyName string, keyVersion string, parameters KeyReleaseParameters, options *KeyVaultClientReleaseOptions) (KeyVaultClientReleaseResponse, error) {
	var err error
	const operationName = "KeyVaultClient.Release"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.releaseCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientReleaseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientReleaseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientReleaseResponse{}, err
	}
	resp, err := client.releaseHandleResponse(httpResp)
	return resp, err
}

// releaseCreateRequest creates the Release request.
func (client *KeyVaultClient) releaseCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyReleaseParameters, _ *KeyVaultClientReleaseOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/release"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// releaseHandleResponse handles the Release response.
func (client *KeyVaultClient) releaseHandleResponse(resp *http.Response) (KeyVaultClientReleaseResponse, error) {
	result := KeyVaultClientReleaseResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyReleaseResult); err != nil {
		return KeyVaultClientReleaseResponse{}, err
	}
	return result, nil
}

// RestoreKey - Restores a backed up key to a vault.
//
// Imports a previously backed up key into Azure Key Vault, restoring the key, its
// key identifier, attributes and access control policies. The RESTORE operation
// may be used to import a previously backed up key. Individual versions of a key
// cannot be restored. The key is restored in its entirety with the same key name
// as it had when it was backed up. If the key name is not available in the target
// Key Vault, the RESTORE operation will be rejected. While the key name is
// retained during restore, the final key identifier will change if the key is
// restored to a different vault. Restore will restore all versions and preserve
// version identifiers. The RESTORE operation is subject to security constraints:
// The target Key Vault must be owned by the same Microsoft Azure Subscription as
// the source Key Vault The user must have RESTORE permission in the target Key
// Vault. This operation requires the keys/restore permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - parameters - The parameters to restore the key.
//   - options - KeyVaultClientRestoreKeyOptions contains the optional parameters for the KeyVaultClient.RestoreKey method.
func (client *KeyVaultClient) RestoreKey(ctx context.Context, parameters KeyRestoreParameters, options *KeyVaultClientRestoreKeyOptions) (KeyVaultClientRestoreKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.RestoreKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.restoreKeyCreateRequest(ctx, parameters, options)
	if err != nil {
		return KeyVaultClientRestoreKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRestoreKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientRestoreKeyResponse{}, err
	}
	resp, err := client.restoreKeyHandleResponse(httpResp)
	return resp, err
}

// restoreKeyCreateRequest creates the RestoreKey request.
func (client *KeyVaultClient) restoreKeyCreateRequest(ctx context.Context, parameters KeyRestoreParameters, _ *KeyVaultClientRestoreKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// restoreKeyHandleResponse handles the RestoreKey response.
func (client *KeyVaultClient) restoreKeyHandleResponse(resp *http.Response) (KeyVaultClientRestoreKeyResponse, error) {
	result := KeyVaultClientRestoreKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientRestoreKeyResponse{}, err
	}
	return result, nil
}

// RotateKey - Creates a new key version, stores it, then returns key parameters, attributes
// and policy to the client.
//
// The operation will rotate the key based on the key policy. It requires the
// keys/rotate permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of key to be rotated. The system will generate a new version in the
//     specified key.
//   - options - KeyVaultClientRotateKeyOptions contains the optional parameters for the KeyVaultClient.RotateKey method.
func (client *KeyVaultClient) RotateKey(ctx context.Context, keyName string, options *KeyVaultClientRotateKeyOptions) (KeyVaultClientRotateKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.RotateKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.rotateKeyCreateRequest(ctx, keyName, options)
	if err != nil {
		return KeyVaultClientRotateKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientRotateKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientRotateKeyResponse{}, err
	}
	resp, err := client.rotateKeyHandleResponse(httpResp)
	return resp, err
}

// rotateKeyCreateRequest creates the RotateKey request.
func (client *KeyVaultClient) rotateKeyCreateRequest(ctx context.Context, keyName string, _ *KeyVaultClientRotateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/rotate"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// rotateKeyHandleResponse handles the RotateKey response.
func (client *KeyVaultClient) rotateKeyHandleResponse(resp *http.Response) (KeyVaultClientRotateKeyResponse, error) {
	result := KeyVaultClientRotateKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientRotateKeyResponse{}, err
	}
	return result, nil
}

// Sign - Creates a signature from a digest using the specified key.
//
// The SIGN operation is applicable to asymmetric and symmetric keys stored in
// Azure Key Vault since this operation uses the private portion of the key. This
// operation requires the keys/sign permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the signing operation.
//   - options - KeyVaultClientSignOptions contains the optional parameters for the KeyVaultClient.Sign method.
func (client *KeyVaultClient) Sign(ctx context.Context, keyName string, keyVersion string, parameters KeySignParameters, options *KeyVaultClientSignOptions) (KeyVaultClientSignResponse, error) {
	var err error
	const operationName = "KeyVaultClient.Sign"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.signCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientSignResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientSignResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientSignResponse{}, err
	}
	resp, err := client.signHandleResponse(httpResp)
	return resp, err
}

// signCreateRequest creates the Sign request.
func (client *KeyVaultClient) signCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeySignParameters, _ *KeyVaultClientSignOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/sign"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// signHandleResponse handles the Sign response.
func (client *KeyVaultClient) signHandleResponse(resp *http.Response) (KeyVaultClientSignResponse, error) {
	result := KeyVaultClientSignResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return KeyVaultClientSignResponse{}, err
	}
	return result, nil
}

// UnwrapKey - Unwraps a symmetric key using the specified key that was initially used for
// wrapping that key.
//
// The UNWRAP operation supports decryption of a symmetric key using the target
// key encryption key. This operation is the reverse of the WRAP operation. The
// UNWRAP operation applies to asymmetric and symmetric keys stored in Azure Key
// Vault since it uses the private portion of the key. This operation requires the
// keys/unwrapKey permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the key operation.
//   - options - KeyVaultClientUnwrapKeyOptions contains the optional parameters for the KeyVaultClient.UnwrapKey method.
func (client *KeyVaultClient) UnwrapKey(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientUnwrapKeyOptions) (KeyVaultClientUnwrapKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.UnwrapKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.unwrapKeyCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientUnwrapKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUnwrapKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientUnwrapKeyResponse{}, err
	}
	resp, err := client.unwrapKeyHandleResponse(httpResp)
	return resp, err
}

// unwrapKeyCreateRequest creates the UnwrapKey request.
func (client *KeyVaultClient) unwrapKeyCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, _ *KeyVaultClientUnwrapKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/unwrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// unwrapKeyHandleResponse handles the UnwrapKey response.
func (client *KeyVaultClient) unwrapKeyHandleResponse(resp *http.Response) (KeyVaultClientUnwrapKeyResponse, error) {
	result := KeyVaultClientUnwrapKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return KeyVaultClientUnwrapKeyResponse{}, err
	}
	return result, nil
}

// UpdateKey - The update key operation changes specified attributes of a stored key and can
// be applied to any key type and key version stored in Azure Key Vault.
//
// In order to perform this operation, the key must already exist in the Key
// Vault. Note: The cryptographic material of a key itself cannot be changed. This
// operation requires the keys/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of key to update.
//   - keyVersion - The version of the key to update.
//   - parameters - The parameters of the key to update.
//   - options - KeyVaultClientUpdateKeyOptions contains the optional parameters for the KeyVaultClient.UpdateKey method.
func (client *KeyVaultClient) UpdateKey(ctx context.Context, keyName string, keyVersion string, parameters KeyUpdateParameters, options *KeyVaultClientUpdateKeyOptions) (KeyVaultClientUpdateKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.UpdateKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateKeyCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientUpdateKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientUpdateKeyResponse{}, err
	}
	resp, err := client.updateKeyHandleResponse(httpResp)
	return resp, err
}

// updateKeyCreateRequest creates the UpdateKey request.
func (client *KeyVaultClient) updateKeyCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyUpdateParameters, _ *KeyVaultClientUpdateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// updateKeyHandleResponse handles the UpdateKey response.
func (client *KeyVaultClient) updateKeyHandleResponse(resp *http.Response) (KeyVaultClientUpdateKeyResponse, error) {
	result := KeyVaultClientUpdateKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return KeyVaultClientUpdateKeyResponse{}, err
	}
	return result, nil
}

// UpdateKeyRotationPolicy - Updates the rotation policy for a key.
//
// Set specified members in the key policy. Leave others as undefined. This
// operation requires the keys/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key in the given vault.
//   - keyRotationPolicy - The policy for the key.
//   - options - KeyVaultClientUpdateKeyRotationPolicyOptions contains the optional parameters for the KeyVaultClient.UpdateKeyRotationPolicy
//     method.
func (client *KeyVaultClient) UpdateKeyRotationPolicy(ctx context.Context, keyName string, keyRotationPolicy KeyRotationPolicy, options *KeyVaultClientUpdateKeyRotationPolicyOptions) (KeyVaultClientUpdateKeyRotationPolicyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.UpdateKeyRotationPolicy"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateKeyRotationPolicyCreateRequest(ctx, keyName, keyRotationPolicy, options)
	if err != nil {
		return KeyVaultClientUpdateKeyRotationPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientUpdateKeyRotationPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientUpdateKeyRotationPolicyResponse{}, err
	}
	resp, err := client.updateKeyRotationPolicyHandleResponse(httpResp)
	return resp, err
}

// updateKeyRotationPolicyCreateRequest creates the UpdateKeyRotationPolicy request.
func (client *KeyVaultClient) updateKeyRotationPolicyCreateRequest(ctx context.Context, keyName string, keyRotationPolicy KeyRotationPolicy, _ *KeyVaultClientUpdateKeyRotationPolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/rotationpolicy"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, keyRotationPolicy); err != nil {
		return nil, err
	}
	return req, nil
}

// updateKeyRotationPolicyHandleResponse handles the UpdateKeyRotationPolicy response.
func (client *KeyVaultClient) updateKeyRotationPolicyHandleResponse(resp *http.Response) (KeyVaultClientUpdateKeyRotationPolicyResponse, error) {
	result := KeyVaultClientUpdateKeyRotationPolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyRotationPolicy); err != nil {
		return KeyVaultClientUpdateKeyRotationPolicyResponse{}, err
	}
	return result, nil
}

// Verify - Verifies a signature using a specified key.
//
// The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault.
// VERIFY is not strictly necessary for asymmetric keys stored in Azure Key Vault
// since signature verification can be performed using the public portion of the
// key but this operation is supported as a convenience for callers that only have
// a key-reference and not the public portion of the key. This operation requires
// the keys/verify permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for verify operations.
//   - options - KeyVaultClientVerifyOptions contains the optional parameters for the KeyVaultClient.Verify method.
func (client *KeyVaultClient) Verify(ctx context.Context, keyName string, keyVersion string, parameters KeyVerifyParameters, options *KeyVaultClientVerifyOptions) (KeyVaultClientVerifyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.Verify"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.verifyCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientVerifyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientVerifyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientVerifyResponse{}, err
	}
	resp, err := client.verifyHandleResponse(httpResp)
	return resp, err
}

// verifyCreateRequest creates the Verify request.
func (client *KeyVaultClient) verifyCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyVerifyParameters, _ *KeyVaultClientVerifyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/verify"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// verifyHandleResponse handles the Verify response.
func (client *KeyVaultClient) verifyHandleResponse(resp *http.Response) (KeyVaultClientVerifyResponse, error) {
	result := KeyVaultClientVerifyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyVerifyResult); err != nil {
		return KeyVaultClientVerifyResponse{}, err
	}
	return result, nil
}

// WrapKey - Wraps a symmetric key using a specified key.
//
// The WRAP operation supports encryption of a symmetric key using a key
// encryption key that has previously been stored in an Azure Key Vault. The WRAP
// operation is only strictly necessary for symmetric keys stored in Azure Key
// Vault since protection with an asymmetric key can be performed using the public
// portion of the key. This operation is supported for asymmetric keys as a
// convenience for callers that have a key-reference but do not have access to the
// public key material. This operation requires the keys/wrapKey permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.6-preview.1
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for wrap operation.
//   - options - KeyVaultClientWrapKeyOptions contains the optional parameters for the KeyVaultClient.WrapKey method.
func (client *KeyVaultClient) WrapKey(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientWrapKeyOptions) (KeyVaultClientWrapKeyResponse, error) {
	var err error
	const operationName = "KeyVaultClient.WrapKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.wrapKeyCreateRequest(ctx, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVaultClientWrapKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return KeyVaultClientWrapKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return KeyVaultClientWrapKeyResponse{}, err
	}
	resp, err := client.wrapKeyHandleResponse(httpResp)
	return resp, err
}

// wrapKeyCreateRequest creates the WrapKey request.
func (client *KeyVaultClient) wrapKeyCreateRequest(ctx context.Context, keyName string, keyVersion string, parameters KeyOperationsParameters, _ *KeyVaultClientWrapKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", client.vaultBaseUrl)
	urlPath := "/keys/{key-name}/{key-version}/wrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.6-preview.1")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, parameters); err != nil {
		return nil, err
	}
	return req, nil
}

// wrapKeyHandleResponse handles the WrapKey response.
func (client *KeyVaultClient) wrapKeyHandleResponse(resp *http.Response) (KeyVaultClientWrapKeyResponse, error) {
	result := KeyVaultClientWrapKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return KeyVaultClientWrapKeyResponse{}, err
	}
	return result, nil
}
