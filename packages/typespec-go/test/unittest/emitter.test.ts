import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, readFile } from 'fs/promises';
import { existsSync, rmSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';
import { cleanupGeneratedFiles } from '../../src/emitter.js';

// Types for the diagnostic object
interface MockDiagnostic {
  code: string;
  severity: string;
  message: string;
  target: unknown;
}

// Simple mock context type
interface MockContext {
  diagnostics: MockDiagnostic[];
  program: {
    reportDiagnostic: (diagnostic: MockDiagnostic) => void;
  };
  emitterOutputDir: string;
  options: Record<string, unknown>;
}

// Simple mock for the context
const createMockContext = (): MockContext => {
  const context: MockContext = {
    program: {
      reportDiagnostic: (diagnostic: MockDiagnostic) => {
        // Store diagnostics for testing
        context.diagnostics = context.diagnostics || [];
        context.diagnostics.push(diagnostic);
      },
    },
    emitterOutputDir: '',
    options: {},
    diagnostics: [],
  };
  return context;
};

let mockContext: ReturnType<typeof createMockContext>;

describe('cleanupGeneratedFiles', () => {
  let testDir: string;

  beforeEach(async () => {
    // Create a unique test directory
    testDir = join(tmpdir(), `test-cleanup-${Date.now()}`);
    await mkdir(testDir, { recursive: true });

    // Create mock context
    mockContext = createMockContext();
    mockContext.emitterOutputDir = testDir;
  });

  afterEach(() => {
    // Clean up test directory
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
  });

  async function createTestFile(relativePath: string, content: string): Promise<string> {
    const fullPath = join(testDir, relativePath);
    const dir = join(fullPath, '..');
    await mkdir(dir, { recursive: true });
    await writeFile(fullPath, content);
    return fullPath;
  }

  async function fileExists(relativePath: string): Promise<boolean> {
    try {
      await readFile(join(testDir, relativePath));
      return true;
    } catch {
      return false;
    }
  }

  it('should delete generated .go files with the do-not-edit comment', async () => {
    // Create a generated file with the do-not-edit marker
    const generatedContent = `// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
package main

func main() {
    // This is a generated file
}`;

    await createTestFile('generated.go', generatedContent);

    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
    await cleanupGeneratedFiles(mockContext as any, testDir);

    // Verify the file was deleted
    expect(await fileExists('generated.go')).toBe(false);
  });

  it('should preserve user-written .go files without the do-not-edit comment', async () => {
    // Create a user-written file without the do-not-edit marker
    const userContent = `package main

func main() {
    // This is a user-written file
}`;

    await createTestFile('user.go', userContent);

    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
    await cleanupGeneratedFiles(mockContext as any, testDir);

    // Verify the file was NOT deleted
    expect(await fileExists('user.go')).toBe(true);
  });

  it('should handle nested directories recursively', async () => {
    // Create generated files in nested directories
    const generatedContent = `// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
package nested`;

    const userContent = `package nested
// User written code`;

    await createTestFile('subdir1/generated.go', generatedContent);
    await createTestFile('subdir1/user.go', userContent);
    await createTestFile('subdir2/deep/generated.go', generatedContent);
    await createTestFile('subdir2/deep/user.go', userContent);

    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
    await cleanupGeneratedFiles(mockContext as any, testDir);

    // Verify only generated files were deleted
    expect(await fileExists('subdir1/generated.go')).toBe(false);
    expect(await fileExists('subdir1/user.go')).toBe(true);
    expect(await fileExists('subdir2/deep/generated.go')).toBe(false);
    expect(await fileExists('subdir2/deep/user.go')).toBe(true);
  });

  it('should ignore non-.go files', async () => {
    // Create various non-Go files, some with the do-not-edit marker
    const generatedContent = `// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.`;

    await createTestFile('README.md', generatedContent);
    await createTestFile('config.json', generatedContent);

    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
    await cleanupGeneratedFiles(mockContext as any, testDir);

    // Verify all non-Go files were preserved
    expect(await fileExists('README.md')).toBe(true);
    expect(await fileExists('config.json')).toBe(true);
  });

  it('should handle directory that does not exist gracefully', async () => {
    const nonExistentDir = join(testDir, 'does-not-exist');

    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
    await cleanupGeneratedFiles(mockContext as any, nonExistentDir);

    // Should not throw an error or report diagnostics
    expect(mockContext.diagnostics).toHaveLength(0);
  });
});
