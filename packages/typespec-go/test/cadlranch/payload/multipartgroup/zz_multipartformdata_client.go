// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package multipartgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
)

// MultiPartFormDataClient contains the methods for the Payload.MultiPart namespace.
// Don't use this type directly, use [MultiPartClient.NewMultiPartFormDataClient] instead.
type MultiPartFormDataClient struct {
	internal *azcore.Client
}

// Basic - Test content-type: multipart/form-data
//   - options - MultiPartFormDataClientBasicOptions contains the optional parameters for the MultiPartFormDataClient.Basic method.
func (client *MultiPartFormDataClient) Basic(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientBasicOptions) (MultiPartFormDataClientBasicResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.Basic"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.basicCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientBasicResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientBasicResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientBasicResponse{}, err
	}
	return MultiPartFormDataClientBasicResponse{}, nil
}

// basicCreateRequest creates the Basic request.
func (client *MultiPartFormDataClient) basicCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientBasicOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/mixed-parts"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}

// BinaryArrayParts - Test content-type: multipart/form-data for scenario contains multi binary parts
//   - options - MultiPartFormDataClientBinaryArrayPartsOptions contains the optional parameters for the MultiPartFormDataClient.BinaryArrayParts
//     method.
func (client *MultiPartFormDataClient) BinaryArrayParts(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientBinaryArrayPartsOptions) (MultiPartFormDataClientBinaryArrayPartsResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.BinaryArrayParts"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.binaryArrayPartsCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientBinaryArrayPartsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientBinaryArrayPartsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientBinaryArrayPartsResponse{}, err
	}
	return MultiPartFormDataClientBinaryArrayPartsResponse{}, nil
}

// binaryArrayPartsCreateRequest creates the BinaryArrayParts request.
func (client *MultiPartFormDataClient) binaryArrayPartsCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientBinaryArrayPartsOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/binary-array-parts"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}

// CheckFileNameAndContentType - Test content-type: multipart/form-data
//   - options - MultiPartFormDataClientCheckFileNameAndContentTypeOptions contains the optional parameters for the MultiPartFormDataClient.CheckFileNameAndContentType
//     method.
func (client *MultiPartFormDataClient) CheckFileNameAndContentType(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientCheckFileNameAndContentTypeOptions) (MultiPartFormDataClientCheckFileNameAndContentTypeResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.CheckFileNameAndContentType"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.checkFileNameAndContentTypeCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientCheckFileNameAndContentTypeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientCheckFileNameAndContentTypeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientCheckFileNameAndContentTypeResponse{}, err
	}
	return MultiPartFormDataClientCheckFileNameAndContentTypeResponse{}, nil
}

// checkFileNameAndContentTypeCreateRequest creates the CheckFileNameAndContentType request.
func (client *MultiPartFormDataClient) checkFileNameAndContentTypeCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientCheckFileNameAndContentTypeOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/check-filename-and-content-type"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}

// Complex - Test content-type: multipart/form-data for mixed scenarios
//   - options - MultiPartFormDataClientComplexOptions contains the optional parameters for the MultiPartFormDataClient.Complex
//     method.
func (client *MultiPartFormDataClient) Complex(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientComplexOptions) (MultiPartFormDataClientComplexResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.Complex"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.complexCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientComplexResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientComplexResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientComplexResponse{}, err
	}
	return MultiPartFormDataClientComplexResponse{}, nil
}

// complexCreateRequest creates the Complex request.
func (client *MultiPartFormDataClient) complexCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientComplexOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/complex-parts"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}

// JSONArrayParts - Test content-type: multipart/form-data for scenario contains multi json parts
//   - options - MultiPartFormDataClientJSONArrayPartsOptions contains the optional parameters for the MultiPartFormDataClient.JSONArrayParts
//     method.
func (client *MultiPartFormDataClient) JSONArrayParts(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientJSONArrayPartsOptions) (MultiPartFormDataClientJSONArrayPartsResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.JSONArrayParts"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.jsonArrayPartsCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientJSONArrayPartsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientJSONArrayPartsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientJSONArrayPartsResponse{}, err
	}
	return MultiPartFormDataClientJSONArrayPartsResponse{}, nil
}

// jsonArrayPartsCreateRequest creates the JSONArrayParts request.
func (client *MultiPartFormDataClient) jsonArrayPartsCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientJSONArrayPartsOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/json-array-parts"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}

// JSONPart - Test content-type: multipart/form-data for scenario contains json part and binary part
//   - options - MultiPartFormDataClientJSONPartOptions contains the optional parameters for the MultiPartFormDataClient.JSONPart
//     method.
func (client *MultiPartFormDataClient) JSONPart(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientJSONPartOptions) (MultiPartFormDataClientJSONPartResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.JSONPart"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.jsonPartCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientJSONPartResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientJSONPartResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientJSONPartResponse{}, err
	}
	return MultiPartFormDataClientJSONPartResponse{}, nil
}

// jsonPartCreateRequest creates the JSONPart request.
func (client *MultiPartFormDataClient) jsonPartCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientJSONPartOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/json-part"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}

// MultiBinaryParts - Test content-type: multipart/form-data for scenario contains multi binary parts
//   - options - MultiPartFormDataClientMultiBinaryPartsOptions contains the optional parameters for the MultiPartFormDataClient.MultiBinaryParts
//     method.
func (client *MultiPartFormDataClient) MultiBinaryParts(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientMultiBinaryPartsOptions) (MultiPartFormDataClientMultiBinaryPartsResponse, error) {
	var err error
	const operationName = "MultiPartFormDataClient.MultiBinaryParts"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.multiBinaryPartsCreateRequest(ctx, body, options)
	if err != nil {
		return MultiPartFormDataClientMultiBinaryPartsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MultiPartFormDataClientMultiBinaryPartsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return MultiPartFormDataClientMultiBinaryPartsResponse{}, err
	}
	return MultiPartFormDataClientMultiBinaryPartsResponse{}, nil
}

// multiBinaryPartsCreateRequest creates the MultiBinaryParts request.
func (client *MultiPartFormDataClient) multiBinaryPartsCreateRequest(ctx context.Context, body io.ReadSeekCloser, options *MultiPartFormDataClientMultiBinaryPartsOptions) (*policy.Request, error) {
	urlPath := "/multipart/form-data/multi-binary-parts"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"multipart/form-data"}
	if err := req.SetBody(body, "multipart/form-data"); err != nil {
		return nil, err
	}
	return req, nil
}
