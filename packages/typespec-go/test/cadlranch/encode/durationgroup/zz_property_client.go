// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package durationgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// PropertyClient contains the methods for the Encode.Duration namespace.
// Don't use this type directly, use [DurationClient.NewPropertyClient] instead.
type PropertyClient struct {
	internal *azcore.Client
}

// - options - PropertyClientDefaultOptions contains the optional parameters for the PropertyClient.Default method.
func (client *PropertyClient) Default(ctx context.Context, body DefaultDurationProperty, options *PropertyClientDefaultOptions) (PropertyClientDefaultResponse, error) {
	var err error
	req, err := client.defaultCreateRequest(ctx, body, options)
	if err != nil {
		return PropertyClientDefaultResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PropertyClientDefaultResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PropertyClientDefaultResponse{}, err
	}
	resp, err := client.defaultHandleResponse(httpResp)
	return resp, err
}

// defaultCreateRequest creates the Default request.
func (client *PropertyClient) defaultCreateRequest(ctx context.Context, body DefaultDurationProperty, options *PropertyClientDefaultOptions) (*policy.Request, error) {
	urlPath := "/encode/duration/property/default"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// defaultHandleResponse handles the Default response.
func (client *PropertyClient) defaultHandleResponse(resp *http.Response) (PropertyClientDefaultResponse, error) {
	result := PropertyClientDefaultResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DefaultDurationProperty); err != nil {
		return PropertyClientDefaultResponse{}, err
	}
	return result, nil
}

// - options - PropertyClientFloatSecondsOptions contains the optional parameters for the PropertyClient.FloatSeconds method.
func (client *PropertyClient) FloatSeconds(ctx context.Context, body FloatSecondsDurationProperty, options *PropertyClientFloatSecondsOptions) (PropertyClientFloatSecondsResponse, error) {
	var err error
	req, err := client.floatSecondsCreateRequest(ctx, body, options)
	if err != nil {
		return PropertyClientFloatSecondsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PropertyClientFloatSecondsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PropertyClientFloatSecondsResponse{}, err
	}
	resp, err := client.floatSecondsHandleResponse(httpResp)
	return resp, err
}

// floatSecondsCreateRequest creates the FloatSeconds request.
func (client *PropertyClient) floatSecondsCreateRequest(ctx context.Context, body FloatSecondsDurationProperty, options *PropertyClientFloatSecondsOptions) (*policy.Request, error) {
	urlPath := "/encode/duration/property/float-seconds"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// floatSecondsHandleResponse handles the FloatSeconds response.
func (client *PropertyClient) floatSecondsHandleResponse(resp *http.Response) (PropertyClientFloatSecondsResponse, error) {
	result := PropertyClientFloatSecondsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FloatSecondsDurationProperty); err != nil {
		return PropertyClientFloatSecondsResponse{}, err
	}
	return result, nil
}

//   - options - PropertyClientFloatSecondsArrayOptions contains the optional parameters for the PropertyClient.FloatSecondsArray
//     method.
func (client *PropertyClient) FloatSecondsArray(ctx context.Context, body FloatSecondsDurationArrayProperty, options *PropertyClientFloatSecondsArrayOptions) (PropertyClientFloatSecondsArrayResponse, error) {
	var err error
	req, err := client.floatSecondsArrayCreateRequest(ctx, body, options)
	if err != nil {
		return PropertyClientFloatSecondsArrayResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PropertyClientFloatSecondsArrayResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PropertyClientFloatSecondsArrayResponse{}, err
	}
	resp, err := client.floatSecondsArrayHandleResponse(httpResp)
	return resp, err
}

// floatSecondsArrayCreateRequest creates the FloatSecondsArray request.
func (client *PropertyClient) floatSecondsArrayCreateRequest(ctx context.Context, body FloatSecondsDurationArrayProperty, options *PropertyClientFloatSecondsArrayOptions) (*policy.Request, error) {
	urlPath := "/encode/duration/property/float-seconds-array"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// floatSecondsArrayHandleResponse handles the FloatSecondsArray response.
func (client *PropertyClient) floatSecondsArrayHandleResponse(resp *http.Response) (PropertyClientFloatSecondsArrayResponse, error) {
	result := PropertyClientFloatSecondsArrayResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FloatSecondsDurationArrayProperty); err != nil {
		return PropertyClientFloatSecondsArrayResponse{}, err
	}
	return result, nil
}

// - options - PropertyClientISO8601Options contains the optional parameters for the PropertyClient.ISO8601 method.
func (client *PropertyClient) ISO8601(ctx context.Context, body ISO8601DurationProperty, options *PropertyClientISO8601Options) (PropertyClientISO8601Response, error) {
	var err error
	req, err := client.iso8601CreateRequest(ctx, body, options)
	if err != nil {
		return PropertyClientISO8601Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PropertyClientISO8601Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PropertyClientISO8601Response{}, err
	}
	resp, err := client.iso8601HandleResponse(httpResp)
	return resp, err
}

// iso8601CreateRequest creates the ISO8601 request.
func (client *PropertyClient) iso8601CreateRequest(ctx context.Context, body ISO8601DurationProperty, options *PropertyClientISO8601Options) (*policy.Request, error) {
	urlPath := "/encode/duration/property/iso8601"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// iso8601HandleResponse handles the ISO8601 response.
func (client *PropertyClient) iso8601HandleResponse(resp *http.Response) (PropertyClientISO8601Response, error) {
	result := PropertyClientISO8601Response{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ISO8601DurationProperty); err != nil {
		return PropertyClientISO8601Response{}, err
	}
	return result, nil
}

// - options - PropertyClientInt32SecondsOptions contains the optional parameters for the PropertyClient.Int32Seconds method.
func (client *PropertyClient) Int32Seconds(ctx context.Context, body Int32SecondsDurationProperty, options *PropertyClientInt32SecondsOptions) (PropertyClientInt32SecondsResponse, error) {
	var err error
	req, err := client.int32SecondsCreateRequest(ctx, body, options)
	if err != nil {
		return PropertyClientInt32SecondsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PropertyClientInt32SecondsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PropertyClientInt32SecondsResponse{}, err
	}
	resp, err := client.int32SecondsHandleResponse(httpResp)
	return resp, err
}

// int32SecondsCreateRequest creates the Int32Seconds request.
func (client *PropertyClient) int32SecondsCreateRequest(ctx context.Context, body Int32SecondsDurationProperty, options *PropertyClientInt32SecondsOptions) (*policy.Request, error) {
	urlPath := "/encode/duration/property/int32-seconds"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// int32SecondsHandleResponse handles the Int32Seconds response.
func (client *PropertyClient) int32SecondsHandleResponse(resp *http.Response) (PropertyClientInt32SecondsResponse, error) {
	result := PropertyClientInt32SecondsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32SecondsDurationProperty); err != nil {
		return PropertyClientInt32SecondsResponse{}, err
	}
	return result, nil
}
