// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package collectionfmtgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
)

// CollectionFormatQueryClient contains the methods for the CollectionFormatQuery group.
// Don't use this type directly, use [CollectionFormatClient.NewCollectionFormatQueryClient] instead.
type CollectionFormatQueryClient struct {
	internal *azcore.Client
}

// CSV -
// If the operation fails it returns an *azcore.ResponseError type.
//   - colors - Possible values for colors are [blue,red,green]
//   - options - CollectionFormatQueryClientCSVOptions contains the optional parameters for the CollectionFormatQueryClient.CSV
//     method.
func (client *CollectionFormatQueryClient) CSV(ctx context.Context, colors []string, options *CollectionFormatQueryClientCSVOptions) (CollectionFormatQueryClientCSVResponse, error) {
	var err error
	const operationName = "CollectionFormatQueryClient.CSV"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.csvCreateRequest(ctx, colors, options)
	if err != nil {
		return CollectionFormatQueryClientCSVResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CollectionFormatQueryClientCSVResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return CollectionFormatQueryClientCSVResponse{}, err
	}
	return CollectionFormatQueryClientCSVResponse{}, nil
}

// csvCreateRequest creates the CSV request.
func (client *CollectionFormatQueryClient) csvCreateRequest(ctx context.Context, colors []string, _ *CollectionFormatQueryClientCSVOptions) (*policy.Request, error) {
	urlPath := "/parameters/collection-format/query/csv"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("colors", strings.Join(colors, ","))
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Multi -
// If the operation fails it returns an *azcore.ResponseError type.
//   - colors - Possible values for colors are [blue,red,green]
//   - options - CollectionFormatQueryClientMultiOptions contains the optional parameters for the CollectionFormatQueryClient.Multi
//     method.
func (client *CollectionFormatQueryClient) Multi(ctx context.Context, colors []string, options *CollectionFormatQueryClientMultiOptions) (CollectionFormatQueryClientMultiResponse, error) {
	var err error
	const operationName = "CollectionFormatQueryClient.Multi"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.multiCreateRequest(ctx, colors, options)
	if err != nil {
		return CollectionFormatQueryClientMultiResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CollectionFormatQueryClientMultiResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return CollectionFormatQueryClientMultiResponse{}, err
	}
	return CollectionFormatQueryClientMultiResponse{}, nil
}

// multiCreateRequest creates the Multi request.
func (client *CollectionFormatQueryClient) multiCreateRequest(ctx context.Context, colors []string, _ *CollectionFormatQueryClientMultiOptions) (*policy.Request, error) {
	urlPath := "/parameters/collection-format/query/multi"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	for _, qv := range colors {
		reqQP.Add("colors", qv)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Pipes -
// If the operation fails it returns an *azcore.ResponseError type.
//   - colors - Possible values for colors are [blue,red,green]
//   - options - CollectionFormatQueryClientPipesOptions contains the optional parameters for the CollectionFormatQueryClient.Pipes
//     method.
func (client *CollectionFormatQueryClient) Pipes(ctx context.Context, colors []string, options *CollectionFormatQueryClientPipesOptions) (CollectionFormatQueryClientPipesResponse, error) {
	var err error
	const operationName = "CollectionFormatQueryClient.Pipes"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.pipesCreateRequest(ctx, colors, options)
	if err != nil {
		return CollectionFormatQueryClientPipesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CollectionFormatQueryClientPipesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return CollectionFormatQueryClientPipesResponse{}, err
	}
	return CollectionFormatQueryClientPipesResponse{}, nil
}

// pipesCreateRequest creates the Pipes request.
func (client *CollectionFormatQueryClient) pipesCreateRequest(ctx context.Context, colors []string, _ *CollectionFormatQueryClientPipesOptions) (*policy.Request, error) {
	urlPath := "/parameters/collection-format/query/pipes"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("colors", strings.Join(colors, "|"))
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Ssv -
// If the operation fails it returns an *azcore.ResponseError type.
//   - colors - Possible values for colors are [blue,red,green]
//   - options - CollectionFormatQueryClientSsvOptions contains the optional parameters for the CollectionFormatQueryClient.Ssv
//     method.
func (client *CollectionFormatQueryClient) Ssv(ctx context.Context, colors []string, options *CollectionFormatQueryClientSsvOptions) (CollectionFormatQueryClientSsvResponse, error) {
	var err error
	const operationName = "CollectionFormatQueryClient.Ssv"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.ssvCreateRequest(ctx, colors, options)
	if err != nil {
		return CollectionFormatQueryClientSsvResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CollectionFormatQueryClientSsvResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return CollectionFormatQueryClientSsvResponse{}, err
	}
	return CollectionFormatQueryClientSsvResponse{}, nil
}

// ssvCreateRequest creates the Ssv request.
func (client *CollectionFormatQueryClient) ssvCreateRequest(ctx context.Context, colors []string, _ *CollectionFormatQueryClientSsvOptions) (*policy.Request, error) {
	urlPath := "/parameters/collection-format/query/ssv"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("colors", strings.Join(colors, " "))
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Tsv -
// If the operation fails it returns an *azcore.ResponseError type.
//   - colors - Possible values for colors are [blue,red,green]
//   - options - CollectionFormatQueryClientTsvOptions contains the optional parameters for the CollectionFormatQueryClient.Tsv
//     method.
func (client *CollectionFormatQueryClient) Tsv(ctx context.Context, colors []string, options *CollectionFormatQueryClientTsvOptions) (CollectionFormatQueryClientTsvResponse, error) {
	var err error
	const operationName = "CollectionFormatQueryClient.Tsv"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.tsvCreateRequest(ctx, colors, options)
	if err != nil {
		return CollectionFormatQueryClientTsvResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return CollectionFormatQueryClientTsvResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return CollectionFormatQueryClientTsvResponse{}, err
	}
	return CollectionFormatQueryClientTsvResponse{}, nil
}

// tsvCreateRequest creates the Tsv request.
func (client *CollectionFormatQueryClient) tsvCreateRequest(ctx context.Context, colors []string, _ *CollectionFormatQueryClientTsvOptions) (*policy.Request, error) {
	urlPath := "/parameters/collection-format/query/tsv"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("colors", strings.Join(colors, "\t"))
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}
