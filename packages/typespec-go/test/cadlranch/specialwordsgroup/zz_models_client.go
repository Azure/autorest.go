//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package specialwordsgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// ModelsClient contains the methods for the SpecialWords group.
// Don't use this type directly, use a constructor function instead.
type ModelsClient struct {
	internal *azcore.Client
}

func (client *ModelsClient) WithAnd(ctx context.Context, body And, options *ModelsClientWithAndOptions) (ModelsClientWithAndResponse, error) {
	var err error
	req, err := client.withAndCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithAndResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithAndResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithAndResponse{}, err
	}
	return ModelsClientWithAndResponse{}, nil
}

// withAndCreateRequest creates the WithAnd request.
func (client *ModelsClient) withAndCreateRequest(ctx context.Context, body And, options *ModelsClientWithAndOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/and"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithAs(ctx context.Context, body As, options *ModelsClientWithAsOptions) (ModelsClientWithAsResponse, error) {
	var err error
	req, err := client.withAsCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithAsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithAsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithAsResponse{}, err
	}
	return ModelsClientWithAsResponse{}, nil
}

// withAsCreateRequest creates the WithAs request.
func (client *ModelsClient) withAsCreateRequest(ctx context.Context, body As, options *ModelsClientWithAsOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/as"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithAssert(ctx context.Context, body Assert, options *ModelsClientWithAssertOptions) (ModelsClientWithAssertResponse, error) {
	var err error
	req, err := client.withAssertCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithAssertResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithAssertResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithAssertResponse{}, err
	}
	return ModelsClientWithAssertResponse{}, nil
}

// withAssertCreateRequest creates the WithAssert request.
func (client *ModelsClient) withAssertCreateRequest(ctx context.Context, body Assert, options *ModelsClientWithAssertOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/assert"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithAsync(ctx context.Context, body Async, options *ModelsClientWithAsyncOptions) (ModelsClientWithAsyncResponse, error) {
	var err error
	req, err := client.withAsyncCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithAsyncResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithAsyncResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithAsyncResponse{}, err
	}
	return ModelsClientWithAsyncResponse{}, nil
}

// withAsyncCreateRequest creates the WithAsync request.
func (client *ModelsClient) withAsyncCreateRequest(ctx context.Context, body Async, options *ModelsClientWithAsyncOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/async"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithAwait(ctx context.Context, body Await, options *ModelsClientWithAwaitOptions) (ModelsClientWithAwaitResponse, error) {
	var err error
	req, err := client.withAwaitCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithAwaitResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithAwaitResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithAwaitResponse{}, err
	}
	return ModelsClientWithAwaitResponse{}, nil
}

// withAwaitCreateRequest creates the WithAwait request.
func (client *ModelsClient) withAwaitCreateRequest(ctx context.Context, body Await, options *ModelsClientWithAwaitOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/await"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithBreak(ctx context.Context, body Break, options *ModelsClientWithBreakOptions) (ModelsClientWithBreakResponse, error) {
	var err error
	req, err := client.withBreakCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithBreakResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithBreakResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithBreakResponse{}, err
	}
	return ModelsClientWithBreakResponse{}, nil
}

// withBreakCreateRequest creates the WithBreak request.
func (client *ModelsClient) withBreakCreateRequest(ctx context.Context, body Break, options *ModelsClientWithBreakOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/break"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithClass(ctx context.Context, body Class, options *ModelsClientWithClassOptions) (ModelsClientWithClassResponse, error) {
	var err error
	req, err := client.withClassCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithClassResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithClassResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithClassResponse{}, err
	}
	return ModelsClientWithClassResponse{}, nil
}

// withClassCreateRequest creates the WithClass request.
func (client *ModelsClient) withClassCreateRequest(ctx context.Context, body Class, options *ModelsClientWithClassOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/class"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithConstructor(ctx context.Context, body Constructor, options *ModelsClientWithConstructorOptions) (ModelsClientWithConstructorResponse, error) {
	var err error
	req, err := client.withConstructorCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithConstructorResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithConstructorResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithConstructorResponse{}, err
	}
	return ModelsClientWithConstructorResponse{}, nil
}

// withConstructorCreateRequest creates the WithConstructor request.
func (client *ModelsClient) withConstructorCreateRequest(ctx context.Context, body Constructor, options *ModelsClientWithConstructorOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/constructor"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithContinue(ctx context.Context, body Continue, options *ModelsClientWithContinueOptions) (ModelsClientWithContinueResponse, error) {
	var err error
	req, err := client.withContinueCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithContinueResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithContinueResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithContinueResponse{}, err
	}
	return ModelsClientWithContinueResponse{}, nil
}

// withContinueCreateRequest creates the WithContinue request.
func (client *ModelsClient) withContinueCreateRequest(ctx context.Context, body Continue, options *ModelsClientWithContinueOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/continue"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithDef(ctx context.Context, body Def, options *ModelsClientWithDefOptions) (ModelsClientWithDefResponse, error) {
	var err error
	req, err := client.withDefCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithDefResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithDefResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithDefResponse{}, err
	}
	return ModelsClientWithDefResponse{}, nil
}

// withDefCreateRequest creates the WithDef request.
func (client *ModelsClient) withDefCreateRequest(ctx context.Context, body Def, options *ModelsClientWithDefOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/def"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithDel(ctx context.Context, body Del, options *ModelsClientWithDelOptions) (ModelsClientWithDelResponse, error) {
	var err error
	req, err := client.withDelCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithDelResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithDelResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithDelResponse{}, err
	}
	return ModelsClientWithDelResponse{}, nil
}

// withDelCreateRequest creates the WithDel request.
func (client *ModelsClient) withDelCreateRequest(ctx context.Context, body Del, options *ModelsClientWithDelOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/del"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithElif(ctx context.Context, body Elif, options *ModelsClientWithElifOptions) (ModelsClientWithElifResponse, error) {
	var err error
	req, err := client.withElifCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithElifResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithElifResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithElifResponse{}, err
	}
	return ModelsClientWithElifResponse{}, nil
}

// withElifCreateRequest creates the WithElif request.
func (client *ModelsClient) withElifCreateRequest(ctx context.Context, body Elif, options *ModelsClientWithElifOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/elif"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithElse(ctx context.Context, body Else, options *ModelsClientWithElseOptions) (ModelsClientWithElseResponse, error) {
	var err error
	req, err := client.withElseCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithElseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithElseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithElseResponse{}, err
	}
	return ModelsClientWithElseResponse{}, nil
}

// withElseCreateRequest creates the WithElse request.
func (client *ModelsClient) withElseCreateRequest(ctx context.Context, body Else, options *ModelsClientWithElseOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/else"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithExcept(ctx context.Context, body Except, options *ModelsClientWithExceptOptions) (ModelsClientWithExceptResponse, error) {
	var err error
	req, err := client.withExceptCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithExceptResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithExceptResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithExceptResponse{}, err
	}
	return ModelsClientWithExceptResponse{}, nil
}

// withExceptCreateRequest creates the WithExcept request.
func (client *ModelsClient) withExceptCreateRequest(ctx context.Context, body Except, options *ModelsClientWithExceptOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/except"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithExec(ctx context.Context, body Exec, options *ModelsClientWithExecOptions) (ModelsClientWithExecResponse, error) {
	var err error
	req, err := client.withExecCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithExecResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithExecResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithExecResponse{}, err
	}
	return ModelsClientWithExecResponse{}, nil
}

// withExecCreateRequest creates the WithExec request.
func (client *ModelsClient) withExecCreateRequest(ctx context.Context, body Exec, options *ModelsClientWithExecOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/exec"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithFinally(ctx context.Context, body Finally, options *ModelsClientWithFinallyOptions) (ModelsClientWithFinallyResponse, error) {
	var err error
	req, err := client.withFinallyCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithFinallyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithFinallyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithFinallyResponse{}, err
	}
	return ModelsClientWithFinallyResponse{}, nil
}

// withFinallyCreateRequest creates the WithFinally request.
func (client *ModelsClient) withFinallyCreateRequest(ctx context.Context, body Finally, options *ModelsClientWithFinallyOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/finally"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithFor(ctx context.Context, body For, options *ModelsClientWithForOptions) (ModelsClientWithForResponse, error) {
	var err error
	req, err := client.withForCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithForResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithForResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithForResponse{}, err
	}
	return ModelsClientWithForResponse{}, nil
}

// withForCreateRequest creates the WithFor request.
func (client *ModelsClient) withForCreateRequest(ctx context.Context, body For, options *ModelsClientWithForOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/for"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithFrom(ctx context.Context, body From, options *ModelsClientWithFromOptions) (ModelsClientWithFromResponse, error) {
	var err error
	req, err := client.withFromCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithFromResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithFromResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithFromResponse{}, err
	}
	return ModelsClientWithFromResponse{}, nil
}

// withFromCreateRequest creates the WithFrom request.
func (client *ModelsClient) withFromCreateRequest(ctx context.Context, body From, options *ModelsClientWithFromOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/from"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithGlobal(ctx context.Context, body Global, options *ModelsClientWithGlobalOptions) (ModelsClientWithGlobalResponse, error) {
	var err error
	req, err := client.withGlobalCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithGlobalResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithGlobalResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithGlobalResponse{}, err
	}
	return ModelsClientWithGlobalResponse{}, nil
}

// withGlobalCreateRequest creates the WithGlobal request.
func (client *ModelsClient) withGlobalCreateRequest(ctx context.Context, body Global, options *ModelsClientWithGlobalOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/global"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithIf(ctx context.Context, body If, options *ModelsClientWithIfOptions) (ModelsClientWithIfResponse, error) {
	var err error
	req, err := client.withIfCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithIfResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithIfResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithIfResponse{}, err
	}
	return ModelsClientWithIfResponse{}, nil
}

// withIfCreateRequest creates the WithIf request.
func (client *ModelsClient) withIfCreateRequest(ctx context.Context, body If, options *ModelsClientWithIfOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/if"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithImport(ctx context.Context, body Import, options *ModelsClientWithImportOptions) (ModelsClientWithImportResponse, error) {
	var err error
	req, err := client.withImportCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithImportResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithImportResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithImportResponse{}, err
	}
	return ModelsClientWithImportResponse{}, nil
}

// withImportCreateRequest creates the WithImport request.
func (client *ModelsClient) withImportCreateRequest(ctx context.Context, body Import, options *ModelsClientWithImportOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/import"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithIn(ctx context.Context, body In, options *ModelsClientWithInOptions) (ModelsClientWithInResponse, error) {
	var err error
	req, err := client.withInCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithInResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithInResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithInResponse{}, err
	}
	return ModelsClientWithInResponse{}, nil
}

// withInCreateRequest creates the WithIn request.
func (client *ModelsClient) withInCreateRequest(ctx context.Context, body In, options *ModelsClientWithInOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/in"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithIs(ctx context.Context, body Is, options *ModelsClientWithIsOptions) (ModelsClientWithIsResponse, error) {
	var err error
	req, err := client.withIsCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithIsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithIsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithIsResponse{}, err
	}
	return ModelsClientWithIsResponse{}, nil
}

// withIsCreateRequest creates the WithIs request.
func (client *ModelsClient) withIsCreateRequest(ctx context.Context, body Is, options *ModelsClientWithIsOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/is"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithLambda(ctx context.Context, body Lambda, options *ModelsClientWithLambdaOptions) (ModelsClientWithLambdaResponse, error) {
	var err error
	req, err := client.withLambdaCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithLambdaResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithLambdaResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithLambdaResponse{}, err
	}
	return ModelsClientWithLambdaResponse{}, nil
}

// withLambdaCreateRequest creates the WithLambda request.
func (client *ModelsClient) withLambdaCreateRequest(ctx context.Context, body Lambda, options *ModelsClientWithLambdaOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/lambda"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithNot(ctx context.Context, body Not, options *ModelsClientWithNotOptions) (ModelsClientWithNotResponse, error) {
	var err error
	req, err := client.withNotCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithNotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithNotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithNotResponse{}, err
	}
	return ModelsClientWithNotResponse{}, nil
}

// withNotCreateRequest creates the WithNot request.
func (client *ModelsClient) withNotCreateRequest(ctx context.Context, body Not, options *ModelsClientWithNotOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/not"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithOr(ctx context.Context, body Or, options *ModelsClientWithOrOptions) (ModelsClientWithOrResponse, error) {
	var err error
	req, err := client.withOrCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithOrResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithOrResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithOrResponse{}, err
	}
	return ModelsClientWithOrResponse{}, nil
}

// withOrCreateRequest creates the WithOr request.
func (client *ModelsClient) withOrCreateRequest(ctx context.Context, body Or, options *ModelsClientWithOrOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/or"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithPass(ctx context.Context, body Pass, options *ModelsClientWithPassOptions) (ModelsClientWithPassResponse, error) {
	var err error
	req, err := client.withPassCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithPassResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithPassResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithPassResponse{}, err
	}
	return ModelsClientWithPassResponse{}, nil
}

// withPassCreateRequest creates the WithPass request.
func (client *ModelsClient) withPassCreateRequest(ctx context.Context, body Pass, options *ModelsClientWithPassOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/pass"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithRaise(ctx context.Context, body Raise, options *ModelsClientWithRaiseOptions) (ModelsClientWithRaiseResponse, error) {
	var err error
	req, err := client.withRaiseCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithRaiseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithRaiseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithRaiseResponse{}, err
	}
	return ModelsClientWithRaiseResponse{}, nil
}

// withRaiseCreateRequest creates the WithRaise request.
func (client *ModelsClient) withRaiseCreateRequest(ctx context.Context, body Raise, options *ModelsClientWithRaiseOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/raise"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithReturn(ctx context.Context, body Return, options *ModelsClientWithReturnOptions) (ModelsClientWithReturnResponse, error) {
	var err error
	req, err := client.withReturnCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithReturnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithReturnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithReturnResponse{}, err
	}
	return ModelsClientWithReturnResponse{}, nil
}

// withReturnCreateRequest creates the WithReturn request.
func (client *ModelsClient) withReturnCreateRequest(ctx context.Context, body Return, options *ModelsClientWithReturnOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/return"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithTry(ctx context.Context, body Try, options *ModelsClientWithTryOptions) (ModelsClientWithTryResponse, error) {
	var err error
	req, err := client.withTryCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithTryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithTryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithTryResponse{}, err
	}
	return ModelsClientWithTryResponse{}, nil
}

// withTryCreateRequest creates the WithTry request.
func (client *ModelsClient) withTryCreateRequest(ctx context.Context, body Try, options *ModelsClientWithTryOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/try"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithWhile(ctx context.Context, body While, options *ModelsClientWithWhileOptions) (ModelsClientWithWhileResponse, error) {
	var err error
	req, err := client.withWhileCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithWhileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithWhileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithWhileResponse{}, err
	}
	return ModelsClientWithWhileResponse{}, nil
}

// withWhileCreateRequest creates the WithWhile request.
func (client *ModelsClient) withWhileCreateRequest(ctx context.Context, body While, options *ModelsClientWithWhileOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/while"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithWith(ctx context.Context, body With, options *ModelsClientWithWithOptions) (ModelsClientWithWithResponse, error) {
	var err error
	req, err := client.withWithCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithWithResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithWithResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithWithResponse{}, err
	}
	return ModelsClientWithWithResponse{}, nil
}

// withWithCreateRequest creates the WithWith request.
func (client *ModelsClient) withWithCreateRequest(ctx context.Context, body With, options *ModelsClientWithWithOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/with"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

func (client *ModelsClient) WithYield(ctx context.Context, body Yield, options *ModelsClientWithYieldOptions) (ModelsClientWithYieldResponse, error) {
	var err error
	req, err := client.withYieldCreateRequest(ctx, body, options)
	if err != nil {
		return ModelsClientWithYieldResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ModelsClientWithYieldResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return ModelsClientWithYieldResponse{}, err
	}
	return ModelsClientWithYieldResponse{}, nil
}

// withYieldCreateRequest creates the WithYield request.
func (client *ModelsClient) withYieldCreateRequest(ctx context.Context, body Yield, options *ModelsClientWithYieldOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/yield"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}
