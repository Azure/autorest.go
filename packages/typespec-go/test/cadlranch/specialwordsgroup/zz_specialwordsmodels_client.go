// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package specialwordsgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// SpecialWordsModelsClient - Verify model names
// Don't use this type directly, use [SpecialWordsClient.NewSpecialWordsModelsClient] instead.
type SpecialWordsModelsClient struct {
	internal *azcore.Client
}

// WithAnd -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithAndOptions contains the optional parameters for the SpecialWordsModelsClient.WithAnd
//     method.
func (client *SpecialWordsModelsClient) WithAnd(ctx context.Context, body And, options *SpecialWordsModelsClientWithAndOptions) (SpecialWordsModelsClientWithAndResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithAnd"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withAndCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithAndResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithAndResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithAndResponse{}, err
	}
	return SpecialWordsModelsClientWithAndResponse{}, nil
}

// withAndCreateRequest creates the WithAnd request.
func (client *SpecialWordsModelsClient) withAndCreateRequest(ctx context.Context, body And, _ *SpecialWordsModelsClientWithAndOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/and"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithAs -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithAsOptions contains the optional parameters for the SpecialWordsModelsClient.WithAs
//     method.
func (client *SpecialWordsModelsClient) WithAs(ctx context.Context, body As, options *SpecialWordsModelsClientWithAsOptions) (SpecialWordsModelsClientWithAsResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithAs"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withAsCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithAsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithAsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithAsResponse{}, err
	}
	return SpecialWordsModelsClientWithAsResponse{}, nil
}

// withAsCreateRequest creates the WithAs request.
func (client *SpecialWordsModelsClient) withAsCreateRequest(ctx context.Context, body As, _ *SpecialWordsModelsClientWithAsOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/as"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithAssert -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithAssertOptions contains the optional parameters for the SpecialWordsModelsClient.WithAssert
//     method.
func (client *SpecialWordsModelsClient) WithAssert(ctx context.Context, body Assert, options *SpecialWordsModelsClientWithAssertOptions) (SpecialWordsModelsClientWithAssertResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithAssert"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withAssertCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithAssertResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithAssertResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithAssertResponse{}, err
	}
	return SpecialWordsModelsClientWithAssertResponse{}, nil
}

// withAssertCreateRequest creates the WithAssert request.
func (client *SpecialWordsModelsClient) withAssertCreateRequest(ctx context.Context, body Assert, _ *SpecialWordsModelsClientWithAssertOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/assert"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithAsync -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithAsyncOptions contains the optional parameters for the SpecialWordsModelsClient.WithAsync
//     method.
func (client *SpecialWordsModelsClient) WithAsync(ctx context.Context, body Async, options *SpecialWordsModelsClientWithAsyncOptions) (SpecialWordsModelsClientWithAsyncResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithAsync"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withAsyncCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithAsyncResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithAsyncResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithAsyncResponse{}, err
	}
	return SpecialWordsModelsClientWithAsyncResponse{}, nil
}

// withAsyncCreateRequest creates the WithAsync request.
func (client *SpecialWordsModelsClient) withAsyncCreateRequest(ctx context.Context, body Async, _ *SpecialWordsModelsClientWithAsyncOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/async"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithAwait -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithAwaitOptions contains the optional parameters for the SpecialWordsModelsClient.WithAwait
//     method.
func (client *SpecialWordsModelsClient) WithAwait(ctx context.Context, body Await, options *SpecialWordsModelsClientWithAwaitOptions) (SpecialWordsModelsClientWithAwaitResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithAwait"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withAwaitCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithAwaitResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithAwaitResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithAwaitResponse{}, err
	}
	return SpecialWordsModelsClientWithAwaitResponse{}, nil
}

// withAwaitCreateRequest creates the WithAwait request.
func (client *SpecialWordsModelsClient) withAwaitCreateRequest(ctx context.Context, body Await, _ *SpecialWordsModelsClientWithAwaitOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/await"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithBreak -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithBreakOptions contains the optional parameters for the SpecialWordsModelsClient.WithBreak
//     method.
func (client *SpecialWordsModelsClient) WithBreak(ctx context.Context, body Break, options *SpecialWordsModelsClientWithBreakOptions) (SpecialWordsModelsClientWithBreakResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithBreak"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withBreakCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithBreakResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithBreakResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithBreakResponse{}, err
	}
	return SpecialWordsModelsClientWithBreakResponse{}, nil
}

// withBreakCreateRequest creates the WithBreak request.
func (client *SpecialWordsModelsClient) withBreakCreateRequest(ctx context.Context, body Break, _ *SpecialWordsModelsClientWithBreakOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/break"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithClass -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithClassOptions contains the optional parameters for the SpecialWordsModelsClient.WithClass
//     method.
func (client *SpecialWordsModelsClient) WithClass(ctx context.Context, body Class, options *SpecialWordsModelsClientWithClassOptions) (SpecialWordsModelsClientWithClassResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithClass"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withClassCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithClassResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithClassResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithClassResponse{}, err
	}
	return SpecialWordsModelsClientWithClassResponse{}, nil
}

// withClassCreateRequest creates the WithClass request.
func (client *SpecialWordsModelsClient) withClassCreateRequest(ctx context.Context, body Class, _ *SpecialWordsModelsClientWithClassOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/class"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithConstructor -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithConstructorOptions contains the optional parameters for the SpecialWordsModelsClient.WithConstructor
//     method.
func (client *SpecialWordsModelsClient) WithConstructor(ctx context.Context, body Constructor, options *SpecialWordsModelsClientWithConstructorOptions) (SpecialWordsModelsClientWithConstructorResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithConstructor"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withConstructorCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithConstructorResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithConstructorResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithConstructorResponse{}, err
	}
	return SpecialWordsModelsClientWithConstructorResponse{}, nil
}

// withConstructorCreateRequest creates the WithConstructor request.
func (client *SpecialWordsModelsClient) withConstructorCreateRequest(ctx context.Context, body Constructor, _ *SpecialWordsModelsClientWithConstructorOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/constructor"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithContinue -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithContinueOptions contains the optional parameters for the SpecialWordsModelsClient.WithContinue
//     method.
func (client *SpecialWordsModelsClient) WithContinue(ctx context.Context, body Continue, options *SpecialWordsModelsClientWithContinueOptions) (SpecialWordsModelsClientWithContinueResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithContinue"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withContinueCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithContinueResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithContinueResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithContinueResponse{}, err
	}
	return SpecialWordsModelsClientWithContinueResponse{}, nil
}

// withContinueCreateRequest creates the WithContinue request.
func (client *SpecialWordsModelsClient) withContinueCreateRequest(ctx context.Context, body Continue, _ *SpecialWordsModelsClientWithContinueOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/continue"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithDef -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithDefOptions contains the optional parameters for the SpecialWordsModelsClient.WithDef
//     method.
func (client *SpecialWordsModelsClient) WithDef(ctx context.Context, body Def, options *SpecialWordsModelsClientWithDefOptions) (SpecialWordsModelsClientWithDefResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithDef"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withDefCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithDefResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithDefResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithDefResponse{}, err
	}
	return SpecialWordsModelsClientWithDefResponse{}, nil
}

// withDefCreateRequest creates the WithDef request.
func (client *SpecialWordsModelsClient) withDefCreateRequest(ctx context.Context, body Def, _ *SpecialWordsModelsClientWithDefOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/def"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithDel -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithDelOptions contains the optional parameters for the SpecialWordsModelsClient.WithDel
//     method.
func (client *SpecialWordsModelsClient) WithDel(ctx context.Context, body Del, options *SpecialWordsModelsClientWithDelOptions) (SpecialWordsModelsClientWithDelResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithDel"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withDelCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithDelResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithDelResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithDelResponse{}, err
	}
	return SpecialWordsModelsClientWithDelResponse{}, nil
}

// withDelCreateRequest creates the WithDel request.
func (client *SpecialWordsModelsClient) withDelCreateRequest(ctx context.Context, body Del, _ *SpecialWordsModelsClientWithDelOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/del"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithElif -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithElifOptions contains the optional parameters for the SpecialWordsModelsClient.WithElif
//     method.
func (client *SpecialWordsModelsClient) WithElif(ctx context.Context, body Elif, options *SpecialWordsModelsClientWithElifOptions) (SpecialWordsModelsClientWithElifResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithElif"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withElifCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithElifResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithElifResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithElifResponse{}, err
	}
	return SpecialWordsModelsClientWithElifResponse{}, nil
}

// withElifCreateRequest creates the WithElif request.
func (client *SpecialWordsModelsClient) withElifCreateRequest(ctx context.Context, body Elif, _ *SpecialWordsModelsClientWithElifOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/elif"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithElse -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithElseOptions contains the optional parameters for the SpecialWordsModelsClient.WithElse
//     method.
func (client *SpecialWordsModelsClient) WithElse(ctx context.Context, body Else, options *SpecialWordsModelsClientWithElseOptions) (SpecialWordsModelsClientWithElseResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithElse"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withElseCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithElseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithElseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithElseResponse{}, err
	}
	return SpecialWordsModelsClientWithElseResponse{}, nil
}

// withElseCreateRequest creates the WithElse request.
func (client *SpecialWordsModelsClient) withElseCreateRequest(ctx context.Context, body Else, _ *SpecialWordsModelsClientWithElseOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/else"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithExcept -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithExceptOptions contains the optional parameters for the SpecialWordsModelsClient.WithExcept
//     method.
func (client *SpecialWordsModelsClient) WithExcept(ctx context.Context, body Except, options *SpecialWordsModelsClientWithExceptOptions) (SpecialWordsModelsClientWithExceptResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithExcept"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withExceptCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithExceptResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithExceptResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithExceptResponse{}, err
	}
	return SpecialWordsModelsClientWithExceptResponse{}, nil
}

// withExceptCreateRequest creates the WithExcept request.
func (client *SpecialWordsModelsClient) withExceptCreateRequest(ctx context.Context, body Except, _ *SpecialWordsModelsClientWithExceptOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/except"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithExec -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithExecOptions contains the optional parameters for the SpecialWordsModelsClient.WithExec
//     method.
func (client *SpecialWordsModelsClient) WithExec(ctx context.Context, body Exec, options *SpecialWordsModelsClientWithExecOptions) (SpecialWordsModelsClientWithExecResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithExec"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withExecCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithExecResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithExecResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithExecResponse{}, err
	}
	return SpecialWordsModelsClientWithExecResponse{}, nil
}

// withExecCreateRequest creates the WithExec request.
func (client *SpecialWordsModelsClient) withExecCreateRequest(ctx context.Context, body Exec, _ *SpecialWordsModelsClientWithExecOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/exec"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithFinally -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithFinallyOptions contains the optional parameters for the SpecialWordsModelsClient.WithFinally
//     method.
func (client *SpecialWordsModelsClient) WithFinally(ctx context.Context, body Finally, options *SpecialWordsModelsClientWithFinallyOptions) (SpecialWordsModelsClientWithFinallyResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithFinally"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withFinallyCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithFinallyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithFinallyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithFinallyResponse{}, err
	}
	return SpecialWordsModelsClientWithFinallyResponse{}, nil
}

// withFinallyCreateRequest creates the WithFinally request.
func (client *SpecialWordsModelsClient) withFinallyCreateRequest(ctx context.Context, body Finally, _ *SpecialWordsModelsClientWithFinallyOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/finally"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithFor -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithForOptions contains the optional parameters for the SpecialWordsModelsClient.WithFor
//     method.
func (client *SpecialWordsModelsClient) WithFor(ctx context.Context, body For, options *SpecialWordsModelsClientWithForOptions) (SpecialWordsModelsClientWithForResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithFor"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withForCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithForResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithForResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithForResponse{}, err
	}
	return SpecialWordsModelsClientWithForResponse{}, nil
}

// withForCreateRequest creates the WithFor request.
func (client *SpecialWordsModelsClient) withForCreateRequest(ctx context.Context, body For, _ *SpecialWordsModelsClientWithForOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/for"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithFrom -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithFromOptions contains the optional parameters for the SpecialWordsModelsClient.WithFrom
//     method.
func (client *SpecialWordsModelsClient) WithFrom(ctx context.Context, body From, options *SpecialWordsModelsClientWithFromOptions) (SpecialWordsModelsClientWithFromResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithFrom"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withFromCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithFromResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithFromResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithFromResponse{}, err
	}
	return SpecialWordsModelsClientWithFromResponse{}, nil
}

// withFromCreateRequest creates the WithFrom request.
func (client *SpecialWordsModelsClient) withFromCreateRequest(ctx context.Context, body From, _ *SpecialWordsModelsClientWithFromOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/from"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithGlobal -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithGlobalOptions contains the optional parameters for the SpecialWordsModelsClient.WithGlobal
//     method.
func (client *SpecialWordsModelsClient) WithGlobal(ctx context.Context, body Global, options *SpecialWordsModelsClientWithGlobalOptions) (SpecialWordsModelsClientWithGlobalResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithGlobal"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withGlobalCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithGlobalResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithGlobalResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithGlobalResponse{}, err
	}
	return SpecialWordsModelsClientWithGlobalResponse{}, nil
}

// withGlobalCreateRequest creates the WithGlobal request.
func (client *SpecialWordsModelsClient) withGlobalCreateRequest(ctx context.Context, body Global, _ *SpecialWordsModelsClientWithGlobalOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/global"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithIf -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithIfOptions contains the optional parameters for the SpecialWordsModelsClient.WithIf
//     method.
func (client *SpecialWordsModelsClient) WithIf(ctx context.Context, body If, options *SpecialWordsModelsClientWithIfOptions) (SpecialWordsModelsClientWithIfResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithIf"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withIfCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithIfResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithIfResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithIfResponse{}, err
	}
	return SpecialWordsModelsClientWithIfResponse{}, nil
}

// withIfCreateRequest creates the WithIf request.
func (client *SpecialWordsModelsClient) withIfCreateRequest(ctx context.Context, body If, _ *SpecialWordsModelsClientWithIfOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/if"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithImport -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithImportOptions contains the optional parameters for the SpecialWordsModelsClient.WithImport
//     method.
func (client *SpecialWordsModelsClient) WithImport(ctx context.Context, body Import, options *SpecialWordsModelsClientWithImportOptions) (SpecialWordsModelsClientWithImportResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithImport"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withImportCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithImportResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithImportResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithImportResponse{}, err
	}
	return SpecialWordsModelsClientWithImportResponse{}, nil
}

// withImportCreateRequest creates the WithImport request.
func (client *SpecialWordsModelsClient) withImportCreateRequest(ctx context.Context, body Import, _ *SpecialWordsModelsClientWithImportOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/import"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithIn -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithInOptions contains the optional parameters for the SpecialWordsModelsClient.WithIn
//     method.
func (client *SpecialWordsModelsClient) WithIn(ctx context.Context, body In, options *SpecialWordsModelsClientWithInOptions) (SpecialWordsModelsClientWithInResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithIn"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withInCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithInResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithInResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithInResponse{}, err
	}
	return SpecialWordsModelsClientWithInResponse{}, nil
}

// withInCreateRequest creates the WithIn request.
func (client *SpecialWordsModelsClient) withInCreateRequest(ctx context.Context, body In, _ *SpecialWordsModelsClientWithInOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/in"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithIs -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithIsOptions contains the optional parameters for the SpecialWordsModelsClient.WithIs
//     method.
func (client *SpecialWordsModelsClient) WithIs(ctx context.Context, body Is, options *SpecialWordsModelsClientWithIsOptions) (SpecialWordsModelsClientWithIsResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithIs"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withIsCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithIsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithIsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithIsResponse{}, err
	}
	return SpecialWordsModelsClientWithIsResponse{}, nil
}

// withIsCreateRequest creates the WithIs request.
func (client *SpecialWordsModelsClient) withIsCreateRequest(ctx context.Context, body Is, _ *SpecialWordsModelsClientWithIsOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/is"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithLambda -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithLambdaOptions contains the optional parameters for the SpecialWordsModelsClient.WithLambda
//     method.
func (client *SpecialWordsModelsClient) WithLambda(ctx context.Context, body Lambda, options *SpecialWordsModelsClientWithLambdaOptions) (SpecialWordsModelsClientWithLambdaResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithLambda"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withLambdaCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithLambdaResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithLambdaResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithLambdaResponse{}, err
	}
	return SpecialWordsModelsClientWithLambdaResponse{}, nil
}

// withLambdaCreateRequest creates the WithLambda request.
func (client *SpecialWordsModelsClient) withLambdaCreateRequest(ctx context.Context, body Lambda, _ *SpecialWordsModelsClientWithLambdaOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/lambda"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithNot -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithNotOptions contains the optional parameters for the SpecialWordsModelsClient.WithNot
//     method.
func (client *SpecialWordsModelsClient) WithNot(ctx context.Context, body Not, options *SpecialWordsModelsClientWithNotOptions) (SpecialWordsModelsClientWithNotResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithNot"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withNotCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithNotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithNotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithNotResponse{}, err
	}
	return SpecialWordsModelsClientWithNotResponse{}, nil
}

// withNotCreateRequest creates the WithNot request.
func (client *SpecialWordsModelsClient) withNotCreateRequest(ctx context.Context, body Not, _ *SpecialWordsModelsClientWithNotOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/not"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithOr -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithOrOptions contains the optional parameters for the SpecialWordsModelsClient.WithOr
//     method.
func (client *SpecialWordsModelsClient) WithOr(ctx context.Context, body Or, options *SpecialWordsModelsClientWithOrOptions) (SpecialWordsModelsClientWithOrResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithOr"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withOrCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithOrResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithOrResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithOrResponse{}, err
	}
	return SpecialWordsModelsClientWithOrResponse{}, nil
}

// withOrCreateRequest creates the WithOr request.
func (client *SpecialWordsModelsClient) withOrCreateRequest(ctx context.Context, body Or, _ *SpecialWordsModelsClientWithOrOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/or"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithPass -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithPassOptions contains the optional parameters for the SpecialWordsModelsClient.WithPass
//     method.
func (client *SpecialWordsModelsClient) WithPass(ctx context.Context, body Pass, options *SpecialWordsModelsClientWithPassOptions) (SpecialWordsModelsClientWithPassResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithPass"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withPassCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithPassResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithPassResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithPassResponse{}, err
	}
	return SpecialWordsModelsClientWithPassResponse{}, nil
}

// withPassCreateRequest creates the WithPass request.
func (client *SpecialWordsModelsClient) withPassCreateRequest(ctx context.Context, body Pass, _ *SpecialWordsModelsClientWithPassOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/pass"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithRaise -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithRaiseOptions contains the optional parameters for the SpecialWordsModelsClient.WithRaise
//     method.
func (client *SpecialWordsModelsClient) WithRaise(ctx context.Context, body Raise, options *SpecialWordsModelsClientWithRaiseOptions) (SpecialWordsModelsClientWithRaiseResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithRaise"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withRaiseCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithRaiseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithRaiseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithRaiseResponse{}, err
	}
	return SpecialWordsModelsClientWithRaiseResponse{}, nil
}

// withRaiseCreateRequest creates the WithRaise request.
func (client *SpecialWordsModelsClient) withRaiseCreateRequest(ctx context.Context, body Raise, _ *SpecialWordsModelsClientWithRaiseOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/raise"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithReturn -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithReturnOptions contains the optional parameters for the SpecialWordsModelsClient.WithReturn
//     method.
func (client *SpecialWordsModelsClient) WithReturn(ctx context.Context, body Return, options *SpecialWordsModelsClientWithReturnOptions) (SpecialWordsModelsClientWithReturnResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithReturn"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withReturnCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithReturnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithReturnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithReturnResponse{}, err
	}
	return SpecialWordsModelsClientWithReturnResponse{}, nil
}

// withReturnCreateRequest creates the WithReturn request.
func (client *SpecialWordsModelsClient) withReturnCreateRequest(ctx context.Context, body Return, _ *SpecialWordsModelsClientWithReturnOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/return"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithTry -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithTryOptions contains the optional parameters for the SpecialWordsModelsClient.WithTry
//     method.
func (client *SpecialWordsModelsClient) WithTry(ctx context.Context, body Try, options *SpecialWordsModelsClientWithTryOptions) (SpecialWordsModelsClientWithTryResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithTry"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withTryCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithTryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithTryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithTryResponse{}, err
	}
	return SpecialWordsModelsClientWithTryResponse{}, nil
}

// withTryCreateRequest creates the WithTry request.
func (client *SpecialWordsModelsClient) withTryCreateRequest(ctx context.Context, body Try, _ *SpecialWordsModelsClientWithTryOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/try"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithWhile -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithWhileOptions contains the optional parameters for the SpecialWordsModelsClient.WithWhile
//     method.
func (client *SpecialWordsModelsClient) WithWhile(ctx context.Context, body While, options *SpecialWordsModelsClientWithWhileOptions) (SpecialWordsModelsClientWithWhileResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithWhile"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withWhileCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithWhileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithWhileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithWhileResponse{}, err
	}
	return SpecialWordsModelsClientWithWhileResponse{}, nil
}

// withWhileCreateRequest creates the WithWhile request.
func (client *SpecialWordsModelsClient) withWhileCreateRequest(ctx context.Context, body While, _ *SpecialWordsModelsClientWithWhileOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/while"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithWith -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithWithOptions contains the optional parameters for the SpecialWordsModelsClient.WithWith
//     method.
func (client *SpecialWordsModelsClient) WithWith(ctx context.Context, body With, options *SpecialWordsModelsClientWithWithOptions) (SpecialWordsModelsClientWithWithResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithWith"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withWithCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithWithResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithWithResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithWithResponse{}, err
	}
	return SpecialWordsModelsClientWithWithResponse{}, nil
}

// withWithCreateRequest creates the WithWith request.
func (client *SpecialWordsModelsClient) withWithCreateRequest(ctx context.Context, body With, _ *SpecialWordsModelsClientWithWithOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/with"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// WithYield -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsModelsClientWithYieldOptions contains the optional parameters for the SpecialWordsModelsClient.WithYield
//     method.
func (client *SpecialWordsModelsClient) WithYield(ctx context.Context, body Yield, options *SpecialWordsModelsClientWithYieldOptions) (SpecialWordsModelsClientWithYieldResponse, error) {
	var err error
	const operationName = "SpecialWordsModelsClient.WithYield"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withYieldCreateRequest(ctx, body, options)
	if err != nil {
		return SpecialWordsModelsClientWithYieldResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsModelsClientWithYieldResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsModelsClientWithYieldResponse{}, err
	}
	return SpecialWordsModelsClientWithYieldResponse{}, nil
}

// withYieldCreateRequest creates the WithYield request.
func (client *SpecialWordsModelsClient) withYieldCreateRequest(ctx context.Context, body Yield, _ *SpecialWordsModelsClientWithYieldOptions) (*policy.Request, error) {
	urlPath := "/special-words/models/yield"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}
