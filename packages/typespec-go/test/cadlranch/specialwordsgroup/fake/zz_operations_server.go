// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"specialwordsgroup"
)

// OperationsServer is a fake server for instances of the specialwordsgroup.OperationsClient type.
type OperationsServer struct {
	// And is the fake for method OperationsClient.And
	// HTTP status codes to indicate success: http.StatusNoContent
	And func(ctx context.Context, options *specialwordsgroup.OperationsClientAndOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientAndResponse], errResp azfake.ErrorResponder)

	// As is the fake for method OperationsClient.As
	// HTTP status codes to indicate success: http.StatusNoContent
	As func(ctx context.Context, options *specialwordsgroup.OperationsClientAsOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientAsResponse], errResp azfake.ErrorResponder)

	// Assert is the fake for method OperationsClient.Assert
	// HTTP status codes to indicate success: http.StatusNoContent
	Assert func(ctx context.Context, options *specialwordsgroup.OperationsClientAssertOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientAssertResponse], errResp azfake.ErrorResponder)

	// Async is the fake for method OperationsClient.Async
	// HTTP status codes to indicate success: http.StatusNoContent
	Async func(ctx context.Context, options *specialwordsgroup.OperationsClientAsyncOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientAsyncResponse], errResp azfake.ErrorResponder)

	// Await is the fake for method OperationsClient.Await
	// HTTP status codes to indicate success: http.StatusNoContent
	Await func(ctx context.Context, options *specialwordsgroup.OperationsClientAwaitOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientAwaitResponse], errResp azfake.ErrorResponder)

	// Break is the fake for method OperationsClient.Break
	// HTTP status codes to indicate success: http.StatusNoContent
	Break func(ctx context.Context, options *specialwordsgroup.OperationsClientBreakOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientBreakResponse], errResp azfake.ErrorResponder)

	// Class is the fake for method OperationsClient.Class
	// HTTP status codes to indicate success: http.StatusNoContent
	Class func(ctx context.Context, options *specialwordsgroup.OperationsClientClassOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientClassResponse], errResp azfake.ErrorResponder)

	// Constructor is the fake for method OperationsClient.Constructor
	// HTTP status codes to indicate success: http.StatusNoContent
	Constructor func(ctx context.Context, options *specialwordsgroup.OperationsClientConstructorOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientConstructorResponse], errResp azfake.ErrorResponder)

	// Continue is the fake for method OperationsClient.Continue
	// HTTP status codes to indicate success: http.StatusNoContent
	Continue func(ctx context.Context, options *specialwordsgroup.OperationsClientContinueOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientContinueResponse], errResp azfake.ErrorResponder)

	// Def is the fake for method OperationsClient.Def
	// HTTP status codes to indicate success: http.StatusNoContent
	Def func(ctx context.Context, options *specialwordsgroup.OperationsClientDefOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientDefResponse], errResp azfake.ErrorResponder)

	// Del is the fake for method OperationsClient.Del
	// HTTP status codes to indicate success: http.StatusNoContent
	Del func(ctx context.Context, options *specialwordsgroup.OperationsClientDelOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientDelResponse], errResp azfake.ErrorResponder)

	// Elif is the fake for method OperationsClient.Elif
	// HTTP status codes to indicate success: http.StatusNoContent
	Elif func(ctx context.Context, options *specialwordsgroup.OperationsClientElifOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientElifResponse], errResp azfake.ErrorResponder)

	// Else is the fake for method OperationsClient.Else
	// HTTP status codes to indicate success: http.StatusNoContent
	Else func(ctx context.Context, options *specialwordsgroup.OperationsClientElseOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientElseResponse], errResp azfake.ErrorResponder)

	// Except is the fake for method OperationsClient.Except
	// HTTP status codes to indicate success: http.StatusNoContent
	Except func(ctx context.Context, options *specialwordsgroup.OperationsClientExceptOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientExceptResponse], errResp azfake.ErrorResponder)

	// Exec is the fake for method OperationsClient.Exec
	// HTTP status codes to indicate success: http.StatusNoContent
	Exec func(ctx context.Context, options *specialwordsgroup.OperationsClientExecOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientExecResponse], errResp azfake.ErrorResponder)

	// Finally is the fake for method OperationsClient.Finally
	// HTTP status codes to indicate success: http.StatusNoContent
	Finally func(ctx context.Context, options *specialwordsgroup.OperationsClientFinallyOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientFinallyResponse], errResp azfake.ErrorResponder)

	// For is the fake for method OperationsClient.For
	// HTTP status codes to indicate success: http.StatusNoContent
	For func(ctx context.Context, options *specialwordsgroup.OperationsClientForOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientForResponse], errResp azfake.ErrorResponder)

	// From is the fake for method OperationsClient.From
	// HTTP status codes to indicate success: http.StatusNoContent
	From func(ctx context.Context, options *specialwordsgroup.OperationsClientFromOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientFromResponse], errResp azfake.ErrorResponder)

	// Global is the fake for method OperationsClient.Global
	// HTTP status codes to indicate success: http.StatusNoContent
	Global func(ctx context.Context, options *specialwordsgroup.OperationsClientGlobalOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientGlobalResponse], errResp azfake.ErrorResponder)

	// If is the fake for method OperationsClient.If
	// HTTP status codes to indicate success: http.StatusNoContent
	If func(ctx context.Context, options *specialwordsgroup.OperationsClientIfOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientIfResponse], errResp azfake.ErrorResponder)

	// Import is the fake for method OperationsClient.Import
	// HTTP status codes to indicate success: http.StatusNoContent
	Import func(ctx context.Context, options *specialwordsgroup.OperationsClientImportOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientImportResponse], errResp azfake.ErrorResponder)

	// In is the fake for method OperationsClient.In
	// HTTP status codes to indicate success: http.StatusNoContent
	In func(ctx context.Context, options *specialwordsgroup.OperationsClientInOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientInResponse], errResp azfake.ErrorResponder)

	// Is is the fake for method OperationsClient.Is
	// HTTP status codes to indicate success: http.StatusNoContent
	Is func(ctx context.Context, options *specialwordsgroup.OperationsClientIsOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientIsResponse], errResp azfake.ErrorResponder)

	// Lambda is the fake for method OperationsClient.Lambda
	// HTTP status codes to indicate success: http.StatusNoContent
	Lambda func(ctx context.Context, options *specialwordsgroup.OperationsClientLambdaOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientLambdaResponse], errResp azfake.ErrorResponder)

	// Not is the fake for method OperationsClient.Not
	// HTTP status codes to indicate success: http.StatusNoContent
	Not func(ctx context.Context, options *specialwordsgroup.OperationsClientNotOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientNotResponse], errResp azfake.ErrorResponder)

	// Or is the fake for method OperationsClient.Or
	// HTTP status codes to indicate success: http.StatusNoContent
	Or func(ctx context.Context, options *specialwordsgroup.OperationsClientOrOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientOrResponse], errResp azfake.ErrorResponder)

	// Pass is the fake for method OperationsClient.Pass
	// HTTP status codes to indicate success: http.StatusNoContent
	Pass func(ctx context.Context, options *specialwordsgroup.OperationsClientPassOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientPassResponse], errResp azfake.ErrorResponder)

	// Raise is the fake for method OperationsClient.Raise
	// HTTP status codes to indicate success: http.StatusNoContent
	Raise func(ctx context.Context, options *specialwordsgroup.OperationsClientRaiseOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientRaiseResponse], errResp azfake.ErrorResponder)

	// Return is the fake for method OperationsClient.Return
	// HTTP status codes to indicate success: http.StatusNoContent
	Return func(ctx context.Context, options *specialwordsgroup.OperationsClientReturnOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientReturnResponse], errResp azfake.ErrorResponder)

	// Try is the fake for method OperationsClient.Try
	// HTTP status codes to indicate success: http.StatusNoContent
	Try func(ctx context.Context, options *specialwordsgroup.OperationsClientTryOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientTryResponse], errResp azfake.ErrorResponder)

	// While is the fake for method OperationsClient.While
	// HTTP status codes to indicate success: http.StatusNoContent
	While func(ctx context.Context, options *specialwordsgroup.OperationsClientWhileOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientWhileResponse], errResp azfake.ErrorResponder)

	// With is the fake for method OperationsClient.With
	// HTTP status codes to indicate success: http.StatusNoContent
	With func(ctx context.Context, options *specialwordsgroup.OperationsClientWithOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientWithResponse], errResp azfake.ErrorResponder)

	// Yield is the fake for method OperationsClient.Yield
	// HTTP status codes to indicate success: http.StatusNoContent
	Yield func(ctx context.Context, options *specialwordsgroup.OperationsClientYieldOptions) (resp azfake.Responder[specialwordsgroup.OperationsClientYieldResponse], errResp azfake.ErrorResponder)
}

// NewOperationsServerTransport creates a new instance of OperationsServerTransport with the provided implementation.
// The returned OperationsServerTransport instance is connected to an instance of specialwordsgroup.OperationsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewOperationsServerTransport(srv *OperationsServer) *OperationsServerTransport {
	return &OperationsServerTransport{srv: srv}
}

// OperationsServerTransport connects instances of specialwordsgroup.OperationsClient to instances of OperationsServer.
// Don't use this type directly, use NewOperationsServerTransport instead.
type OperationsServerTransport struct {
	srv *OperationsServer
}

// Do implements the policy.Transporter interface for OperationsServerTransport.
func (o *OperationsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "OperationsClient.And":
		resp, err = o.dispatchAnd(req)
	case "OperationsClient.As":
		resp, err = o.dispatchAs(req)
	case "OperationsClient.Assert":
		resp, err = o.dispatchAssert(req)
	case "OperationsClient.Async":
		resp, err = o.dispatchAsync(req)
	case "OperationsClient.Await":
		resp, err = o.dispatchAwait(req)
	case "OperationsClient.Break":
		resp, err = o.dispatchBreak(req)
	case "OperationsClient.Class":
		resp, err = o.dispatchClass(req)
	case "OperationsClient.Constructor":
		resp, err = o.dispatchConstructor(req)
	case "OperationsClient.Continue":
		resp, err = o.dispatchContinue(req)
	case "OperationsClient.Def":
		resp, err = o.dispatchDef(req)
	case "OperationsClient.Del":
		resp, err = o.dispatchDel(req)
	case "OperationsClient.Elif":
		resp, err = o.dispatchElif(req)
	case "OperationsClient.Else":
		resp, err = o.dispatchElse(req)
	case "OperationsClient.Except":
		resp, err = o.dispatchExcept(req)
	case "OperationsClient.Exec":
		resp, err = o.dispatchExec(req)
	case "OperationsClient.Finally":
		resp, err = o.dispatchFinally(req)
	case "OperationsClient.For":
		resp, err = o.dispatchFor(req)
	case "OperationsClient.From":
		resp, err = o.dispatchFrom(req)
	case "OperationsClient.Global":
		resp, err = o.dispatchGlobal(req)
	case "OperationsClient.If":
		resp, err = o.dispatchIf(req)
	case "OperationsClient.Import":
		resp, err = o.dispatchImport(req)
	case "OperationsClient.In":
		resp, err = o.dispatchIn(req)
	case "OperationsClient.Is":
		resp, err = o.dispatchIs(req)
	case "OperationsClient.Lambda":
		resp, err = o.dispatchLambda(req)
	case "OperationsClient.Not":
		resp, err = o.dispatchNot(req)
	case "OperationsClient.Or":
		resp, err = o.dispatchOr(req)
	case "OperationsClient.Pass":
		resp, err = o.dispatchPass(req)
	case "OperationsClient.Raise":
		resp, err = o.dispatchRaise(req)
	case "OperationsClient.Return":
		resp, err = o.dispatchReturn(req)
	case "OperationsClient.Try":
		resp, err = o.dispatchTry(req)
	case "OperationsClient.While":
		resp, err = o.dispatchWhile(req)
	case "OperationsClient.With":
		resp, err = o.dispatchWith(req)
	case "OperationsClient.Yield":
		resp, err = o.dispatchYield(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (o *OperationsServerTransport) dispatchAnd(req *http.Request) (*http.Response, error) {
	if o.srv.And == nil {
		return nil, &nonRetriableError{errors.New("fake for method And not implemented")}
	}
	respr, errRespr := o.srv.And(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchAs(req *http.Request) (*http.Response, error) {
	if o.srv.As == nil {
		return nil, &nonRetriableError{errors.New("fake for method As not implemented")}
	}
	respr, errRespr := o.srv.As(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchAssert(req *http.Request) (*http.Response, error) {
	if o.srv.Assert == nil {
		return nil, &nonRetriableError{errors.New("fake for method Assert not implemented")}
	}
	respr, errRespr := o.srv.Assert(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchAsync(req *http.Request) (*http.Response, error) {
	if o.srv.Async == nil {
		return nil, &nonRetriableError{errors.New("fake for method Async not implemented")}
	}
	respr, errRespr := o.srv.Async(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchAwait(req *http.Request) (*http.Response, error) {
	if o.srv.Await == nil {
		return nil, &nonRetriableError{errors.New("fake for method Await not implemented")}
	}
	respr, errRespr := o.srv.Await(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchBreak(req *http.Request) (*http.Response, error) {
	if o.srv.Break == nil {
		return nil, &nonRetriableError{errors.New("fake for method Break not implemented")}
	}
	respr, errRespr := o.srv.Break(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchClass(req *http.Request) (*http.Response, error) {
	if o.srv.Class == nil {
		return nil, &nonRetriableError{errors.New("fake for method Class not implemented")}
	}
	respr, errRespr := o.srv.Class(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchConstructor(req *http.Request) (*http.Response, error) {
	if o.srv.Constructor == nil {
		return nil, &nonRetriableError{errors.New("fake for method Constructor not implemented")}
	}
	respr, errRespr := o.srv.Constructor(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchContinue(req *http.Request) (*http.Response, error) {
	if o.srv.Continue == nil {
		return nil, &nonRetriableError{errors.New("fake for method Continue not implemented")}
	}
	respr, errRespr := o.srv.Continue(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchDef(req *http.Request) (*http.Response, error) {
	if o.srv.Def == nil {
		return nil, &nonRetriableError{errors.New("fake for method Def not implemented")}
	}
	respr, errRespr := o.srv.Def(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchDel(req *http.Request) (*http.Response, error) {
	if o.srv.Del == nil {
		return nil, &nonRetriableError{errors.New("fake for method Del not implemented")}
	}
	respr, errRespr := o.srv.Del(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchElif(req *http.Request) (*http.Response, error) {
	if o.srv.Elif == nil {
		return nil, &nonRetriableError{errors.New("fake for method Elif not implemented")}
	}
	respr, errRespr := o.srv.Elif(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchElse(req *http.Request) (*http.Response, error) {
	if o.srv.Else == nil {
		return nil, &nonRetriableError{errors.New("fake for method Else not implemented")}
	}
	respr, errRespr := o.srv.Else(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchExcept(req *http.Request) (*http.Response, error) {
	if o.srv.Except == nil {
		return nil, &nonRetriableError{errors.New("fake for method Except not implemented")}
	}
	respr, errRespr := o.srv.Except(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchExec(req *http.Request) (*http.Response, error) {
	if o.srv.Exec == nil {
		return nil, &nonRetriableError{errors.New("fake for method Exec not implemented")}
	}
	respr, errRespr := o.srv.Exec(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchFinally(req *http.Request) (*http.Response, error) {
	if o.srv.Finally == nil {
		return nil, &nonRetriableError{errors.New("fake for method Finally not implemented")}
	}
	respr, errRespr := o.srv.Finally(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchFor(req *http.Request) (*http.Response, error) {
	if o.srv.For == nil {
		return nil, &nonRetriableError{errors.New("fake for method For not implemented")}
	}
	respr, errRespr := o.srv.For(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchFrom(req *http.Request) (*http.Response, error) {
	if o.srv.From == nil {
		return nil, &nonRetriableError{errors.New("fake for method From not implemented")}
	}
	respr, errRespr := o.srv.From(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchGlobal(req *http.Request) (*http.Response, error) {
	if o.srv.Global == nil {
		return nil, &nonRetriableError{errors.New("fake for method Global not implemented")}
	}
	respr, errRespr := o.srv.Global(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchIf(req *http.Request) (*http.Response, error) {
	if o.srv.If == nil {
		return nil, &nonRetriableError{errors.New("fake for method If not implemented")}
	}
	respr, errRespr := o.srv.If(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchImport(req *http.Request) (*http.Response, error) {
	if o.srv.Import == nil {
		return nil, &nonRetriableError{errors.New("fake for method Import not implemented")}
	}
	respr, errRespr := o.srv.Import(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchIn(req *http.Request) (*http.Response, error) {
	if o.srv.In == nil {
		return nil, &nonRetriableError{errors.New("fake for method In not implemented")}
	}
	respr, errRespr := o.srv.In(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchIs(req *http.Request) (*http.Response, error) {
	if o.srv.Is == nil {
		return nil, &nonRetriableError{errors.New("fake for method Is not implemented")}
	}
	respr, errRespr := o.srv.Is(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchLambda(req *http.Request) (*http.Response, error) {
	if o.srv.Lambda == nil {
		return nil, &nonRetriableError{errors.New("fake for method Lambda not implemented")}
	}
	respr, errRespr := o.srv.Lambda(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchNot(req *http.Request) (*http.Response, error) {
	if o.srv.Not == nil {
		return nil, &nonRetriableError{errors.New("fake for method Not not implemented")}
	}
	respr, errRespr := o.srv.Not(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchOr(req *http.Request) (*http.Response, error) {
	if o.srv.Or == nil {
		return nil, &nonRetriableError{errors.New("fake for method Or not implemented")}
	}
	respr, errRespr := o.srv.Or(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchPass(req *http.Request) (*http.Response, error) {
	if o.srv.Pass == nil {
		return nil, &nonRetriableError{errors.New("fake for method Pass not implemented")}
	}
	respr, errRespr := o.srv.Pass(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchRaise(req *http.Request) (*http.Response, error) {
	if o.srv.Raise == nil {
		return nil, &nonRetriableError{errors.New("fake for method Raise not implemented")}
	}
	respr, errRespr := o.srv.Raise(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchReturn(req *http.Request) (*http.Response, error) {
	if o.srv.Return == nil {
		return nil, &nonRetriableError{errors.New("fake for method Return not implemented")}
	}
	respr, errRespr := o.srv.Return(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchTry(req *http.Request) (*http.Response, error) {
	if o.srv.Try == nil {
		return nil, &nonRetriableError{errors.New("fake for method Try not implemented")}
	}
	respr, errRespr := o.srv.Try(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchWhile(req *http.Request) (*http.Response, error) {
	if o.srv.While == nil {
		return nil, &nonRetriableError{errors.New("fake for method While not implemented")}
	}
	respr, errRespr := o.srv.While(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchWith(req *http.Request) (*http.Response, error) {
	if o.srv.With == nil {
		return nil, &nonRetriableError{errors.New("fake for method With not implemented")}
	}
	respr, errRespr := o.srv.With(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (o *OperationsServerTransport) dispatchYield(req *http.Request) (*http.Response, error) {
	if o.srv.Yield == nil {
		return nil, &nonRetriableError{errors.New("fake for method Yield not implemented")}
	}
	respr, errRespr := o.srv.Yield(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
