// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"specialwordsgroup"
)

// ModelsServer is a fake server for instances of the specialwordsgroup.ModelsClient type.
type ModelsServer struct {
	// WithAnd is the fake for method ModelsClient.WithAnd
	// HTTP status codes to indicate success: http.StatusNoContent
	WithAnd func(ctx context.Context, body specialwordsgroup.And, options *specialwordsgroup.ModelsClientWithAndOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithAndResponse], errResp azfake.ErrorResponder)

	// WithAs is the fake for method ModelsClient.WithAs
	// HTTP status codes to indicate success: http.StatusNoContent
	WithAs func(ctx context.Context, body specialwordsgroup.As, options *specialwordsgroup.ModelsClientWithAsOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithAsResponse], errResp azfake.ErrorResponder)

	// WithAssert is the fake for method ModelsClient.WithAssert
	// HTTP status codes to indicate success: http.StatusNoContent
	WithAssert func(ctx context.Context, body specialwordsgroup.Assert, options *specialwordsgroup.ModelsClientWithAssertOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithAssertResponse], errResp azfake.ErrorResponder)

	// WithAsync is the fake for method ModelsClient.WithAsync
	// HTTP status codes to indicate success: http.StatusNoContent
	WithAsync func(ctx context.Context, body specialwordsgroup.Async, options *specialwordsgroup.ModelsClientWithAsyncOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithAsyncResponse], errResp azfake.ErrorResponder)

	// WithAwait is the fake for method ModelsClient.WithAwait
	// HTTP status codes to indicate success: http.StatusNoContent
	WithAwait func(ctx context.Context, body specialwordsgroup.Await, options *specialwordsgroup.ModelsClientWithAwaitOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithAwaitResponse], errResp azfake.ErrorResponder)

	// WithBreak is the fake for method ModelsClient.WithBreak
	// HTTP status codes to indicate success: http.StatusNoContent
	WithBreak func(ctx context.Context, body specialwordsgroup.Break, options *specialwordsgroup.ModelsClientWithBreakOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithBreakResponse], errResp azfake.ErrorResponder)

	// WithClass is the fake for method ModelsClient.WithClass
	// HTTP status codes to indicate success: http.StatusNoContent
	WithClass func(ctx context.Context, body specialwordsgroup.Class, options *specialwordsgroup.ModelsClientWithClassOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithClassResponse], errResp azfake.ErrorResponder)

	// WithConstructor is the fake for method ModelsClient.WithConstructor
	// HTTP status codes to indicate success: http.StatusNoContent
	WithConstructor func(ctx context.Context, body specialwordsgroup.Constructor, options *specialwordsgroup.ModelsClientWithConstructorOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithConstructorResponse], errResp azfake.ErrorResponder)

	// WithContinue is the fake for method ModelsClient.WithContinue
	// HTTP status codes to indicate success: http.StatusNoContent
	WithContinue func(ctx context.Context, body specialwordsgroup.Continue, options *specialwordsgroup.ModelsClientWithContinueOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithContinueResponse], errResp azfake.ErrorResponder)

	// WithDef is the fake for method ModelsClient.WithDef
	// HTTP status codes to indicate success: http.StatusNoContent
	WithDef func(ctx context.Context, body specialwordsgroup.Def, options *specialwordsgroup.ModelsClientWithDefOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithDefResponse], errResp azfake.ErrorResponder)

	// WithDel is the fake for method ModelsClient.WithDel
	// HTTP status codes to indicate success: http.StatusNoContent
	WithDel func(ctx context.Context, body specialwordsgroup.Del, options *specialwordsgroup.ModelsClientWithDelOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithDelResponse], errResp azfake.ErrorResponder)

	// WithElif is the fake for method ModelsClient.WithElif
	// HTTP status codes to indicate success: http.StatusNoContent
	WithElif func(ctx context.Context, body specialwordsgroup.Elif, options *specialwordsgroup.ModelsClientWithElifOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithElifResponse], errResp azfake.ErrorResponder)

	// WithElse is the fake for method ModelsClient.WithElse
	// HTTP status codes to indicate success: http.StatusNoContent
	WithElse func(ctx context.Context, body specialwordsgroup.Else, options *specialwordsgroup.ModelsClientWithElseOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithElseResponse], errResp azfake.ErrorResponder)

	// WithExcept is the fake for method ModelsClient.WithExcept
	// HTTP status codes to indicate success: http.StatusNoContent
	WithExcept func(ctx context.Context, body specialwordsgroup.Except, options *specialwordsgroup.ModelsClientWithExceptOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithExceptResponse], errResp azfake.ErrorResponder)

	// WithExec is the fake for method ModelsClient.WithExec
	// HTTP status codes to indicate success: http.StatusNoContent
	WithExec func(ctx context.Context, body specialwordsgroup.Exec, options *specialwordsgroup.ModelsClientWithExecOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithExecResponse], errResp azfake.ErrorResponder)

	// WithFinally is the fake for method ModelsClient.WithFinally
	// HTTP status codes to indicate success: http.StatusNoContent
	WithFinally func(ctx context.Context, body specialwordsgroup.Finally, options *specialwordsgroup.ModelsClientWithFinallyOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithFinallyResponse], errResp azfake.ErrorResponder)

	// WithFor is the fake for method ModelsClient.WithFor
	// HTTP status codes to indicate success: http.StatusNoContent
	WithFor func(ctx context.Context, body specialwordsgroup.For, options *specialwordsgroup.ModelsClientWithForOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithForResponse], errResp azfake.ErrorResponder)

	// WithFrom is the fake for method ModelsClient.WithFrom
	// HTTP status codes to indicate success: http.StatusNoContent
	WithFrom func(ctx context.Context, body specialwordsgroup.From, options *specialwordsgroup.ModelsClientWithFromOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithFromResponse], errResp azfake.ErrorResponder)

	// WithGlobal is the fake for method ModelsClient.WithGlobal
	// HTTP status codes to indicate success: http.StatusNoContent
	WithGlobal func(ctx context.Context, body specialwordsgroup.Global, options *specialwordsgroup.ModelsClientWithGlobalOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithGlobalResponse], errResp azfake.ErrorResponder)

	// WithIf is the fake for method ModelsClient.WithIf
	// HTTP status codes to indicate success: http.StatusNoContent
	WithIf func(ctx context.Context, body specialwordsgroup.If, options *specialwordsgroup.ModelsClientWithIfOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithIfResponse], errResp azfake.ErrorResponder)

	// WithImport is the fake for method ModelsClient.WithImport
	// HTTP status codes to indicate success: http.StatusNoContent
	WithImport func(ctx context.Context, body specialwordsgroup.Import, options *specialwordsgroup.ModelsClientWithImportOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithImportResponse], errResp azfake.ErrorResponder)

	// WithIn is the fake for method ModelsClient.WithIn
	// HTTP status codes to indicate success: http.StatusNoContent
	WithIn func(ctx context.Context, body specialwordsgroup.In, options *specialwordsgroup.ModelsClientWithInOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithInResponse], errResp azfake.ErrorResponder)

	// WithIs is the fake for method ModelsClient.WithIs
	// HTTP status codes to indicate success: http.StatusNoContent
	WithIs func(ctx context.Context, body specialwordsgroup.Is, options *specialwordsgroup.ModelsClientWithIsOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithIsResponse], errResp azfake.ErrorResponder)

	// WithLambda is the fake for method ModelsClient.WithLambda
	// HTTP status codes to indicate success: http.StatusNoContent
	WithLambda func(ctx context.Context, body specialwordsgroup.Lambda, options *specialwordsgroup.ModelsClientWithLambdaOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithLambdaResponse], errResp azfake.ErrorResponder)

	// WithNot is the fake for method ModelsClient.WithNot
	// HTTP status codes to indicate success: http.StatusNoContent
	WithNot func(ctx context.Context, body specialwordsgroup.Not, options *specialwordsgroup.ModelsClientWithNotOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithNotResponse], errResp azfake.ErrorResponder)

	// WithOr is the fake for method ModelsClient.WithOr
	// HTTP status codes to indicate success: http.StatusNoContent
	WithOr func(ctx context.Context, body specialwordsgroup.Or, options *specialwordsgroup.ModelsClientWithOrOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithOrResponse], errResp azfake.ErrorResponder)

	// WithPass is the fake for method ModelsClient.WithPass
	// HTTP status codes to indicate success: http.StatusNoContent
	WithPass func(ctx context.Context, body specialwordsgroup.Pass, options *specialwordsgroup.ModelsClientWithPassOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithPassResponse], errResp azfake.ErrorResponder)

	// WithRaise is the fake for method ModelsClient.WithRaise
	// HTTP status codes to indicate success: http.StatusNoContent
	WithRaise func(ctx context.Context, body specialwordsgroup.Raise, options *specialwordsgroup.ModelsClientWithRaiseOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithRaiseResponse], errResp azfake.ErrorResponder)

	// WithReturn is the fake for method ModelsClient.WithReturn
	// HTTP status codes to indicate success: http.StatusNoContent
	WithReturn func(ctx context.Context, body specialwordsgroup.Return, options *specialwordsgroup.ModelsClientWithReturnOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithReturnResponse], errResp azfake.ErrorResponder)

	// WithTry is the fake for method ModelsClient.WithTry
	// HTTP status codes to indicate success: http.StatusNoContent
	WithTry func(ctx context.Context, body specialwordsgroup.Try, options *specialwordsgroup.ModelsClientWithTryOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithTryResponse], errResp azfake.ErrorResponder)

	// WithWhile is the fake for method ModelsClient.WithWhile
	// HTTP status codes to indicate success: http.StatusNoContent
	WithWhile func(ctx context.Context, body specialwordsgroup.While, options *specialwordsgroup.ModelsClientWithWhileOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithWhileResponse], errResp azfake.ErrorResponder)

	// WithWith is the fake for method ModelsClient.WithWith
	// HTTP status codes to indicate success: http.StatusNoContent
	WithWith func(ctx context.Context, body specialwordsgroup.With, options *specialwordsgroup.ModelsClientWithWithOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithWithResponse], errResp azfake.ErrorResponder)

	// WithYield is the fake for method ModelsClient.WithYield
	// HTTP status codes to indicate success: http.StatusNoContent
	WithYield func(ctx context.Context, body specialwordsgroup.Yield, options *specialwordsgroup.ModelsClientWithYieldOptions) (resp azfake.Responder[specialwordsgroup.ModelsClientWithYieldResponse], errResp azfake.ErrorResponder)
}

// NewModelsServerTransport creates a new instance of ModelsServerTransport with the provided implementation.
// The returned ModelsServerTransport instance is connected to an instance of specialwordsgroup.ModelsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewModelsServerTransport(srv *ModelsServer) *ModelsServerTransport {
	return &ModelsServerTransport{srv: srv}
}

// ModelsServerTransport connects instances of specialwordsgroup.ModelsClient to instances of ModelsServer.
// Don't use this type directly, use NewModelsServerTransport instead.
type ModelsServerTransport struct {
	srv *ModelsServer
}

// Do implements the policy.Transporter interface for ModelsServerTransport.
func (m *ModelsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "ModelsClient.WithAnd":
		resp, err = m.dispatchWithAnd(req)
	case "ModelsClient.WithAs":
		resp, err = m.dispatchWithAs(req)
	case "ModelsClient.WithAssert":
		resp, err = m.dispatchWithAssert(req)
	case "ModelsClient.WithAsync":
		resp, err = m.dispatchWithAsync(req)
	case "ModelsClient.WithAwait":
		resp, err = m.dispatchWithAwait(req)
	case "ModelsClient.WithBreak":
		resp, err = m.dispatchWithBreak(req)
	case "ModelsClient.WithClass":
		resp, err = m.dispatchWithClass(req)
	case "ModelsClient.WithConstructor":
		resp, err = m.dispatchWithConstructor(req)
	case "ModelsClient.WithContinue":
		resp, err = m.dispatchWithContinue(req)
	case "ModelsClient.WithDef":
		resp, err = m.dispatchWithDef(req)
	case "ModelsClient.WithDel":
		resp, err = m.dispatchWithDel(req)
	case "ModelsClient.WithElif":
		resp, err = m.dispatchWithElif(req)
	case "ModelsClient.WithElse":
		resp, err = m.dispatchWithElse(req)
	case "ModelsClient.WithExcept":
		resp, err = m.dispatchWithExcept(req)
	case "ModelsClient.WithExec":
		resp, err = m.dispatchWithExec(req)
	case "ModelsClient.WithFinally":
		resp, err = m.dispatchWithFinally(req)
	case "ModelsClient.WithFor":
		resp, err = m.dispatchWithFor(req)
	case "ModelsClient.WithFrom":
		resp, err = m.dispatchWithFrom(req)
	case "ModelsClient.WithGlobal":
		resp, err = m.dispatchWithGlobal(req)
	case "ModelsClient.WithIf":
		resp, err = m.dispatchWithIf(req)
	case "ModelsClient.WithImport":
		resp, err = m.dispatchWithImport(req)
	case "ModelsClient.WithIn":
		resp, err = m.dispatchWithIn(req)
	case "ModelsClient.WithIs":
		resp, err = m.dispatchWithIs(req)
	case "ModelsClient.WithLambda":
		resp, err = m.dispatchWithLambda(req)
	case "ModelsClient.WithNot":
		resp, err = m.dispatchWithNot(req)
	case "ModelsClient.WithOr":
		resp, err = m.dispatchWithOr(req)
	case "ModelsClient.WithPass":
		resp, err = m.dispatchWithPass(req)
	case "ModelsClient.WithRaise":
		resp, err = m.dispatchWithRaise(req)
	case "ModelsClient.WithReturn":
		resp, err = m.dispatchWithReturn(req)
	case "ModelsClient.WithTry":
		resp, err = m.dispatchWithTry(req)
	case "ModelsClient.WithWhile":
		resp, err = m.dispatchWithWhile(req)
	case "ModelsClient.WithWith":
		resp, err = m.dispatchWithWith(req)
	case "ModelsClient.WithYield":
		resp, err = m.dispatchWithYield(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithAnd(req *http.Request) (*http.Response, error) {
	if m.srv.WithAnd == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithAnd not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.And](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithAnd(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithAs(req *http.Request) (*http.Response, error) {
	if m.srv.WithAs == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithAs not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.As](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithAs(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithAssert(req *http.Request) (*http.Response, error) {
	if m.srv.WithAssert == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithAssert not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Assert](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithAssert(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithAsync(req *http.Request) (*http.Response, error) {
	if m.srv.WithAsync == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithAsync not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Async](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithAsync(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithAwait(req *http.Request) (*http.Response, error) {
	if m.srv.WithAwait == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithAwait not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Await](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithAwait(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithBreak(req *http.Request) (*http.Response, error) {
	if m.srv.WithBreak == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithBreak not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Break](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithBreak(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithClass(req *http.Request) (*http.Response, error) {
	if m.srv.WithClass == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithClass not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Class](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithClass(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithConstructor(req *http.Request) (*http.Response, error) {
	if m.srv.WithConstructor == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithConstructor not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Constructor](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithConstructor(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithContinue(req *http.Request) (*http.Response, error) {
	if m.srv.WithContinue == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithContinue not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Continue](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithContinue(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithDef(req *http.Request) (*http.Response, error) {
	if m.srv.WithDef == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithDef not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Def](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithDef(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithDel(req *http.Request) (*http.Response, error) {
	if m.srv.WithDel == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithDel not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Del](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithDel(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithElif(req *http.Request) (*http.Response, error) {
	if m.srv.WithElif == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithElif not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Elif](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithElif(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithElse(req *http.Request) (*http.Response, error) {
	if m.srv.WithElse == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithElse not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Else](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithElse(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithExcept(req *http.Request) (*http.Response, error) {
	if m.srv.WithExcept == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithExcept not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Except](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithExcept(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithExec(req *http.Request) (*http.Response, error) {
	if m.srv.WithExec == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithExec not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Exec](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithExec(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithFinally(req *http.Request) (*http.Response, error) {
	if m.srv.WithFinally == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithFinally not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Finally](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithFinally(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithFor(req *http.Request) (*http.Response, error) {
	if m.srv.WithFor == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithFor not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.For](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithFor(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithFrom(req *http.Request) (*http.Response, error) {
	if m.srv.WithFrom == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithFrom not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.From](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithFrom(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithGlobal(req *http.Request) (*http.Response, error) {
	if m.srv.WithGlobal == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithGlobal not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Global](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithGlobal(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithIf(req *http.Request) (*http.Response, error) {
	if m.srv.WithIf == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithIf not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.If](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithIf(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithImport(req *http.Request) (*http.Response, error) {
	if m.srv.WithImport == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithImport not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Import](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithImport(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithIn(req *http.Request) (*http.Response, error) {
	if m.srv.WithIn == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithIn not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.In](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithIn(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithIs(req *http.Request) (*http.Response, error) {
	if m.srv.WithIs == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithIs not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Is](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithIs(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithLambda(req *http.Request) (*http.Response, error) {
	if m.srv.WithLambda == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithLambda not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Lambda](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithLambda(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithNot(req *http.Request) (*http.Response, error) {
	if m.srv.WithNot == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithNot not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Not](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithNot(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithOr(req *http.Request) (*http.Response, error) {
	if m.srv.WithOr == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithOr not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Or](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithOr(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithPass(req *http.Request) (*http.Response, error) {
	if m.srv.WithPass == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithPass not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Pass](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithPass(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithRaise(req *http.Request) (*http.Response, error) {
	if m.srv.WithRaise == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithRaise not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Raise](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithRaise(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithReturn(req *http.Request) (*http.Response, error) {
	if m.srv.WithReturn == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithReturn not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Return](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithReturn(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithTry(req *http.Request) (*http.Response, error) {
	if m.srv.WithTry == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithTry not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Try](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithTry(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithWhile(req *http.Request) (*http.Response, error) {
	if m.srv.WithWhile == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithWhile not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.While](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithWhile(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithWith(req *http.Request) (*http.Response, error) {
	if m.srv.WithWith == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithWith not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.With](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithWith(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (m *ModelsServerTransport) dispatchWithYield(req *http.Request) (*http.Response, error) {
	if m.srv.WithYield == nil {
		return nil, &nonRetriableError{errors.New("fake for method WithYield not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[specialwordsgroup.Yield](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := m.srv.WithYield(req.Context(), body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
