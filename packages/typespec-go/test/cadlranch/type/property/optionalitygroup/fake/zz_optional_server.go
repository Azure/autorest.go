// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
	"sync"
)

// OptionalServer is a fake server for instances of the optionalitygroup.OptionalClient type.
type OptionalServer struct {
	// OptionalBooleanLiteralServer contains the fakes for client OptionalBooleanLiteralClient
	OptionalBooleanLiteralServer OptionalBooleanLiteralServer

	// OptionalBytesServer contains the fakes for client OptionalBytesClient
	OptionalBytesServer OptionalBytesServer

	// OptionalCollectionsByteServer contains the fakes for client OptionalCollectionsByteClient
	OptionalCollectionsByteServer OptionalCollectionsByteServer

	// OptionalCollectionsModelServer contains the fakes for client OptionalCollectionsModelClient
	OptionalCollectionsModelServer OptionalCollectionsModelServer

	// OptionalDatetimeServer contains the fakes for client OptionalDatetimeClient
	OptionalDatetimeServer OptionalDatetimeServer

	// OptionalDurationServer contains the fakes for client OptionalDurationClient
	OptionalDurationServer OptionalDurationServer

	// OptionalFloatLiteralServer contains the fakes for client OptionalFloatLiteralClient
	OptionalFloatLiteralServer OptionalFloatLiteralServer

	// OptionalIntLiteralServer contains the fakes for client OptionalIntLiteralClient
	OptionalIntLiteralServer OptionalIntLiteralServer

	// OptionalRequiredAndOptionalServer contains the fakes for client OptionalRequiredAndOptionalClient
	OptionalRequiredAndOptionalServer OptionalRequiredAndOptionalServer

	// OptionalStringServer contains the fakes for client OptionalStringClient
	OptionalStringServer OptionalStringServer

	// OptionalStringLiteralServer contains the fakes for client OptionalStringLiteralClient
	OptionalStringLiteralServer OptionalStringLiteralServer

	// OptionalUnionFloatLiteralServer contains the fakes for client OptionalUnionFloatLiteralClient
	OptionalUnionFloatLiteralServer OptionalUnionFloatLiteralServer

	// OptionalUnionIntLiteralServer contains the fakes for client OptionalUnionIntLiteralClient
	OptionalUnionIntLiteralServer OptionalUnionIntLiteralServer

	// OptionalUnionStringLiteralServer contains the fakes for client OptionalUnionStringLiteralClient
	OptionalUnionStringLiteralServer OptionalUnionStringLiteralServer
}

// NewOptionalServerTransport creates a new instance of OptionalServerTransport with the provided implementation.
// The returned OptionalServerTransport instance is connected to an instance of optionalitygroup.OptionalClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewOptionalServerTransport(srv *OptionalServer) *OptionalServerTransport {
	return &OptionalServerTransport{srv: srv}
}

// OptionalServerTransport connects instances of optionalitygroup.OptionalClient to instances of OptionalServer.
// Don't use this type directly, use NewOptionalServerTransport instead.
type OptionalServerTransport struct {
	srv                                 *OptionalServer
	trMu                                sync.Mutex
	trOptionalBooleanLiteralServer      *OptionalBooleanLiteralServerTransport
	trOptionalBytesServer               *OptionalBytesServerTransport
	trOptionalCollectionsByteServer     *OptionalCollectionsByteServerTransport
	trOptionalCollectionsModelServer    *OptionalCollectionsModelServerTransport
	trOptionalDatetimeServer            *OptionalDatetimeServerTransport
	trOptionalDurationServer            *OptionalDurationServerTransport
	trOptionalFloatLiteralServer        *OptionalFloatLiteralServerTransport
	trOptionalIntLiteralServer          *OptionalIntLiteralServerTransport
	trOptionalRequiredAndOptionalServer *OptionalRequiredAndOptionalServerTransport
	trOptionalStringServer              *OptionalStringServerTransport
	trOptionalStringLiteralServer       *OptionalStringLiteralServerTransport
	trOptionalUnionFloatLiteralServer   *OptionalUnionFloatLiteralServerTransport
	trOptionalUnionIntLiteralServer     *OptionalUnionIntLiteralServerTransport
	trOptionalUnionStringLiteralServer  *OptionalUnionStringLiteralServerTransport
}

// Do implements the policy.Transporter interface for OptionalServerTransport.
func (o *OptionalServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return o.dispatchToClientFake(req, method[:strings.Index(method, ".")])
}

func (o *OptionalServerTransport) dispatchToClientFake(req *http.Request, client string) (*http.Response, error) {
	var resp *http.Response
	var err error

	switch client {
	case "OptionalBooleanLiteralClient":
		initServer(&o.trMu, &o.trOptionalBooleanLiteralServer, func() *OptionalBooleanLiteralServerTransport {
			return NewOptionalBooleanLiteralServerTransport(&o.srv.OptionalBooleanLiteralServer)
		})
		resp, err = o.trOptionalBooleanLiteralServer.Do(req)
	case "OptionalBytesClient":
		initServer(&o.trMu, &o.trOptionalBytesServer, func() *OptionalBytesServerTransport {
			return NewOptionalBytesServerTransport(&o.srv.OptionalBytesServer)
		})
		resp, err = o.trOptionalBytesServer.Do(req)
	case "OptionalCollectionsByteClient":
		initServer(&o.trMu, &o.trOptionalCollectionsByteServer, func() *OptionalCollectionsByteServerTransport {
			return NewOptionalCollectionsByteServerTransport(&o.srv.OptionalCollectionsByteServer)
		})
		resp, err = o.trOptionalCollectionsByteServer.Do(req)
	case "OptionalCollectionsModelClient":
		initServer(&o.trMu, &o.trOptionalCollectionsModelServer, func() *OptionalCollectionsModelServerTransport {
			return NewOptionalCollectionsModelServerTransport(&o.srv.OptionalCollectionsModelServer)
		})
		resp, err = o.trOptionalCollectionsModelServer.Do(req)
	case "OptionalDatetimeClient":
		initServer(&o.trMu, &o.trOptionalDatetimeServer, func() *OptionalDatetimeServerTransport {
			return NewOptionalDatetimeServerTransport(&o.srv.OptionalDatetimeServer)
		})
		resp, err = o.trOptionalDatetimeServer.Do(req)
	case "OptionalDurationClient":
		initServer(&o.trMu, &o.trOptionalDurationServer, func() *OptionalDurationServerTransport {
			return NewOptionalDurationServerTransport(&o.srv.OptionalDurationServer)
		})
		resp, err = o.trOptionalDurationServer.Do(req)
	case "OptionalFloatLiteralClient":
		initServer(&o.trMu, &o.trOptionalFloatLiteralServer, func() *OptionalFloatLiteralServerTransport {
			return NewOptionalFloatLiteralServerTransport(&o.srv.OptionalFloatLiteralServer)
		})
		resp, err = o.trOptionalFloatLiteralServer.Do(req)
	case "OptionalIntLiteralClient":
		initServer(&o.trMu, &o.trOptionalIntLiteralServer, func() *OptionalIntLiteralServerTransport {
			return NewOptionalIntLiteralServerTransport(&o.srv.OptionalIntLiteralServer)
		})
		resp, err = o.trOptionalIntLiteralServer.Do(req)
	case "OptionalRequiredAndOptionalClient":
		initServer(&o.trMu, &o.trOptionalRequiredAndOptionalServer, func() *OptionalRequiredAndOptionalServerTransport {
			return NewOptionalRequiredAndOptionalServerTransport(&o.srv.OptionalRequiredAndOptionalServer)
		})
		resp, err = o.trOptionalRequiredAndOptionalServer.Do(req)
	case "OptionalStringClient":
		initServer(&o.trMu, &o.trOptionalStringServer, func() *OptionalStringServerTransport {
			return NewOptionalStringServerTransport(&o.srv.OptionalStringServer)
		})
		resp, err = o.trOptionalStringServer.Do(req)
	case "OptionalStringLiteralClient":
		initServer(&o.trMu, &o.trOptionalStringLiteralServer, func() *OptionalStringLiteralServerTransport {
			return NewOptionalStringLiteralServerTransport(&o.srv.OptionalStringLiteralServer)
		})
		resp, err = o.trOptionalStringLiteralServer.Do(req)
	case "OptionalUnionFloatLiteralClient":
		initServer(&o.trMu, &o.trOptionalUnionFloatLiteralServer, func() *OptionalUnionFloatLiteralServerTransport {
			return NewOptionalUnionFloatLiteralServerTransport(&o.srv.OptionalUnionFloatLiteralServer)
		})
		resp, err = o.trOptionalUnionFloatLiteralServer.Do(req)
	case "OptionalUnionIntLiteralClient":
		initServer(&o.trMu, &o.trOptionalUnionIntLiteralServer, func() *OptionalUnionIntLiteralServerTransport {
			return NewOptionalUnionIntLiteralServerTransport(&o.srv.OptionalUnionIntLiteralServer)
		})
		resp, err = o.trOptionalUnionIntLiteralServer.Do(req)
	case "OptionalUnionStringLiteralClient":
		initServer(&o.trMu, &o.trOptionalUnionStringLiteralServer, func() *OptionalUnionStringLiteralServerTransport {
			return NewOptionalUnionStringLiteralServerTransport(&o.srv.OptionalUnionStringLiteralServer)
		})
		resp, err = o.trOptionalUnionStringLiteralServer.Do(req)
	default:
		err = fmt.Errorf("unhandled client %s", client)
	}

	return resp, err
}
