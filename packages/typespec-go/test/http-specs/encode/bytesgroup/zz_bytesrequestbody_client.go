// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package bytesgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
)

// BytesRequestBodyClient contains the methods for the BytesRequestBody group.
// Don't use this type directly, use [BytesClient.NewBytesRequestBodyClient] instead.
type BytesRequestBodyClient struct {
	internal *azcore.Client
}

// Base64 -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - BytesRequestBodyClientBase64Options contains the optional parameters for the BytesRequestBodyClient.Base64 method.
func (client *BytesRequestBodyClient) Base64(ctx context.Context, value []byte, options *BytesRequestBodyClientBase64Options) (BytesRequestBodyClientBase64Response, error) {
	var err error
	const operationName = "BytesRequestBodyClient.Base64"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.base64CreateRequest(ctx, value, options)
	if err != nil {
		return BytesRequestBodyClientBase64Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BytesRequestBodyClientBase64Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BytesRequestBodyClientBase64Response{}, err
	}
	return BytesRequestBodyClientBase64Response{}, nil
}

// base64CreateRequest creates the Base64 request.
func (client *BytesRequestBodyClient) base64CreateRequest(ctx context.Context, value []byte, _ *BytesRequestBodyClientBase64Options) (*policy.Request, error) {
	urlPath := "/encode/bytes/body/request/base64"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsByteArray(req, value, runtime.Base64StdFormat); err != nil {
		return nil, err
	}
	return req, nil
}

// Base64URL -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - BytesRequestBodyClientBase64URLOptions contains the optional parameters for the BytesRequestBodyClient.Base64URL
//     method.
func (client *BytesRequestBodyClient) Base64URL(ctx context.Context, value []byte, options *BytesRequestBodyClientBase64URLOptions) (BytesRequestBodyClientBase64URLResponse, error) {
	var err error
	const operationName = "BytesRequestBodyClient.Base64URL"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.base64URLCreateRequest(ctx, value, options)
	if err != nil {
		return BytesRequestBodyClientBase64URLResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BytesRequestBodyClientBase64URLResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BytesRequestBodyClientBase64URLResponse{}, err
	}
	return BytesRequestBodyClientBase64URLResponse{}, nil
}

// base64URLCreateRequest creates the Base64URL request.
func (client *BytesRequestBodyClient) base64URLCreateRequest(ctx context.Context, value []byte, _ *BytesRequestBodyClientBase64URLOptions) (*policy.Request, error) {
	urlPath := "/encode/bytes/body/request/base64url"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsByteArray(req, value, runtime.Base64URLFormat); err != nil {
		return nil, err
	}
	return req, nil
}

// CustomContentType -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - BytesRequestBodyClientCustomContentTypeOptions contains the optional parameters for the BytesRequestBodyClient.CustomContentType
//     method.
func (client *BytesRequestBodyClient) CustomContentType(ctx context.Context, value io.ReadSeekCloser, options *BytesRequestBodyClientCustomContentTypeOptions) (BytesRequestBodyClientCustomContentTypeResponse, error) {
	var err error
	const operationName = "BytesRequestBodyClient.CustomContentType"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.customContentTypeCreateRequest(ctx, value, options)
	if err != nil {
		return BytesRequestBodyClientCustomContentTypeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BytesRequestBodyClientCustomContentTypeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BytesRequestBodyClientCustomContentTypeResponse{}, err
	}
	return BytesRequestBodyClientCustomContentTypeResponse{}, nil
}

// customContentTypeCreateRequest creates the CustomContentType request.
func (client *BytesRequestBodyClient) customContentTypeCreateRequest(ctx context.Context, value io.ReadSeekCloser, _ *BytesRequestBodyClientCustomContentTypeOptions) (*policy.Request, error) {
	urlPath := "/encode/bytes/body/request/custom-content-type"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"image/png"}
	if err := req.SetBody(value, "image/png"); err != nil {
		return nil, err
	}
	return req, nil
}

// Default -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - BytesRequestBodyClientDefaultOptions contains the optional parameters for the BytesRequestBodyClient.Default
//     method.
func (client *BytesRequestBodyClient) Default(ctx context.Context, value []byte, options *BytesRequestBodyClientDefaultOptions) (BytesRequestBodyClientDefaultResponse, error) {
	var err error
	const operationName = "BytesRequestBodyClient.Default"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.defaultCreateRequest(ctx, value, options)
	if err != nil {
		return BytesRequestBodyClientDefaultResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BytesRequestBodyClientDefaultResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BytesRequestBodyClientDefaultResponse{}, err
	}
	return BytesRequestBodyClientDefaultResponse{}, nil
}

// defaultCreateRequest creates the Default request.
func (client *BytesRequestBodyClient) defaultCreateRequest(ctx context.Context, value []byte, _ *BytesRequestBodyClientDefaultOptions) (*policy.Request, error) {
	urlPath := "/encode/bytes/body/request/default"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsByteArray(req, value, runtime.Base64StdFormat); err != nil {
		return nil, err
	}
	return req, nil
}

// OctetStream -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - BytesRequestBodyClientOctetStreamOptions contains the optional parameters for the BytesRequestBodyClient.OctetStream
//     method.
func (client *BytesRequestBodyClient) OctetStream(ctx context.Context, value io.ReadSeekCloser, options *BytesRequestBodyClientOctetStreamOptions) (BytesRequestBodyClientOctetStreamResponse, error) {
	var err error
	const operationName = "BytesRequestBodyClient.OctetStream"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.octetStreamCreateRequest(ctx, value, options)
	if err != nil {
		return BytesRequestBodyClientOctetStreamResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BytesRequestBodyClientOctetStreamResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BytesRequestBodyClientOctetStreamResponse{}, err
	}
	return BytesRequestBodyClientOctetStreamResponse{}, nil
}

// octetStreamCreateRequest creates the OctetStream request.
func (client *BytesRequestBodyClient) octetStreamCreateRequest(ctx context.Context, value io.ReadSeekCloser, _ *BytesRequestBodyClientOctetStreamOptions) (*policy.Request, error) {
	urlPath := "/encode/bytes/body/request/octet-stream"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/octet-stream"}
	if err := req.SetBody(value, "application/octet-stream"); err != nil {
		return nil, err
	}
	return req, nil
}
