// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
	"sync"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// ScalarServer is a fake server for instances of the scalargroup.ScalarClient type.
type ScalarServer struct {
	// ScalarBooleanServer contains the fakes for client ScalarBooleanClient
	ScalarBooleanServer ScalarBooleanServer

	// ScalarDecimal128TypeServer contains the fakes for client ScalarDecimal128TypeClient
	ScalarDecimal128TypeServer ScalarDecimal128TypeServer

	// ScalarDecimal128VerifyServer contains the fakes for client ScalarDecimal128VerifyClient
	ScalarDecimal128VerifyServer ScalarDecimal128VerifyServer

	// ScalarDecimalTypeServer contains the fakes for client ScalarDecimalTypeClient
	ScalarDecimalTypeServer ScalarDecimalTypeServer

	// ScalarDecimalVerifyServer contains the fakes for client ScalarDecimalVerifyClient
	ScalarDecimalVerifyServer ScalarDecimalVerifyServer

	// ScalarStringServer contains the fakes for client ScalarStringClient
	ScalarStringServer ScalarStringServer

	// ScalarUnknownServer contains the fakes for client ScalarUnknownClient
	ScalarUnknownServer ScalarUnknownServer
}

// NewScalarServerTransport creates a new instance of ScalarServerTransport with the provided implementation.
// The returned ScalarServerTransport instance is connected to an instance of scalargroup.ScalarClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewScalarServerTransport(srv *ScalarServer) *ScalarServerTransport {
	return &ScalarServerTransport{srv: srv}
}

// ScalarServerTransport connects instances of scalargroup.ScalarClient to instances of ScalarServer.
// Don't use this type directly, use NewScalarServerTransport instead.
type ScalarServerTransport struct {
	srv                            *ScalarServer
	trMu                           sync.Mutex
	trScalarBooleanServer          *ScalarBooleanServerTransport
	trScalarDecimal128TypeServer   *ScalarDecimal128TypeServerTransport
	trScalarDecimal128VerifyServer *ScalarDecimal128VerifyServerTransport
	trScalarDecimalTypeServer      *ScalarDecimalTypeServerTransport
	trScalarDecimalVerifyServer    *ScalarDecimalVerifyServerTransport
	trScalarStringServer           *ScalarStringServerTransport
	trScalarUnknownServer          *ScalarUnknownServerTransport
}

// Do implements the policy.Transporter interface for ScalarServerTransport.
func (s *ScalarServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToClientFake(req, method[:strings.Index(method, ".")])
}

func (s *ScalarServerTransport) dispatchToClientFake(req *http.Request, client string) (*http.Response, error) {
	var resp *http.Response
	var err error

	switch client {
	case "ScalarBooleanClient":
		initServer(&s.trMu, &s.trScalarBooleanServer, func() *ScalarBooleanServerTransport {
			return NewScalarBooleanServerTransport(&s.srv.ScalarBooleanServer)
		})
		resp, err = s.trScalarBooleanServer.Do(req)
	case "ScalarDecimal128TypeClient":
		initServer(&s.trMu, &s.trScalarDecimal128TypeServer, func() *ScalarDecimal128TypeServerTransport {
			return NewScalarDecimal128TypeServerTransport(&s.srv.ScalarDecimal128TypeServer)
		})
		resp, err = s.trScalarDecimal128TypeServer.Do(req)
	case "ScalarDecimal128VerifyClient":
		initServer(&s.trMu, &s.trScalarDecimal128VerifyServer, func() *ScalarDecimal128VerifyServerTransport {
			return NewScalarDecimal128VerifyServerTransport(&s.srv.ScalarDecimal128VerifyServer)
		})
		resp, err = s.trScalarDecimal128VerifyServer.Do(req)
	case "ScalarDecimalTypeClient":
		initServer(&s.trMu, &s.trScalarDecimalTypeServer, func() *ScalarDecimalTypeServerTransport {
			return NewScalarDecimalTypeServerTransport(&s.srv.ScalarDecimalTypeServer)
		})
		resp, err = s.trScalarDecimalTypeServer.Do(req)
	case "ScalarDecimalVerifyClient":
		initServer(&s.trMu, &s.trScalarDecimalVerifyServer, func() *ScalarDecimalVerifyServerTransport {
			return NewScalarDecimalVerifyServerTransport(&s.srv.ScalarDecimalVerifyServer)
		})
		resp, err = s.trScalarDecimalVerifyServer.Do(req)
	case "ScalarStringClient":
		initServer(&s.trMu, &s.trScalarStringServer, func() *ScalarStringServerTransport {
			return NewScalarStringServerTransport(&s.srv.ScalarStringServer)
		})
		resp, err = s.trScalarStringServer.Do(req)
	case "ScalarUnknownClient":
		initServer(&s.trMu, &s.trScalarUnknownServer, func() *ScalarUnknownServerTransport {
			return NewScalarUnknownServerTransport(&s.srv.ScalarUnknownServer)
		})
		resp, err = s.trScalarUnknownServer.Do(req)
	default:
		err = fmt.Errorf("unhandled client %s", client)
	}

	return resp, err
}

// set this to conditionally intercept incoming requests to ScalarServerTransport
var scalarServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
