// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
	"sync"
)

// ValueTypesServer is a fake server for instances of the valuetypesgroup.ValueTypesClient type.
type ValueTypesServer struct {
	// ValueTypesBooleanServer contains the fakes for client ValueTypesBooleanClient
	ValueTypesBooleanServer ValueTypesBooleanServer

	// ValueTypesBooleanLiteralServer contains the fakes for client ValueTypesBooleanLiteralClient
	ValueTypesBooleanLiteralServer ValueTypesBooleanLiteralServer

	// ValueTypesBytesServer contains the fakes for client ValueTypesBytesClient
	ValueTypesBytesServer ValueTypesBytesServer

	// ValueTypesCollectionsIntServer contains the fakes for client ValueTypesCollectionsIntClient
	ValueTypesCollectionsIntServer ValueTypesCollectionsIntServer

	// ValueTypesCollectionsModelServer contains the fakes for client ValueTypesCollectionsModelClient
	ValueTypesCollectionsModelServer ValueTypesCollectionsModelServer

	// ValueTypesCollectionsStringServer contains the fakes for client ValueTypesCollectionsStringClient
	ValueTypesCollectionsStringServer ValueTypesCollectionsStringServer

	// ValueTypesDatetimeServer contains the fakes for client ValueTypesDatetimeClient
	ValueTypesDatetimeServer ValueTypesDatetimeServer

	// ValueTypesDecimal128Server contains the fakes for client ValueTypesDecimal128Client
	ValueTypesDecimal128Server ValueTypesDecimal128Server

	// ValueTypesDecimalServer contains the fakes for client ValueTypesDecimalClient
	ValueTypesDecimalServer ValueTypesDecimalServer

	// ValueTypesDictionaryStringServer contains the fakes for client ValueTypesDictionaryStringClient
	ValueTypesDictionaryStringServer ValueTypesDictionaryStringServer

	// ValueTypesDurationServer contains the fakes for client ValueTypesDurationClient
	ValueTypesDurationServer ValueTypesDurationServer

	// ValueTypesEnumServer contains the fakes for client ValueTypesEnumClient
	ValueTypesEnumServer ValueTypesEnumServer

	// ValueTypesExtensibleEnumServer contains the fakes for client ValueTypesExtensibleEnumClient
	ValueTypesExtensibleEnumServer ValueTypesExtensibleEnumServer

	// ValueTypesFloatServer contains the fakes for client ValueTypesFloatClient
	ValueTypesFloatServer ValueTypesFloatServer

	// ValueTypesFloatLiteralServer contains the fakes for client ValueTypesFloatLiteralClient
	ValueTypesFloatLiteralServer ValueTypesFloatLiteralServer

	// ValueTypesIntServer contains the fakes for client ValueTypesIntClient
	ValueTypesIntServer ValueTypesIntServer

	// ValueTypesIntLiteralServer contains the fakes for client ValueTypesIntLiteralClient
	ValueTypesIntLiteralServer ValueTypesIntLiteralServer

	// ValueTypesModelServer contains the fakes for client ValueTypesModelClient
	ValueTypesModelServer ValueTypesModelServer

	// ValueTypesNeverServer contains the fakes for client ValueTypesNeverClient
	ValueTypesNeverServer ValueTypesNeverServer

	// ValueTypesStringServer contains the fakes for client ValueTypesStringClient
	ValueTypesStringServer ValueTypesStringServer

	// ValueTypesStringLiteralServer contains the fakes for client ValueTypesStringLiteralClient
	ValueTypesStringLiteralServer ValueTypesStringLiteralServer

	// ValueTypesUnionEnumValueServer contains the fakes for client ValueTypesUnionEnumValueClient
	ValueTypesUnionEnumValueServer ValueTypesUnionEnumValueServer

	// ValueTypesUnionFloatLiteralServer contains the fakes for client ValueTypesUnionFloatLiteralClient
	ValueTypesUnionFloatLiteralServer ValueTypesUnionFloatLiteralServer

	// ValueTypesUnionIntLiteralServer contains the fakes for client ValueTypesUnionIntLiteralClient
	ValueTypesUnionIntLiteralServer ValueTypesUnionIntLiteralServer

	// ValueTypesUnionStringLiteralServer contains the fakes for client ValueTypesUnionStringLiteralClient
	ValueTypesUnionStringLiteralServer ValueTypesUnionStringLiteralServer

	// ValueTypesUnknownArrayServer contains the fakes for client ValueTypesUnknownArrayClient
	ValueTypesUnknownArrayServer ValueTypesUnknownArrayServer

	// ValueTypesUnknownDictServer contains the fakes for client ValueTypesUnknownDictClient
	ValueTypesUnknownDictServer ValueTypesUnknownDictServer

	// ValueTypesUnknownIntServer contains the fakes for client ValueTypesUnknownIntClient
	ValueTypesUnknownIntServer ValueTypesUnknownIntServer

	// ValueTypesUnknownStringServer contains the fakes for client ValueTypesUnknownStringClient
	ValueTypesUnknownStringServer ValueTypesUnknownStringServer
}

// NewValueTypesServerTransport creates a new instance of ValueTypesServerTransport with the provided implementation.
// The returned ValueTypesServerTransport instance is connected to an instance of valuetypesgroup.ValueTypesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewValueTypesServerTransport(srv *ValueTypesServer) *ValueTypesServerTransport {
	return &ValueTypesServerTransport{srv: srv}
}

// ValueTypesServerTransport connects instances of valuetypesgroup.ValueTypesClient to instances of ValueTypesServer.
// Don't use this type directly, use NewValueTypesServerTransport instead.
type ValueTypesServerTransport struct {
	srv                                  *ValueTypesServer
	trMu                                 sync.Mutex
	trValueTypesBooleanServer            *ValueTypesBooleanServerTransport
	trValueTypesBooleanLiteralServer     *ValueTypesBooleanLiteralServerTransport
	trValueTypesBytesServer              *ValueTypesBytesServerTransport
	trValueTypesCollectionsIntServer     *ValueTypesCollectionsIntServerTransport
	trValueTypesCollectionsModelServer   *ValueTypesCollectionsModelServerTransport
	trValueTypesCollectionsStringServer  *ValueTypesCollectionsStringServerTransport
	trValueTypesDatetimeServer           *ValueTypesDatetimeServerTransport
	trValueTypesDecimal128Server         *ValueTypesDecimal128ServerTransport
	trValueTypesDecimalServer            *ValueTypesDecimalServerTransport
	trValueTypesDictionaryStringServer   *ValueTypesDictionaryStringServerTransport
	trValueTypesDurationServer           *ValueTypesDurationServerTransport
	trValueTypesEnumServer               *ValueTypesEnumServerTransport
	trValueTypesExtensibleEnumServer     *ValueTypesExtensibleEnumServerTransport
	trValueTypesFloatServer              *ValueTypesFloatServerTransport
	trValueTypesFloatLiteralServer       *ValueTypesFloatLiteralServerTransport
	trValueTypesIntServer                *ValueTypesIntServerTransport
	trValueTypesIntLiteralServer         *ValueTypesIntLiteralServerTransport
	trValueTypesModelServer              *ValueTypesModelServerTransport
	trValueTypesNeverServer              *ValueTypesNeverServerTransport
	trValueTypesStringServer             *ValueTypesStringServerTransport
	trValueTypesStringLiteralServer      *ValueTypesStringLiteralServerTransport
	trValueTypesUnionEnumValueServer     *ValueTypesUnionEnumValueServerTransport
	trValueTypesUnionFloatLiteralServer  *ValueTypesUnionFloatLiteralServerTransport
	trValueTypesUnionIntLiteralServer    *ValueTypesUnionIntLiteralServerTransport
	trValueTypesUnionStringLiteralServer *ValueTypesUnionStringLiteralServerTransport
	trValueTypesUnknownArrayServer       *ValueTypesUnknownArrayServerTransport
	trValueTypesUnknownDictServer        *ValueTypesUnknownDictServerTransport
	trValueTypesUnknownIntServer         *ValueTypesUnknownIntServerTransport
	trValueTypesUnknownStringServer      *ValueTypesUnknownStringServerTransport
}

// Do implements the policy.Transporter interface for ValueTypesServerTransport.
func (v *ValueTypesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return v.dispatchToClientFake(req, method[:strings.Index(method, ".")])
}

func (v *ValueTypesServerTransport) dispatchToClientFake(req *http.Request, client string) (*http.Response, error) {
	var resp *http.Response
	var err error

	switch client {
	case "ValueTypesBooleanClient":
		initServer(&v.trMu, &v.trValueTypesBooleanServer, func() *ValueTypesBooleanServerTransport {
			return NewValueTypesBooleanServerTransport(&v.srv.ValueTypesBooleanServer)
		})
		resp, err = v.trValueTypesBooleanServer.Do(req)
	case "ValueTypesBooleanLiteralClient":
		initServer(&v.trMu, &v.trValueTypesBooleanLiteralServer, func() *ValueTypesBooleanLiteralServerTransport {
			return NewValueTypesBooleanLiteralServerTransport(&v.srv.ValueTypesBooleanLiteralServer)
		})
		resp, err = v.trValueTypesBooleanLiteralServer.Do(req)
	case "ValueTypesBytesClient":
		initServer(&v.trMu, &v.trValueTypesBytesServer, func() *ValueTypesBytesServerTransport {
			return NewValueTypesBytesServerTransport(&v.srv.ValueTypesBytesServer)
		})
		resp, err = v.trValueTypesBytesServer.Do(req)
	case "ValueTypesCollectionsIntClient":
		initServer(&v.trMu, &v.trValueTypesCollectionsIntServer, func() *ValueTypesCollectionsIntServerTransport {
			return NewValueTypesCollectionsIntServerTransport(&v.srv.ValueTypesCollectionsIntServer)
		})
		resp, err = v.trValueTypesCollectionsIntServer.Do(req)
	case "ValueTypesCollectionsModelClient":
		initServer(&v.trMu, &v.trValueTypesCollectionsModelServer, func() *ValueTypesCollectionsModelServerTransport {
			return NewValueTypesCollectionsModelServerTransport(&v.srv.ValueTypesCollectionsModelServer)
		})
		resp, err = v.trValueTypesCollectionsModelServer.Do(req)
	case "ValueTypesCollectionsStringClient":
		initServer(&v.trMu, &v.trValueTypesCollectionsStringServer, func() *ValueTypesCollectionsStringServerTransport {
			return NewValueTypesCollectionsStringServerTransport(&v.srv.ValueTypesCollectionsStringServer)
		})
		resp, err = v.trValueTypesCollectionsStringServer.Do(req)
	case "ValueTypesDatetimeClient":
		initServer(&v.trMu, &v.trValueTypesDatetimeServer, func() *ValueTypesDatetimeServerTransport {
			return NewValueTypesDatetimeServerTransport(&v.srv.ValueTypesDatetimeServer)
		})
		resp, err = v.trValueTypesDatetimeServer.Do(req)
	case "ValueTypesDecimal128Client":
		initServer(&v.trMu, &v.trValueTypesDecimal128Server, func() *ValueTypesDecimal128ServerTransport {
			return NewValueTypesDecimal128ServerTransport(&v.srv.ValueTypesDecimal128Server)
		})
		resp, err = v.trValueTypesDecimal128Server.Do(req)
	case "ValueTypesDecimalClient":
		initServer(&v.trMu, &v.trValueTypesDecimalServer, func() *ValueTypesDecimalServerTransport {
			return NewValueTypesDecimalServerTransport(&v.srv.ValueTypesDecimalServer)
		})
		resp, err = v.trValueTypesDecimalServer.Do(req)
	case "ValueTypesDictionaryStringClient":
		initServer(&v.trMu, &v.trValueTypesDictionaryStringServer, func() *ValueTypesDictionaryStringServerTransport {
			return NewValueTypesDictionaryStringServerTransport(&v.srv.ValueTypesDictionaryStringServer)
		})
		resp, err = v.trValueTypesDictionaryStringServer.Do(req)
	case "ValueTypesDurationClient":
		initServer(&v.trMu, &v.trValueTypesDurationServer, func() *ValueTypesDurationServerTransport {
			return NewValueTypesDurationServerTransport(&v.srv.ValueTypesDurationServer)
		})
		resp, err = v.trValueTypesDurationServer.Do(req)
	case "ValueTypesEnumClient":
		initServer(&v.trMu, &v.trValueTypesEnumServer, func() *ValueTypesEnumServerTransport {
			return NewValueTypesEnumServerTransport(&v.srv.ValueTypesEnumServer)
		})
		resp, err = v.trValueTypesEnumServer.Do(req)
	case "ValueTypesExtensibleEnumClient":
		initServer(&v.trMu, &v.trValueTypesExtensibleEnumServer, func() *ValueTypesExtensibleEnumServerTransport {
			return NewValueTypesExtensibleEnumServerTransport(&v.srv.ValueTypesExtensibleEnumServer)
		})
		resp, err = v.trValueTypesExtensibleEnumServer.Do(req)
	case "ValueTypesFloatClient":
		initServer(&v.trMu, &v.trValueTypesFloatServer, func() *ValueTypesFloatServerTransport {
			return NewValueTypesFloatServerTransport(&v.srv.ValueTypesFloatServer)
		})
		resp, err = v.trValueTypesFloatServer.Do(req)
	case "ValueTypesFloatLiteralClient":
		initServer(&v.trMu, &v.trValueTypesFloatLiteralServer, func() *ValueTypesFloatLiteralServerTransport {
			return NewValueTypesFloatLiteralServerTransport(&v.srv.ValueTypesFloatLiteralServer)
		})
		resp, err = v.trValueTypesFloatLiteralServer.Do(req)
	case "ValueTypesIntClient":
		initServer(&v.trMu, &v.trValueTypesIntServer, func() *ValueTypesIntServerTransport {
			return NewValueTypesIntServerTransport(&v.srv.ValueTypesIntServer)
		})
		resp, err = v.trValueTypesIntServer.Do(req)
	case "ValueTypesIntLiteralClient":
		initServer(&v.trMu, &v.trValueTypesIntLiteralServer, func() *ValueTypesIntLiteralServerTransport {
			return NewValueTypesIntLiteralServerTransport(&v.srv.ValueTypesIntLiteralServer)
		})
		resp, err = v.trValueTypesIntLiteralServer.Do(req)
	case "ValueTypesModelClient":
		initServer(&v.trMu, &v.trValueTypesModelServer, func() *ValueTypesModelServerTransport {
			return NewValueTypesModelServerTransport(&v.srv.ValueTypesModelServer)
		})
		resp, err = v.trValueTypesModelServer.Do(req)
	case "ValueTypesNeverClient":
		initServer(&v.trMu, &v.trValueTypesNeverServer, func() *ValueTypesNeverServerTransport {
			return NewValueTypesNeverServerTransport(&v.srv.ValueTypesNeverServer)
		})
		resp, err = v.trValueTypesNeverServer.Do(req)
	case "ValueTypesStringClient":
		initServer(&v.trMu, &v.trValueTypesStringServer, func() *ValueTypesStringServerTransport {
			return NewValueTypesStringServerTransport(&v.srv.ValueTypesStringServer)
		})
		resp, err = v.trValueTypesStringServer.Do(req)
	case "ValueTypesStringLiteralClient":
		initServer(&v.trMu, &v.trValueTypesStringLiteralServer, func() *ValueTypesStringLiteralServerTransport {
			return NewValueTypesStringLiteralServerTransport(&v.srv.ValueTypesStringLiteralServer)
		})
		resp, err = v.trValueTypesStringLiteralServer.Do(req)
	case "ValueTypesUnionEnumValueClient":
		initServer(&v.trMu, &v.trValueTypesUnionEnumValueServer, func() *ValueTypesUnionEnumValueServerTransport {
			return NewValueTypesUnionEnumValueServerTransport(&v.srv.ValueTypesUnionEnumValueServer)
		})
		resp, err = v.trValueTypesUnionEnumValueServer.Do(req)
	case "ValueTypesUnionFloatLiteralClient":
		initServer(&v.trMu, &v.trValueTypesUnionFloatLiteralServer, func() *ValueTypesUnionFloatLiteralServerTransport {
			return NewValueTypesUnionFloatLiteralServerTransport(&v.srv.ValueTypesUnionFloatLiteralServer)
		})
		resp, err = v.trValueTypesUnionFloatLiteralServer.Do(req)
	case "ValueTypesUnionIntLiteralClient":
		initServer(&v.trMu, &v.trValueTypesUnionIntLiteralServer, func() *ValueTypesUnionIntLiteralServerTransport {
			return NewValueTypesUnionIntLiteralServerTransport(&v.srv.ValueTypesUnionIntLiteralServer)
		})
		resp, err = v.trValueTypesUnionIntLiteralServer.Do(req)
	case "ValueTypesUnionStringLiteralClient":
		initServer(&v.trMu, &v.trValueTypesUnionStringLiteralServer, func() *ValueTypesUnionStringLiteralServerTransport {
			return NewValueTypesUnionStringLiteralServerTransport(&v.srv.ValueTypesUnionStringLiteralServer)
		})
		resp, err = v.trValueTypesUnionStringLiteralServer.Do(req)
	case "ValueTypesUnknownArrayClient":
		initServer(&v.trMu, &v.trValueTypesUnknownArrayServer, func() *ValueTypesUnknownArrayServerTransport {
			return NewValueTypesUnknownArrayServerTransport(&v.srv.ValueTypesUnknownArrayServer)
		})
		resp, err = v.trValueTypesUnknownArrayServer.Do(req)
	case "ValueTypesUnknownDictClient":
		initServer(&v.trMu, &v.trValueTypesUnknownDictServer, func() *ValueTypesUnknownDictServerTransport {
			return NewValueTypesUnknownDictServerTransport(&v.srv.ValueTypesUnknownDictServer)
		})
		resp, err = v.trValueTypesUnknownDictServer.Do(req)
	case "ValueTypesUnknownIntClient":
		initServer(&v.trMu, &v.trValueTypesUnknownIntServer, func() *ValueTypesUnknownIntServerTransport {
			return NewValueTypesUnknownIntServerTransport(&v.srv.ValueTypesUnknownIntServer)
		})
		resp, err = v.trValueTypesUnknownIntServer.Do(req)
	case "ValueTypesUnknownStringClient":
		initServer(&v.trMu, &v.trValueTypesUnknownStringServer, func() *ValueTypesUnknownStringServerTransport {
			return NewValueTypesUnknownStringServerTransport(&v.srv.ValueTypesUnknownStringServer)
		})
		resp, err = v.trValueTypesUnknownStringServer.Do(req)
	default:
		err = fmt.Errorf("unhandled client %s", client)
	}

	return resp, err
}

// set this to conditionally intercept incoming requests to ValueTypesServerTransport
var valueTypesServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
