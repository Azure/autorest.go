// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"specialwordsgroup"

	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// SpecialWordsOperationsServer is a fake server for instances of the specialwordsgroup.SpecialWordsOperationsClient type.
type SpecialWordsOperationsServer struct {
	// And is the fake for method SpecialWordsOperationsClient.And
	// HTTP status codes to indicate success: http.StatusNoContent
	And func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientAndOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientAndResponse], errResp azfake.ErrorResponder)

	// As is the fake for method SpecialWordsOperationsClient.As
	// HTTP status codes to indicate success: http.StatusNoContent
	As func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientAsOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientAsResponse], errResp azfake.ErrorResponder)

	// Assert is the fake for method SpecialWordsOperationsClient.Assert
	// HTTP status codes to indicate success: http.StatusNoContent
	Assert func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientAssertOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientAssertResponse], errResp azfake.ErrorResponder)

	// Async is the fake for method SpecialWordsOperationsClient.Async
	// HTTP status codes to indicate success: http.StatusNoContent
	Async func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientAsyncOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientAsyncResponse], errResp azfake.ErrorResponder)

	// Await is the fake for method SpecialWordsOperationsClient.Await
	// HTTP status codes to indicate success: http.StatusNoContent
	Await func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientAwaitOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientAwaitResponse], errResp azfake.ErrorResponder)

	// Break is the fake for method SpecialWordsOperationsClient.Break
	// HTTP status codes to indicate success: http.StatusNoContent
	Break func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientBreakOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientBreakResponse], errResp azfake.ErrorResponder)

	// Class is the fake for method SpecialWordsOperationsClient.Class
	// HTTP status codes to indicate success: http.StatusNoContent
	Class func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientClassOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientClassResponse], errResp azfake.ErrorResponder)

	// Constructor is the fake for method SpecialWordsOperationsClient.Constructor
	// HTTP status codes to indicate success: http.StatusNoContent
	Constructor func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientConstructorOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientConstructorResponse], errResp azfake.ErrorResponder)

	// Continue is the fake for method SpecialWordsOperationsClient.Continue
	// HTTP status codes to indicate success: http.StatusNoContent
	Continue func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientContinueOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientContinueResponse], errResp azfake.ErrorResponder)

	// Def is the fake for method SpecialWordsOperationsClient.Def
	// HTTP status codes to indicate success: http.StatusNoContent
	Def func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientDefOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientDefResponse], errResp azfake.ErrorResponder)

	// Del is the fake for method SpecialWordsOperationsClient.Del
	// HTTP status codes to indicate success: http.StatusNoContent
	Del func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientDelOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientDelResponse], errResp azfake.ErrorResponder)

	// Elif is the fake for method SpecialWordsOperationsClient.Elif
	// HTTP status codes to indicate success: http.StatusNoContent
	Elif func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientElifOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientElifResponse], errResp azfake.ErrorResponder)

	// Else is the fake for method SpecialWordsOperationsClient.Else
	// HTTP status codes to indicate success: http.StatusNoContent
	Else func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientElseOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientElseResponse], errResp azfake.ErrorResponder)

	// Except is the fake for method SpecialWordsOperationsClient.Except
	// HTTP status codes to indicate success: http.StatusNoContent
	Except func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientExceptOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientExceptResponse], errResp azfake.ErrorResponder)

	// Exec is the fake for method SpecialWordsOperationsClient.Exec
	// HTTP status codes to indicate success: http.StatusNoContent
	Exec func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientExecOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientExecResponse], errResp azfake.ErrorResponder)

	// Finally is the fake for method SpecialWordsOperationsClient.Finally
	// HTTP status codes to indicate success: http.StatusNoContent
	Finally func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientFinallyOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientFinallyResponse], errResp azfake.ErrorResponder)

	// For is the fake for method SpecialWordsOperationsClient.For
	// HTTP status codes to indicate success: http.StatusNoContent
	For func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientForOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientForResponse], errResp azfake.ErrorResponder)

	// From is the fake for method SpecialWordsOperationsClient.From
	// HTTP status codes to indicate success: http.StatusNoContent
	From func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientFromOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientFromResponse], errResp azfake.ErrorResponder)

	// Global is the fake for method SpecialWordsOperationsClient.Global
	// HTTP status codes to indicate success: http.StatusNoContent
	Global func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientGlobalOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientGlobalResponse], errResp azfake.ErrorResponder)

	// If is the fake for method SpecialWordsOperationsClient.If
	// HTTP status codes to indicate success: http.StatusNoContent
	If func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientIfOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientIfResponse], errResp azfake.ErrorResponder)

	// Import is the fake for method SpecialWordsOperationsClient.Import
	// HTTP status codes to indicate success: http.StatusNoContent
	Import func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientImportOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientImportResponse], errResp azfake.ErrorResponder)

	// In is the fake for method SpecialWordsOperationsClient.In
	// HTTP status codes to indicate success: http.StatusNoContent
	In func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientInOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientInResponse], errResp azfake.ErrorResponder)

	// Is is the fake for method SpecialWordsOperationsClient.Is
	// HTTP status codes to indicate success: http.StatusNoContent
	Is func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientIsOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientIsResponse], errResp azfake.ErrorResponder)

	// Lambda is the fake for method SpecialWordsOperationsClient.Lambda
	// HTTP status codes to indicate success: http.StatusNoContent
	Lambda func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientLambdaOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientLambdaResponse], errResp azfake.ErrorResponder)

	// Not is the fake for method SpecialWordsOperationsClient.Not
	// HTTP status codes to indicate success: http.StatusNoContent
	Not func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientNotOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientNotResponse], errResp azfake.ErrorResponder)

	// Or is the fake for method SpecialWordsOperationsClient.Or
	// HTTP status codes to indicate success: http.StatusNoContent
	Or func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientOrOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientOrResponse], errResp azfake.ErrorResponder)

	// Pass is the fake for method SpecialWordsOperationsClient.Pass
	// HTTP status codes to indicate success: http.StatusNoContent
	Pass func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientPassOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientPassResponse], errResp azfake.ErrorResponder)

	// Raise is the fake for method SpecialWordsOperationsClient.Raise
	// HTTP status codes to indicate success: http.StatusNoContent
	Raise func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientRaiseOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientRaiseResponse], errResp azfake.ErrorResponder)

	// Return is the fake for method SpecialWordsOperationsClient.Return
	// HTTP status codes to indicate success: http.StatusNoContent
	Return func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientReturnOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientReturnResponse], errResp azfake.ErrorResponder)

	// Try is the fake for method SpecialWordsOperationsClient.Try
	// HTTP status codes to indicate success: http.StatusNoContent
	Try func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientTryOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientTryResponse], errResp azfake.ErrorResponder)

	// While is the fake for method SpecialWordsOperationsClient.While
	// HTTP status codes to indicate success: http.StatusNoContent
	While func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientWhileOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientWhileResponse], errResp azfake.ErrorResponder)

	// With is the fake for method SpecialWordsOperationsClient.With
	// HTTP status codes to indicate success: http.StatusNoContent
	With func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientWithOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientWithResponse], errResp azfake.ErrorResponder)

	// Yield is the fake for method SpecialWordsOperationsClient.Yield
	// HTTP status codes to indicate success: http.StatusNoContent
	Yield func(ctx context.Context, options *specialwordsgroup.SpecialWordsOperationsClientYieldOptions) (resp azfake.Responder[specialwordsgroup.SpecialWordsOperationsClientYieldResponse], errResp azfake.ErrorResponder)
}

// NewSpecialWordsOperationsServerTransport creates a new instance of SpecialWordsOperationsServerTransport with the provided implementation.
// The returned SpecialWordsOperationsServerTransport instance is connected to an instance of specialwordsgroup.SpecialWordsOperationsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewSpecialWordsOperationsServerTransport(srv *SpecialWordsOperationsServer) *SpecialWordsOperationsServerTransport {
	return &SpecialWordsOperationsServerTransport{srv: srv}
}

// SpecialWordsOperationsServerTransport connects instances of specialwordsgroup.SpecialWordsOperationsClient to instances of SpecialWordsOperationsServer.
// Don't use this type directly, use NewSpecialWordsOperationsServerTransport instead.
type SpecialWordsOperationsServerTransport struct {
	srv *SpecialWordsOperationsServer
}

// Do implements the policy.Transporter interface for SpecialWordsOperationsServerTransport.
func (s *SpecialWordsOperationsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return s.dispatchToMethodFake(req, method)
}

func (s *SpecialWordsOperationsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var intercepted bool
		var res result
		if specialWordsOperationsServerTransportInterceptor != nil {
			res.resp, res.err, intercepted = specialWordsOperationsServerTransportInterceptor.Do(req)
		}
		if !intercepted {
			switch method {
			case "SpecialWordsOperationsClient.And":
				res.resp, res.err = s.dispatchAnd(req)
			case "SpecialWordsOperationsClient.As":
				res.resp, res.err = s.dispatchAs(req)
			case "SpecialWordsOperationsClient.Assert":
				res.resp, res.err = s.dispatchAssert(req)
			case "SpecialWordsOperationsClient.Async":
				res.resp, res.err = s.dispatchAsync(req)
			case "SpecialWordsOperationsClient.Await":
				res.resp, res.err = s.dispatchAwait(req)
			case "SpecialWordsOperationsClient.Break":
				res.resp, res.err = s.dispatchBreak(req)
			case "SpecialWordsOperationsClient.Class":
				res.resp, res.err = s.dispatchClass(req)
			case "SpecialWordsOperationsClient.Constructor":
				res.resp, res.err = s.dispatchConstructor(req)
			case "SpecialWordsOperationsClient.Continue":
				res.resp, res.err = s.dispatchContinue(req)
			case "SpecialWordsOperationsClient.Def":
				res.resp, res.err = s.dispatchDef(req)
			case "SpecialWordsOperationsClient.Del":
				res.resp, res.err = s.dispatchDel(req)
			case "SpecialWordsOperationsClient.Elif":
				res.resp, res.err = s.dispatchElif(req)
			case "SpecialWordsOperationsClient.Else":
				res.resp, res.err = s.dispatchElse(req)
			case "SpecialWordsOperationsClient.Except":
				res.resp, res.err = s.dispatchExcept(req)
			case "SpecialWordsOperationsClient.Exec":
				res.resp, res.err = s.dispatchExec(req)
			case "SpecialWordsOperationsClient.Finally":
				res.resp, res.err = s.dispatchFinally(req)
			case "SpecialWordsOperationsClient.For":
				res.resp, res.err = s.dispatchFor(req)
			case "SpecialWordsOperationsClient.From":
				res.resp, res.err = s.dispatchFrom(req)
			case "SpecialWordsOperationsClient.Global":
				res.resp, res.err = s.dispatchGlobal(req)
			case "SpecialWordsOperationsClient.If":
				res.resp, res.err = s.dispatchIf(req)
			case "SpecialWordsOperationsClient.Import":
				res.resp, res.err = s.dispatchImport(req)
			case "SpecialWordsOperationsClient.In":
				res.resp, res.err = s.dispatchIn(req)
			case "SpecialWordsOperationsClient.Is":
				res.resp, res.err = s.dispatchIs(req)
			case "SpecialWordsOperationsClient.Lambda":
				res.resp, res.err = s.dispatchLambda(req)
			case "SpecialWordsOperationsClient.Not":
				res.resp, res.err = s.dispatchNot(req)
			case "SpecialWordsOperationsClient.Or":
				res.resp, res.err = s.dispatchOr(req)
			case "SpecialWordsOperationsClient.Pass":
				res.resp, res.err = s.dispatchPass(req)
			case "SpecialWordsOperationsClient.Raise":
				res.resp, res.err = s.dispatchRaise(req)
			case "SpecialWordsOperationsClient.Return":
				res.resp, res.err = s.dispatchReturn(req)
			case "SpecialWordsOperationsClient.Try":
				res.resp, res.err = s.dispatchTry(req)
			case "SpecialWordsOperationsClient.While":
				res.resp, res.err = s.dispatchWhile(req)
			case "SpecialWordsOperationsClient.With":
				res.resp, res.err = s.dispatchWith(req)
			case "SpecialWordsOperationsClient.Yield":
				res.resp, res.err = s.dispatchYield(req)
			default:
				res.err = fmt.Errorf("unhandled API %s", method)
			}

		}
		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (s *SpecialWordsOperationsServerTransport) dispatchAnd(req *http.Request) (*http.Response, error) {
	if s.srv.And == nil {
		return nil, &nonRetriableError{errors.New("fake for method And not implemented")}
	}
	respr, errRespr := s.srv.And(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchAs(req *http.Request) (*http.Response, error) {
	if s.srv.As == nil {
		return nil, &nonRetriableError{errors.New("fake for method As not implemented")}
	}
	respr, errRespr := s.srv.As(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchAssert(req *http.Request) (*http.Response, error) {
	if s.srv.Assert == nil {
		return nil, &nonRetriableError{errors.New("fake for method Assert not implemented")}
	}
	respr, errRespr := s.srv.Assert(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchAsync(req *http.Request) (*http.Response, error) {
	if s.srv.Async == nil {
		return nil, &nonRetriableError{errors.New("fake for method Async not implemented")}
	}
	respr, errRespr := s.srv.Async(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchAwait(req *http.Request) (*http.Response, error) {
	if s.srv.Await == nil {
		return nil, &nonRetriableError{errors.New("fake for method Await not implemented")}
	}
	respr, errRespr := s.srv.Await(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchBreak(req *http.Request) (*http.Response, error) {
	if s.srv.Break == nil {
		return nil, &nonRetriableError{errors.New("fake for method Break not implemented")}
	}
	respr, errRespr := s.srv.Break(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchClass(req *http.Request) (*http.Response, error) {
	if s.srv.Class == nil {
		return nil, &nonRetriableError{errors.New("fake for method Class not implemented")}
	}
	respr, errRespr := s.srv.Class(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchConstructor(req *http.Request) (*http.Response, error) {
	if s.srv.Constructor == nil {
		return nil, &nonRetriableError{errors.New("fake for method Constructor not implemented")}
	}
	respr, errRespr := s.srv.Constructor(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchContinue(req *http.Request) (*http.Response, error) {
	if s.srv.Continue == nil {
		return nil, &nonRetriableError{errors.New("fake for method Continue not implemented")}
	}
	respr, errRespr := s.srv.Continue(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchDef(req *http.Request) (*http.Response, error) {
	if s.srv.Def == nil {
		return nil, &nonRetriableError{errors.New("fake for method Def not implemented")}
	}
	respr, errRespr := s.srv.Def(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchDel(req *http.Request) (*http.Response, error) {
	if s.srv.Del == nil {
		return nil, &nonRetriableError{errors.New("fake for method Del not implemented")}
	}
	respr, errRespr := s.srv.Del(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchElif(req *http.Request) (*http.Response, error) {
	if s.srv.Elif == nil {
		return nil, &nonRetriableError{errors.New("fake for method Elif not implemented")}
	}
	respr, errRespr := s.srv.Elif(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchElse(req *http.Request) (*http.Response, error) {
	if s.srv.Else == nil {
		return nil, &nonRetriableError{errors.New("fake for method Else not implemented")}
	}
	respr, errRespr := s.srv.Else(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchExcept(req *http.Request) (*http.Response, error) {
	if s.srv.Except == nil {
		return nil, &nonRetriableError{errors.New("fake for method Except not implemented")}
	}
	respr, errRespr := s.srv.Except(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchExec(req *http.Request) (*http.Response, error) {
	if s.srv.Exec == nil {
		return nil, &nonRetriableError{errors.New("fake for method Exec not implemented")}
	}
	respr, errRespr := s.srv.Exec(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchFinally(req *http.Request) (*http.Response, error) {
	if s.srv.Finally == nil {
		return nil, &nonRetriableError{errors.New("fake for method Finally not implemented")}
	}
	respr, errRespr := s.srv.Finally(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchFor(req *http.Request) (*http.Response, error) {
	if s.srv.For == nil {
		return nil, &nonRetriableError{errors.New("fake for method For not implemented")}
	}
	respr, errRespr := s.srv.For(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchFrom(req *http.Request) (*http.Response, error) {
	if s.srv.From == nil {
		return nil, &nonRetriableError{errors.New("fake for method From not implemented")}
	}
	respr, errRespr := s.srv.From(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchGlobal(req *http.Request) (*http.Response, error) {
	if s.srv.Global == nil {
		return nil, &nonRetriableError{errors.New("fake for method Global not implemented")}
	}
	respr, errRespr := s.srv.Global(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchIf(req *http.Request) (*http.Response, error) {
	if s.srv.If == nil {
		return nil, &nonRetriableError{errors.New("fake for method If not implemented")}
	}
	respr, errRespr := s.srv.If(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchImport(req *http.Request) (*http.Response, error) {
	if s.srv.Import == nil {
		return nil, &nonRetriableError{errors.New("fake for method Import not implemented")}
	}
	respr, errRespr := s.srv.Import(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchIn(req *http.Request) (*http.Response, error) {
	if s.srv.In == nil {
		return nil, &nonRetriableError{errors.New("fake for method In not implemented")}
	}
	respr, errRespr := s.srv.In(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchIs(req *http.Request) (*http.Response, error) {
	if s.srv.Is == nil {
		return nil, &nonRetriableError{errors.New("fake for method Is not implemented")}
	}
	respr, errRespr := s.srv.Is(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchLambda(req *http.Request) (*http.Response, error) {
	if s.srv.Lambda == nil {
		return nil, &nonRetriableError{errors.New("fake for method Lambda not implemented")}
	}
	respr, errRespr := s.srv.Lambda(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchNot(req *http.Request) (*http.Response, error) {
	if s.srv.Not == nil {
		return nil, &nonRetriableError{errors.New("fake for method Not not implemented")}
	}
	respr, errRespr := s.srv.Not(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchOr(req *http.Request) (*http.Response, error) {
	if s.srv.Or == nil {
		return nil, &nonRetriableError{errors.New("fake for method Or not implemented")}
	}
	respr, errRespr := s.srv.Or(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchPass(req *http.Request) (*http.Response, error) {
	if s.srv.Pass == nil {
		return nil, &nonRetriableError{errors.New("fake for method Pass not implemented")}
	}
	respr, errRespr := s.srv.Pass(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchRaise(req *http.Request) (*http.Response, error) {
	if s.srv.Raise == nil {
		return nil, &nonRetriableError{errors.New("fake for method Raise not implemented")}
	}
	respr, errRespr := s.srv.Raise(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchReturn(req *http.Request) (*http.Response, error) {
	if s.srv.Return == nil {
		return nil, &nonRetriableError{errors.New("fake for method Return not implemented")}
	}
	respr, errRespr := s.srv.Return(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchTry(req *http.Request) (*http.Response, error) {
	if s.srv.Try == nil {
		return nil, &nonRetriableError{errors.New("fake for method Try not implemented")}
	}
	respr, errRespr := s.srv.Try(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchWhile(req *http.Request) (*http.Response, error) {
	if s.srv.While == nil {
		return nil, &nonRetriableError{errors.New("fake for method While not implemented")}
	}
	respr, errRespr := s.srv.While(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchWith(req *http.Request) (*http.Response, error) {
	if s.srv.With == nil {
		return nil, &nonRetriableError{errors.New("fake for method With not implemented")}
	}
	respr, errRespr := s.srv.With(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *SpecialWordsOperationsServerTransport) dispatchYield(req *http.Request) (*http.Response, error) {
	if s.srv.Yield == nil {
		return nil, &nonRetriableError{errors.New("fake for method Yield not implemented")}
	}
	respr, errRespr := s.srv.Yield(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// set this to conditionally intercept incoming requests to SpecialWordsOperationsServerTransport
var specialWordsOperationsServerTransportInterceptor interface {
	// Do returns true if the server transport should use the returned response/error
	Do(*http.Request) (*http.Response, error, bool)
}
