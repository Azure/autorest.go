// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package specialwordsgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// SpecialWordsOperationsClient - Test reserved words as operation name.
// Don't use this type directly, use [SpecialWordsClient.NewSpecialWordsOperationsClient] instead.
type SpecialWordsOperationsClient struct {
	internal *azcore.Client
}

// And -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientAndOptions contains the optional parameters for the SpecialWordsOperationsClient.And
//     method.
func (client *SpecialWordsOperationsClient) And(ctx context.Context, options *SpecialWordsOperationsClientAndOptions) (SpecialWordsOperationsClientAndResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.And"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.andCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientAndResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientAndResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientAndResponse{}, err
	}
	return SpecialWordsOperationsClientAndResponse{}, nil
}

// andCreateRequest creates the And request.
func (client *SpecialWordsOperationsClient) andCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientAndOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/and"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// As -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientAsOptions contains the optional parameters for the SpecialWordsOperationsClient.As
//     method.
func (client *SpecialWordsOperationsClient) As(ctx context.Context, options *SpecialWordsOperationsClientAsOptions) (SpecialWordsOperationsClientAsResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.As"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.asCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientAsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientAsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientAsResponse{}, err
	}
	return SpecialWordsOperationsClientAsResponse{}, nil
}

// asCreateRequest creates the As request.
func (client *SpecialWordsOperationsClient) asCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientAsOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/as"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Assert -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientAssertOptions contains the optional parameters for the SpecialWordsOperationsClient.Assert
//     method.
func (client *SpecialWordsOperationsClient) Assert(ctx context.Context, options *SpecialWordsOperationsClientAssertOptions) (SpecialWordsOperationsClientAssertResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Assert"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.assertCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientAssertResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientAssertResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientAssertResponse{}, err
	}
	return SpecialWordsOperationsClientAssertResponse{}, nil
}

// assertCreateRequest creates the Assert request.
func (client *SpecialWordsOperationsClient) assertCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientAssertOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/assert"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Async -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientAsyncOptions contains the optional parameters for the SpecialWordsOperationsClient.Async
//     method.
func (client *SpecialWordsOperationsClient) Async(ctx context.Context, options *SpecialWordsOperationsClientAsyncOptions) (SpecialWordsOperationsClientAsyncResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Async"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.asyncCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientAsyncResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientAsyncResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientAsyncResponse{}, err
	}
	return SpecialWordsOperationsClientAsyncResponse{}, nil
}

// asyncCreateRequest creates the Async request.
func (client *SpecialWordsOperationsClient) asyncCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientAsyncOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/async"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Await -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientAwaitOptions contains the optional parameters for the SpecialWordsOperationsClient.Await
//     method.
func (client *SpecialWordsOperationsClient) Await(ctx context.Context, options *SpecialWordsOperationsClientAwaitOptions) (SpecialWordsOperationsClientAwaitResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Await"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.awaitCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientAwaitResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientAwaitResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientAwaitResponse{}, err
	}
	return SpecialWordsOperationsClientAwaitResponse{}, nil
}

// awaitCreateRequest creates the Await request.
func (client *SpecialWordsOperationsClient) awaitCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientAwaitOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/await"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Break -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientBreakOptions contains the optional parameters for the SpecialWordsOperationsClient.Break
//     method.
func (client *SpecialWordsOperationsClient) Break(ctx context.Context, options *SpecialWordsOperationsClientBreakOptions) (SpecialWordsOperationsClientBreakResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Break"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.breakCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientBreakResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientBreakResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientBreakResponse{}, err
	}
	return SpecialWordsOperationsClientBreakResponse{}, nil
}

// breakCreateRequest creates the Break request.
func (client *SpecialWordsOperationsClient) breakCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientBreakOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/break"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Class -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientClassOptions contains the optional parameters for the SpecialWordsOperationsClient.Class
//     method.
func (client *SpecialWordsOperationsClient) Class(ctx context.Context, options *SpecialWordsOperationsClientClassOptions) (SpecialWordsOperationsClientClassResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Class"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.classCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientClassResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientClassResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientClassResponse{}, err
	}
	return SpecialWordsOperationsClientClassResponse{}, nil
}

// classCreateRequest creates the Class request.
func (client *SpecialWordsOperationsClient) classCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientClassOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/class"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Constructor -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientConstructorOptions contains the optional parameters for the SpecialWordsOperationsClient.Constructor
//     method.
func (client *SpecialWordsOperationsClient) Constructor(ctx context.Context, options *SpecialWordsOperationsClientConstructorOptions) (SpecialWordsOperationsClientConstructorResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Constructor"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.constructorCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientConstructorResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientConstructorResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientConstructorResponse{}, err
	}
	return SpecialWordsOperationsClientConstructorResponse{}, nil
}

// constructorCreateRequest creates the Constructor request.
func (client *SpecialWordsOperationsClient) constructorCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientConstructorOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/constructor"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Continue -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientContinueOptions contains the optional parameters for the SpecialWordsOperationsClient.Continue
//     method.
func (client *SpecialWordsOperationsClient) Continue(ctx context.Context, options *SpecialWordsOperationsClientContinueOptions) (SpecialWordsOperationsClientContinueResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Continue"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.continueCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientContinueResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientContinueResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientContinueResponse{}, err
	}
	return SpecialWordsOperationsClientContinueResponse{}, nil
}

// continueCreateRequest creates the Continue request.
func (client *SpecialWordsOperationsClient) continueCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientContinueOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/continue"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Def -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientDefOptions contains the optional parameters for the SpecialWordsOperationsClient.Def
//     method.
func (client *SpecialWordsOperationsClient) Def(ctx context.Context, options *SpecialWordsOperationsClientDefOptions) (SpecialWordsOperationsClientDefResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Def"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.defCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientDefResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientDefResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientDefResponse{}, err
	}
	return SpecialWordsOperationsClientDefResponse{}, nil
}

// defCreateRequest creates the Def request.
func (client *SpecialWordsOperationsClient) defCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientDefOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/def"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Del -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientDelOptions contains the optional parameters for the SpecialWordsOperationsClient.Del
//     method.
func (client *SpecialWordsOperationsClient) Del(ctx context.Context, options *SpecialWordsOperationsClientDelOptions) (SpecialWordsOperationsClientDelResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Del"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.delCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientDelResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientDelResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientDelResponse{}, err
	}
	return SpecialWordsOperationsClientDelResponse{}, nil
}

// delCreateRequest creates the Del request.
func (client *SpecialWordsOperationsClient) delCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientDelOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/del"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Elif -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientElifOptions contains the optional parameters for the SpecialWordsOperationsClient.Elif
//     method.
func (client *SpecialWordsOperationsClient) Elif(ctx context.Context, options *SpecialWordsOperationsClientElifOptions) (SpecialWordsOperationsClientElifResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Elif"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.elifCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientElifResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientElifResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientElifResponse{}, err
	}
	return SpecialWordsOperationsClientElifResponse{}, nil
}

// elifCreateRequest creates the Elif request.
func (client *SpecialWordsOperationsClient) elifCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientElifOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/elif"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Else -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientElseOptions contains the optional parameters for the SpecialWordsOperationsClient.Else
//     method.
func (client *SpecialWordsOperationsClient) Else(ctx context.Context, options *SpecialWordsOperationsClientElseOptions) (SpecialWordsOperationsClientElseResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Else"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.elseCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientElseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientElseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientElseResponse{}, err
	}
	return SpecialWordsOperationsClientElseResponse{}, nil
}

// elseCreateRequest creates the Else request.
func (client *SpecialWordsOperationsClient) elseCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientElseOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/else"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Except -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientExceptOptions contains the optional parameters for the SpecialWordsOperationsClient.Except
//     method.
func (client *SpecialWordsOperationsClient) Except(ctx context.Context, options *SpecialWordsOperationsClientExceptOptions) (SpecialWordsOperationsClientExceptResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Except"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.exceptCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientExceptResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientExceptResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientExceptResponse{}, err
	}
	return SpecialWordsOperationsClientExceptResponse{}, nil
}

// exceptCreateRequest creates the Except request.
func (client *SpecialWordsOperationsClient) exceptCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientExceptOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/except"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Exec -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientExecOptions contains the optional parameters for the SpecialWordsOperationsClient.Exec
//     method.
func (client *SpecialWordsOperationsClient) Exec(ctx context.Context, options *SpecialWordsOperationsClientExecOptions) (SpecialWordsOperationsClientExecResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Exec"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.execCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientExecResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientExecResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientExecResponse{}, err
	}
	return SpecialWordsOperationsClientExecResponse{}, nil
}

// execCreateRequest creates the Exec request.
func (client *SpecialWordsOperationsClient) execCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientExecOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/exec"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Finally -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientFinallyOptions contains the optional parameters for the SpecialWordsOperationsClient.Finally
//     method.
func (client *SpecialWordsOperationsClient) Finally(ctx context.Context, options *SpecialWordsOperationsClientFinallyOptions) (SpecialWordsOperationsClientFinallyResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Finally"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.finallyCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientFinallyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientFinallyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientFinallyResponse{}, err
	}
	return SpecialWordsOperationsClientFinallyResponse{}, nil
}

// finallyCreateRequest creates the Finally request.
func (client *SpecialWordsOperationsClient) finallyCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientFinallyOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/finally"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// For -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientForOptions contains the optional parameters for the SpecialWordsOperationsClient.For
//     method.
func (client *SpecialWordsOperationsClient) For(ctx context.Context, options *SpecialWordsOperationsClientForOptions) (SpecialWordsOperationsClientForResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.For"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.forCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientForResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientForResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientForResponse{}, err
	}
	return SpecialWordsOperationsClientForResponse{}, nil
}

// forCreateRequest creates the For request.
func (client *SpecialWordsOperationsClient) forCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientForOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/for"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// From -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientFromOptions contains the optional parameters for the SpecialWordsOperationsClient.From
//     method.
func (client *SpecialWordsOperationsClient) From(ctx context.Context, options *SpecialWordsOperationsClientFromOptions) (SpecialWordsOperationsClientFromResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.From"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.fromCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientFromResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientFromResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientFromResponse{}, err
	}
	return SpecialWordsOperationsClientFromResponse{}, nil
}

// fromCreateRequest creates the From request.
func (client *SpecialWordsOperationsClient) fromCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientFromOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/from"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Global -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientGlobalOptions contains the optional parameters for the SpecialWordsOperationsClient.Global
//     method.
func (client *SpecialWordsOperationsClient) Global(ctx context.Context, options *SpecialWordsOperationsClientGlobalOptions) (SpecialWordsOperationsClientGlobalResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Global"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.globalCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientGlobalResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientGlobalResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientGlobalResponse{}, err
	}
	return SpecialWordsOperationsClientGlobalResponse{}, nil
}

// globalCreateRequest creates the Global request.
func (client *SpecialWordsOperationsClient) globalCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientGlobalOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/global"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// If -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientIfOptions contains the optional parameters for the SpecialWordsOperationsClient.If
//     method.
func (client *SpecialWordsOperationsClient) If(ctx context.Context, options *SpecialWordsOperationsClientIfOptions) (SpecialWordsOperationsClientIfResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.If"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.ifCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientIfResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientIfResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientIfResponse{}, err
	}
	return SpecialWordsOperationsClientIfResponse{}, nil
}

// ifCreateRequest creates the If request.
func (client *SpecialWordsOperationsClient) ifCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientIfOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/if"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Import -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientImportOptions contains the optional parameters for the SpecialWordsOperationsClient.Import
//     method.
func (client *SpecialWordsOperationsClient) Import(ctx context.Context, options *SpecialWordsOperationsClientImportOptions) (SpecialWordsOperationsClientImportResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Import"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.importCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientImportResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientImportResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientImportResponse{}, err
	}
	return SpecialWordsOperationsClientImportResponse{}, nil
}

// importCreateRequest creates the Import request.
func (client *SpecialWordsOperationsClient) importCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientImportOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/import"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// In -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientInOptions contains the optional parameters for the SpecialWordsOperationsClient.In
//     method.
func (client *SpecialWordsOperationsClient) In(ctx context.Context, options *SpecialWordsOperationsClientInOptions) (SpecialWordsOperationsClientInResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.In"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.inCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientInResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientInResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientInResponse{}, err
	}
	return SpecialWordsOperationsClientInResponse{}, nil
}

// inCreateRequest creates the In request.
func (client *SpecialWordsOperationsClient) inCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientInOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/in"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Is -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientIsOptions contains the optional parameters for the SpecialWordsOperationsClient.Is
//     method.
func (client *SpecialWordsOperationsClient) Is(ctx context.Context, options *SpecialWordsOperationsClientIsOptions) (SpecialWordsOperationsClientIsResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Is"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.isCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientIsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientIsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientIsResponse{}, err
	}
	return SpecialWordsOperationsClientIsResponse{}, nil
}

// isCreateRequest creates the Is request.
func (client *SpecialWordsOperationsClient) isCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientIsOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/is"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Lambda -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientLambdaOptions contains the optional parameters for the SpecialWordsOperationsClient.Lambda
//     method.
func (client *SpecialWordsOperationsClient) Lambda(ctx context.Context, options *SpecialWordsOperationsClientLambdaOptions) (SpecialWordsOperationsClientLambdaResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Lambda"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.lambdaCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientLambdaResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientLambdaResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientLambdaResponse{}, err
	}
	return SpecialWordsOperationsClientLambdaResponse{}, nil
}

// lambdaCreateRequest creates the Lambda request.
func (client *SpecialWordsOperationsClient) lambdaCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientLambdaOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/lambda"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Not -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientNotOptions contains the optional parameters for the SpecialWordsOperationsClient.Not
//     method.
func (client *SpecialWordsOperationsClient) Not(ctx context.Context, options *SpecialWordsOperationsClientNotOptions) (SpecialWordsOperationsClientNotResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Not"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.notCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientNotResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientNotResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientNotResponse{}, err
	}
	return SpecialWordsOperationsClientNotResponse{}, nil
}

// notCreateRequest creates the Not request.
func (client *SpecialWordsOperationsClient) notCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientNotOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/not"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Or -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientOrOptions contains the optional parameters for the SpecialWordsOperationsClient.Or
//     method.
func (client *SpecialWordsOperationsClient) Or(ctx context.Context, options *SpecialWordsOperationsClientOrOptions) (SpecialWordsOperationsClientOrResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Or"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.orCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientOrResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientOrResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientOrResponse{}, err
	}
	return SpecialWordsOperationsClientOrResponse{}, nil
}

// orCreateRequest creates the Or request.
func (client *SpecialWordsOperationsClient) orCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientOrOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/or"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Pass -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientPassOptions contains the optional parameters for the SpecialWordsOperationsClient.Pass
//     method.
func (client *SpecialWordsOperationsClient) Pass(ctx context.Context, options *SpecialWordsOperationsClientPassOptions) (SpecialWordsOperationsClientPassResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Pass"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.passCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientPassResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientPassResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientPassResponse{}, err
	}
	return SpecialWordsOperationsClientPassResponse{}, nil
}

// passCreateRequest creates the Pass request.
func (client *SpecialWordsOperationsClient) passCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientPassOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/pass"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Raise -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientRaiseOptions contains the optional parameters for the SpecialWordsOperationsClient.Raise
//     method.
func (client *SpecialWordsOperationsClient) Raise(ctx context.Context, options *SpecialWordsOperationsClientRaiseOptions) (SpecialWordsOperationsClientRaiseResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Raise"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.raiseCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientRaiseResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientRaiseResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientRaiseResponse{}, err
	}
	return SpecialWordsOperationsClientRaiseResponse{}, nil
}

// raiseCreateRequest creates the Raise request.
func (client *SpecialWordsOperationsClient) raiseCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientRaiseOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/raise"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Return -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientReturnOptions contains the optional parameters for the SpecialWordsOperationsClient.Return
//     method.
func (client *SpecialWordsOperationsClient) Return(ctx context.Context, options *SpecialWordsOperationsClientReturnOptions) (SpecialWordsOperationsClientReturnResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Return"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.returnCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientReturnResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientReturnResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientReturnResponse{}, err
	}
	return SpecialWordsOperationsClientReturnResponse{}, nil
}

// returnCreateRequest creates the Return request.
func (client *SpecialWordsOperationsClient) returnCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientReturnOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/return"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Try -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientTryOptions contains the optional parameters for the SpecialWordsOperationsClient.Try
//     method.
func (client *SpecialWordsOperationsClient) Try(ctx context.Context, options *SpecialWordsOperationsClientTryOptions) (SpecialWordsOperationsClientTryResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Try"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.tryCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientTryResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientTryResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientTryResponse{}, err
	}
	return SpecialWordsOperationsClientTryResponse{}, nil
}

// tryCreateRequest creates the Try request.
func (client *SpecialWordsOperationsClient) tryCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientTryOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/try"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// While -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientWhileOptions contains the optional parameters for the SpecialWordsOperationsClient.While
//     method.
func (client *SpecialWordsOperationsClient) While(ctx context.Context, options *SpecialWordsOperationsClientWhileOptions) (SpecialWordsOperationsClientWhileResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.While"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.whileCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientWhileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientWhileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientWhileResponse{}, err
	}
	return SpecialWordsOperationsClientWhileResponse{}, nil
}

// whileCreateRequest creates the While request.
func (client *SpecialWordsOperationsClient) whileCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientWhileOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/while"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// With -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientWithOptions contains the optional parameters for the SpecialWordsOperationsClient.With
//     method.
func (client *SpecialWordsOperationsClient) With(ctx context.Context, options *SpecialWordsOperationsClientWithOptions) (SpecialWordsOperationsClientWithResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.With"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.withCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientWithResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientWithResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientWithResponse{}, err
	}
	return SpecialWordsOperationsClientWithResponse{}, nil
}

// withCreateRequest creates the With request.
func (client *SpecialWordsOperationsClient) withCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientWithOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/with"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// Yield -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - SpecialWordsOperationsClientYieldOptions contains the optional parameters for the SpecialWordsOperationsClient.Yield
//     method.
func (client *SpecialWordsOperationsClient) Yield(ctx context.Context, options *SpecialWordsOperationsClientYieldOptions) (SpecialWordsOperationsClientYieldResponse, error) {
	var err error
	const operationName = "SpecialWordsOperationsClient.Yield"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.yieldCreateRequest(ctx, options)
	if err != nil {
		return SpecialWordsOperationsClientYieldResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return SpecialWordsOperationsClientYieldResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return SpecialWordsOperationsClientYieldResponse{}, err
	}
	return SpecialWordsOperationsClientYieldResponse{}, nil
}

// yieldCreateRequest creates the Yield request.
func (client *SpecialWordsOperationsClient) yieldCreateRequest(ctx context.Context, _ *SpecialWordsOperationsClientYieldOptions) (*policy.Request, error) {
	urlPath := "/special-words/operations/yield"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}
