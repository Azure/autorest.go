// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package pageablegroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// PageableServerDrivenPaginationContinuationTokenClient contains the methods for the PageableServerDrivenPaginationContinuationToken
// group.
// Don't use this type directly, use [PageableServerDrivenPaginationClient.NewPageableServerDrivenPaginationContinuationTokenClient] instead.
type PageableServerDrivenPaginationContinuationTokenClient struct {
	internal *azcore.Client
}

//   - options - PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyOptions contains the optional parameters
//     for the PageableServerDrivenPaginationContinuationTokenClient.NewRequestHeaderResponseBodyPager method.
func (client *PageableServerDrivenPaginationContinuationTokenClient) NewRequestHeaderResponseBodyPager(options *PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyOptions) *runtime.Pager[PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse] {
	return runtime.NewPager(runtime.PagingHandler[PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse]{
		More: func(page PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse) bool {
			return false
		},
		Fetcher: func(ctx context.Context, page *PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse) (PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PageableServerDrivenPaginationContinuationTokenClient.NewRequestHeaderResponseBodyPager")
			req, err := client.requestHeaderResponseBodyCreateRequest(ctx, options)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse{}, runtime.NewResponseError(resp)
			}
			return client.requestHeaderResponseBodyHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// requestHeaderResponseBodyCreateRequest creates the RequestHeaderResponseBody request.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestHeaderResponseBodyCreateRequest(ctx context.Context, options *PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyOptions) (*policy.Request, error) {
	urlPath := "/payload/pageable/server-driven-pagination/continuationtoken/request-header-response-body"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Bar != nil {
		reqQP.Set("bar", *options.Bar)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Foo != nil {
		req.Raw().Header["foo"] = []string{*options.Foo}
	}
	if options != nil && options.Token != nil {
		req.Raw().Header["token"] = []string{*options.Token}
	}
	return req, nil
}

// requestHeaderResponseBodyHandleResponse handles the RequestHeaderResponseBody response.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestHeaderResponseBodyHandleResponse(resp *http.Response) (PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse, error) {
	result := PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestHeaderResponseBodyResponse); err != nil {
		return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseBodyResponse{}, err
	}
	return result, nil
}

//   - options - PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderOptions contains the optional
//     parameters for the PageableServerDrivenPaginationContinuationTokenClient.NewRequestHeaderResponseHeaderPager method.
func (client *PageableServerDrivenPaginationContinuationTokenClient) NewRequestHeaderResponseHeaderPager(options *PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderOptions) *runtime.Pager[PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse] {
	return runtime.NewPager(runtime.PagingHandler[PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse]{
		More: func(page PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse) bool {
			return false
		},
		Fetcher: func(ctx context.Context, page *PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse) (PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PageableServerDrivenPaginationContinuationTokenClient.NewRequestHeaderResponseHeaderPager")
			req, err := client.requestHeaderResponseHeaderCreateRequest(ctx, options)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse{}, runtime.NewResponseError(resp)
			}
			return client.requestHeaderResponseHeaderHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// requestHeaderResponseHeaderCreateRequest creates the RequestHeaderResponseHeader request.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestHeaderResponseHeaderCreateRequest(ctx context.Context, options *PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderOptions) (*policy.Request, error) {
	urlPath := "/payload/pageable/server-driven-pagination/continuationtoken/request-header-response-header"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Bar != nil {
		reqQP.Set("bar", *options.Bar)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Foo != nil {
		req.Raw().Header["foo"] = []string{*options.Foo}
	}
	if options != nil && options.Token != nil {
		req.Raw().Header["token"] = []string{*options.Token}
	}
	return req, nil
}

// requestHeaderResponseHeaderHandleResponse handles the RequestHeaderResponseHeader response.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestHeaderResponseHeaderHandleResponse(resp *http.Response) (PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse, error) {
	result := PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse{}
	if vals, ok := resp.Header["next-token"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.NextToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestHeaderResponseHeaderResponse); err != nil {
		return PageableServerDrivenPaginationContinuationTokenClientRequestHeaderResponseHeaderResponse{}, err
	}
	return result, nil
}

//   - options - PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyOptions contains the optional parameters
//     for the PageableServerDrivenPaginationContinuationTokenClient.NewRequestQueryResponseBodyPager method.
func (client *PageableServerDrivenPaginationContinuationTokenClient) NewRequestQueryResponseBodyPager(options *PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyOptions) *runtime.Pager[PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse] {
	return runtime.NewPager(runtime.PagingHandler[PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse]{
		More: func(page PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse) bool {
			return false
		},
		Fetcher: func(ctx context.Context, page *PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse) (PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PageableServerDrivenPaginationContinuationTokenClient.NewRequestQueryResponseBodyPager")
			req, err := client.requestQueryResponseBodyCreateRequest(ctx, options)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse{}, runtime.NewResponseError(resp)
			}
			return client.requestQueryResponseBodyHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// requestQueryResponseBodyCreateRequest creates the RequestQueryResponseBody request.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestQueryResponseBodyCreateRequest(ctx context.Context, options *PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyOptions) (*policy.Request, error) {
	urlPath := "/payload/pageable/server-driven-pagination/continuationtoken/request-query-response-body"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Bar != nil {
		reqQP.Set("bar", *options.Bar)
	}
	if options != nil && options.Token != nil {
		reqQP.Set("token", *options.Token)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Foo != nil {
		req.Raw().Header["foo"] = []string{*options.Foo}
	}
	return req, nil
}

// requestQueryResponseBodyHandleResponse handles the RequestQueryResponseBody response.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestQueryResponseBodyHandleResponse(resp *http.Response) (PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse, error) {
	result := PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestQueryResponseBodyResponse); err != nil {
		return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseBodyResponse{}, err
	}
	return result, nil
}

//   - options - PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderOptions contains the optional
//     parameters for the PageableServerDrivenPaginationContinuationTokenClient.NewRequestQueryResponseHeaderPager method.
func (client *PageableServerDrivenPaginationContinuationTokenClient) NewRequestQueryResponseHeaderPager(options *PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderOptions) *runtime.Pager[PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse] {
	return runtime.NewPager(runtime.PagingHandler[PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse]{
		More: func(page PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse) bool {
			return false
		},
		Fetcher: func(ctx context.Context, page *PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse) (PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PageableServerDrivenPaginationContinuationTokenClient.NewRequestQueryResponseHeaderPager")
			req, err := client.requestQueryResponseHeaderCreateRequest(ctx, options)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse{}, runtime.NewResponseError(resp)
			}
			return client.requestQueryResponseHeaderHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// requestQueryResponseHeaderCreateRequest creates the RequestQueryResponseHeader request.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestQueryResponseHeaderCreateRequest(ctx context.Context, options *PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderOptions) (*policy.Request, error) {
	urlPath := "/payload/pageable/server-driven-pagination/continuationtoken/request-query-response-header"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Bar != nil {
		reqQP.Set("bar", *options.Bar)
	}
	if options != nil && options.Token != nil {
		reqQP.Set("token", *options.Token)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Foo != nil {
		req.Raw().Header["foo"] = []string{*options.Foo}
	}
	return req, nil
}

// requestQueryResponseHeaderHandleResponse handles the RequestQueryResponseHeader response.
func (client *PageableServerDrivenPaginationContinuationTokenClient) requestQueryResponseHeaderHandleResponse(resp *http.Response) (PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse, error) {
	result := PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse{}
	if vals, ok := resp.Header["next-token"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.NextToken = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RequestQueryResponseHeaderResponse); err != nil {
		return PageableServerDrivenPaginationContinuationTokenClientRequestQueryResponseHeaderResponse{}, err
	}
	return result, nil
}
