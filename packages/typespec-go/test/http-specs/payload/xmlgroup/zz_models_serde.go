// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package xmlgroup

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalXML implements the xml.Marshaller interface for type ModelWithArrayOfModel.
func (m ModelWithArrayOfModel) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithArrayOfModel
	aux := &struct {
		*alias
		Items *[]SimpleModel `xml:"items>SimpleModel"`
	}{
		alias: (*alias)(&m),
	}
	if m.Items != nil {
		aux.Items = &m.Items
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithDictionary.
func (m ModelWithDictionary) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithDictionary
	aux := &struct {
		*alias
		Metadata additionalProperties `xml:"metadata"`
	}{
		alias: (*alias)(&m),
	}
	aux.Metadata = (additionalProperties)(m.Metadata)
	return enc.EncodeElement(aux, start)
}

// UnmarshalXML implements the xml.Unmarshaller interface for type ModelWithDictionary.
func (m *ModelWithDictionary) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	type alias ModelWithDictionary
	aux := &struct {
		*alias
		Metadata additionalProperties `xml:"metadata"`
	}{
		alias: (*alias)(m),
	}
	if err := dec.DecodeElement(aux, &start); err != nil {
		return err
	}
	m.Metadata = (map[string]*string)(aux.Metadata)
	return nil
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithEmptyArray.
func (m ModelWithEmptyArray) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithEmptyArray
	aux := &struct {
		*alias
		Items *[]SimpleModel `xml:"items>SimpleModel"`
	}{
		alias: (*alias)(&m),
	}
	if m.Items != nil {
		aux.Items = &m.Items
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithEncodedNames.
func (m ModelWithEncodedNames) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	start.Name.Local = "ModelWithEncodedNamesSrc"
	type alias ModelWithEncodedNames
	aux := &struct {
		*alias
		Colors *[]string `xml:"PossibleColors>string"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithRenamedArrays.
func (m ModelWithRenamedArrays) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithRenamedArrays
	aux := &struct {
		*alias
		Colors *[]string `xml:"Colors"`
		Counts *[]int32  `xml:"Counts>int32"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	if m.Counts != nil {
		aux.Counts = &m.Counts
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithRenamedFields.
func (m ModelWithRenamedFields) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	start.Name.Local = "ModelWithRenamedFieldsSrc"
	type alias ModelWithRenamedFields
	aux := &struct {
		*alias
	}{
		alias: (*alias)(&m),
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithSimpleArrays.
func (m ModelWithSimpleArrays) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithSimpleArrays
	aux := &struct {
		*alias
		Colors *[]string `xml:"colors>string"`
		Counts *[]int32  `xml:"counts>int32"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	if m.Counts != nil {
		aux.Counts = &m.Counts
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithUnwrappedArray.
func (m ModelWithUnwrappedArray) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithUnwrappedArray
	aux := &struct {
		*alias
		Colors *[]string `xml:"colors"`
		Counts *[]int32  `xml:"counts>int32"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	if m.Counts != nil {
		aux.Counts = &m.Counts
	}
	return enc.EncodeElement(aux, start)
}

// MarshalJSON implements the json.Marshaller interface for type XMLErrorBody.
func (x XMLErrorBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", x.Code)
	populate(objectMap, "message", x.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XMLErrorBody.
func (x *XMLErrorBody) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", x, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &x.Code)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &x.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", x, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
