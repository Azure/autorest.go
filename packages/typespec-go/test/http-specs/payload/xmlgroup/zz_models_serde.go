// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package xmlgroup

import "encoding/xml"

// MarshalXML implements the xml.Marshaller interface for type ModelWithArrayOfModel.
func (m ModelWithArrayOfModel) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithArrayOfModel
	aux := &struct {
		*alias
		Items *[]SimpleModel `xml:"items>SimpleModel"`
	}{
		alias: (*alias)(&m),
	}
	if m.Items != nil {
		aux.Items = &m.Items
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithDictionary.
func (m ModelWithDictionary) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithDictionary
	aux := &struct {
		*alias
		Metadata additionalProperties `xml:"metadata"`
	}{
		alias: (*alias)(&m),
	}
	aux.Metadata = (additionalProperties)(m.Metadata)
	return enc.EncodeElement(aux, start)
}

// UnmarshalXML implements the xml.Unmarshaller interface for type ModelWithDictionary.
func (m *ModelWithDictionary) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	type alias ModelWithDictionary
	aux := &struct {
		*alias
		Metadata additionalProperties `xml:"metadata"`
	}{
		alias: (*alias)(m),
	}
	if err := dec.DecodeElement(aux, &start); err != nil {
		return err
	}
	m.Metadata = (map[string]*string)(aux.Metadata)
	return nil
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithEmptyArray.
func (m ModelWithEmptyArray) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithEmptyArray
	aux := &struct {
		*alias
		Items *[]SimpleModel `xml:"items>SimpleModel"`
	}{
		alias: (*alias)(&m),
	}
	if m.Items != nil {
		aux.Items = &m.Items
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithEncodedNames.
func (m ModelWithEncodedNames) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	start.Name.Local = "ModelWithEncodedNamesSrc"
	type alias ModelWithEncodedNames
	aux := &struct {
		*alias
		Colors *[]string `xml:"PossibleColors>string"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithRenamedArrays.
func (m ModelWithRenamedArrays) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithRenamedArrays
	aux := &struct {
		*alias
		Colors *[]string `xml:"Colors"`
		Counts *[]int32  `xml:"Counts>int32"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	if m.Counts != nil {
		aux.Counts = &m.Counts
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithRenamedFields.
func (m ModelWithRenamedFields) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	start.Name.Local = "ModelWithRenamedFieldsSrc"
	type alias ModelWithRenamedFields
	aux := &struct {
		*alias
	}{
		alias: (*alias)(&m),
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithSimpleArrays.
func (m ModelWithSimpleArrays) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithSimpleArrays
	aux := &struct {
		*alias
		Colors *[]string `xml:"colors>string"`
		Counts *[]int32  `xml:"counts>int32"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	if m.Counts != nil {
		aux.Counts = &m.Counts
	}
	return enc.EncodeElement(aux, start)
}

// MarshalXML implements the xml.Marshaller interface for type ModelWithUnwrappedArray.
func (m ModelWithUnwrappedArray) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	type alias ModelWithUnwrappedArray
	aux := &struct {
		*alias
		Colors *[]string `xml:"colors"`
		Counts *[]int32  `xml:"counts>int32"`
	}{
		alias: (*alias)(&m),
	}
	if m.Colors != nil {
		aux.Colors = &m.Colors
	}
	if m.Counts != nil {
		aux.Counts = &m.Counts
	}
	return enc.EncodeElement(aux, start)
}
