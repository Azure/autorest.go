// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package mediatypegroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/streaming"
	"net/http"
	"strings"
)

// MediaTypeStringBodyClient contains the methods for the MediaTypeStringBody group.
// Don't use this type directly, use [MediaTypeClient.NewMediaTypeStringBodyClient] instead.
type MediaTypeStringBodyClient struct {
	internal *azcore.Client
	endpoint string
}

// GetAsJSON -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - MediaTypeStringBodyClientGetAsJSONOptions contains the optional parameters for the MediaTypeStringBodyClient.GetAsJSON
//     method.
func (client *MediaTypeStringBodyClient) GetAsJSON(ctx context.Context, options *MediaTypeStringBodyClientGetAsJSONOptions) (MediaTypeStringBodyClientGetAsJSONResponse, error) {
	var err error
	const operationName = "MediaTypeStringBodyClient.GetAsJSON"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAsJSONCreateRequest(ctx, options)
	if err != nil {
		return MediaTypeStringBodyClientGetAsJSONResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MediaTypeStringBodyClientGetAsJSONResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return MediaTypeStringBodyClientGetAsJSONResponse{}, err
	}
	resp, err := client.getAsJSONHandleResponse(httpResp)
	return resp, err
}

// getAsJSONCreateRequest creates the GetAsJSON request.
func (client *MediaTypeStringBodyClient) getAsJSONCreateRequest(ctx context.Context, _ *MediaTypeStringBodyClientGetAsJSONOptions) (*policy.Request, error) {
	urlPath := "/payload/media-type/string-body/getAsJson"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getAsJSONHandleResponse handles the GetAsJSON response.
func (client *MediaTypeStringBodyClient) getAsJSONHandleResponse(resp *http.Response) (MediaTypeStringBodyClientGetAsJSONResponse, error) {
	result := MediaTypeStringBodyClientGetAsJSONResponse{}
	if val := resp.Header.Get("content-type"); val != "" {
		result.ContentType = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return MediaTypeStringBodyClientGetAsJSONResponse{}, err
	}
	return result, nil
}

// GetAsText -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - MediaTypeStringBodyClientGetAsTextOptions contains the optional parameters for the MediaTypeStringBodyClient.GetAsText
//     method.
func (client *MediaTypeStringBodyClient) GetAsText(ctx context.Context, options *MediaTypeStringBodyClientGetAsTextOptions) (MediaTypeStringBodyClientGetAsTextResponse, error) {
	var err error
	const operationName = "MediaTypeStringBodyClient.GetAsText"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getAsTextCreateRequest(ctx, options)
	if err != nil {
		return MediaTypeStringBodyClientGetAsTextResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MediaTypeStringBodyClientGetAsTextResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return MediaTypeStringBodyClientGetAsTextResponse{}, err
	}
	resp, err := client.getAsTextHandleResponse(httpResp)
	return resp, err
}

// getAsTextCreateRequest creates the GetAsText request.
func (client *MediaTypeStringBodyClient) getAsTextCreateRequest(ctx context.Context, _ *MediaTypeStringBodyClientGetAsTextOptions) (*policy.Request, error) {
	urlPath := "/payload/media-type/string-body/getAsText"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"text/plain"}
	return req, nil
}

// getAsTextHandleResponse handles the GetAsText response.
func (client *MediaTypeStringBodyClient) getAsTextHandleResponse(resp *http.Response) (MediaTypeStringBodyClientGetAsTextResponse, error) {
	result := MediaTypeStringBodyClientGetAsTextResponse{}
	if val := resp.Header.Get("content-type"); val != "" {
		result.ContentType = &val
	}
	body, err := runtime.Payload(resp)
	if err != nil {
		return MediaTypeStringBodyClientGetAsTextResponse{}, err
	}
	txt := string(body)
	result.Value = &txt
	return result, nil
}

// SendAsJSON -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - MediaTypeStringBodyClientSendAsJSONOptions contains the optional parameters for the MediaTypeStringBodyClient.SendAsJSON
//     method.
func (client *MediaTypeStringBodyClient) SendAsJSON(ctx context.Context, textParam string, options *MediaTypeStringBodyClientSendAsJSONOptions) (MediaTypeStringBodyClientSendAsJSONResponse, error) {
	var err error
	const operationName = "MediaTypeStringBodyClient.SendAsJSON"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.sendAsJSONCreateRequest(ctx, textParam, options)
	if err != nil {
		return MediaTypeStringBodyClientSendAsJSONResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MediaTypeStringBodyClientSendAsJSONResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return MediaTypeStringBodyClientSendAsJSONResponse{}, err
	}
	return MediaTypeStringBodyClientSendAsJSONResponse{}, nil
}

// sendAsJSONCreateRequest creates the SendAsJSON request.
func (client *MediaTypeStringBodyClient) sendAsJSONCreateRequest(ctx context.Context, textParam string, _ *MediaTypeStringBodyClientSendAsJSONOptions) (*policy.Request, error) {
	urlPath := "/payload/media-type/string-body/sendAsJson"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, textParam); err != nil {
		return nil, err
	}
	return req, nil
}

// SendAsText -
// If the operation fails it returns an *azcore.ResponseError type.
//   - options - MediaTypeStringBodyClientSendAsTextOptions contains the optional parameters for the MediaTypeStringBodyClient.SendAsText
//     method.
func (client *MediaTypeStringBodyClient) SendAsText(ctx context.Context, textParam string, options *MediaTypeStringBodyClientSendAsTextOptions) (MediaTypeStringBodyClientSendAsTextResponse, error) {
	var err error
	const operationName = "MediaTypeStringBodyClient.SendAsText"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.sendAsTextCreateRequest(ctx, textParam, options)
	if err != nil {
		return MediaTypeStringBodyClientSendAsTextResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return MediaTypeStringBodyClientSendAsTextResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return MediaTypeStringBodyClientSendAsTextResponse{}, err
	}
	return MediaTypeStringBodyClientSendAsTextResponse{}, nil
}

// sendAsTextCreateRequest creates the SendAsText request.
func (client *MediaTypeStringBodyClient) sendAsTextCreateRequest(ctx context.Context, textParam string, _ *MediaTypeStringBodyClientSendAsTextOptions) (*policy.Request, error) {
	urlPath := "/payload/media-type/string-body/sendAsText"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	body := streaming.NopCloser(strings.NewReader(textParam))
	req.Raw().Header["Content-Type"] = []string{"text/plain"}
	if err := req.SetBody(body, "text/plain"); err != nil {
		return nil, err
	}
	return req, nil
}
