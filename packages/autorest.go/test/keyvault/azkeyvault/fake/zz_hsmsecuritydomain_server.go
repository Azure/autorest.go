//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package fake

import (
	"azkeyvault"
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// HSMSecurityDomainServer is a fake server for instances of the azkeyvault.HSMSecurityDomainClient type.
type HSMSecurityDomainServer struct {
	// BeginDownload is the fake for method HSMSecurityDomainClient.BeginDownload
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDownload func(ctx context.Context, host string, certificateInfoObject azkeyvault.CertificateInfoObject, options *azkeyvault.HSMSecurityDomainClientBeginDownloadOptions) (resp azfake.PollerResponder[azkeyvault.HSMSecurityDomainClientDownloadResponse], errResp azfake.ErrorResponder)

	// DownloadPending is the fake for method HSMSecurityDomainClient.DownloadPending
	// HTTP status codes to indicate success: http.StatusOK
	DownloadPending func(ctx context.Context, host string, options *azkeyvault.HSMSecurityDomainClientDownloadPendingOptions) (resp azfake.Responder[azkeyvault.HSMSecurityDomainClientDownloadPendingResponse], errResp azfake.ErrorResponder)

	// TransferKey is the fake for method HSMSecurityDomainClient.TransferKey
	// HTTP status codes to indicate success: http.StatusOK
	TransferKey func(ctx context.Context, host string, options *azkeyvault.HSMSecurityDomainClientTransferKeyOptions) (resp azfake.Responder[azkeyvault.HSMSecurityDomainClientTransferKeyResponse], errResp azfake.ErrorResponder)

	// BeginUpload is the fake for method HSMSecurityDomainClient.BeginUpload
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginUpload func(ctx context.Context, host string, securityDomain azkeyvault.SecurityDomainObject, options *azkeyvault.HSMSecurityDomainClientBeginUploadOptions) (resp azfake.PollerResponder[azkeyvault.HSMSecurityDomainClientUploadResponse], errResp azfake.ErrorResponder)

	// UploadPending is the fake for method HSMSecurityDomainClient.UploadPending
	// HTTP status codes to indicate success: http.StatusOK
	UploadPending func(ctx context.Context, host string, options *azkeyvault.HSMSecurityDomainClientUploadPendingOptions) (resp azfake.Responder[azkeyvault.HSMSecurityDomainClientUploadPendingResponse], errResp azfake.ErrorResponder)
}

// NewHSMSecurityDomainServerTransport creates a new instance of HSMSecurityDomainServerTransport with the provided implementation.
// The returned HSMSecurityDomainServerTransport instance is connected to an instance of azkeyvault.HSMSecurityDomainClient by way of the
// undefined.Transporter field.
func NewHSMSecurityDomainServerTransport(srv *HSMSecurityDomainServer) *HSMSecurityDomainServerTransport {
	return &HSMSecurityDomainServerTransport{srv: srv}
}

// HSMSecurityDomainServerTransport connects instances of azkeyvault.HSMSecurityDomainClient to instances of HSMSecurityDomainServer.
// Don't use this type directly, use NewHSMSecurityDomainServerTransport instead.
type HSMSecurityDomainServerTransport struct {
	srv           *HSMSecurityDomainServer
	beginDownload *azfake.PollerResponder[azkeyvault.HSMSecurityDomainClientDownloadResponse]
	beginUpload   *azfake.PollerResponder[azkeyvault.HSMSecurityDomainClientUploadResponse]
}

// Do implements the policy.Transporter interface for HSMSecurityDomainServerTransport.
func (h *HSMSecurityDomainServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "HSMSecurityDomainClient.BeginDownload":
		resp, err = h.dispatchBeginDownload(req)
	case "HSMSecurityDomainClient.DownloadPending":
		resp, err = h.dispatchDownloadPending(req)
	case "HSMSecurityDomainClient.TransferKey":
		resp, err = h.dispatchTransferKey(req)
	case "HSMSecurityDomainClient.BeginUpload":
		resp, err = h.dispatchBeginUpload(req)
	case "HSMSecurityDomainClient.UploadPending":
		resp, err = h.dispatchUploadPending(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (h *HSMSecurityDomainServerTransport) dispatchBeginDownload(req *http.Request) (*http.Response, error) {
	if h.srv.BeginDownload == nil {
		return nil, &nonRetriableError{errors.New("method BeginDownload not implemented")}
	}
	if h.beginDownload == nil {
		body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateInfoObject](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := h.srv.BeginDownload(req.Context(), req.URL.Host, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		h.beginDownload = &respr
	}

	resp, err := server.PollerResponderNext(h.beginDownload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(h.beginDownload) {
		h.beginDownload = nil
	}

	return resp, nil
}

func (h *HSMSecurityDomainServerTransport) dispatchDownloadPending(req *http.Request) (*http.Response, error) {
	if h.srv.DownloadPending == nil {
		return nil, &nonRetriableError{errors.New("method DownloadPending not implemented")}
	}
	respr, errRespr := h.srv.DownloadPending(req.Context(), req.URL.Host, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecurityDomainOperationStatus, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HSMSecurityDomainServerTransport) dispatchTransferKey(req *http.Request) (*http.Response, error) {
	if h.srv.TransferKey == nil {
		return nil, &nonRetriableError{errors.New("method TransferKey not implemented")}
	}
	respr, errRespr := h.srv.TransferKey(req.Context(), req.URL.Host, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).TransferKey, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HSMSecurityDomainServerTransport) dispatchBeginUpload(req *http.Request) (*http.Response, error) {
	if h.srv.BeginUpload == nil {
		return nil, &nonRetriableError{errors.New("method BeginUpload not implemented")}
	}
	if h.beginUpload == nil {
		body, err := server.UnmarshalRequestAsJSON[azkeyvault.SecurityDomainObject](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := h.srv.BeginUpload(req.Context(), req.URL.Host, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		h.beginUpload = &respr
	}

	resp, err := server.PollerResponderNext(h.beginUpload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(h.beginUpload) {
		h.beginUpload = nil
	}

	return resp, nil
}

func (h *HSMSecurityDomainServerTransport) dispatchUploadPending(req *http.Request) (*http.Response, error) {
	if h.srv.UploadPending == nil {
		return nil, &nonRetriableError{errors.New("method UploadPending not implemented")}
	}
	respr, errRespr := h.srv.UploadPending(req.Context(), req.URL.Host, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecurityDomainOperationStatus, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
