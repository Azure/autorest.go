//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package fake

import (
	"azkeyvault"
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
)

// Server is a fake server for instances of the azkeyvault.Client type.
type Server struct {
	// BackupCertificate is the fake for method Client.BackupCertificate
	// HTTP status codes to indicate success: http.StatusOK
	BackupCertificate func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientBackupCertificateOptions) (resp azfake.Responder[azkeyvault.ClientBackupCertificateResponse], errResp azfake.ErrorResponder)

	// BackupKey is the fake for method Client.BackupKey
	// HTTP status codes to indicate success: http.StatusOK
	BackupKey func(ctx context.Context, host string, keyName string, options *azkeyvault.ClientBackupKeyOptions) (resp azfake.Responder[azkeyvault.ClientBackupKeyResponse], errResp azfake.ErrorResponder)

	// BackupSecret is the fake for method Client.BackupSecret
	// HTTP status codes to indicate success: http.StatusOK
	BackupSecret func(ctx context.Context, host string, secretName string, options *azkeyvault.ClientBackupSecretOptions) (resp azfake.Responder[azkeyvault.ClientBackupSecretResponse], errResp azfake.ErrorResponder)

	// BackupStorageAccount is the fake for method Client.BackupStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	BackupStorageAccount func(ctx context.Context, host string, storageAccountName string, options *azkeyvault.ClientBackupStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientBackupStorageAccountResponse], errResp azfake.ErrorResponder)

	// CreateCertificate is the fake for method Client.CreateCertificate
	// HTTP status codes to indicate success: http.StatusAccepted
	CreateCertificate func(ctx context.Context, host string, certificateName string, parameters azkeyvault.CertificateCreateParameters, options *azkeyvault.ClientCreateCertificateOptions) (resp azfake.Responder[azkeyvault.ClientCreateCertificateResponse], errResp azfake.ErrorResponder)

	// CreateKey is the fake for method Client.CreateKey
	// HTTP status codes to indicate success: http.StatusOK
	CreateKey func(ctx context.Context, host string, keyName string, parameters azkeyvault.KeyCreateParameters, options *azkeyvault.ClientCreateKeyOptions) (resp azfake.Responder[azkeyvault.ClientCreateKeyResponse], errResp azfake.ErrorResponder)

	// Decrypt is the fake for method Client.Decrypt
	// HTTP status codes to indicate success: http.StatusOK
	Decrypt func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeyOperationsParameters, options *azkeyvault.ClientDecryptOptions) (resp azfake.Responder[azkeyvault.ClientDecryptResponse], errResp azfake.ErrorResponder)

	// DeleteCertificate is the fake for method Client.DeleteCertificate
	// HTTP status codes to indicate success: http.StatusOK
	DeleteCertificate func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientDeleteCertificateOptions) (resp azfake.Responder[azkeyvault.ClientDeleteCertificateResponse], errResp azfake.ErrorResponder)

	// DeleteCertificateContacts is the fake for method Client.DeleteCertificateContacts
	// HTTP status codes to indicate success: http.StatusOK
	DeleteCertificateContacts func(ctx context.Context, host string, options *azkeyvault.ClientDeleteCertificateContactsOptions) (resp azfake.Responder[azkeyvault.ClientDeleteCertificateContactsResponse], errResp azfake.ErrorResponder)

	// DeleteCertificateIssuer is the fake for method Client.DeleteCertificateIssuer
	// HTTP status codes to indicate success: http.StatusOK
	DeleteCertificateIssuer func(ctx context.Context, host string, issuerName string, options *azkeyvault.ClientDeleteCertificateIssuerOptions) (resp azfake.Responder[azkeyvault.ClientDeleteCertificateIssuerResponse], errResp azfake.ErrorResponder)

	// DeleteCertificateOperation is the fake for method Client.DeleteCertificateOperation
	// HTTP status codes to indicate success: http.StatusOK
	DeleteCertificateOperation func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientDeleteCertificateOperationOptions) (resp azfake.Responder[azkeyvault.ClientDeleteCertificateOperationResponse], errResp azfake.ErrorResponder)

	// DeleteKey is the fake for method Client.DeleteKey
	// HTTP status codes to indicate success: http.StatusOK
	DeleteKey func(ctx context.Context, host string, keyName string, options *azkeyvault.ClientDeleteKeyOptions) (resp azfake.Responder[azkeyvault.ClientDeleteKeyResponse], errResp azfake.ErrorResponder)

	// DeleteSasDefinition is the fake for method Client.DeleteSasDefinition
	// HTTP status codes to indicate success: http.StatusOK
	DeleteSasDefinition func(ctx context.Context, host string, storageAccountName string, sasDefinitionName string, options *azkeyvault.ClientDeleteSasDefinitionOptions) (resp azfake.Responder[azkeyvault.ClientDeleteSasDefinitionResponse], errResp azfake.ErrorResponder)

	// DeleteSecret is the fake for method Client.DeleteSecret
	// HTTP status codes to indicate success: http.StatusOK
	DeleteSecret func(ctx context.Context, host string, secretName string, options *azkeyvault.ClientDeleteSecretOptions) (resp azfake.Responder[azkeyvault.ClientDeleteSecretResponse], errResp azfake.ErrorResponder)

	// DeleteStorageAccount is the fake for method Client.DeleteStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	DeleteStorageAccount func(ctx context.Context, host string, storageAccountName string, options *azkeyvault.ClientDeleteStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientDeleteStorageAccountResponse], errResp azfake.ErrorResponder)

	// Encrypt is the fake for method Client.Encrypt
	// HTTP status codes to indicate success: http.StatusOK
	Encrypt func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeyOperationsParameters, options *azkeyvault.ClientEncryptOptions) (resp azfake.Responder[azkeyvault.ClientEncryptResponse], errResp azfake.ErrorResponder)

	// BeginFullBackup is the fake for method Client.BeginFullBackup
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginFullBackup func(ctx context.Context, host string, options *azkeyvault.ClientBeginFullBackupOptions) (resp azfake.PollerResponder[azkeyvault.ClientFullBackupResponse], errResp azfake.ErrorResponder)

	// FullBackupStatus is the fake for method Client.FullBackupStatus
	// HTTP status codes to indicate success: http.StatusOK
	FullBackupStatus func(ctx context.Context, host string, jobID string, options *azkeyvault.ClientFullBackupStatusOptions) (resp azfake.Responder[azkeyvault.ClientFullBackupStatusResponse], errResp azfake.ErrorResponder)

	// BeginFullRestoreOperation is the fake for method Client.BeginFullRestoreOperation
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginFullRestoreOperation func(ctx context.Context, host string, restoreBlobDetails azkeyvault.RestoreOperationParameters, options *azkeyvault.ClientBeginFullRestoreOperationOptions) (resp azfake.PollerResponder[azkeyvault.ClientFullRestoreOperationResponse], errResp azfake.ErrorResponder)

	// GetCertificate is the fake for method Client.GetCertificate
	// HTTP status codes to indicate success: http.StatusOK
	GetCertificate func(ctx context.Context, host string, certificateName string, certificateVersion string, options *azkeyvault.ClientGetCertificateOptions) (resp azfake.Responder[azkeyvault.ClientGetCertificateResponse], errResp azfake.ErrorResponder)

	// GetCertificateContacts is the fake for method Client.GetCertificateContacts
	// HTTP status codes to indicate success: http.StatusOK
	GetCertificateContacts func(ctx context.Context, host string, options *azkeyvault.ClientGetCertificateContactsOptions) (resp azfake.Responder[azkeyvault.ClientGetCertificateContactsResponse], errResp azfake.ErrorResponder)

	// GetCertificateIssuer is the fake for method Client.GetCertificateIssuer
	// HTTP status codes to indicate success: http.StatusOK
	GetCertificateIssuer func(ctx context.Context, host string, issuerName string, options *azkeyvault.ClientGetCertificateIssuerOptions) (resp azfake.Responder[azkeyvault.ClientGetCertificateIssuerResponse], errResp azfake.ErrorResponder)

	// NewGetCertificateIssuersPager is the fake for method Client.NewGetCertificateIssuersPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetCertificateIssuersPager func(host string, options *azkeyvault.ClientGetCertificateIssuersOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetCertificateIssuersResponse])

	// GetCertificateOperation is the fake for method Client.GetCertificateOperation
	// HTTP status codes to indicate success: http.StatusOK
	GetCertificateOperation func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientGetCertificateOperationOptions) (resp azfake.Responder[azkeyvault.ClientGetCertificateOperationResponse], errResp azfake.ErrorResponder)

	// GetCertificatePolicy is the fake for method Client.GetCertificatePolicy
	// HTTP status codes to indicate success: http.StatusOK
	GetCertificatePolicy func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientGetCertificatePolicyOptions) (resp azfake.Responder[azkeyvault.ClientGetCertificatePolicyResponse], errResp azfake.ErrorResponder)

	// NewGetCertificateVersionsPager is the fake for method Client.NewGetCertificateVersionsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetCertificateVersionsPager func(host string, certificateName string, options *azkeyvault.ClientGetCertificateVersionsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetCertificateVersionsResponse])

	// NewGetCertificatesPager is the fake for method Client.NewGetCertificatesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetCertificatesPager func(host string, options *azkeyvault.ClientGetCertificatesOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetCertificatesResponse])

	// GetDeletedCertificate is the fake for method Client.GetDeletedCertificate
	// HTTP status codes to indicate success: http.StatusOK
	GetDeletedCertificate func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientGetDeletedCertificateOptions) (resp azfake.Responder[azkeyvault.ClientGetDeletedCertificateResponse], errResp azfake.ErrorResponder)

	// NewGetDeletedCertificatesPager is the fake for method Client.NewGetDeletedCertificatesPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetDeletedCertificatesPager func(host string, options *azkeyvault.ClientGetDeletedCertificatesOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetDeletedCertificatesResponse])

	// GetDeletedKey is the fake for method Client.GetDeletedKey
	// HTTP status codes to indicate success: http.StatusOK
	GetDeletedKey func(ctx context.Context, host string, keyName string, options *azkeyvault.ClientGetDeletedKeyOptions) (resp azfake.Responder[azkeyvault.ClientGetDeletedKeyResponse], errResp azfake.ErrorResponder)

	// NewGetDeletedKeysPager is the fake for method Client.NewGetDeletedKeysPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetDeletedKeysPager func(host string, options *azkeyvault.ClientGetDeletedKeysOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetDeletedKeysResponse])

	// GetDeletedSasDefinition is the fake for method Client.GetDeletedSasDefinition
	// HTTP status codes to indicate success: http.StatusOK
	GetDeletedSasDefinition func(ctx context.Context, host string, storageAccountName string, sasDefinitionName string, options *azkeyvault.ClientGetDeletedSasDefinitionOptions) (resp azfake.Responder[azkeyvault.ClientGetDeletedSasDefinitionResponse], errResp azfake.ErrorResponder)

	// NewGetDeletedSasDefinitionsPager is the fake for method Client.NewGetDeletedSasDefinitionsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetDeletedSasDefinitionsPager func(host string, storageAccountName string, options *azkeyvault.ClientGetDeletedSasDefinitionsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetDeletedSasDefinitionsResponse])

	// GetDeletedSecret is the fake for method Client.GetDeletedSecret
	// HTTP status codes to indicate success: http.StatusOK
	GetDeletedSecret func(ctx context.Context, host string, secretName string, options *azkeyvault.ClientGetDeletedSecretOptions) (resp azfake.Responder[azkeyvault.ClientGetDeletedSecretResponse], errResp azfake.ErrorResponder)

	// NewGetDeletedSecretsPager is the fake for method Client.NewGetDeletedSecretsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetDeletedSecretsPager func(host string, options *azkeyvault.ClientGetDeletedSecretsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetDeletedSecretsResponse])

	// GetDeletedStorageAccount is the fake for method Client.GetDeletedStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	GetDeletedStorageAccount func(ctx context.Context, host string, storageAccountName string, options *azkeyvault.ClientGetDeletedStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientGetDeletedStorageAccountResponse], errResp azfake.ErrorResponder)

	// NewGetDeletedStorageAccountsPager is the fake for method Client.NewGetDeletedStorageAccountsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetDeletedStorageAccountsPager func(host string, options *azkeyvault.ClientGetDeletedStorageAccountsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetDeletedStorageAccountsResponse])

	// GetKey is the fake for method Client.GetKey
	// HTTP status codes to indicate success: http.StatusOK
	GetKey func(ctx context.Context, host string, keyName string, keyVersion string, options *azkeyvault.ClientGetKeyOptions) (resp azfake.Responder[azkeyvault.ClientGetKeyResponse], errResp azfake.ErrorResponder)

	// NewGetKeyVersionsPager is the fake for method Client.NewGetKeyVersionsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetKeyVersionsPager func(host string, keyName string, options *azkeyvault.ClientGetKeyVersionsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetKeyVersionsResponse])

	// NewGetKeysPager is the fake for method Client.NewGetKeysPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetKeysPager func(host string, options *azkeyvault.ClientGetKeysOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetKeysResponse])

	// GetSasDefinition is the fake for method Client.GetSasDefinition
	// HTTP status codes to indicate success: http.StatusOK
	GetSasDefinition func(ctx context.Context, host string, storageAccountName string, sasDefinitionName string, options *azkeyvault.ClientGetSasDefinitionOptions) (resp azfake.Responder[azkeyvault.ClientGetSasDefinitionResponse], errResp azfake.ErrorResponder)

	// NewGetSasDefinitionsPager is the fake for method Client.NewGetSasDefinitionsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetSasDefinitionsPager func(host string, storageAccountName string, options *azkeyvault.ClientGetSasDefinitionsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetSasDefinitionsResponse])

	// GetSecret is the fake for method Client.GetSecret
	// HTTP status codes to indicate success: http.StatusOK
	GetSecret func(ctx context.Context, host string, secretName string, secretVersion string, options *azkeyvault.ClientGetSecretOptions) (resp azfake.Responder[azkeyvault.ClientGetSecretResponse], errResp azfake.ErrorResponder)

	// NewGetSecretVersionsPager is the fake for method Client.NewGetSecretVersionsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetSecretVersionsPager func(host string, secretName string, options *azkeyvault.ClientGetSecretVersionsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetSecretVersionsResponse])

	// NewGetSecretsPager is the fake for method Client.NewGetSecretsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetSecretsPager func(host string, options *azkeyvault.ClientGetSecretsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetSecretsResponse])

	// GetStorageAccount is the fake for method Client.GetStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	GetStorageAccount func(ctx context.Context, host string, storageAccountName string, options *azkeyvault.ClientGetStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientGetStorageAccountResponse], errResp azfake.ErrorResponder)

	// NewGetStorageAccountsPager is the fake for method Client.NewGetStorageAccountsPager
	// HTTP status codes to indicate success: http.StatusOK
	NewGetStorageAccountsPager func(host string, options *azkeyvault.ClientGetStorageAccountsOptions) (resp azfake.PagerResponder[azkeyvault.ClientGetStorageAccountsResponse])

	// ImportCertificate is the fake for method Client.ImportCertificate
	// HTTP status codes to indicate success: http.StatusOK
	ImportCertificate func(ctx context.Context, host string, certificateName string, parameters azkeyvault.CertificateImportParameters, options *azkeyvault.ClientImportCertificateOptions) (resp azfake.Responder[azkeyvault.ClientImportCertificateResponse], errResp azfake.ErrorResponder)

	// ImportKey is the fake for method Client.ImportKey
	// HTTP status codes to indicate success: http.StatusOK
	ImportKey func(ctx context.Context, host string, keyName string, parameters azkeyvault.KeyImportParameters, options *azkeyvault.ClientImportKeyOptions) (resp azfake.Responder[azkeyvault.ClientImportKeyResponse], errResp azfake.ErrorResponder)

	// MergeCertificate is the fake for method Client.MergeCertificate
	// HTTP status codes to indicate success: http.StatusCreated
	MergeCertificate func(ctx context.Context, host string, certificateName string, parameters azkeyvault.CertificateMergeParameters, options *azkeyvault.ClientMergeCertificateOptions) (resp azfake.Responder[azkeyvault.ClientMergeCertificateResponse], errResp azfake.ErrorResponder)

	// PurgeDeletedCertificate is the fake for method Client.PurgeDeletedCertificate
	// HTTP status codes to indicate success: http.StatusNoContent
	PurgeDeletedCertificate func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientPurgeDeletedCertificateOptions) (resp azfake.Responder[azkeyvault.ClientPurgeDeletedCertificateResponse], errResp azfake.ErrorResponder)

	// PurgeDeletedKey is the fake for method Client.PurgeDeletedKey
	// HTTP status codes to indicate success: http.StatusNoContent
	PurgeDeletedKey func(ctx context.Context, host string, keyName string, options *azkeyvault.ClientPurgeDeletedKeyOptions) (resp azfake.Responder[azkeyvault.ClientPurgeDeletedKeyResponse], errResp azfake.ErrorResponder)

	// PurgeDeletedSecret is the fake for method Client.PurgeDeletedSecret
	// HTTP status codes to indicate success: http.StatusNoContent
	PurgeDeletedSecret func(ctx context.Context, host string, secretName string, options *azkeyvault.ClientPurgeDeletedSecretOptions) (resp azfake.Responder[azkeyvault.ClientPurgeDeletedSecretResponse], errResp azfake.ErrorResponder)

	// PurgeDeletedStorageAccount is the fake for method Client.PurgeDeletedStorageAccount
	// HTTP status codes to indicate success: http.StatusNoContent
	PurgeDeletedStorageAccount func(ctx context.Context, host string, storageAccountName string, options *azkeyvault.ClientPurgeDeletedStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientPurgeDeletedStorageAccountResponse], errResp azfake.ErrorResponder)

	// RecoverDeletedCertificate is the fake for method Client.RecoverDeletedCertificate
	// HTTP status codes to indicate success: http.StatusOK
	RecoverDeletedCertificate func(ctx context.Context, host string, certificateName string, options *azkeyvault.ClientRecoverDeletedCertificateOptions) (resp azfake.Responder[azkeyvault.ClientRecoverDeletedCertificateResponse], errResp azfake.ErrorResponder)

	// RecoverDeletedKey is the fake for method Client.RecoverDeletedKey
	// HTTP status codes to indicate success: http.StatusOK
	RecoverDeletedKey func(ctx context.Context, host string, keyName string, options *azkeyvault.ClientRecoverDeletedKeyOptions) (resp azfake.Responder[azkeyvault.ClientRecoverDeletedKeyResponse], errResp azfake.ErrorResponder)

	// RecoverDeletedSasDefinition is the fake for method Client.RecoverDeletedSasDefinition
	// HTTP status codes to indicate success: http.StatusOK
	RecoverDeletedSasDefinition func(ctx context.Context, host string, storageAccountName string, sasDefinitionName string, options *azkeyvault.ClientRecoverDeletedSasDefinitionOptions) (resp azfake.Responder[azkeyvault.ClientRecoverDeletedSasDefinitionResponse], errResp azfake.ErrorResponder)

	// RecoverDeletedSecret is the fake for method Client.RecoverDeletedSecret
	// HTTP status codes to indicate success: http.StatusOK
	RecoverDeletedSecret func(ctx context.Context, host string, secretName string, options *azkeyvault.ClientRecoverDeletedSecretOptions) (resp azfake.Responder[azkeyvault.ClientRecoverDeletedSecretResponse], errResp azfake.ErrorResponder)

	// RecoverDeletedStorageAccount is the fake for method Client.RecoverDeletedStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	RecoverDeletedStorageAccount func(ctx context.Context, host string, storageAccountName string, options *azkeyvault.ClientRecoverDeletedStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientRecoverDeletedStorageAccountResponse], errResp azfake.ErrorResponder)

	// RegenerateStorageAccountKey is the fake for method Client.RegenerateStorageAccountKey
	// HTTP status codes to indicate success: http.StatusOK
	RegenerateStorageAccountKey func(ctx context.Context, host string, storageAccountName string, parameters azkeyvault.StorageAccountRegenerteKeyParameters, options *azkeyvault.ClientRegenerateStorageAccountKeyOptions) (resp azfake.Responder[azkeyvault.ClientRegenerateStorageAccountKeyResponse], errResp azfake.ErrorResponder)

	// RestoreCertificate is the fake for method Client.RestoreCertificate
	// HTTP status codes to indicate success: http.StatusOK
	RestoreCertificate func(ctx context.Context, host string, parameters azkeyvault.CertificateRestoreParameters, options *azkeyvault.ClientRestoreCertificateOptions) (resp azfake.Responder[azkeyvault.ClientRestoreCertificateResponse], errResp azfake.ErrorResponder)

	// RestoreKey is the fake for method Client.RestoreKey
	// HTTP status codes to indicate success: http.StatusOK
	RestoreKey func(ctx context.Context, host string, parameters azkeyvault.KeyRestoreParameters, options *azkeyvault.ClientRestoreKeyOptions) (resp azfake.Responder[azkeyvault.ClientRestoreKeyResponse], errResp azfake.ErrorResponder)

	// RestoreSecret is the fake for method Client.RestoreSecret
	// HTTP status codes to indicate success: http.StatusOK
	RestoreSecret func(ctx context.Context, host string, parameters azkeyvault.SecretRestoreParameters, options *azkeyvault.ClientRestoreSecretOptions) (resp azfake.Responder[azkeyvault.ClientRestoreSecretResponse], errResp azfake.ErrorResponder)

	// RestoreStatus is the fake for method Client.RestoreStatus
	// HTTP status codes to indicate success: http.StatusOK
	RestoreStatus func(ctx context.Context, host string, jobID string, options *azkeyvault.ClientRestoreStatusOptions) (resp azfake.Responder[azkeyvault.ClientRestoreStatusResponse], errResp azfake.ErrorResponder)

	// RestoreStorageAccount is the fake for method Client.RestoreStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	RestoreStorageAccount func(ctx context.Context, host string, parameters azkeyvault.StorageRestoreParameters, options *azkeyvault.ClientRestoreStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientRestoreStorageAccountResponse], errResp azfake.ErrorResponder)

	// BeginSelectiveKeyRestoreOperation is the fake for method Client.BeginSelectiveKeyRestoreOperation
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginSelectiveKeyRestoreOperation func(ctx context.Context, host string, keyName string, restoreBlobDetails azkeyvault.SelectiveKeyRestoreOperationParameters, options *azkeyvault.ClientBeginSelectiveKeyRestoreOperationOptions) (resp azfake.PollerResponder[azkeyvault.ClientSelectiveKeyRestoreOperationResponse], errResp azfake.ErrorResponder)

	// SetCertificateContacts is the fake for method Client.SetCertificateContacts
	// HTTP status codes to indicate success: http.StatusOK
	SetCertificateContacts func(ctx context.Context, host string, contacts azkeyvault.Contacts, options *azkeyvault.ClientSetCertificateContactsOptions) (resp azfake.Responder[azkeyvault.ClientSetCertificateContactsResponse], errResp azfake.ErrorResponder)

	// SetCertificateIssuer is the fake for method Client.SetCertificateIssuer
	// HTTP status codes to indicate success: http.StatusOK
	SetCertificateIssuer func(ctx context.Context, host string, issuerName string, parameter azkeyvault.CertificateIssuerSetParameters, options *azkeyvault.ClientSetCertificateIssuerOptions) (resp azfake.Responder[azkeyvault.ClientSetCertificateIssuerResponse], errResp azfake.ErrorResponder)

	// SetSasDefinition is the fake for method Client.SetSasDefinition
	// HTTP status codes to indicate success: http.StatusOK
	SetSasDefinition func(ctx context.Context, host string, storageAccountName string, sasDefinitionName string, parameters azkeyvault.SasDefinitionCreateParameters, options *azkeyvault.ClientSetSasDefinitionOptions) (resp azfake.Responder[azkeyvault.ClientSetSasDefinitionResponse], errResp azfake.ErrorResponder)

	// SetSecret is the fake for method Client.SetSecret
	// HTTP status codes to indicate success: http.StatusOK
	SetSecret func(ctx context.Context, host string, secretName string, parameters azkeyvault.SecretSetParameters, options *azkeyvault.ClientSetSecretOptions) (resp azfake.Responder[azkeyvault.ClientSetSecretResponse], errResp azfake.ErrorResponder)

	// SetStorageAccount is the fake for method Client.SetStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	SetStorageAccount func(ctx context.Context, host string, storageAccountName string, parameters azkeyvault.StorageAccountCreateParameters, options *azkeyvault.ClientSetStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientSetStorageAccountResponse], errResp azfake.ErrorResponder)

	// Sign is the fake for method Client.Sign
	// HTTP status codes to indicate success: http.StatusOK
	Sign func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeySignParameters, options *azkeyvault.ClientSignOptions) (resp azfake.Responder[azkeyvault.ClientSignResponse], errResp azfake.ErrorResponder)

	// UnwrapKey is the fake for method Client.UnwrapKey
	// HTTP status codes to indicate success: http.StatusOK
	UnwrapKey func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeyOperationsParameters, options *azkeyvault.ClientUnwrapKeyOptions) (resp azfake.Responder[azkeyvault.ClientUnwrapKeyResponse], errResp azfake.ErrorResponder)

	// UpdateCertificate is the fake for method Client.UpdateCertificate
	// HTTP status codes to indicate success: http.StatusOK
	UpdateCertificate func(ctx context.Context, host string, certificateName string, certificateVersion string, parameters azkeyvault.CertificateUpdateParameters, options *azkeyvault.ClientUpdateCertificateOptions) (resp azfake.Responder[azkeyvault.ClientUpdateCertificateResponse], errResp azfake.ErrorResponder)

	// UpdateCertificateIssuer is the fake for method Client.UpdateCertificateIssuer
	// HTTP status codes to indicate success: http.StatusOK
	UpdateCertificateIssuer func(ctx context.Context, host string, issuerName string, parameter azkeyvault.CertificateIssuerUpdateParameters, options *azkeyvault.ClientUpdateCertificateIssuerOptions) (resp azfake.Responder[azkeyvault.ClientUpdateCertificateIssuerResponse], errResp azfake.ErrorResponder)

	// UpdateCertificateOperation is the fake for method Client.UpdateCertificateOperation
	// HTTP status codes to indicate success: http.StatusOK
	UpdateCertificateOperation func(ctx context.Context, host string, certificateName string, certificateOperation azkeyvault.CertificateOperationUpdateParameter, options *azkeyvault.ClientUpdateCertificateOperationOptions) (resp azfake.Responder[azkeyvault.ClientUpdateCertificateOperationResponse], errResp azfake.ErrorResponder)

	// UpdateCertificatePolicy is the fake for method Client.UpdateCertificatePolicy
	// HTTP status codes to indicate success: http.StatusOK
	UpdateCertificatePolicy func(ctx context.Context, host string, certificateName string, certificatePolicy azkeyvault.CertificatePolicy, options *azkeyvault.ClientUpdateCertificatePolicyOptions) (resp azfake.Responder[azkeyvault.ClientUpdateCertificatePolicyResponse], errResp azfake.ErrorResponder)

	// UpdateKey is the fake for method Client.UpdateKey
	// HTTP status codes to indicate success: http.StatusOK
	UpdateKey func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeyUpdateParameters, options *azkeyvault.ClientUpdateKeyOptions) (resp azfake.Responder[azkeyvault.ClientUpdateKeyResponse], errResp azfake.ErrorResponder)

	// UpdateSasDefinition is the fake for method Client.UpdateSasDefinition
	// HTTP status codes to indicate success: http.StatusOK
	UpdateSasDefinition func(ctx context.Context, host string, storageAccountName string, sasDefinitionName string, parameters azkeyvault.SasDefinitionUpdateParameters, options *azkeyvault.ClientUpdateSasDefinitionOptions) (resp azfake.Responder[azkeyvault.ClientUpdateSasDefinitionResponse], errResp azfake.ErrorResponder)

	// UpdateSecret is the fake for method Client.UpdateSecret
	// HTTP status codes to indicate success: http.StatusOK
	UpdateSecret func(ctx context.Context, host string, secretName string, secretVersion string, parameters azkeyvault.SecretUpdateParameters, options *azkeyvault.ClientUpdateSecretOptions) (resp azfake.Responder[azkeyvault.ClientUpdateSecretResponse], errResp azfake.ErrorResponder)

	// UpdateStorageAccount is the fake for method Client.UpdateStorageAccount
	// HTTP status codes to indicate success: http.StatusOK
	UpdateStorageAccount func(ctx context.Context, host string, storageAccountName string, parameters azkeyvault.StorageAccountUpdateParameters, options *azkeyvault.ClientUpdateStorageAccountOptions) (resp azfake.Responder[azkeyvault.ClientUpdateStorageAccountResponse], errResp azfake.ErrorResponder)

	// Verify is the fake for method Client.Verify
	// HTTP status codes to indicate success: http.StatusOK
	Verify func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeyVerifyParameters, options *azkeyvault.ClientVerifyOptions) (resp azfake.Responder[azkeyvault.ClientVerifyResponse], errResp azfake.ErrorResponder)

	// WrapKey is the fake for method Client.WrapKey
	// HTTP status codes to indicate success: http.StatusOK
	WrapKey func(ctx context.Context, host string, keyName string, keyVersion string, parameters azkeyvault.KeyOperationsParameters, options *azkeyvault.ClientWrapKeyOptions) (resp azfake.Responder[azkeyvault.ClientWrapKeyResponse], errResp azfake.ErrorResponder)
}

// NewServerTransport creates a new instance of ServerTransport with the provided implementation.
// The returned ServerTransport instance is connected to an instance of azkeyvault.Client by way of the
// undefined.Transporter field.
func NewServerTransport(srv *Server) *ServerTransport {
	return &ServerTransport{srv: srv}
}

// ServerTransport connects instances of azkeyvault.Client to instances of Server.
// Don't use this type directly, use NewServerTransport instead.
type ServerTransport struct {
	srv                               *Server
	beginFullBackup                   *azfake.PollerResponder[azkeyvault.ClientFullBackupResponse]
	beginFullRestoreOperation         *azfake.PollerResponder[azkeyvault.ClientFullRestoreOperationResponse]
	newGetCertificateIssuersPager     *azfake.PagerResponder[azkeyvault.ClientGetCertificateIssuersResponse]
	newGetCertificateVersionsPager    *azfake.PagerResponder[azkeyvault.ClientGetCertificateVersionsResponse]
	newGetCertificatesPager           *azfake.PagerResponder[azkeyvault.ClientGetCertificatesResponse]
	newGetDeletedCertificatesPager    *azfake.PagerResponder[azkeyvault.ClientGetDeletedCertificatesResponse]
	newGetDeletedKeysPager            *azfake.PagerResponder[azkeyvault.ClientGetDeletedKeysResponse]
	newGetDeletedSasDefinitionsPager  *azfake.PagerResponder[azkeyvault.ClientGetDeletedSasDefinitionsResponse]
	newGetDeletedSecretsPager         *azfake.PagerResponder[azkeyvault.ClientGetDeletedSecretsResponse]
	newGetDeletedStorageAccountsPager *azfake.PagerResponder[azkeyvault.ClientGetDeletedStorageAccountsResponse]
	newGetKeyVersionsPager            *azfake.PagerResponder[azkeyvault.ClientGetKeyVersionsResponse]
	newGetKeysPager                   *azfake.PagerResponder[azkeyvault.ClientGetKeysResponse]
	newGetSasDefinitionsPager         *azfake.PagerResponder[azkeyvault.ClientGetSasDefinitionsResponse]
	newGetSecretVersionsPager         *azfake.PagerResponder[azkeyvault.ClientGetSecretVersionsResponse]
	newGetSecretsPager                *azfake.PagerResponder[azkeyvault.ClientGetSecretsResponse]
	newGetStorageAccountsPager        *azfake.PagerResponder[azkeyvault.ClientGetStorageAccountsResponse]
	beginSelectiveKeyRestoreOperation *azfake.PollerResponder[azkeyvault.ClientSelectiveKeyRestoreOperationResponse]
}

// Do implements the policy.Transporter interface for ServerTransport.
func (s *ServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "Client.BackupCertificate":
		resp, err = s.dispatchBackupCertificate(req)
	case "Client.BackupKey":
		resp, err = s.dispatchBackupKey(req)
	case "Client.BackupSecret":
		resp, err = s.dispatchBackupSecret(req)
	case "Client.BackupStorageAccount":
		resp, err = s.dispatchBackupStorageAccount(req)
	case "Client.CreateCertificate":
		resp, err = s.dispatchCreateCertificate(req)
	case "Client.CreateKey":
		resp, err = s.dispatchCreateKey(req)
	case "Client.Decrypt":
		resp, err = s.dispatchDecrypt(req)
	case "Client.DeleteCertificate":
		resp, err = s.dispatchDeleteCertificate(req)
	case "Client.DeleteCertificateContacts":
		resp, err = s.dispatchDeleteCertificateContacts(req)
	case "Client.DeleteCertificateIssuer":
		resp, err = s.dispatchDeleteCertificateIssuer(req)
	case "Client.DeleteCertificateOperation":
		resp, err = s.dispatchDeleteCertificateOperation(req)
	case "Client.DeleteKey":
		resp, err = s.dispatchDeleteKey(req)
	case "Client.DeleteSasDefinition":
		resp, err = s.dispatchDeleteSasDefinition(req)
	case "Client.DeleteSecret":
		resp, err = s.dispatchDeleteSecret(req)
	case "Client.DeleteStorageAccount":
		resp, err = s.dispatchDeleteStorageAccount(req)
	case "Client.Encrypt":
		resp, err = s.dispatchEncrypt(req)
	case "Client.BeginFullBackup":
		resp, err = s.dispatchBeginFullBackup(req)
	case "Client.FullBackupStatus":
		resp, err = s.dispatchFullBackupStatus(req)
	case "Client.BeginFullRestoreOperation":
		resp, err = s.dispatchBeginFullRestoreOperation(req)
	case "Client.GetCertificate":
		resp, err = s.dispatchGetCertificate(req)
	case "Client.GetCertificateContacts":
		resp, err = s.dispatchGetCertificateContacts(req)
	case "Client.GetCertificateIssuer":
		resp, err = s.dispatchGetCertificateIssuer(req)
	case "Client.NewGetCertificateIssuersPager":
		resp, err = s.dispatchNewGetCertificateIssuersPager(req)
	case "Client.GetCertificateOperation":
		resp, err = s.dispatchGetCertificateOperation(req)
	case "Client.GetCertificatePolicy":
		resp, err = s.dispatchGetCertificatePolicy(req)
	case "Client.NewGetCertificateVersionsPager":
		resp, err = s.dispatchNewGetCertificateVersionsPager(req)
	case "Client.NewGetCertificatesPager":
		resp, err = s.dispatchNewGetCertificatesPager(req)
	case "Client.GetDeletedCertificate":
		resp, err = s.dispatchGetDeletedCertificate(req)
	case "Client.NewGetDeletedCertificatesPager":
		resp, err = s.dispatchNewGetDeletedCertificatesPager(req)
	case "Client.GetDeletedKey":
		resp, err = s.dispatchGetDeletedKey(req)
	case "Client.NewGetDeletedKeysPager":
		resp, err = s.dispatchNewGetDeletedKeysPager(req)
	case "Client.GetDeletedSasDefinition":
		resp, err = s.dispatchGetDeletedSasDefinition(req)
	case "Client.NewGetDeletedSasDefinitionsPager":
		resp, err = s.dispatchNewGetDeletedSasDefinitionsPager(req)
	case "Client.GetDeletedSecret":
		resp, err = s.dispatchGetDeletedSecret(req)
	case "Client.NewGetDeletedSecretsPager":
		resp, err = s.dispatchNewGetDeletedSecretsPager(req)
	case "Client.GetDeletedStorageAccount":
		resp, err = s.dispatchGetDeletedStorageAccount(req)
	case "Client.NewGetDeletedStorageAccountsPager":
		resp, err = s.dispatchNewGetDeletedStorageAccountsPager(req)
	case "Client.GetKey":
		resp, err = s.dispatchGetKey(req)
	case "Client.NewGetKeyVersionsPager":
		resp, err = s.dispatchNewGetKeyVersionsPager(req)
	case "Client.NewGetKeysPager":
		resp, err = s.dispatchNewGetKeysPager(req)
	case "Client.GetSasDefinition":
		resp, err = s.dispatchGetSasDefinition(req)
	case "Client.NewGetSasDefinitionsPager":
		resp, err = s.dispatchNewGetSasDefinitionsPager(req)
	case "Client.GetSecret":
		resp, err = s.dispatchGetSecret(req)
	case "Client.NewGetSecretVersionsPager":
		resp, err = s.dispatchNewGetSecretVersionsPager(req)
	case "Client.NewGetSecretsPager":
		resp, err = s.dispatchNewGetSecretsPager(req)
	case "Client.GetStorageAccount":
		resp, err = s.dispatchGetStorageAccount(req)
	case "Client.NewGetStorageAccountsPager":
		resp, err = s.dispatchNewGetStorageAccountsPager(req)
	case "Client.ImportCertificate":
		resp, err = s.dispatchImportCertificate(req)
	case "Client.ImportKey":
		resp, err = s.dispatchImportKey(req)
	case "Client.MergeCertificate":
		resp, err = s.dispatchMergeCertificate(req)
	case "Client.PurgeDeletedCertificate":
		resp, err = s.dispatchPurgeDeletedCertificate(req)
	case "Client.PurgeDeletedKey":
		resp, err = s.dispatchPurgeDeletedKey(req)
	case "Client.PurgeDeletedSecret":
		resp, err = s.dispatchPurgeDeletedSecret(req)
	case "Client.PurgeDeletedStorageAccount":
		resp, err = s.dispatchPurgeDeletedStorageAccount(req)
	case "Client.RecoverDeletedCertificate":
		resp, err = s.dispatchRecoverDeletedCertificate(req)
	case "Client.RecoverDeletedKey":
		resp, err = s.dispatchRecoverDeletedKey(req)
	case "Client.RecoverDeletedSasDefinition":
		resp, err = s.dispatchRecoverDeletedSasDefinition(req)
	case "Client.RecoverDeletedSecret":
		resp, err = s.dispatchRecoverDeletedSecret(req)
	case "Client.RecoverDeletedStorageAccount":
		resp, err = s.dispatchRecoverDeletedStorageAccount(req)
	case "Client.RegenerateStorageAccountKey":
		resp, err = s.dispatchRegenerateStorageAccountKey(req)
	case "Client.RestoreCertificate":
		resp, err = s.dispatchRestoreCertificate(req)
	case "Client.RestoreKey":
		resp, err = s.dispatchRestoreKey(req)
	case "Client.RestoreSecret":
		resp, err = s.dispatchRestoreSecret(req)
	case "Client.RestoreStatus":
		resp, err = s.dispatchRestoreStatus(req)
	case "Client.RestoreStorageAccount":
		resp, err = s.dispatchRestoreStorageAccount(req)
	case "Client.BeginSelectiveKeyRestoreOperation":
		resp, err = s.dispatchBeginSelectiveKeyRestoreOperation(req)
	case "Client.SetCertificateContacts":
		resp, err = s.dispatchSetCertificateContacts(req)
	case "Client.SetCertificateIssuer":
		resp, err = s.dispatchSetCertificateIssuer(req)
	case "Client.SetSasDefinition":
		resp, err = s.dispatchSetSasDefinition(req)
	case "Client.SetSecret":
		resp, err = s.dispatchSetSecret(req)
	case "Client.SetStorageAccount":
		resp, err = s.dispatchSetStorageAccount(req)
	case "Client.Sign":
		resp, err = s.dispatchSign(req)
	case "Client.UnwrapKey":
		resp, err = s.dispatchUnwrapKey(req)
	case "Client.UpdateCertificate":
		resp, err = s.dispatchUpdateCertificate(req)
	case "Client.UpdateCertificateIssuer":
		resp, err = s.dispatchUpdateCertificateIssuer(req)
	case "Client.UpdateCertificateOperation":
		resp, err = s.dispatchUpdateCertificateOperation(req)
	case "Client.UpdateCertificatePolicy":
		resp, err = s.dispatchUpdateCertificatePolicy(req)
	case "Client.UpdateKey":
		resp, err = s.dispatchUpdateKey(req)
	case "Client.UpdateSasDefinition":
		resp, err = s.dispatchUpdateSasDefinition(req)
	case "Client.UpdateSecret":
		resp, err = s.dispatchUpdateSecret(req)
	case "Client.UpdateStorageAccount":
		resp, err = s.dispatchUpdateStorageAccount(req)
	case "Client.Verify":
		resp, err = s.dispatchVerify(req)
	case "Client.WrapKey":
		resp, err = s.dispatchWrapKey(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (s *ServerTransport) dispatchBackupCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.BackupCertificate == nil {
		return nil, &nonRetriableError{errors.New("method BackupCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/backup"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.BackupCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).BackupCertificateResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBackupKey(req *http.Request) (*http.Response, error) {
	if s.srv.BackupKey == nil {
		return nil, &nonRetriableError{errors.New("method BackupKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/backup"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.BackupKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).BackupKeyResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBackupSecret(req *http.Request) (*http.Response, error) {
	if s.srv.BackupSecret == nil {
		return nil, &nonRetriableError{errors.New("method BackupSecret not implemented")}
	}
	const regexStr = "/secrets/(?P<secret_name>[a-zA-Z0-9-_]+)/backup"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.BackupSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).BackupSecretResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBackupStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.BackupStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method BackupStorageAccount not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/backup"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.BackupStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).BackupStorageResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchCreateCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.CreateCertificate == nil {
		return nil, &nonRetriableError{errors.New("method CreateCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/create"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateCreateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.CreateCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateOperation, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchCreateKey(req *http.Request) (*http.Response, error) {
	if s.srv.CreateKey == nil {
		return nil, &nonRetriableError{errors.New("method CreateKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/create"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyCreateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.CreateKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDecrypt(req *http.Request) (*http.Response, error) {
	if s.srv.Decrypt == nil {
		return nil, &nonRetriableError{errors.New("method Decrypt not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)/decrypt"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyOperationsParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Decrypt(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyOperationResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteCertificate == nil {
		return nil, &nonRetriableError{errors.New("method DeleteCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedCertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteCertificateContacts(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteCertificateContacts == nil {
		return nil, &nonRetriableError{errors.New("method DeleteCertificateContacts not implemented")}
	}
	respr, errRespr := s.srv.DeleteCertificateContacts(req.Context(), req.URL.Host, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Contacts, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteCertificateIssuer(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteCertificateIssuer == nil {
		return nil, &nonRetriableError{errors.New("method DeleteCertificateIssuer not implemented")}
	}
	const regexStr = "/certificates/issuers/(?P<issuer_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteCertificateIssuer(req.Context(), req.URL.Host, matches[regex.SubexpIndex("issuer_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).IssuerBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteCertificateOperation(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteCertificateOperation == nil {
		return nil, &nonRetriableError{errors.New("method DeleteCertificateOperation not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/pending"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteCertificateOperation(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateOperation, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteKey(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteKey == nil {
		return nil, &nonRetriableError{errors.New("method DeleteKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedKeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteSasDefinition(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteSasDefinition == nil {
		return nil, &nonRetriableError{errors.New("method DeleteSasDefinition not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas/(?P<sas_definition-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteSasDefinition(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], matches[regex.SubexpIndex("sas_definition-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedSasDefinitionBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteSecret(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteSecret == nil {
		return nil, &nonRetriableError{errors.New("method DeleteSecret not implemented")}
	}
	const regexStr = "/secrets/(?P<secret_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedSecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method DeleteStorageAccount not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.DeleteStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedStorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchEncrypt(req *http.Request) (*http.Response, error) {
	if s.srv.Encrypt == nil {
		return nil, &nonRetriableError{errors.New("method Encrypt not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)/encrypt"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyOperationsParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Encrypt(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyOperationResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBeginFullBackup(req *http.Request) (*http.Response, error) {
	if s.srv.BeginFullBackup == nil {
		return nil, &nonRetriableError{errors.New("method BeginFullBackup not implemented")}
	}
	if s.beginFullBackup == nil {
		body, err := server.UnmarshalRequestAsJSON[azkeyvault.SASTokenParameter](req)
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientBeginFullBackupOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &azkeyvault.ClientBeginFullBackupOptions{
				AzureStorageBlobContainerURI: &body,
			}
		}
		respr, errRespr := s.srv.BeginFullBackup(req.Context(), req.URL.Host, options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		s.beginFullBackup = &respr
	}

	resp, err := server.PollerResponderNext(s.beginFullBackup, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(s.beginFullBackup) {
		s.beginFullBackup = nil
	}

	return resp, nil
}

func (s *ServerTransport) dispatchFullBackupStatus(req *http.Request) (*http.Response, error) {
	if s.srv.FullBackupStatus == nil {
		return nil, &nonRetriableError{errors.New("method FullBackupStatus not implemented")}
	}
	const regexStr = "/backup/(?P<jobId>[a-zA-Z0-9-_]+)/pending"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.FullBackupStatus(req.Context(), req.URL.Host, matches[regex.SubexpIndex("jobId")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).FullBackupOperation, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBeginFullRestoreOperation(req *http.Request) (*http.Response, error) {
	if s.srv.BeginFullRestoreOperation == nil {
		return nil, &nonRetriableError{errors.New("method BeginFullRestoreOperation not implemented")}
	}
	if s.beginFullRestoreOperation == nil {
		body, err := server.UnmarshalRequestAsJSON[azkeyvault.RestoreOperationParameters](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginFullRestoreOperation(req.Context(), req.URL.Host, body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		s.beginFullRestoreOperation = &respr
	}

	resp, err := server.PollerResponderNext(s.beginFullRestoreOperation, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(s.beginFullRestoreOperation) {
		s.beginFullRestoreOperation = nil
	}

	return resp, nil
}

func (s *ServerTransport) dispatchGetCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.GetCertificate == nil {
		return nil, &nonRetriableError{errors.New("method GetCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/(?P<certificate_version>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], matches[regex.SubexpIndex("certificate_version")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetCertificateContacts(req *http.Request) (*http.Response, error) {
	if s.srv.GetCertificateContacts == nil {
		return nil, &nonRetriableError{errors.New("method GetCertificateContacts not implemented")}
	}
	respr, errRespr := s.srv.GetCertificateContacts(req.Context(), req.URL.Host, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Contacts, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetCertificateIssuer(req *http.Request) (*http.Response, error) {
	if s.srv.GetCertificateIssuer == nil {
		return nil, &nonRetriableError{errors.New("method GetCertificateIssuer not implemented")}
	}
	const regexStr = "/certificates/issuers/(?P<issuer_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetCertificateIssuer(req.Context(), req.URL.Host, matches[regex.SubexpIndex("issuer_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).IssuerBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetCertificateIssuersPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetCertificateIssuersPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetCertificateIssuersPager not implemented")}
	}
	if s.newGetCertificateIssuersPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetCertificateIssuersOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetCertificateIssuersOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetCertificateIssuersPager(req.URL.Host, options)
		s.newGetCertificateIssuersPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetCertificateIssuersPager, req, func(page *azkeyvault.ClientGetCertificateIssuersResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetCertificateIssuersPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetCertificateIssuersPager) {
		s.newGetCertificateIssuersPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetCertificateOperation(req *http.Request) (*http.Response, error) {
	if s.srv.GetCertificateOperation == nil {
		return nil, &nonRetriableError{errors.New("method GetCertificateOperation not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/pending"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetCertificateOperation(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateOperation, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetCertificatePolicy(req *http.Request) (*http.Response, error) {
	if s.srv.GetCertificatePolicy == nil {
		return nil, &nonRetriableError{errors.New("method GetCertificatePolicy not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/policy"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetCertificatePolicy(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificatePolicy, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetCertificateVersionsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetCertificateVersionsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetCertificateVersionsPager not implemented")}
	}
	if s.newGetCertificateVersionsPager == nil {
		const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/versions"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetCertificateVersionsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetCertificateVersionsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetCertificateVersionsPager(req.URL.Host, matches[regex.SubexpIndex("certificate_name")], options)
		s.newGetCertificateVersionsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetCertificateVersionsPager, req, func(page *azkeyvault.ClientGetCertificateVersionsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetCertificateVersionsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetCertificateVersionsPager) {
		s.newGetCertificateVersionsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetCertificatesPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetCertificatesPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetCertificatesPager not implemented")}
	}
	if s.newGetCertificatesPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		includePendingParam, err := parseOptional(qp.Get("includePending"), strconv.ParseBool)
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetCertificatesOptions
		if maxresultsParam != nil || includePendingParam != nil {
			options = &azkeyvault.ClientGetCertificatesOptions{
				Maxresults:     maxresultsParam,
				IncludePending: includePendingParam,
			}
		}
		resp := s.srv.NewGetCertificatesPager(req.URL.Host, options)
		s.newGetCertificatesPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetCertificatesPager, req, func(page *azkeyvault.ClientGetCertificatesResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetCertificatesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetCertificatesPager) {
		s.newGetCertificatesPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetDeletedCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.GetDeletedCertificate == nil {
		return nil, &nonRetriableError{errors.New("method GetDeletedCertificate not implemented")}
	}
	const regexStr = "/deletedcertificates/(?P<certificate_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetDeletedCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedCertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetDeletedCertificatesPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetDeletedCertificatesPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetDeletedCertificatesPager not implemented")}
	}
	if s.newGetDeletedCertificatesPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		includePendingParam, err := parseOptional(qp.Get("includePending"), strconv.ParseBool)
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetDeletedCertificatesOptions
		if maxresultsParam != nil || includePendingParam != nil {
			options = &azkeyvault.ClientGetDeletedCertificatesOptions{
				Maxresults:     maxresultsParam,
				IncludePending: includePendingParam,
			}
		}
		resp := s.srv.NewGetDeletedCertificatesPager(req.URL.Host, options)
		s.newGetDeletedCertificatesPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetDeletedCertificatesPager, req, func(page *azkeyvault.ClientGetDeletedCertificatesResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetDeletedCertificatesPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetDeletedCertificatesPager) {
		s.newGetDeletedCertificatesPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetDeletedKey(req *http.Request) (*http.Response, error) {
	if s.srv.GetDeletedKey == nil {
		return nil, &nonRetriableError{errors.New("method GetDeletedKey not implemented")}
	}
	const regexStr = "/deletedkeys/(?P<key_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetDeletedKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedKeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetDeletedKeysPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetDeletedKeysPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetDeletedKeysPager not implemented")}
	}
	if s.newGetDeletedKeysPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetDeletedKeysOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetDeletedKeysOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetDeletedKeysPager(req.URL.Host, options)
		s.newGetDeletedKeysPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetDeletedKeysPager, req, func(page *azkeyvault.ClientGetDeletedKeysResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetDeletedKeysPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetDeletedKeysPager) {
		s.newGetDeletedKeysPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetDeletedSasDefinition(req *http.Request) (*http.Response, error) {
	if s.srv.GetDeletedSasDefinition == nil {
		return nil, &nonRetriableError{errors.New("method GetDeletedSasDefinition not implemented")}
	}
	const regexStr = "/deletedstorage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas/(?P<sas_definition-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetDeletedSasDefinition(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], matches[regex.SubexpIndex("sas_definition-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedSasDefinitionBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetDeletedSasDefinitionsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetDeletedSasDefinitionsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetDeletedSasDefinitionsPager not implemented")}
	}
	if s.newGetDeletedSasDefinitionsPager == nil {
		const regexStr = "/deletedstorage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetDeletedSasDefinitionsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetDeletedSasDefinitionsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetDeletedSasDefinitionsPager(req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], options)
		s.newGetDeletedSasDefinitionsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetDeletedSasDefinitionsPager, req, func(page *azkeyvault.ClientGetDeletedSasDefinitionsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetDeletedSasDefinitionsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetDeletedSasDefinitionsPager) {
		s.newGetDeletedSasDefinitionsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetDeletedSecret(req *http.Request) (*http.Response, error) {
	if s.srv.GetDeletedSecret == nil {
		return nil, &nonRetriableError{errors.New("method GetDeletedSecret not implemented")}
	}
	const regexStr = "/deletedsecrets/(?P<secret_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetDeletedSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedSecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetDeletedSecretsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetDeletedSecretsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetDeletedSecretsPager not implemented")}
	}
	if s.newGetDeletedSecretsPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetDeletedSecretsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetDeletedSecretsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetDeletedSecretsPager(req.URL.Host, options)
		s.newGetDeletedSecretsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetDeletedSecretsPager, req, func(page *azkeyvault.ClientGetDeletedSecretsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetDeletedSecretsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetDeletedSecretsPager) {
		s.newGetDeletedSecretsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetDeletedStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.GetDeletedStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method GetDeletedStorageAccount not implemented")}
	}
	const regexStr = "/deletedstorage/(?P<storage_account-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetDeletedStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).DeletedStorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetDeletedStorageAccountsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetDeletedStorageAccountsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetDeletedStorageAccountsPager not implemented")}
	}
	if s.newGetDeletedStorageAccountsPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetDeletedStorageAccountsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetDeletedStorageAccountsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetDeletedStorageAccountsPager(req.URL.Host, options)
		s.newGetDeletedStorageAccountsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetDeletedStorageAccountsPager, req, func(page *azkeyvault.ClientGetDeletedStorageAccountsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetDeletedStorageAccountsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetDeletedStorageAccountsPager) {
		s.newGetDeletedStorageAccountsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetKey(req *http.Request) (*http.Response, error) {
	if s.srv.GetKey == nil {
		return nil, &nonRetriableError{errors.New("method GetKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetKeyVersionsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetKeyVersionsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetKeyVersionsPager not implemented")}
	}
	if s.newGetKeyVersionsPager == nil {
		const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/versions"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetKeyVersionsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetKeyVersionsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetKeyVersionsPager(req.URL.Host, matches[regex.SubexpIndex("key_name")], options)
		s.newGetKeyVersionsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetKeyVersionsPager, req, func(page *azkeyvault.ClientGetKeyVersionsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetKeyVersionsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetKeyVersionsPager) {
		s.newGetKeyVersionsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetKeysPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetKeysPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetKeysPager not implemented")}
	}
	if s.newGetKeysPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetKeysOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetKeysOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetKeysPager(req.URL.Host, options)
		s.newGetKeysPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetKeysPager, req, func(page *azkeyvault.ClientGetKeysResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetKeysPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetKeysPager) {
		s.newGetKeysPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetSasDefinition(req *http.Request) (*http.Response, error) {
	if s.srv.GetSasDefinition == nil {
		return nil, &nonRetriableError{errors.New("method GetSasDefinition not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas/(?P<sas_definition-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetSasDefinition(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], matches[regex.SubexpIndex("sas_definition-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SasDefinitionBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetSasDefinitionsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetSasDefinitionsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetSasDefinitionsPager not implemented")}
	}
	if s.newGetSasDefinitionsPager == nil {
		const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetSasDefinitionsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetSasDefinitionsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetSasDefinitionsPager(req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], options)
		s.newGetSasDefinitionsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetSasDefinitionsPager, req, func(page *azkeyvault.ClientGetSasDefinitionsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetSasDefinitionsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetSasDefinitionsPager) {
		s.newGetSasDefinitionsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetSecret(req *http.Request) (*http.Response, error) {
	if s.srv.GetSecret == nil {
		return nil, &nonRetriableError{errors.New("method GetSecret not implemented")}
	}
	const regexStr = "/secrets/(?P<secret_name>[a-zA-Z0-9-_]+)/(?P<secret_version>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], matches[regex.SubexpIndex("secret_version")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetSecretVersionsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetSecretVersionsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetSecretVersionsPager not implemented")}
	}
	if s.newGetSecretVersionsPager == nil {
		const regexStr = "/secrets/(?P<secret_name>[a-zA-Z0-9-_]+)/versions"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetSecretVersionsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetSecretVersionsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetSecretVersionsPager(req.URL.Host, matches[regex.SubexpIndex("secret_name")], options)
		s.newGetSecretVersionsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetSecretVersionsPager, req, func(page *azkeyvault.ClientGetSecretVersionsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetSecretVersionsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetSecretVersionsPager) {
		s.newGetSecretVersionsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetSecretsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetSecretsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetSecretsPager not implemented")}
	}
	if s.newGetSecretsPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetSecretsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetSecretsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetSecretsPager(req.URL.Host, options)
		s.newGetSecretsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetSecretsPager, req, func(page *azkeyvault.ClientGetSecretsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetSecretsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetSecretsPager) {
		s.newGetSecretsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.GetStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method GetStorageAccount not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.GetStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).StorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchNewGetStorageAccountsPager(req *http.Request) (*http.Response, error) {
	if s.srv.NewGetStorageAccountsPager == nil {
		return nil, &nonRetriableError{errors.New("method NewGetStorageAccountsPager not implemented")}
	}
	if s.newGetStorageAccountsPager == nil {
		qp := req.URL.Query()
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return 0, err
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		var options *azkeyvault.ClientGetStorageAccountsOptions
		if maxresultsParam != nil {
			options = &azkeyvault.ClientGetStorageAccountsOptions{
				Maxresults: maxresultsParam,
			}
		}
		resp := s.srv.NewGetStorageAccountsPager(req.URL.Host, options)
		s.newGetStorageAccountsPager = &resp
		server.PagerResponderInjectNextLinks(s.newGetStorageAccountsPager, req, func(page *azkeyvault.ClientGetStorageAccountsResponse, createLink func() string) {
			page.NextLink = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(s.newGetStorageAccountsPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(s.newGetStorageAccountsPager) {
		s.newGetStorageAccountsPager = nil
	}
	return resp, nil
}

func (s *ServerTransport) dispatchImportCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.ImportCertificate == nil {
		return nil, &nonRetriableError{errors.New("method ImportCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/import"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateImportParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.ImportCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchImportKey(req *http.Request) (*http.Response, error) {
	if s.srv.ImportKey == nil {
		return nil, &nonRetriableError{errors.New("method ImportKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyImportParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.ImportKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchMergeCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.MergeCertificate == nil {
		return nil, &nonRetriableError{errors.New("method MergeCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/pending/merge"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateMergeParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.MergeCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchPurgeDeletedCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.PurgeDeletedCertificate == nil {
		return nil, &nonRetriableError{errors.New("method PurgeDeletedCertificate not implemented")}
	}
	const regexStr = "/deletedcertificates/(?P<certificate_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.PurgeDeletedCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchPurgeDeletedKey(req *http.Request) (*http.Response, error) {
	if s.srv.PurgeDeletedKey == nil {
		return nil, &nonRetriableError{errors.New("method PurgeDeletedKey not implemented")}
	}
	const regexStr = "/deletedkeys/(?P<key_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.PurgeDeletedKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchPurgeDeletedSecret(req *http.Request) (*http.Response, error) {
	if s.srv.PurgeDeletedSecret == nil {
		return nil, &nonRetriableError{errors.New("method PurgeDeletedSecret not implemented")}
	}
	const regexStr = "/deletedsecrets/(?P<secret_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.PurgeDeletedSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchPurgeDeletedStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.PurgeDeletedStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method PurgeDeletedStorageAccount not implemented")}
	}
	const regexStr = "/deletedstorage/(?P<storage_account-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.PurgeDeletedStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRecoverDeletedCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.RecoverDeletedCertificate == nil {
		return nil, &nonRetriableError{errors.New("method RecoverDeletedCertificate not implemented")}
	}
	const regexStr = "/deletedcertificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/recover"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.RecoverDeletedCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRecoverDeletedKey(req *http.Request) (*http.Response, error) {
	if s.srv.RecoverDeletedKey == nil {
		return nil, &nonRetriableError{errors.New("method RecoverDeletedKey not implemented")}
	}
	const regexStr = "/deletedkeys/(?P<key_name>[a-zA-Z0-9-_]+)/recover"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.RecoverDeletedKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRecoverDeletedSasDefinition(req *http.Request) (*http.Response, error) {
	if s.srv.RecoverDeletedSasDefinition == nil {
		return nil, &nonRetriableError{errors.New("method RecoverDeletedSasDefinition not implemented")}
	}
	const regexStr = "/deletedstorage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas/(?P<sas_definition-name>[a-zA-Z0-9-_]+)/recover"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.RecoverDeletedSasDefinition(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], matches[regex.SubexpIndex("sas_definition-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SasDefinitionBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRecoverDeletedSecret(req *http.Request) (*http.Response, error) {
	if s.srv.RecoverDeletedSecret == nil {
		return nil, &nonRetriableError{errors.New("method RecoverDeletedSecret not implemented")}
	}
	const regexStr = "/deletedsecrets/(?P<secret_name>[a-zA-Z0-9-_]+)/recover"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.RecoverDeletedSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRecoverDeletedStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.RecoverDeletedStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method RecoverDeletedStorageAccount not implemented")}
	}
	const regexStr = "/deletedstorage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/recover"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.RecoverDeletedStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).StorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRegenerateStorageAccountKey(req *http.Request) (*http.Response, error) {
	if s.srv.RegenerateStorageAccountKey == nil {
		return nil, &nonRetriableError{errors.New("method RegenerateStorageAccountKey not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/regeneratekey"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.StorageAccountRegenerteKeyParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.RegenerateStorageAccountKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).StorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRestoreCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.RestoreCertificate == nil {
		return nil, &nonRetriableError{errors.New("method RestoreCertificate not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateRestoreParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.RestoreCertificate(req.Context(), req.URL.Host, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRestoreKey(req *http.Request) (*http.Response, error) {
	if s.srv.RestoreKey == nil {
		return nil, &nonRetriableError{errors.New("method RestoreKey not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyRestoreParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.RestoreKey(req.Context(), req.URL.Host, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRestoreSecret(req *http.Request) (*http.Response, error) {
	if s.srv.RestoreSecret == nil {
		return nil, &nonRetriableError{errors.New("method RestoreSecret not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.SecretRestoreParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.RestoreSecret(req.Context(), req.URL.Host, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRestoreStatus(req *http.Request) (*http.Response, error) {
	if s.srv.RestoreStatus == nil {
		return nil, &nonRetriableError{errors.New("method RestoreStatus not implemented")}
	}
	const regexStr = "/restore/(?P<jobId>[a-zA-Z0-9-_]+)/pending"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	respr, errRespr := s.srv.RestoreStatus(req.Context(), req.URL.Host, matches[regex.SubexpIndex("jobId")], nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).RestoreOperation, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRestoreStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.RestoreStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method RestoreStorageAccount not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.StorageRestoreParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.RestoreStorageAccount(req.Context(), req.URL.Host, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).StorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBeginSelectiveKeyRestoreOperation(req *http.Request) (*http.Response, error) {
	if s.srv.BeginSelectiveKeyRestoreOperation == nil {
		return nil, &nonRetriableError{errors.New("method BeginSelectiveKeyRestoreOperation not implemented")}
	}
	if s.beginSelectiveKeyRestoreOperation == nil {
		const regexStr = "/keys/(?P<keyName>[a-zA-Z0-9-_]+)/restore"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		body, err := server.UnmarshalRequestAsJSON[azkeyvault.SelectiveKeyRestoreOperationParameters](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := s.srv.BeginSelectiveKeyRestoreOperation(req.Context(), req.URL.Host, matches[regex.SubexpIndex("keyName")], body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		s.beginSelectiveKeyRestoreOperation = &respr
	}

	resp, err := server.PollerResponderNext(s.beginSelectiveKeyRestoreOperation, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(s.beginSelectiveKeyRestoreOperation) {
		s.beginSelectiveKeyRestoreOperation = nil
	}

	return resp, nil
}

func (s *ServerTransport) dispatchSetCertificateContacts(req *http.Request) (*http.Response, error) {
	if s.srv.SetCertificateContacts == nil {
		return nil, &nonRetriableError{errors.New("method SetCertificateContacts not implemented")}
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.Contacts](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.SetCertificateContacts(req.Context(), req.URL.Host, body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).Contacts, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetCertificateIssuer(req *http.Request) (*http.Response, error) {
	if s.srv.SetCertificateIssuer == nil {
		return nil, &nonRetriableError{errors.New("method SetCertificateIssuer not implemented")}
	}
	const regexStr = "/certificates/issuers/(?P<issuer_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateIssuerSetParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.SetCertificateIssuer(req.Context(), req.URL.Host, matches[regex.SubexpIndex("issuer_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).IssuerBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetSasDefinition(req *http.Request) (*http.Response, error) {
	if s.srv.SetSasDefinition == nil {
		return nil, &nonRetriableError{errors.New("method SetSasDefinition not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas/(?P<sas_definition-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.SasDefinitionCreateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.SetSasDefinition(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], matches[regex.SubexpIndex("sas_definition-name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SasDefinitionBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetSecret(req *http.Request) (*http.Response, error) {
	if s.srv.SetSecret == nil {
		return nil, &nonRetriableError{errors.New("method SetSecret not implemented")}
	}
	const regexStr = "/secrets/(?P<secret_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.SecretSetParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.SetSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.SetStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method SetStorageAccount not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.StorageAccountCreateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.SetStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).StorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSign(req *http.Request) (*http.Response, error) {
	if s.srv.Sign == nil {
		return nil, &nonRetriableError{errors.New("method Sign not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)/sign"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeySignParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Sign(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyOperationResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUnwrapKey(req *http.Request) (*http.Response, error) {
	if s.srv.UnwrapKey == nil {
		return nil, &nonRetriableError{errors.New("method UnwrapKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)/unwrapkey"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyOperationsParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UnwrapKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyOperationResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateCertificate(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateCertificate == nil {
		return nil, &nonRetriableError{errors.New("method UpdateCertificate not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/(?P<certificate_version>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateUpdateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateCertificate(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], matches[regex.SubexpIndex("certificate_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateCertificateIssuer(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateCertificateIssuer == nil {
		return nil, &nonRetriableError{errors.New("method UpdateCertificateIssuer not implemented")}
	}
	const regexStr = "/certificates/issuers/(?P<issuer_name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateIssuerUpdateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateCertificateIssuer(req.Context(), req.URL.Host, matches[regex.SubexpIndex("issuer_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).IssuerBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateCertificateOperation(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateCertificateOperation == nil {
		return nil, &nonRetriableError{errors.New("method UpdateCertificateOperation not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/pending"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificateOperationUpdateParameter](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateCertificateOperation(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificateOperation, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateCertificatePolicy(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateCertificatePolicy == nil {
		return nil, &nonRetriableError{errors.New("method UpdateCertificatePolicy not implemented")}
	}
	const regexStr = "/certificates/(?P<certificate_name>[a-zA-Z0-9-_]+)/policy"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.CertificatePolicy](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateCertificatePolicy(req.Context(), req.URL.Host, matches[regex.SubexpIndex("certificate_name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).CertificatePolicy, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateKey(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateKey == nil {
		return nil, &nonRetriableError{errors.New("method UpdateKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyUpdateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateSasDefinition(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateSasDefinition == nil {
		return nil, &nonRetriableError{errors.New("method UpdateSasDefinition not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)/sas/(?P<sas_definition-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.SasDefinitionUpdateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateSasDefinition(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], matches[regex.SubexpIndex("sas_definition-name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SasDefinitionBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateSecret(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateSecret == nil {
		return nil, &nonRetriableError{errors.New("method UpdateSecret not implemented")}
	}
	const regexStr = "/secrets/(?P<secret_name>[a-zA-Z0-9-_]+)/(?P<secret_version>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.SecretUpdateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateSecret(req.Context(), req.URL.Host, matches[regex.SubexpIndex("secret_name")], matches[regex.SubexpIndex("secret_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).SecretBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUpdateStorageAccount(req *http.Request) (*http.Response, error) {
	if s.srv.UpdateStorageAccount == nil {
		return nil, &nonRetriableError{errors.New("method UpdateStorageAccount not implemented")}
	}
	const regexStr = "/storage/(?P<storage_account-name>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.StorageAccountUpdateParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.UpdateStorageAccount(req.Context(), req.URL.Host, matches[regex.SubexpIndex("storage_account-name")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).StorageBundle, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchVerify(req *http.Request) (*http.Response, error) {
	if s.srv.Verify == nil {
		return nil, &nonRetriableError{errors.New("method Verify not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)/verify"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyVerifyParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.Verify(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyVerifyResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (s *ServerTransport) dispatchWrapKey(req *http.Request) (*http.Response, error) {
	if s.srv.WrapKey == nil {
		return nil, &nonRetriableError{errors.New("method WrapKey not implemented")}
	}
	const regexStr = "/keys/(?P<key_name>[a-zA-Z0-9-_]+)/(?P<key_version>[a-zA-Z0-9-_]+)/wrapkey"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	body, err := server.UnmarshalRequestAsJSON[azkeyvault.KeyOperationsParameters](req)
	if err != nil {
		return nil, err
	}
	respr, errRespr := s.srv.WrapKey(req.Context(), req.URL.Host, matches[regex.SubexpIndex("key_name")], matches[regex.SubexpIndex("key_version")], body, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsJSON(respContent, server.GetResponse(respr).KeyOperationResult, req)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
