// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package headergroup

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"time"
)

// HeaderClient contains the methods for the Header group.
// Don't use this type directly, use a constructor function instead.
type HeaderClient struct {
	internal *azcore.Client
}

// CustomRequestID - Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - HeaderClientCustomRequestIDOptions contains the optional parameters for the HeaderClient.CustomRequestID method.
func (client *HeaderClient) CustomRequestID(ctx context.Context, options *HeaderClientCustomRequestIDOptions) (HeaderClientCustomRequestIDResponse, error) {
	var err error
	const operationName = "HeaderClient.CustomRequestID"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.customRequestIDCreateRequest(ctx, options)
	if err != nil {
		return HeaderClientCustomRequestIDResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientCustomRequestIDResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientCustomRequestIDResponse{}, err
	}
	return HeaderClientCustomRequestIDResponse{}, nil
}

// customRequestIDCreateRequest creates the CustomRequestID request.
func (client *HeaderClient) customRequestIDCreateRequest(ctx context.Context, options *HeaderClientCustomRequestIDOptions) (*policy.Request, error) {
	urlPath := "/header/custom/x-ms-client-request-id/9C4D50EE-2D56-4CD3-8152-34347DC9F2B0"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamBool - Send a post request with header values "scenario": "true", "value": true or "scenario": "false", "value": false
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "true" or "false"
//   - value - Send a post request with header values true or false
//   - options - HeaderClientParamBoolOptions contains the optional parameters for the HeaderClient.ParamBool method.
func (client *HeaderClient) ParamBool(ctx context.Context, scenario string, value bool, options *HeaderClientParamBoolOptions) (HeaderClientParamBoolResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamBool"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramBoolCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamBoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamBoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamBoolResponse{}, err
	}
	return HeaderClientParamBoolResponse{}, nil
}

// paramBoolCreateRequest creates the ParamBool request.
func (client *HeaderClient) paramBoolCreateRequest(ctx context.Context, scenario string, value bool, options *HeaderClientParamBoolOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/bool"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatBool(value)}
	return req, nil
}

// ParamByte - Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - value - Send a post request with header values "啊齄丂狛狜隣郎隣兀﨩"
//   - options - HeaderClientParamByteOptions contains the optional parameters for the HeaderClient.ParamByte method.
func (client *HeaderClient) ParamByte(ctx context.Context, scenario string, value []byte, options *HeaderClientParamByteOptions) (HeaderClientParamByteResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamByte"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramByteCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamByteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamByteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamByteResponse{}, err
	}
	return HeaderClientParamByteResponse{}, nil
}

// paramByteCreateRequest creates the ParamByte request.
func (client *HeaderClient) paramByteCreateRequest(ctx context.Context, scenario string, value []byte, options *HeaderClientParamByteOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/byte"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{base64.StdEncoding.EncodeToString(value)}
	return req, nil
}

// ParamDate - Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario": "min", "value":
// "0001-01-01"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - value - Send a post request with header values "2010-01-01" or "0001-01-01"
//   - options - HeaderClientParamDateOptions contains the optional parameters for the HeaderClient.ParamDate method.
func (client *HeaderClient) ParamDate(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDateOptions) (HeaderClientParamDateResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamDate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramDateCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamDateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamDateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamDateResponse{}, err
	}
	return HeaderClientParamDateResponse{}, nil
}

// paramDateCreateRequest creates the ParamDate request.
func (client *HeaderClient) paramDateCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDateOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/date"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{value.Format("2006-01-02")}
	return req, nil
}

// ParamDatetime - Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or "scenario":
// "min", "value": "0001-01-01T00:00:00Z"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - value - Send a post request with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
//   - options - HeaderClientParamDatetimeOptions contains the optional parameters for the HeaderClient.ParamDatetime method.
func (client *HeaderClient) ParamDatetime(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDatetimeOptions) (HeaderClientParamDatetimeResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamDatetime"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramDatetimeCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamDatetimeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamDatetimeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamDatetimeResponse{}, err
	}
	return HeaderClientParamDatetimeResponse{}, nil
}

// paramDatetimeCreateRequest creates the ParamDatetime request.
func (client *HeaderClient) paramDatetimeCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDatetimeOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/datetime"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{value.Format(time.RFC3339Nano)}
	return req, nil
}

// ParamDatetimeRFC1123 - Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56
// GMT" or "scenario": "min", "value": "Mon, 01 Jan 0001 00:00:00 GMT"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientParamDatetimeRFC1123Options contains the optional parameters for the HeaderClient.ParamDatetimeRFC1123
//     method.
func (client *HeaderClient) ParamDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderClientParamDatetimeRFC1123Options) (HeaderClientParamDatetimeRFC1123Response, error) {
	var err error
	const operationName = "HeaderClient.ParamDatetimeRFC1123"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientParamDatetimeRFC1123Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamDatetimeRFC1123Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamDatetimeRFC1123Response{}, err
	}
	return HeaderClientParamDatetimeRFC1123Response{}, nil
}

// paramDatetimeRFC1123CreateRequest creates the ParamDatetimeRFC1123 request.
func (client *HeaderClient) paramDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderClientParamDatetimeRFC1123Options) (*policy.Request, error) {
	urlPath := "/header/param/prim/datetimerfc1123"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	if options != nil && options.Value != nil {
		req.Raw().Header["value"] = []string{options.Value.Format(time.RFC1123)}
	}
	return req, nil
}

// ParamDouble - Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario": "negative",
// "value": -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 7e120 or -3.0
//   - options - HeaderClientParamDoubleOptions contains the optional parameters for the HeaderClient.ParamDouble method.
func (client *HeaderClient) ParamDouble(ctx context.Context, scenario string, value float64, options *HeaderClientParamDoubleOptions) (HeaderClientParamDoubleResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamDouble"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramDoubleCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamDoubleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamDoubleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamDoubleResponse{}, err
	}
	return HeaderClientParamDoubleResponse{}, nil
}

// paramDoubleCreateRequest creates the ParamDouble request.
func (client *HeaderClient) paramDoubleCreateRequest(ctx context.Context, scenario string, value float64, options *HeaderClientParamDoubleOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/double"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatFloat(value, 'f', -1, 64)}
	return req, nil
}

// ParamDuration - Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - value - Send a post request with header values "P123DT22H14M12.011S"
//   - options - HeaderClientParamDurationOptions contains the optional parameters for the HeaderClient.ParamDuration method.
func (client *HeaderClient) ParamDuration(ctx context.Context, scenario string, value string, options *HeaderClientParamDurationOptions) (HeaderClientParamDurationResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamDuration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramDurationCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamDurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamDurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamDurationResponse{}, err
	}
	return HeaderClientParamDurationResponse{}, nil
}

// paramDurationCreateRequest creates the ParamDuration request.
func (client *HeaderClient) paramDurationCreateRequest(ctx context.Context, scenario string, value string, options *HeaderClientParamDurationOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/duration"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{value}
	return req, nil
}

// ParamEnum - Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario": "null", "value":
// null
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientParamEnumOptions contains the optional parameters for the HeaderClient.ParamEnum method.
func (client *HeaderClient) ParamEnum(ctx context.Context, scenario string, options *HeaderClientParamEnumOptions) (HeaderClientParamEnumResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamEnum"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientParamEnumResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamEnumResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamEnumResponse{}, err
	}
	return HeaderClientParamEnumResponse{}, nil
}

// paramEnumCreateRequest creates the ParamEnum request.
func (client *HeaderClient) paramEnumCreateRequest(ctx context.Context, scenario string, options *HeaderClientParamEnumOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/enum"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	if options != nil && options.Value != nil {
		req.Raw().Header["value"] = []string{string(*options.Value)}
	}
	return req, nil
}

// ParamExistingKey - Send a post request with header value "User-Agent": "overwrite"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - userAgent - Send a post request with header value "User-Agent": "overwrite"
//   - options - HeaderClientParamExistingKeyOptions contains the optional parameters for the HeaderClient.ParamExistingKey method.
func (client *HeaderClient) ParamExistingKey(ctx context.Context, userAgent string, options *HeaderClientParamExistingKeyOptions) (HeaderClientParamExistingKeyResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamExistingKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramExistingKeyCreateRequest(ctx, userAgent, options)
	if err != nil {
		return HeaderClientParamExistingKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamExistingKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamExistingKeyResponse{}, err
	}
	return HeaderClientParamExistingKeyResponse{}, nil
}

// paramExistingKeyCreateRequest creates the ParamExistingKey request.
func (client *HeaderClient) paramExistingKeyCreateRequest(ctx context.Context, userAgent string, options *HeaderClientParamExistingKeyOptions) (*policy.Request, error) {
	urlPath := "/header/param/existingkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["User-Agent"] = []string{userAgent}
	return req, nil
}

// ParamFloat - Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario": "negative", "value":
// -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 0.07 or -3.0
//   - options - HeaderClientParamFloatOptions contains the optional parameters for the HeaderClient.ParamFloat method.
func (client *HeaderClient) ParamFloat(ctx context.Context, scenario string, value float32, options *HeaderClientParamFloatOptions) (HeaderClientParamFloatResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamFloat"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramFloatCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamFloatResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamFloatResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamFloatResponse{}, err
	}
	return HeaderClientParamFloatResponse{}, nil
}

// paramFloatCreateRequest creates the ParamFloat request.
func (client *HeaderClient) paramFloatCreateRequest(ctx context.Context, scenario string, value float32, options *HeaderClientParamFloatOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/float"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatFloat(float64(value), 'f', -1, 32)}
	return req, nil
}

// ParamInteger - Send a post request with header values "scenario": "positive", "value": 1 or "scenario": "negative", "value":
// -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 1 or -2
//   - options - HeaderClientParamIntegerOptions contains the optional parameters for the HeaderClient.ParamInteger method.
func (client *HeaderClient) ParamInteger(ctx context.Context, scenario string, value int32, options *HeaderClientParamIntegerOptions) (HeaderClientParamIntegerResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamInteger"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramIntegerCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamIntegerResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamIntegerResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamIntegerResponse{}, err
	}
	return HeaderClientParamIntegerResponse{}, nil
}

// paramIntegerCreateRequest creates the ParamInteger request.
func (client *HeaderClient) paramIntegerCreateRequest(ctx context.Context, scenario string, value int32, options *HeaderClientParamIntegerOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/integer"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatInt(int64(value), 10)}
	return req, nil
}

// ParamLong - Send a post request with header values "scenario": "positive", "value": 105 or "scenario": "negative", "value":
// -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 105 or -2
//   - options - HeaderClientParamLongOptions contains the optional parameters for the HeaderClient.ParamLong method.
func (client *HeaderClient) ParamLong(ctx context.Context, scenario string, value int64, options *HeaderClientParamLongOptions) (HeaderClientParamLongResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamLong"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramLongCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderClientParamLongResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamLongResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamLongResponse{}, err
	}
	return HeaderClientParamLongResponse{}, nil
}

// paramLongCreateRequest creates the ParamLong request.
func (client *HeaderClient) paramLongCreateRequest(ctx context.Context, scenario string, value int64, options *HeaderClientParamLongOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/long"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatInt(value, 10)}
	return req, nil
}

// ParamProtectedKey - Send a post request with header value "Content-Type": "text/html"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - contentType - Send a post request with header value "Content-Type": "text/html"
//   - options - HeaderClientParamProtectedKeyOptions contains the optional parameters for the HeaderClient.ParamProtectedKey
//     method.
func (client *HeaderClient) ParamProtectedKey(ctx context.Context, contentType string, options *HeaderClientParamProtectedKeyOptions) (HeaderClientParamProtectedKeyResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamProtectedKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramProtectedKeyCreateRequest(ctx, contentType, options)
	if err != nil {
		return HeaderClientParamProtectedKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamProtectedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamProtectedKeyResponse{}, err
	}
	return HeaderClientParamProtectedKeyResponse{}, nil
}

// paramProtectedKeyCreateRequest creates the ParamProtectedKey request.
func (client *HeaderClient) paramProtectedKeyCreateRequest(ctx context.Context, contentType string, options *HeaderClientParamProtectedKeyOptions) (*policy.Request, error) {
	urlPath := "/header/param/protectedkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{contentType}
	return req, nil
}

// ParamString - Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps over the
// lazy dog" or "scenario": "null", "value": null or "scenario": "empty", "value": ""
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientParamStringOptions contains the optional parameters for the HeaderClient.ParamString method.
func (client *HeaderClient) ParamString(ctx context.Context, scenario string, options *HeaderClientParamStringOptions) (HeaderClientParamStringResponse, error) {
	var err error
	const operationName = "HeaderClient.ParamString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.paramStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientParamStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientParamStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientParamStringResponse{}, err
	}
	return HeaderClientParamStringResponse{}, nil
}

// paramStringCreateRequest creates the ParamString request.
func (client *HeaderClient) paramStringCreateRequest(ctx context.Context, scenario string, options *HeaderClientParamStringOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/string"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	if options != nil && options.Value != nil {
		req.Raw().Header["value"] = []string{*options.Value}
	}
	return req, nil
}

// ResponseBool - Get a response with header value "value": true or false
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "true" or "false"
//   - options - HeaderClientResponseBoolOptions contains the optional parameters for the HeaderClient.ResponseBool method.
func (client *HeaderClient) ResponseBool(ctx context.Context, scenario string, options *HeaderClientResponseBoolOptions) (HeaderClientResponseBoolResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseBool"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseBoolCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseBoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseBoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseBoolResponse{}, err
	}
	resp, err := client.responseBoolHandleResponse(httpResp)
	return resp, err
}

// responseBoolCreateRequest creates the ResponseBool request.
func (client *HeaderClient) responseBoolCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseBoolOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/bool"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseBoolHandleResponse handles the ResponseBool response.
func (client *HeaderClient) responseBoolHandleResponse(resp *http.Response) (HeaderClientResponseBoolResponse, error) {
	result := HeaderClientResponseBoolResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseBool(val)
		if err != nil {
			return HeaderClientResponseBoolResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseByte - Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - options - HeaderClientResponseByteOptions contains the optional parameters for the HeaderClient.ResponseByte method.
func (client *HeaderClient) ResponseByte(ctx context.Context, scenario string, options *HeaderClientResponseByteOptions) (HeaderClientResponseByteResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseByte"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseByteCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseByteResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseByteResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseByteResponse{}, err
	}
	resp, err := client.responseByteHandleResponse(httpResp)
	return resp, err
}

// responseByteCreateRequest creates the ResponseByte request.
func (client *HeaderClient) responseByteCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseByteOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/byte"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseByteHandleResponse handles the ResponseByte response.
func (client *HeaderClient) responseByteHandleResponse(resp *http.Response) (HeaderClientResponseByteResponse, error) {
	result := HeaderClientResponseByteResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return HeaderClientResponseByteResponse{}, err
		}
		result.Value = value
	}
	return result, nil
}

// ResponseDate - Get a response with header values "2010-01-01" or "0001-01-01"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientResponseDateOptions contains the optional parameters for the HeaderClient.ResponseDate method.
func (client *HeaderClient) ResponseDate(ctx context.Context, scenario string, options *HeaderClientResponseDateOptions) (HeaderClientResponseDateResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseDate"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseDateCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseDateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseDateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseDateResponse{}, err
	}
	resp, err := client.responseDateHandleResponse(httpResp)
	return resp, err
}

// responseDateCreateRequest creates the ResponseDate request.
func (client *HeaderClient) responseDateCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDateOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/date"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseDateHandleResponse handles the ResponseDate response.
func (client *HeaderClient) responseDateHandleResponse(resp *http.Response) (HeaderClientResponseDateResponse, error) {
	result := HeaderClientResponseDateResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse("2006-01-02", val)
		if err != nil {
			return HeaderClientResponseDateResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDatetime - Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientResponseDatetimeOptions contains the optional parameters for the HeaderClient.ResponseDatetime method.
func (client *HeaderClient) ResponseDatetime(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeOptions) (HeaderClientResponseDatetimeResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseDatetime"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseDatetimeCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseDatetimeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseDatetimeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseDatetimeResponse{}, err
	}
	resp, err := client.responseDatetimeHandleResponse(httpResp)
	return resp, err
}

// responseDatetimeCreateRequest creates the ResponseDatetime request.
func (client *HeaderClient) responseDatetimeCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/datetime"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseDatetimeHandleResponse handles the ResponseDatetime response.
func (client *HeaderClient) responseDatetimeHandleResponse(resp *http.Response) (HeaderClientResponseDatetimeResponse, error) {
	result := HeaderClientResponseDatetimeResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC3339Nano, val)
		if err != nil {
			return HeaderClientResponseDatetimeResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDatetimeRFC1123 - Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00
// GMT"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientResponseDatetimeRFC1123Options contains the optional parameters for the HeaderClient.ResponseDatetimeRFC1123
//     method.
func (client *HeaderClient) ResponseDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeRFC1123Options) (HeaderClientResponseDatetimeRFC1123Response, error) {
	var err error
	const operationName = "HeaderClient.ResponseDatetimeRFC1123"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseDatetimeRFC1123Response{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseDatetimeRFC1123Response{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseDatetimeRFC1123Response{}, err
	}
	resp, err := client.responseDatetimeRFC1123HandleResponse(httpResp)
	return resp, err
}

// responseDatetimeRFC1123CreateRequest creates the ResponseDatetimeRFC1123 request.
func (client *HeaderClient) responseDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeRFC1123Options) (*policy.Request, error) {
	urlPath := "/header/response/prim/datetimerfc1123"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseDatetimeRFC1123HandleResponse handles the ResponseDatetimeRFC1123 response.
func (client *HeaderClient) responseDatetimeRFC1123HandleResponse(resp *http.Response) (HeaderClientResponseDatetimeRFC1123Response, error) {
	result := HeaderClientResponseDatetimeRFC1123Response{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return HeaderClientResponseDatetimeRFC1123Response{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDouble - Get a response with header value "value": 7e120 or -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseDoubleOptions contains the optional parameters for the HeaderClient.ResponseDouble method.
func (client *HeaderClient) ResponseDouble(ctx context.Context, scenario string, options *HeaderClientResponseDoubleOptions) (HeaderClientResponseDoubleResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseDouble"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseDoubleCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseDoubleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseDoubleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseDoubleResponse{}, err
	}
	resp, err := client.responseDoubleHandleResponse(httpResp)
	return resp, err
}

// responseDoubleCreateRequest creates the ResponseDouble request.
func (client *HeaderClient) responseDoubleCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDoubleOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/double"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseDoubleHandleResponse handles the ResponseDouble response.
func (client *HeaderClient) responseDoubleHandleResponse(resp *http.Response) (HeaderClientResponseDoubleResponse, error) {
	result := HeaderClientResponseDoubleResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseFloat(val, 64)
		if err != nil {
			return HeaderClientResponseDoubleResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDuration - Get a response with header values "P123DT22H14M12.011S"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - options - HeaderClientResponseDurationOptions contains the optional parameters for the HeaderClient.ResponseDuration method.
func (client *HeaderClient) ResponseDuration(ctx context.Context, scenario string, options *HeaderClientResponseDurationOptions) (HeaderClientResponseDurationResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseDuration"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseDurationCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseDurationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseDurationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseDurationResponse{}, err
	}
	resp, err := client.responseDurationHandleResponse(httpResp)
	return resp, err
}

// responseDurationCreateRequest creates the ResponseDuration request.
func (client *HeaderClient) responseDurationCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDurationOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/duration"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseDurationHandleResponse handles the ResponseDuration response.
func (client *HeaderClient) responseDurationHandleResponse(resp *http.Response) (HeaderClientResponseDurationResponse, error) {
	result := HeaderClientResponseDurationResponse{}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return result, nil
}

// ResponseEnum - Get a response with header values "GREY" or null
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientResponseEnumOptions contains the optional parameters for the HeaderClient.ResponseEnum method.
func (client *HeaderClient) ResponseEnum(ctx context.Context, scenario string, options *HeaderClientResponseEnumOptions) (HeaderClientResponseEnumResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseEnum"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseEnumResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseEnumResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseEnumResponse{}, err
	}
	resp, err := client.responseEnumHandleResponse(httpResp)
	return resp, err
}

// responseEnumCreateRequest creates the ResponseEnum request.
func (client *HeaderClient) responseEnumCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseEnumOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/enum"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseEnumHandleResponse handles the ResponseEnum response.
func (client *HeaderClient) responseEnumHandleResponse(resp *http.Response) (HeaderClientResponseEnumResponse, error) {
	result := HeaderClientResponseEnumResponse{}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = (*GreyscaleColors)(&val)
	}
	return result, nil
}

// ResponseExistingKey - Get a response with header value "User-Agent": "overwrite"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - HeaderClientResponseExistingKeyOptions contains the optional parameters for the HeaderClient.ResponseExistingKey
//     method.
func (client *HeaderClient) ResponseExistingKey(ctx context.Context, options *HeaderClientResponseExistingKeyOptions) (HeaderClientResponseExistingKeyResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseExistingKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseExistingKeyCreateRequest(ctx, options)
	if err != nil {
		return HeaderClientResponseExistingKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseExistingKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseExistingKeyResponse{}, err
	}
	resp, err := client.responseExistingKeyHandleResponse(httpResp)
	return resp, err
}

// responseExistingKeyCreateRequest creates the ResponseExistingKey request.
func (client *HeaderClient) responseExistingKeyCreateRequest(ctx context.Context, options *HeaderClientResponseExistingKeyOptions) (*policy.Request, error) {
	urlPath := "/header/response/existingkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseExistingKeyHandleResponse handles the ResponseExistingKey response.
func (client *HeaderClient) responseExistingKeyHandleResponse(resp *http.Response) (HeaderClientResponseExistingKeyResponse, error) {
	result := HeaderClientResponseExistingKeyResponse{}
	if val := resp.Header.Get("User-Agent"); val != "" {
		result.UserAgent = &val
	}
	return result, nil
}

// ResponseFloat - Get a response with header value "value": 0.07 or -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseFloatOptions contains the optional parameters for the HeaderClient.ResponseFloat method.
func (client *HeaderClient) ResponseFloat(ctx context.Context, scenario string, options *HeaderClientResponseFloatOptions) (HeaderClientResponseFloatResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseFloat"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseFloatCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseFloatResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseFloatResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseFloatResponse{}, err
	}
	resp, err := client.responseFloatHandleResponse(httpResp)
	return resp, err
}

// responseFloatCreateRequest creates the ResponseFloat request.
func (client *HeaderClient) responseFloatCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseFloatOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/float"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseFloatHandleResponse handles the ResponseFloat response.
func (client *HeaderClient) responseFloatHandleResponse(resp *http.Response) (HeaderClientResponseFloatResponse, error) {
	result := HeaderClientResponseFloatResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseFloat(val, 32)
		value := float32(value32)
		if err != nil {
			return HeaderClientResponseFloatResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseInteger - Get a response with header value "value": 1 or -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseIntegerOptions contains the optional parameters for the HeaderClient.ResponseInteger method.
func (client *HeaderClient) ResponseInteger(ctx context.Context, scenario string, options *HeaderClientResponseIntegerOptions) (HeaderClientResponseIntegerResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseInteger"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseIntegerCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseIntegerResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseIntegerResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseIntegerResponse{}, err
	}
	resp, err := client.responseIntegerHandleResponse(httpResp)
	return resp, err
}

// responseIntegerCreateRequest creates the ResponseInteger request.
func (client *HeaderClient) responseIntegerCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseIntegerOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/integer"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseIntegerHandleResponse handles the ResponseInteger response.
func (client *HeaderClient) responseIntegerHandleResponse(resp *http.Response) (HeaderClientResponseIntegerResponse, error) {
	result := HeaderClientResponseIntegerResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseInt(val, 10, 32)
		value := int32(value32)
		if err != nil {
			return HeaderClientResponseIntegerResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseLong - Get a response with header value "value": 105 or -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseLongOptions contains the optional parameters for the HeaderClient.ResponseLong method.
func (client *HeaderClient) ResponseLong(ctx context.Context, scenario string, options *HeaderClientResponseLongOptions) (HeaderClientResponseLongResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseLong"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseLongCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseLongResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseLongResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseLongResponse{}, err
	}
	resp, err := client.responseLongHandleResponse(httpResp)
	return resp, err
}

// responseLongCreateRequest creates the ResponseLong request.
func (client *HeaderClient) responseLongCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseLongOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/long"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseLongHandleResponse handles the ResponseLong response.
func (client *HeaderClient) responseLongHandleResponse(resp *http.Response) (HeaderClientResponseLongResponse, error) {
	result := HeaderClientResponseLongResponse{}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return HeaderClientResponseLongResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseProtectedKey - Get a response with header value "Content-Type": "text/html"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - HeaderClientResponseProtectedKeyOptions contains the optional parameters for the HeaderClient.ResponseProtectedKey
//     method.
func (client *HeaderClient) ResponseProtectedKey(ctx context.Context, options *HeaderClientResponseProtectedKeyOptions) (HeaderClientResponseProtectedKeyResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseProtectedKey"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseProtectedKeyCreateRequest(ctx, options)
	if err != nil {
		return HeaderClientResponseProtectedKeyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseProtectedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseProtectedKeyResponse{}, err
	}
	resp, err := client.responseProtectedKeyHandleResponse(httpResp)
	return resp, err
}

// responseProtectedKeyCreateRequest creates the ResponseProtectedKey request.
func (client *HeaderClient) responseProtectedKeyCreateRequest(ctx context.Context, options *HeaderClientResponseProtectedKeyOptions) (*policy.Request, error) {
	urlPath := "/header/response/protectedkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseProtectedKeyHandleResponse handles the ResponseProtectedKey response.
func (client *HeaderClient) responseProtectedKeyHandleResponse(resp *http.Response) (HeaderClientResponseProtectedKeyResponse, error) {
	result := HeaderClientResponseProtectedKeyResponse{}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// ResponseString - Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientResponseStringOptions contains the optional parameters for the HeaderClient.ResponseString method.
func (client *HeaderClient) ResponseString(ctx context.Context, scenario string, options *HeaderClientResponseStringOptions) (HeaderClientResponseStringResponse, error) {
	var err error
	const operationName = "HeaderClient.ResponseString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.responseStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderClientResponseStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return HeaderClientResponseStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return HeaderClientResponseStringResponse{}, err
	}
	resp, err := client.responseStringHandleResponse(httpResp)
	return resp, err
}

// responseStringCreateRequest creates the ResponseString request.
func (client *HeaderClient) responseStringCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseStringOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/string"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["scenario"] = []string{scenario}
	return req, nil
}

// responseStringHandleResponse handles the ResponseString response.
func (client *HeaderClient) responseStringHandleResponse(resp *http.Response) (HeaderClientResponseStringResponse, error) {
	result := HeaderClientResponseStringResponse{}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return result, nil
}
