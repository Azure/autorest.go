//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"generatortests/headergroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"time"
)

// HeaderServer is a fake server for instances of the headergroup.HeaderClient type.
type HeaderServer struct {
	// CustomRequestID is the fake for method HeaderClient.CustomRequestID
	// HTTP status codes to indicate success: http.StatusOK
	CustomRequestID func(ctx context.Context, options *headergroup.HeaderClientCustomRequestIDOptions) (resp azfake.Responder[headergroup.HeaderClientCustomRequestIDResponse], errResp azfake.ErrorResponder)

	// ParamBool is the fake for method HeaderClient.ParamBool
	// HTTP status codes to indicate success: http.StatusOK
	ParamBool func(ctx context.Context, scenario string, value bool, options *headergroup.HeaderClientParamBoolOptions) (resp azfake.Responder[headergroup.HeaderClientParamBoolResponse], errResp azfake.ErrorResponder)

	// ParamByte is the fake for method HeaderClient.ParamByte
	// HTTP status codes to indicate success: http.StatusOK
	ParamByte func(ctx context.Context, scenario string, value []byte, options *headergroup.HeaderClientParamByteOptions) (resp azfake.Responder[headergroup.HeaderClientParamByteResponse], errResp azfake.ErrorResponder)

	// ParamDate is the fake for method HeaderClient.ParamDate
	// HTTP status codes to indicate success: http.StatusOK
	ParamDate func(ctx context.Context, scenario string, value time.Time, options *headergroup.HeaderClientParamDateOptions) (resp azfake.Responder[headergroup.HeaderClientParamDateResponse], errResp azfake.ErrorResponder)

	// ParamDatetime is the fake for method HeaderClient.ParamDatetime
	// HTTP status codes to indicate success: http.StatusOK
	ParamDatetime func(ctx context.Context, scenario string, value time.Time, options *headergroup.HeaderClientParamDatetimeOptions) (resp azfake.Responder[headergroup.HeaderClientParamDatetimeResponse], errResp azfake.ErrorResponder)

	// ParamDatetimeRFC1123 is the fake for method HeaderClient.ParamDatetimeRFC1123
	// HTTP status codes to indicate success: http.StatusOK
	ParamDatetimeRFC1123 func(ctx context.Context, scenario string, options *headergroup.HeaderClientParamDatetimeRFC1123Options) (resp azfake.Responder[headergroup.HeaderClientParamDatetimeRFC1123Response], errResp azfake.ErrorResponder)

	// ParamDouble is the fake for method HeaderClient.ParamDouble
	// HTTP status codes to indicate success: http.StatusOK
	ParamDouble func(ctx context.Context, scenario string, value float64, options *headergroup.HeaderClientParamDoubleOptions) (resp azfake.Responder[headergroup.HeaderClientParamDoubleResponse], errResp azfake.ErrorResponder)

	// ParamDuration is the fake for method HeaderClient.ParamDuration
	// HTTP status codes to indicate success: http.StatusOK
	ParamDuration func(ctx context.Context, scenario string, value string, options *headergroup.HeaderClientParamDurationOptions) (resp azfake.Responder[headergroup.HeaderClientParamDurationResponse], errResp azfake.ErrorResponder)

	// ParamEnum is the fake for method HeaderClient.ParamEnum
	// HTTP status codes to indicate success: http.StatusOK
	ParamEnum func(ctx context.Context, scenario string, options *headergroup.HeaderClientParamEnumOptions) (resp azfake.Responder[headergroup.HeaderClientParamEnumResponse], errResp azfake.ErrorResponder)

	// ParamExistingKey is the fake for method HeaderClient.ParamExistingKey
	// HTTP status codes to indicate success: http.StatusOK
	ParamExistingKey func(ctx context.Context, userAgent string, options *headergroup.HeaderClientParamExistingKeyOptions) (resp azfake.Responder[headergroup.HeaderClientParamExistingKeyResponse], errResp azfake.ErrorResponder)

	// ParamFloat is the fake for method HeaderClient.ParamFloat
	// HTTP status codes to indicate success: http.StatusOK
	ParamFloat func(ctx context.Context, scenario string, value float32, options *headergroup.HeaderClientParamFloatOptions) (resp azfake.Responder[headergroup.HeaderClientParamFloatResponse], errResp azfake.ErrorResponder)

	// ParamInteger is the fake for method HeaderClient.ParamInteger
	// HTTP status codes to indicate success: http.StatusOK
	ParamInteger func(ctx context.Context, scenario string, value int32, options *headergroup.HeaderClientParamIntegerOptions) (resp azfake.Responder[headergroup.HeaderClientParamIntegerResponse], errResp azfake.ErrorResponder)

	// ParamLong is the fake for method HeaderClient.ParamLong
	// HTTP status codes to indicate success: http.StatusOK
	ParamLong func(ctx context.Context, scenario string, value int64, options *headergroup.HeaderClientParamLongOptions) (resp azfake.Responder[headergroup.HeaderClientParamLongResponse], errResp azfake.ErrorResponder)

	// ParamProtectedKey is the fake for method HeaderClient.ParamProtectedKey
	// HTTP status codes to indicate success: http.StatusOK
	ParamProtectedKey func(ctx context.Context, contentType string, options *headergroup.HeaderClientParamProtectedKeyOptions) (resp azfake.Responder[headergroup.HeaderClientParamProtectedKeyResponse], errResp azfake.ErrorResponder)

	// ParamString is the fake for method HeaderClient.ParamString
	// HTTP status codes to indicate success: http.StatusOK
	ParamString func(ctx context.Context, scenario string, options *headergroup.HeaderClientParamStringOptions) (resp azfake.Responder[headergroup.HeaderClientParamStringResponse], errResp azfake.ErrorResponder)

	// ResponseBool is the fake for method HeaderClient.ResponseBool
	// HTTP status codes to indicate success: http.StatusOK
	ResponseBool func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseBoolOptions) (resp azfake.Responder[headergroup.HeaderClientResponseBoolResponse], errResp azfake.ErrorResponder)

	// ResponseByte is the fake for method HeaderClient.ResponseByte
	// HTTP status codes to indicate success: http.StatusOK
	ResponseByte func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseByteOptions) (resp azfake.Responder[headergroup.HeaderClientResponseByteResponse], errResp azfake.ErrorResponder)

	// ResponseDate is the fake for method HeaderClient.ResponseDate
	// HTTP status codes to indicate success: http.StatusOK
	ResponseDate func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseDateOptions) (resp azfake.Responder[headergroup.HeaderClientResponseDateResponse], errResp azfake.ErrorResponder)

	// ResponseDatetime is the fake for method HeaderClient.ResponseDatetime
	// HTTP status codes to indicate success: http.StatusOK
	ResponseDatetime func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseDatetimeOptions) (resp azfake.Responder[headergroup.HeaderClientResponseDatetimeResponse], errResp azfake.ErrorResponder)

	// ResponseDatetimeRFC1123 is the fake for method HeaderClient.ResponseDatetimeRFC1123
	// HTTP status codes to indicate success: http.StatusOK
	ResponseDatetimeRFC1123 func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseDatetimeRFC1123Options) (resp azfake.Responder[headergroup.HeaderClientResponseDatetimeRFC1123Response], errResp azfake.ErrorResponder)

	// ResponseDouble is the fake for method HeaderClient.ResponseDouble
	// HTTP status codes to indicate success: http.StatusOK
	ResponseDouble func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseDoubleOptions) (resp azfake.Responder[headergroup.HeaderClientResponseDoubleResponse], errResp azfake.ErrorResponder)

	// ResponseDuration is the fake for method HeaderClient.ResponseDuration
	// HTTP status codes to indicate success: http.StatusOK
	ResponseDuration func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseDurationOptions) (resp azfake.Responder[headergroup.HeaderClientResponseDurationResponse], errResp azfake.ErrorResponder)

	// ResponseEnum is the fake for method HeaderClient.ResponseEnum
	// HTTP status codes to indicate success: http.StatusOK
	ResponseEnum func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseEnumOptions) (resp azfake.Responder[headergroup.HeaderClientResponseEnumResponse], errResp azfake.ErrorResponder)

	// ResponseExistingKey is the fake for method HeaderClient.ResponseExistingKey
	// HTTP status codes to indicate success: http.StatusOK
	ResponseExistingKey func(ctx context.Context, options *headergroup.HeaderClientResponseExistingKeyOptions) (resp azfake.Responder[headergroup.HeaderClientResponseExistingKeyResponse], errResp azfake.ErrorResponder)

	// ResponseFloat is the fake for method HeaderClient.ResponseFloat
	// HTTP status codes to indicate success: http.StatusOK
	ResponseFloat func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseFloatOptions) (resp azfake.Responder[headergroup.HeaderClientResponseFloatResponse], errResp azfake.ErrorResponder)

	// ResponseInteger is the fake for method HeaderClient.ResponseInteger
	// HTTP status codes to indicate success: http.StatusOK
	ResponseInteger func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseIntegerOptions) (resp azfake.Responder[headergroup.HeaderClientResponseIntegerResponse], errResp azfake.ErrorResponder)

	// ResponseLong is the fake for method HeaderClient.ResponseLong
	// HTTP status codes to indicate success: http.StatusOK
	ResponseLong func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseLongOptions) (resp azfake.Responder[headergroup.HeaderClientResponseLongResponse], errResp azfake.ErrorResponder)

	// ResponseProtectedKey is the fake for method HeaderClient.ResponseProtectedKey
	// HTTP status codes to indicate success: http.StatusOK
	ResponseProtectedKey func(ctx context.Context, options *headergroup.HeaderClientResponseProtectedKeyOptions) (resp azfake.Responder[headergroup.HeaderClientResponseProtectedKeyResponse], errResp azfake.ErrorResponder)

	// ResponseString is the fake for method HeaderClient.ResponseString
	// HTTP status codes to indicate success: http.StatusOK
	ResponseString func(ctx context.Context, scenario string, options *headergroup.HeaderClientResponseStringOptions) (resp azfake.Responder[headergroup.HeaderClientResponseStringResponse], errResp azfake.ErrorResponder)
}

// NewHeaderServerTransport creates a new instance of HeaderServerTransport with the provided implementation.
// The returned HeaderServerTransport instance is connected to an instance of headergroup.HeaderClient by way of the
// undefined.Transporter field.
func NewHeaderServerTransport(srv *HeaderServer) *HeaderServerTransport {
	return &HeaderServerTransport{srv: srv}
}

// HeaderServerTransport connects instances of headergroup.HeaderClient to instances of HeaderServer.
// Don't use this type directly, use NewHeaderServerTransport instead.
type HeaderServerTransport struct {
	srv *HeaderServer
}

// Do implements the policy.Transporter interface for HeaderServerTransport.
func (h *HeaderServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "HeaderClient.CustomRequestID":
		resp, err = h.dispatchCustomRequestID(req)
	case "HeaderClient.ParamBool":
		resp, err = h.dispatchParamBool(req)
	case "HeaderClient.ParamByte":
		resp, err = h.dispatchParamByte(req)
	case "HeaderClient.ParamDate":
		resp, err = h.dispatchParamDate(req)
	case "HeaderClient.ParamDatetime":
		resp, err = h.dispatchParamDatetime(req)
	case "HeaderClient.ParamDatetimeRFC1123":
		resp, err = h.dispatchParamDatetimeRFC1123(req)
	case "HeaderClient.ParamDouble":
		resp, err = h.dispatchParamDouble(req)
	case "HeaderClient.ParamDuration":
		resp, err = h.dispatchParamDuration(req)
	case "HeaderClient.ParamEnum":
		resp, err = h.dispatchParamEnum(req)
	case "HeaderClient.ParamExistingKey":
		resp, err = h.dispatchParamExistingKey(req)
	case "HeaderClient.ParamFloat":
		resp, err = h.dispatchParamFloat(req)
	case "HeaderClient.ParamInteger":
		resp, err = h.dispatchParamInteger(req)
	case "HeaderClient.ParamLong":
		resp, err = h.dispatchParamLong(req)
	case "HeaderClient.ParamProtectedKey":
		resp, err = h.dispatchParamProtectedKey(req)
	case "HeaderClient.ParamString":
		resp, err = h.dispatchParamString(req)
	case "HeaderClient.ResponseBool":
		resp, err = h.dispatchResponseBool(req)
	case "HeaderClient.ResponseByte":
		resp, err = h.dispatchResponseByte(req)
	case "HeaderClient.ResponseDate":
		resp, err = h.dispatchResponseDate(req)
	case "HeaderClient.ResponseDatetime":
		resp, err = h.dispatchResponseDatetime(req)
	case "HeaderClient.ResponseDatetimeRFC1123":
		resp, err = h.dispatchResponseDatetimeRFC1123(req)
	case "HeaderClient.ResponseDouble":
		resp, err = h.dispatchResponseDouble(req)
	case "HeaderClient.ResponseDuration":
		resp, err = h.dispatchResponseDuration(req)
	case "HeaderClient.ResponseEnum":
		resp, err = h.dispatchResponseEnum(req)
	case "HeaderClient.ResponseExistingKey":
		resp, err = h.dispatchResponseExistingKey(req)
	case "HeaderClient.ResponseFloat":
		resp, err = h.dispatchResponseFloat(req)
	case "HeaderClient.ResponseInteger":
		resp, err = h.dispatchResponseInteger(req)
	case "HeaderClient.ResponseLong":
		resp, err = h.dispatchResponseLong(req)
	case "HeaderClient.ResponseProtectedKey":
		resp, err = h.dispatchResponseProtectedKey(req)
	case "HeaderClient.ResponseString":
		resp, err = h.dispatchResponseString(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (h *HeaderServerTransport) dispatchCustomRequestID(req *http.Request) (*http.Response, error) {
	if h.srv.CustomRequestID == nil {
		return nil, &nonRetriableError{errors.New("fake for method CustomRequestID not implemented")}
	}
	respr, errRespr := h.srv.CustomRequestID(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamBool(req *http.Request) (*http.Response, error) {
	if h.srv.ParamBool == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamBool not implemented")}
	}
	valueParam, err := strconv.ParseBool(getHeaderValue(req.Header, "value"))
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamBool(req.Context(), getHeaderValue(req.Header, "scenario"), valueParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamByte(req *http.Request) (*http.Response, error) {
	if h.srv.ParamByte == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamByte not implemented")}
	}
	valueParam, err := base64.StdEncoding.DecodeString(getHeaderValue(req.Header, "value"))
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamByte(req.Context(), getHeaderValue(req.Header, "scenario"), valueParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamDate(req *http.Request) (*http.Response, error) {
	if h.srv.ParamDate == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamDate not implemented")}
	}
	valueParam, err := time.Parse("2006-01-02", getHeaderValue(req.Header, "value"))
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamDate(req.Context(), getHeaderValue(req.Header, "scenario"), valueParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamDatetime(req *http.Request) (*http.Response, error) {
	if h.srv.ParamDatetime == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamDatetime not implemented")}
	}
	valueParam, err := time.Parse(time.RFC3339Nano, getHeaderValue(req.Header, "value"))
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamDatetime(req.Context(), getHeaderValue(req.Header, "scenario"), valueParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamDatetimeRFC1123(req *http.Request) (*http.Response, error) {
	if h.srv.ParamDatetimeRFC1123 == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamDatetimeRFC1123 not implemented")}
	}
	valueParam, err := parseOptional(getHeaderValue(req.Header, "value"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	var options *headergroup.HeaderClientParamDatetimeRFC1123Options
	if valueParam != nil {
		options = &headergroup.HeaderClientParamDatetimeRFC1123Options{
			Value: valueParam,
		}
	}
	respr, errRespr := h.srv.ParamDatetimeRFC1123(req.Context(), getHeaderValue(req.Header, "scenario"), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamDouble(req *http.Request) (*http.Response, error) {
	if h.srv.ParamDouble == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamDouble not implemented")}
	}
	valueParam, err := strconv.ParseFloat(getHeaderValue(req.Header, "value"), 64)
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamDouble(req.Context(), getHeaderValue(req.Header, "scenario"), valueParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamDuration(req *http.Request) (*http.Response, error) {
	if h.srv.ParamDuration == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamDuration not implemented")}
	}
	respr, errRespr := h.srv.ParamDuration(req.Context(), getHeaderValue(req.Header, "scenario"), getHeaderValue(req.Header, "value"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamEnum(req *http.Request) (*http.Response, error) {
	if h.srv.ParamEnum == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamEnum not implemented")}
	}
	valueParam := getOptional(headergroup.GreyscaleColors(getHeaderValue(req.Header, "value")))
	var options *headergroup.HeaderClientParamEnumOptions
	if valueParam != nil {
		options = &headergroup.HeaderClientParamEnumOptions{
			Value: valueParam,
		}
	}
	respr, errRespr := h.srv.ParamEnum(req.Context(), getHeaderValue(req.Header, "scenario"), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamExistingKey(req *http.Request) (*http.Response, error) {
	if h.srv.ParamExistingKey == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamExistingKey not implemented")}
	}
	respr, errRespr := h.srv.ParamExistingKey(req.Context(), getHeaderValue(req.Header, "User-Agent"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamFloat(req *http.Request) (*http.Response, error) {
	if h.srv.ParamFloat == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamFloat not implemented")}
	}
	valueParam, err := parseWithCast(getHeaderValue(req.Header, "value"), func(v string) (float32, error) {
		p, parseErr := strconv.ParseFloat(v, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return float32(p), nil
	})
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamFloat(req.Context(), getHeaderValue(req.Header, "scenario"), float32(valueParam), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamInteger(req *http.Request) (*http.Response, error) {
	if h.srv.ParamInteger == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamInteger not implemented")}
	}
	valueParam, err := parseWithCast(getHeaderValue(req.Header, "value"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamInteger(req.Context(), getHeaderValue(req.Header, "scenario"), int32(valueParam), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamLong(req *http.Request) (*http.Response, error) {
	if h.srv.ParamLong == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamLong not implemented")}
	}
	valueParam, err := strconv.ParseInt(getHeaderValue(req.Header, "value"), 10, 64)
	if err != nil {
		return nil, err
	}
	respr, errRespr := h.srv.ParamLong(req.Context(), getHeaderValue(req.Header, "scenario"), valueParam, nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamProtectedKey(req *http.Request) (*http.Response, error) {
	if h.srv.ParamProtectedKey == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamProtectedKey not implemented")}
	}
	respr, errRespr := h.srv.ParamProtectedKey(req.Context(), getHeaderValue(req.Header, "Content-Type"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchParamString(req *http.Request) (*http.Response, error) {
	if h.srv.ParamString == nil {
		return nil, &nonRetriableError{errors.New("fake for method ParamString not implemented")}
	}
	valueParam := getOptional(getHeaderValue(req.Header, "value"))
	var options *headergroup.HeaderClientParamStringOptions
	if valueParam != nil {
		options = &headergroup.HeaderClientParamStringOptions{
			Value: valueParam,
		}
	}
	respr, errRespr := h.srv.ParamString(req.Context(), getHeaderValue(req.Header, "scenario"), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseBool(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseBool == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseBool not implemented")}
	}
	respr, errRespr := h.srv.ResponseBool(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", strconv.FormatBool(*val))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseByte(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseByte == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseByte not implemented")}
	}
	respr, errRespr := h.srv.ResponseByte(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", base64.StdEncoding.EncodeToString(val))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseDate(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseDate == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseDate not implemented")}
	}
	respr, errRespr := h.srv.ResponseDate(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", val.Format("2006-01-02"))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseDatetime(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseDatetime == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseDatetime not implemented")}
	}
	respr, errRespr := h.srv.ResponseDatetime(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", val.Format(time.RFC3339Nano))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseDatetimeRFC1123(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseDatetimeRFC1123 == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseDatetimeRFC1123 not implemented")}
	}
	respr, errRespr := h.srv.ResponseDatetimeRFC1123(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseDouble(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseDouble == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseDouble not implemented")}
	}
	respr, errRespr := h.srv.ResponseDouble(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", strconv.FormatFloat(*val, 'f', -1, 64))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseDuration(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseDuration == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseDuration not implemented")}
	}
	respr, errRespr := h.srv.ResponseDuration(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", *val)
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseEnum(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseEnum == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseEnum not implemented")}
	}
	respr, errRespr := h.srv.ResponseEnum(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", string(*val))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseExistingKey(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseExistingKey == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseExistingKey not implemented")}
	}
	respr, errRespr := h.srv.ResponseExistingKey(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).UserAgent; val != nil {
		resp.Header.Set("User-Agent", *val)
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseFloat(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseFloat == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseFloat not implemented")}
	}
	respr, errRespr := h.srv.ResponseFloat(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", strconv.FormatFloat(float64(*val), 'f', -1, 32))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseInteger(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseInteger == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseInteger not implemented")}
	}
	respr, errRespr := h.srv.ResponseInteger(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", strconv.FormatInt(int64(*val), 10))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseLong(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseLong == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseLong not implemented")}
	}
	respr, errRespr := h.srv.ResponseLong(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", strconv.FormatInt(*val, 10))
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseProtectedKey(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseProtectedKey == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseProtectedKey not implemented")}
	}
	respr, errRespr := h.srv.ResponseProtectedKey(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ContentType; val != nil {
		resp.Header.Set("Content-Type", *val)
	}
	return resp, nil
}

func (h *HeaderServerTransport) dispatchResponseString(req *http.Request) (*http.Response, error) {
	if h.srv.ResponseString == nil {
		return nil, &nonRetriableError{errors.New("fake for method ResponseString not implemented")}
	}
	respr, errRespr := h.srv.ResponseString(req.Context(), getHeaderValue(req.Header, "scenario"), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Value; val != nil {
		resp.Header.Set("value", *val)
	}
	return resp, nil
}
