//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	"generatortests/urlgroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"regexp"
)

// PathItemsServer is a fake server for instances of the urlgroup.PathItemsClient type.
type PathItemsServer struct {
	// GetAllWithValues is the fake for method PathItemsClient.GetAllWithValues
	// HTTP status codes to indicate success: http.StatusOK
	GetAllWithValues func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetAllWithValuesOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetAllWithValuesResponse], errResp azfake.ErrorResponder)

	// GetGlobalAndLocalQueryNull is the fake for method PathItemsClient.GetGlobalAndLocalQueryNull
	// HTTP status codes to indicate success: http.StatusOK
	GetGlobalAndLocalQueryNull func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetGlobalAndLocalQueryNullOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetGlobalAndLocalQueryNullResponse], errResp azfake.ErrorResponder)

	// GetGlobalQueryNull is the fake for method PathItemsClient.GetGlobalQueryNull
	// HTTP status codes to indicate success: http.StatusOK
	GetGlobalQueryNull func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetGlobalQueryNullOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetGlobalQueryNullResponse], errResp azfake.ErrorResponder)

	// GetLocalPathItemQueryNull is the fake for method PathItemsClient.GetLocalPathItemQueryNull
	// HTTP status codes to indicate success: http.StatusOK
	GetLocalPathItemQueryNull func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetLocalPathItemQueryNullOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetLocalPathItemQueryNullResponse], errResp azfake.ErrorResponder)
}

// NewPathItemsServerTransport creates a new instance of PathItemsServerTransport with the provided implementation.
// The returned PathItemsServerTransport instance is connected to an instance of urlgroup.PathItemsClient by way of the
// undefined.Transporter field.
func NewPathItemsServerTransport(srv *PathItemsServer) *PathItemsServerTransport {
	return &PathItemsServerTransport{srv: srv}
}

// PathItemsServerTransport connects instances of urlgroup.PathItemsClient to instances of PathItemsServer.
// Don't use this type directly, use NewPathItemsServerTransport instead.
type PathItemsServerTransport struct {
	srv *PathItemsServer
}

// Do implements the policy.Transporter interface for PathItemsServerTransport.
func (p *PathItemsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "PathItemsClient.GetAllWithValues":
		resp, err = p.dispatchGetAllWithValues(req)
	case "PathItemsClient.GetGlobalAndLocalQueryNull":
		resp, err = p.dispatchGetGlobalAndLocalQueryNull(req)
	case "PathItemsClient.GetGlobalQueryNull":
		resp, err = p.dispatchGetGlobalQueryNull(req)
	case "PathItemsClient.GetLocalPathItemQueryNull":
		resp, err = p.dispatchGetLocalPathItemQueryNull(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetAllWithValues(req *http.Request) (*http.Response, error) {
	if p.srv.GetAllWithValues == nil {
		return nil, &nonRetriableError{errors.New("method GetAllWithValues not implemented")}
	}
	const regexStr = "/pathitem/nullable/globalStringPath/(?P<globalStringPath>[a-zA-Z0-9-_]+)/pathItemStringPath/(?P<pathItemStringPath>[a-zA-Z0-9-_]+)/localStringPath/(?P<localStringPath>[a-zA-Z0-9-_]+)/globalStringQuery/pathItemStringQuery/localStringQuery"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringQueryParam := getOptional(qp.Get("pathItemStringQuery"))
	localStringQueryParam := getOptional(qp.Get("localStringQuery"))
	var options *urlgroup.PathItemsClientGetAllWithValuesOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetAllWithValuesOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetAllWithValues(req.Context(), matches[regex.SubexpIndex("pathItemStringPath")], matches[regex.SubexpIndex("localStringPath")], options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetGlobalAndLocalQueryNull(req *http.Request) (*http.Response, error) {
	if p.srv.GetGlobalAndLocalQueryNull == nil {
		return nil, &nonRetriableError{errors.New("method GetGlobalAndLocalQueryNull not implemented")}
	}
	const regexStr = "/pathitem/nullable/globalStringPath/(?P<globalStringPath>[a-zA-Z0-9-_]+)/pathItemStringPath/(?P<pathItemStringPath>[a-zA-Z0-9-_]+)/localStringPath/(?P<localStringPath>[a-zA-Z0-9-_]+)/null/pathItemStringQuery/null"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringQueryParam := getOptional(qp.Get("pathItemStringQuery"))
	localStringQueryParam := getOptional(qp.Get("localStringQuery"))
	var options *urlgroup.PathItemsClientGetGlobalAndLocalQueryNullOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetGlobalAndLocalQueryNullOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetGlobalAndLocalQueryNull(req.Context(), matches[regex.SubexpIndex("pathItemStringPath")], matches[regex.SubexpIndex("localStringPath")], options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetGlobalQueryNull(req *http.Request) (*http.Response, error) {
	if p.srv.GetGlobalQueryNull == nil {
		return nil, &nonRetriableError{errors.New("method GetGlobalQueryNull not implemented")}
	}
	const regexStr = "/pathitem/nullable/globalStringPath/(?P<globalStringPath>[a-zA-Z0-9-_]+)/pathItemStringPath/(?P<pathItemStringPath>[a-zA-Z0-9-_]+)/localStringPath/(?P<localStringPath>[a-zA-Z0-9-_]+)/null/pathItemStringQuery/localStringQuery"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringQueryParam := getOptional(qp.Get("pathItemStringQuery"))
	localStringQueryParam := getOptional(qp.Get("localStringQuery"))
	var options *urlgroup.PathItemsClientGetGlobalQueryNullOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetGlobalQueryNullOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetGlobalQueryNull(req.Context(), matches[regex.SubexpIndex("pathItemStringPath")], matches[regex.SubexpIndex("localStringPath")], options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetLocalPathItemQueryNull(req *http.Request) (*http.Response, error) {
	if p.srv.GetLocalPathItemQueryNull == nil {
		return nil, &nonRetriableError{errors.New("method GetLocalPathItemQueryNull not implemented")}
	}
	const regexStr = "/pathitem/nullable/globalStringPath/(?P<globalStringPath>[a-zA-Z0-9-_]+)/pathItemStringPath/(?P<pathItemStringPath>[a-zA-Z0-9-_]+)/localStringPath/(?P<localStringPath>[a-zA-Z0-9-_]+)/globalStringQuery/null/null"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringQueryParam := getOptional(qp.Get("pathItemStringQuery"))
	localStringQueryParam := getOptional(qp.Get("localStringQuery"))
	var options *urlgroup.PathItemsClientGetLocalPathItemQueryNullOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetLocalPathItemQueryNullOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetLocalPathItemQueryNull(req.Context(), matches[regex.SubexpIndex("pathItemStringPath")], matches[regex.SubexpIndex("localStringPath")], options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
