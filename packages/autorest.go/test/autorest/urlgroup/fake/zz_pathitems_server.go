// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"errors"
	"fmt"
	"generatortests/urlgroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"regexp"
)

// PathItemsServer is a fake server for instances of the urlgroup.PathItemsClient type.
type PathItemsServer struct {
	// GetAllWithValues is the fake for method PathItemsClient.GetAllWithValues
	// HTTP status codes to indicate success: http.StatusOK
	GetAllWithValues func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetAllWithValuesOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetAllWithValuesResponse], errResp azfake.ErrorResponder)

	// GetGlobalAndLocalQueryNull is the fake for method PathItemsClient.GetGlobalAndLocalQueryNull
	// HTTP status codes to indicate success: http.StatusOK
	GetGlobalAndLocalQueryNull func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetGlobalAndLocalQueryNullOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetGlobalAndLocalQueryNullResponse], errResp azfake.ErrorResponder)

	// GetGlobalQueryNull is the fake for method PathItemsClient.GetGlobalQueryNull
	// HTTP status codes to indicate success: http.StatusOK
	GetGlobalQueryNull func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetGlobalQueryNullOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetGlobalQueryNullResponse], errResp azfake.ErrorResponder)

	// GetLocalPathItemQueryNull is the fake for method PathItemsClient.GetLocalPathItemQueryNull
	// HTTP status codes to indicate success: http.StatusOK
	GetLocalPathItemQueryNull func(ctx context.Context, pathItemStringPath string, localStringPath string, options *urlgroup.PathItemsClientGetLocalPathItemQueryNullOptions) (resp azfake.Responder[urlgroup.PathItemsClientGetLocalPathItemQueryNullResponse], errResp azfake.ErrorResponder)
}

// NewPathItemsServerTransport creates a new instance of PathItemsServerTransport with the provided implementation.
// The returned PathItemsServerTransport instance is connected to an instance of urlgroup.PathItemsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewPathItemsServerTransport(srv *PathItemsServer) *PathItemsServerTransport {
	return &PathItemsServerTransport{srv: srv}
}

// PathItemsServerTransport connects instances of urlgroup.PathItemsClient to instances of PathItemsServer.
// Don't use this type directly, use NewPathItemsServerTransport instead.
type PathItemsServerTransport struct {
	srv *PathItemsServer
}

// Do implements the policy.Transporter interface for PathItemsServerTransport.
func (p *PathItemsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return p.dispatchToMethodFake(req, method)
}

func (p *PathItemsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var res result
		switch method {
		case "PathItemsClient.GetAllWithValues":
			res.resp, res.err = p.dispatchGetAllWithValues(req)
		case "PathItemsClient.GetGlobalAndLocalQueryNull":
			res.resp, res.err = p.dispatchGetGlobalAndLocalQueryNull(req)
		case "PathItemsClient.GetGlobalQueryNull":
			res.resp, res.err = p.dispatchGetGlobalQueryNull(req)
		case "PathItemsClient.GetLocalPathItemQueryNull":
			res.resp, res.err = p.dispatchGetLocalPathItemQueryNull(req)
		default:
			res.err = fmt.Errorf("unhandled API %s", method)
		}

		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (p *PathItemsServerTransport) dispatchGetAllWithValues(req *http.Request) (*http.Response, error) {
	if p.srv.GetAllWithValues == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetAllWithValues not implemented")}
	}
	const regexStr = `/pathitem/nullable/globalStringPath/(?P<globalStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/pathItemStringPath/(?P<pathItemStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/localStringPath/(?P<localStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/globalStringQuery/pathItemStringQuery/localStringQuery`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("pathItemStringPath")])
	if err != nil {
		return nil, err
	}
	pathItemStringQueryUnescaped, err := url.QueryUnescape(qp.Get("pathItemStringQuery"))
	if err != nil {
		return nil, err
	}
	pathItemStringQueryParam := getOptional(pathItemStringQueryUnescaped)
	localStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("localStringPath")])
	if err != nil {
		return nil, err
	}
	localStringQueryUnescaped, err := url.QueryUnescape(qp.Get("localStringQuery"))
	if err != nil {
		return nil, err
	}
	localStringQueryParam := getOptional(localStringQueryUnescaped)
	var options *urlgroup.PathItemsClientGetAllWithValuesOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetAllWithValuesOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetAllWithValues(req.Context(), pathItemStringPathParam, localStringPathParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetGlobalAndLocalQueryNull(req *http.Request) (*http.Response, error) {
	if p.srv.GetGlobalAndLocalQueryNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetGlobalAndLocalQueryNull not implemented")}
	}
	const regexStr = `/pathitem/nullable/globalStringPath/(?P<globalStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/pathItemStringPath/(?P<pathItemStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/localStringPath/(?P<localStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/null/pathItemStringQuery/null`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("pathItemStringPath")])
	if err != nil {
		return nil, err
	}
	pathItemStringQueryUnescaped, err := url.QueryUnescape(qp.Get("pathItemStringQuery"))
	if err != nil {
		return nil, err
	}
	pathItemStringQueryParam := getOptional(pathItemStringQueryUnescaped)
	localStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("localStringPath")])
	if err != nil {
		return nil, err
	}
	localStringQueryUnescaped, err := url.QueryUnescape(qp.Get("localStringQuery"))
	if err != nil {
		return nil, err
	}
	localStringQueryParam := getOptional(localStringQueryUnescaped)
	var options *urlgroup.PathItemsClientGetGlobalAndLocalQueryNullOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetGlobalAndLocalQueryNullOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetGlobalAndLocalQueryNull(req.Context(), pathItemStringPathParam, localStringPathParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetGlobalQueryNull(req *http.Request) (*http.Response, error) {
	if p.srv.GetGlobalQueryNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetGlobalQueryNull not implemented")}
	}
	const regexStr = `/pathitem/nullable/globalStringPath/(?P<globalStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/pathItemStringPath/(?P<pathItemStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/localStringPath/(?P<localStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/null/pathItemStringQuery/localStringQuery`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("pathItemStringPath")])
	if err != nil {
		return nil, err
	}
	pathItemStringQueryUnescaped, err := url.QueryUnescape(qp.Get("pathItemStringQuery"))
	if err != nil {
		return nil, err
	}
	pathItemStringQueryParam := getOptional(pathItemStringQueryUnescaped)
	localStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("localStringPath")])
	if err != nil {
		return nil, err
	}
	localStringQueryUnescaped, err := url.QueryUnescape(qp.Get("localStringQuery"))
	if err != nil {
		return nil, err
	}
	localStringQueryParam := getOptional(localStringQueryUnescaped)
	var options *urlgroup.PathItemsClientGetGlobalQueryNullOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetGlobalQueryNullOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetGlobalQueryNull(req.Context(), pathItemStringPathParam, localStringPathParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (p *PathItemsServerTransport) dispatchGetLocalPathItemQueryNull(req *http.Request) (*http.Response, error) {
	if p.srv.GetLocalPathItemQueryNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetLocalPathItemQueryNull not implemented")}
	}
	const regexStr = `/pathitem/nullable/globalStringPath/(?P<globalStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/pathItemStringPath/(?P<pathItemStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/localStringPath/(?P<localStringPath>[!#&$-;=?-\[\]_a-zA-Z0-9~%@]+)/globalStringQuery/null/null`
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.EscapedPath())
	if matches == nil || len(matches) < 3 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	pathItemStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("pathItemStringPath")])
	if err != nil {
		return nil, err
	}
	pathItemStringQueryUnescaped, err := url.QueryUnescape(qp.Get("pathItemStringQuery"))
	if err != nil {
		return nil, err
	}
	pathItemStringQueryParam := getOptional(pathItemStringQueryUnescaped)
	localStringPathParam, err := url.PathUnescape(matches[regex.SubexpIndex("localStringPath")])
	if err != nil {
		return nil, err
	}
	localStringQueryUnescaped, err := url.QueryUnescape(qp.Get("localStringQuery"))
	if err != nil {
		return nil, err
	}
	localStringQueryParam := getOptional(localStringQueryUnescaped)
	var options *urlgroup.PathItemsClientGetLocalPathItemQueryNullOptions
	if pathItemStringQueryParam != nil || localStringQueryParam != nil {
		options = &urlgroup.PathItemsClientGetLocalPathItemQueryNullOptions{
			PathItemStringQuery: pathItemStringQueryParam,
			LocalStringQuery:    localStringQueryParam,
		}
	}
	respr, errRespr := p.srv.GetLocalPathItemQueryNull(req.Context(), pathItemStringPathParam, localStringPathParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
