//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"generatortests/urlgroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// QueriesServer is a fake server for instances of the urlgroup.QueriesClient type.
type QueriesServer struct {
	// ArrayStringCSVEmpty is the fake for method QueriesClient.ArrayStringCSVEmpty
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringCSVEmpty func(ctx context.Context, options *urlgroup.QueriesClientArrayStringCSVEmptyOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringCSVEmptyResponse], errResp azfake.ErrorResponder)

	// ArrayStringCSVNull is the fake for method QueriesClient.ArrayStringCSVNull
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringCSVNull func(ctx context.Context, options *urlgroup.QueriesClientArrayStringCSVNullOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringCSVNullResponse], errResp azfake.ErrorResponder)

	// ArrayStringCSVValid is the fake for method QueriesClient.ArrayStringCSVValid
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringCSVValid func(ctx context.Context, options *urlgroup.QueriesClientArrayStringCSVValidOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringCSVValidResponse], errResp azfake.ErrorResponder)

	// ArrayStringNoCollectionFormatEmpty is the fake for method QueriesClient.ArrayStringNoCollectionFormatEmpty
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringNoCollectionFormatEmpty func(ctx context.Context, options *urlgroup.QueriesClientArrayStringNoCollectionFormatEmptyOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringNoCollectionFormatEmptyResponse], errResp azfake.ErrorResponder)

	// ArrayStringPipesValid is the fake for method QueriesClient.ArrayStringPipesValid
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringPipesValid func(ctx context.Context, options *urlgroup.QueriesClientArrayStringPipesValidOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringPipesValidResponse], errResp azfake.ErrorResponder)

	// ArrayStringSsvValid is the fake for method QueriesClient.ArrayStringSsvValid
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringSsvValid func(ctx context.Context, options *urlgroup.QueriesClientArrayStringSsvValidOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringSsvValidResponse], errResp azfake.ErrorResponder)

	// ArrayStringTsvValid is the fake for method QueriesClient.ArrayStringTsvValid
	// HTTP status codes to indicate success: http.StatusOK
	ArrayStringTsvValid func(ctx context.Context, options *urlgroup.QueriesClientArrayStringTsvValidOptions) (resp azfake.Responder[urlgroup.QueriesClientArrayStringTsvValidResponse], errResp azfake.ErrorResponder)

	// ByteEmpty is the fake for method QueriesClient.ByteEmpty
	// HTTP status codes to indicate success: http.StatusOK
	ByteEmpty func(ctx context.Context, options *urlgroup.QueriesClientByteEmptyOptions) (resp azfake.Responder[urlgroup.QueriesClientByteEmptyResponse], errResp azfake.ErrorResponder)

	// ByteMultiByte is the fake for method QueriesClient.ByteMultiByte
	// HTTP status codes to indicate success: http.StatusOK
	ByteMultiByte func(ctx context.Context, options *urlgroup.QueriesClientByteMultiByteOptions) (resp azfake.Responder[urlgroup.QueriesClientByteMultiByteResponse], errResp azfake.ErrorResponder)

	// ByteNull is the fake for method QueriesClient.ByteNull
	// HTTP status codes to indicate success: http.StatusOK
	ByteNull func(ctx context.Context, options *urlgroup.QueriesClientByteNullOptions) (resp azfake.Responder[urlgroup.QueriesClientByteNullResponse], errResp azfake.ErrorResponder)

	// DateNull is the fake for method QueriesClient.DateNull
	// HTTP status codes to indicate success: http.StatusOK
	DateNull func(ctx context.Context, options *urlgroup.QueriesClientDateNullOptions) (resp azfake.Responder[urlgroup.QueriesClientDateNullResponse], errResp azfake.ErrorResponder)

	// DateTimeNull is the fake for method QueriesClient.DateTimeNull
	// HTTP status codes to indicate success: http.StatusOK
	DateTimeNull func(ctx context.Context, options *urlgroup.QueriesClientDateTimeNullOptions) (resp azfake.Responder[urlgroup.QueriesClientDateTimeNullResponse], errResp azfake.ErrorResponder)

	// DateTimeValid is the fake for method QueriesClient.DateTimeValid
	// HTTP status codes to indicate success: http.StatusOK
	DateTimeValid func(ctx context.Context, options *urlgroup.QueriesClientDateTimeValidOptions) (resp azfake.Responder[urlgroup.QueriesClientDateTimeValidResponse], errResp azfake.ErrorResponder)

	// DateValid is the fake for method QueriesClient.DateValid
	// HTTP status codes to indicate success: http.StatusOK
	DateValid func(ctx context.Context, options *urlgroup.QueriesClientDateValidOptions) (resp azfake.Responder[urlgroup.QueriesClientDateValidResponse], errResp azfake.ErrorResponder)

	// DoubleDecimalNegative is the fake for method QueriesClient.DoubleDecimalNegative
	// HTTP status codes to indicate success: http.StatusOK
	DoubleDecimalNegative func(ctx context.Context, options *urlgroup.QueriesClientDoubleDecimalNegativeOptions) (resp azfake.Responder[urlgroup.QueriesClientDoubleDecimalNegativeResponse], errResp azfake.ErrorResponder)

	// DoubleDecimalPositive is the fake for method QueriesClient.DoubleDecimalPositive
	// HTTP status codes to indicate success: http.StatusOK
	DoubleDecimalPositive func(ctx context.Context, options *urlgroup.QueriesClientDoubleDecimalPositiveOptions) (resp azfake.Responder[urlgroup.QueriesClientDoubleDecimalPositiveResponse], errResp azfake.ErrorResponder)

	// DoubleNull is the fake for method QueriesClient.DoubleNull
	// HTTP status codes to indicate success: http.StatusOK
	DoubleNull func(ctx context.Context, options *urlgroup.QueriesClientDoubleNullOptions) (resp azfake.Responder[urlgroup.QueriesClientDoubleNullResponse], errResp azfake.ErrorResponder)

	// EnumNull is the fake for method QueriesClient.EnumNull
	// HTTP status codes to indicate success: http.StatusOK
	EnumNull func(ctx context.Context, options *urlgroup.QueriesClientEnumNullOptions) (resp azfake.Responder[urlgroup.QueriesClientEnumNullResponse], errResp azfake.ErrorResponder)

	// EnumValid is the fake for method QueriesClient.EnumValid
	// HTTP status codes to indicate success: http.StatusOK
	EnumValid func(ctx context.Context, options *urlgroup.QueriesClientEnumValidOptions) (resp azfake.Responder[urlgroup.QueriesClientEnumValidResponse], errResp azfake.ErrorResponder)

	// FloatNull is the fake for method QueriesClient.FloatNull
	// HTTP status codes to indicate success: http.StatusOK
	FloatNull func(ctx context.Context, options *urlgroup.QueriesClientFloatNullOptions) (resp azfake.Responder[urlgroup.QueriesClientFloatNullResponse], errResp azfake.ErrorResponder)

	// FloatScientificNegative is the fake for method QueriesClient.FloatScientificNegative
	// HTTP status codes to indicate success: http.StatusOK
	FloatScientificNegative func(ctx context.Context, options *urlgroup.QueriesClientFloatScientificNegativeOptions) (resp azfake.Responder[urlgroup.QueriesClientFloatScientificNegativeResponse], errResp azfake.ErrorResponder)

	// FloatScientificPositive is the fake for method QueriesClient.FloatScientificPositive
	// HTTP status codes to indicate success: http.StatusOK
	FloatScientificPositive func(ctx context.Context, options *urlgroup.QueriesClientFloatScientificPositiveOptions) (resp azfake.Responder[urlgroup.QueriesClientFloatScientificPositiveResponse], errResp azfake.ErrorResponder)

	// GetBooleanFalse is the fake for method QueriesClient.GetBooleanFalse
	// HTTP status codes to indicate success: http.StatusOK
	GetBooleanFalse func(ctx context.Context, options *urlgroup.QueriesClientGetBooleanFalseOptions) (resp azfake.Responder[urlgroup.QueriesClientGetBooleanFalseResponse], errResp azfake.ErrorResponder)

	// GetBooleanNull is the fake for method QueriesClient.GetBooleanNull
	// HTTP status codes to indicate success: http.StatusOK
	GetBooleanNull func(ctx context.Context, options *urlgroup.QueriesClientGetBooleanNullOptions) (resp azfake.Responder[urlgroup.QueriesClientGetBooleanNullResponse], errResp azfake.ErrorResponder)

	// GetBooleanTrue is the fake for method QueriesClient.GetBooleanTrue
	// HTTP status codes to indicate success: http.StatusOK
	GetBooleanTrue func(ctx context.Context, options *urlgroup.QueriesClientGetBooleanTrueOptions) (resp azfake.Responder[urlgroup.QueriesClientGetBooleanTrueResponse], errResp azfake.ErrorResponder)

	// GetIntNegativeOneMillion is the fake for method QueriesClient.GetIntNegativeOneMillion
	// HTTP status codes to indicate success: http.StatusOK
	GetIntNegativeOneMillion func(ctx context.Context, options *urlgroup.QueriesClientGetIntNegativeOneMillionOptions) (resp azfake.Responder[urlgroup.QueriesClientGetIntNegativeOneMillionResponse], errResp azfake.ErrorResponder)

	// GetIntNull is the fake for method QueriesClient.GetIntNull
	// HTTP status codes to indicate success: http.StatusOK
	GetIntNull func(ctx context.Context, options *urlgroup.QueriesClientGetIntNullOptions) (resp azfake.Responder[urlgroup.QueriesClientGetIntNullResponse], errResp azfake.ErrorResponder)

	// GetIntOneMillion is the fake for method QueriesClient.GetIntOneMillion
	// HTTP status codes to indicate success: http.StatusOK
	GetIntOneMillion func(ctx context.Context, options *urlgroup.QueriesClientGetIntOneMillionOptions) (resp azfake.Responder[urlgroup.QueriesClientGetIntOneMillionResponse], errResp azfake.ErrorResponder)

	// GetLongNull is the fake for method QueriesClient.GetLongNull
	// HTTP status codes to indicate success: http.StatusOK
	GetLongNull func(ctx context.Context, options *urlgroup.QueriesClientGetLongNullOptions) (resp azfake.Responder[urlgroup.QueriesClientGetLongNullResponse], errResp azfake.ErrorResponder)

	// GetNegativeTenBillion is the fake for method QueriesClient.GetNegativeTenBillion
	// HTTP status codes to indicate success: http.StatusOK
	GetNegativeTenBillion func(ctx context.Context, options *urlgroup.QueriesClientGetNegativeTenBillionOptions) (resp azfake.Responder[urlgroup.QueriesClientGetNegativeTenBillionResponse], errResp azfake.ErrorResponder)

	// GetTenBillion is the fake for method QueriesClient.GetTenBillion
	// HTTP status codes to indicate success: http.StatusOK
	GetTenBillion func(ctx context.Context, options *urlgroup.QueriesClientGetTenBillionOptions) (resp azfake.Responder[urlgroup.QueriesClientGetTenBillionResponse], errResp azfake.ErrorResponder)

	// StringEmpty is the fake for method QueriesClient.StringEmpty
	// HTTP status codes to indicate success: http.StatusOK
	StringEmpty func(ctx context.Context, options *urlgroup.QueriesClientStringEmptyOptions) (resp azfake.Responder[urlgroup.QueriesClientStringEmptyResponse], errResp azfake.ErrorResponder)

	// StringNull is the fake for method QueriesClient.StringNull
	// HTTP status codes to indicate success: http.StatusOK
	StringNull func(ctx context.Context, options *urlgroup.QueriesClientStringNullOptions) (resp azfake.Responder[urlgroup.QueriesClientStringNullResponse], errResp azfake.ErrorResponder)

	// StringURLEncoded is the fake for method QueriesClient.StringURLEncoded
	// HTTP status codes to indicate success: http.StatusOK
	StringURLEncoded func(ctx context.Context, options *urlgroup.QueriesClientStringURLEncodedOptions) (resp azfake.Responder[urlgroup.QueriesClientStringURLEncodedResponse], errResp azfake.ErrorResponder)

	// StringUnicode is the fake for method QueriesClient.StringUnicode
	// HTTP status codes to indicate success: http.StatusOK
	StringUnicode func(ctx context.Context, options *urlgroup.QueriesClientStringUnicodeOptions) (resp azfake.Responder[urlgroup.QueriesClientStringUnicodeResponse], errResp azfake.ErrorResponder)
}

// NewQueriesServerTransport creates a new instance of QueriesServerTransport with the provided implementation.
// The returned QueriesServerTransport instance is connected to an instance of urlgroup.QueriesClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewQueriesServerTransport(srv *QueriesServer) *QueriesServerTransport {
	return &QueriesServerTransport{srv: srv}
}

// QueriesServerTransport connects instances of urlgroup.QueriesClient to instances of QueriesServer.
// Don't use this type directly, use NewQueriesServerTransport instead.
type QueriesServerTransport struct {
	srv *QueriesServer
}

// Do implements the policy.Transporter interface for QueriesServerTransport.
func (q *QueriesServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "QueriesClient.ArrayStringCSVEmpty":
		resp, err = q.dispatchArrayStringCSVEmpty(req)
	case "QueriesClient.ArrayStringCSVNull":
		resp, err = q.dispatchArrayStringCSVNull(req)
	case "QueriesClient.ArrayStringCSVValid":
		resp, err = q.dispatchArrayStringCSVValid(req)
	case "QueriesClient.ArrayStringNoCollectionFormatEmpty":
		resp, err = q.dispatchArrayStringNoCollectionFormatEmpty(req)
	case "QueriesClient.ArrayStringPipesValid":
		resp, err = q.dispatchArrayStringPipesValid(req)
	case "QueriesClient.ArrayStringSsvValid":
		resp, err = q.dispatchArrayStringSsvValid(req)
	case "QueriesClient.ArrayStringTsvValid":
		resp, err = q.dispatchArrayStringTsvValid(req)
	case "QueriesClient.ByteEmpty":
		resp, err = q.dispatchByteEmpty(req)
	case "QueriesClient.ByteMultiByte":
		resp, err = q.dispatchByteMultiByte(req)
	case "QueriesClient.ByteNull":
		resp, err = q.dispatchByteNull(req)
	case "QueriesClient.DateNull":
		resp, err = q.dispatchDateNull(req)
	case "QueriesClient.DateTimeNull":
		resp, err = q.dispatchDateTimeNull(req)
	case "QueriesClient.DateTimeValid":
		resp, err = q.dispatchDateTimeValid(req)
	case "QueriesClient.DateValid":
		resp, err = q.dispatchDateValid(req)
	case "QueriesClient.DoubleDecimalNegative":
		resp, err = q.dispatchDoubleDecimalNegative(req)
	case "QueriesClient.DoubleDecimalPositive":
		resp, err = q.dispatchDoubleDecimalPositive(req)
	case "QueriesClient.DoubleNull":
		resp, err = q.dispatchDoubleNull(req)
	case "QueriesClient.EnumNull":
		resp, err = q.dispatchEnumNull(req)
	case "QueriesClient.EnumValid":
		resp, err = q.dispatchEnumValid(req)
	case "QueriesClient.FloatNull":
		resp, err = q.dispatchFloatNull(req)
	case "QueriesClient.FloatScientificNegative":
		resp, err = q.dispatchFloatScientificNegative(req)
	case "QueriesClient.FloatScientificPositive":
		resp, err = q.dispatchFloatScientificPositive(req)
	case "QueriesClient.GetBooleanFalse":
		resp, err = q.dispatchGetBooleanFalse(req)
	case "QueriesClient.GetBooleanNull":
		resp, err = q.dispatchGetBooleanNull(req)
	case "QueriesClient.GetBooleanTrue":
		resp, err = q.dispatchGetBooleanTrue(req)
	case "QueriesClient.GetIntNegativeOneMillion":
		resp, err = q.dispatchGetIntNegativeOneMillion(req)
	case "QueriesClient.GetIntNull":
		resp, err = q.dispatchGetIntNull(req)
	case "QueriesClient.GetIntOneMillion":
		resp, err = q.dispatchGetIntOneMillion(req)
	case "QueriesClient.GetLongNull":
		resp, err = q.dispatchGetLongNull(req)
	case "QueriesClient.GetNegativeTenBillion":
		resp, err = q.dispatchGetNegativeTenBillion(req)
	case "QueriesClient.GetTenBillion":
		resp, err = q.dispatchGetTenBillion(req)
	case "QueriesClient.StringEmpty":
		resp, err = q.dispatchStringEmpty(req)
	case "QueriesClient.StringNull":
		resp, err = q.dispatchStringNull(req)
	case "QueriesClient.StringURLEncoded":
		resp, err = q.dispatchStringURLEncoded(req)
	case "QueriesClient.StringUnicode":
		resp, err = q.dispatchStringUnicode(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringCSVEmpty(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringCSVEmpty == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringCSVEmpty not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, ",")
	var options *urlgroup.QueriesClientArrayStringCSVEmptyOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringCSVEmptyOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringCSVEmpty(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringCSVNull(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringCSVNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringCSVNull not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, ",")
	var options *urlgroup.QueriesClientArrayStringCSVNullOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringCSVNullOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringCSVNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringCSVValid(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringCSVValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringCSVValid not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, ",")
	var options *urlgroup.QueriesClientArrayStringCSVValidOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringCSVValidOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringCSVValid(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringNoCollectionFormatEmpty(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringNoCollectionFormatEmpty == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringNoCollectionFormatEmpty not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, ",")
	var options *urlgroup.QueriesClientArrayStringNoCollectionFormatEmptyOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringNoCollectionFormatEmptyOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringNoCollectionFormatEmpty(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringPipesValid(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringPipesValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringPipesValid not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, "|")
	var options *urlgroup.QueriesClientArrayStringPipesValidOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringPipesValidOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringPipesValid(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringSsvValid(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringSsvValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringSsvValid not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, " ")
	var options *urlgroup.QueriesClientArrayStringSsvValidOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringSsvValidOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringSsvValid(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchArrayStringTsvValid(req *http.Request) (*http.Response, error) {
	if q.srv.ArrayStringTsvValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method ArrayStringTsvValid not implemented")}
	}
	qp := req.URL.Query()
	arrayQueryUnescaped, err := url.QueryUnescape(qp.Get("arrayQuery"))
	if err != nil {
		return nil, err
	}
	arrayQueryParam := splitHelper(arrayQueryUnescaped, "\t")
	var options *urlgroup.QueriesClientArrayStringTsvValidOptions
	if len(arrayQueryParam) > 0 {
		options = &urlgroup.QueriesClientArrayStringTsvValidOptions{
			ArrayQuery: arrayQueryParam,
		}
	}
	respr, errRespr := q.srv.ArrayStringTsvValid(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchByteEmpty(req *http.Request) (*http.Response, error) {
	if q.srv.ByteEmpty == nil {
		return nil, &nonRetriableError{errors.New("fake for method ByteEmpty not implemented")}
	}
	respr, errRespr := q.srv.ByteEmpty(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchByteMultiByte(req *http.Request) (*http.Response, error) {
	if q.srv.ByteMultiByte == nil {
		return nil, &nonRetriableError{errors.New("fake for method ByteMultiByte not implemented")}
	}
	qp := req.URL.Query()
	byteQueryUnescaped, err := url.QueryUnescape(qp.Get("byteQuery"))
	if err != nil {
		return nil, err
	}
	byteQueryParam, err := base64.StdEncoding.DecodeString(byteQueryUnescaped)
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientByteMultiByteOptions
	if byteQueryParam != nil {
		options = &urlgroup.QueriesClientByteMultiByteOptions{
			ByteQuery: byteQueryParam,
		}
	}
	respr, errRespr := q.srv.ByteMultiByte(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchByteNull(req *http.Request) (*http.Response, error) {
	if q.srv.ByteNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method ByteNull not implemented")}
	}
	qp := req.URL.Query()
	byteQueryUnescaped, err := url.QueryUnescape(qp.Get("byteQuery"))
	if err != nil {
		return nil, err
	}
	byteQueryParam, err := base64.StdEncoding.DecodeString(byteQueryUnescaped)
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientByteNullOptions
	if byteQueryParam != nil {
		options = &urlgroup.QueriesClientByteNullOptions{
			ByteQuery: byteQueryParam,
		}
	}
	respr, errRespr := q.srv.ByteNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDateNull(req *http.Request) (*http.Response, error) {
	if q.srv.DateNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method DateNull not implemented")}
	}
	qp := req.URL.Query()
	dateQueryUnescaped, err := url.QueryUnescape(qp.Get("dateQuery"))
	if err != nil {
		return nil, err
	}
	dateQueryParam, err := parseOptional(dateQueryUnescaped, func(v string) (time.Time, error) { return time.Parse("2006-01-02", v) })
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientDateNullOptions
	if dateQueryParam != nil {
		options = &urlgroup.QueriesClientDateNullOptions{
			DateQuery: dateQueryParam,
		}
	}
	respr, errRespr := q.srv.DateNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDateTimeNull(req *http.Request) (*http.Response, error) {
	if q.srv.DateTimeNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method DateTimeNull not implemented")}
	}
	qp := req.URL.Query()
	dateTimeQueryUnescaped, err := url.QueryUnescape(qp.Get("dateTimeQuery"))
	if err != nil {
		return nil, err
	}
	dateTimeQueryParam, err := parseOptional(dateTimeQueryUnescaped, func(v string) (time.Time, error) { return time.Parse(time.RFC3339Nano, v) })
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientDateTimeNullOptions
	if dateTimeQueryParam != nil {
		options = &urlgroup.QueriesClientDateTimeNullOptions{
			DateTimeQuery: dateTimeQueryParam,
		}
	}
	respr, errRespr := q.srv.DateTimeNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDateTimeValid(req *http.Request) (*http.Response, error) {
	if q.srv.DateTimeValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method DateTimeValid not implemented")}
	}
	respr, errRespr := q.srv.DateTimeValid(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDateValid(req *http.Request) (*http.Response, error) {
	if q.srv.DateValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method DateValid not implemented")}
	}
	respr, errRespr := q.srv.DateValid(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDoubleDecimalNegative(req *http.Request) (*http.Response, error) {
	if q.srv.DoubleDecimalNegative == nil {
		return nil, &nonRetriableError{errors.New("fake for method DoubleDecimalNegative not implemented")}
	}
	respr, errRespr := q.srv.DoubleDecimalNegative(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDoubleDecimalPositive(req *http.Request) (*http.Response, error) {
	if q.srv.DoubleDecimalPositive == nil {
		return nil, &nonRetriableError{errors.New("fake for method DoubleDecimalPositive not implemented")}
	}
	respr, errRespr := q.srv.DoubleDecimalPositive(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchDoubleNull(req *http.Request) (*http.Response, error) {
	if q.srv.DoubleNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method DoubleNull not implemented")}
	}
	qp := req.URL.Query()
	doubleQueryUnescaped, err := url.QueryUnescape(qp.Get("doubleQuery"))
	if err != nil {
		return nil, err
	}
	doubleQueryParam, err := parseOptional(doubleQueryUnescaped, func(v string) (float64, error) {
		p, parseErr := strconv.ParseFloat(v, 64)
		if parseErr != nil {
			return 0, parseErr
		}
		return p, nil
	})
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientDoubleNullOptions
	if doubleQueryParam != nil {
		options = &urlgroup.QueriesClientDoubleNullOptions{
			DoubleQuery: doubleQueryParam,
		}
	}
	respr, errRespr := q.srv.DoubleNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchEnumNull(req *http.Request) (*http.Response, error) {
	if q.srv.EnumNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method EnumNull not implemented")}
	}
	qp := req.URL.Query()
	enumQueryUnescaped, err := url.QueryUnescape(qp.Get("enumQuery"))
	if err != nil {
		return nil, err
	}
	enumQueryParam := getOptional(urlgroup.URIColor(enumQueryUnescaped))
	var options *urlgroup.QueriesClientEnumNullOptions
	if enumQueryParam != nil {
		options = &urlgroup.QueriesClientEnumNullOptions{
			EnumQuery: enumQueryParam,
		}
	}
	respr, errRespr := q.srv.EnumNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchEnumValid(req *http.Request) (*http.Response, error) {
	if q.srv.EnumValid == nil {
		return nil, &nonRetriableError{errors.New("fake for method EnumValid not implemented")}
	}
	qp := req.URL.Query()
	enumQueryUnescaped, err := url.QueryUnescape(qp.Get("enumQuery"))
	if err != nil {
		return nil, err
	}
	enumQueryParam := getOptional(urlgroup.URIColor(enumQueryUnescaped))
	var options *urlgroup.QueriesClientEnumValidOptions
	if enumQueryParam != nil {
		options = &urlgroup.QueriesClientEnumValidOptions{
			EnumQuery: enumQueryParam,
		}
	}
	respr, errRespr := q.srv.EnumValid(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchFloatNull(req *http.Request) (*http.Response, error) {
	if q.srv.FloatNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method FloatNull not implemented")}
	}
	qp := req.URL.Query()
	floatQueryUnescaped, err := url.QueryUnescape(qp.Get("floatQuery"))
	if err != nil {
		return nil, err
	}
	floatQueryParam, err := parseOptional(floatQueryUnescaped, func(v string) (float32, error) {
		p, parseErr := strconv.ParseFloat(v, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return float32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientFloatNullOptions
	if floatQueryParam != nil {
		options = &urlgroup.QueriesClientFloatNullOptions{
			FloatQuery: floatQueryParam,
		}
	}
	respr, errRespr := q.srv.FloatNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchFloatScientificNegative(req *http.Request) (*http.Response, error) {
	if q.srv.FloatScientificNegative == nil {
		return nil, &nonRetriableError{errors.New("fake for method FloatScientificNegative not implemented")}
	}
	respr, errRespr := q.srv.FloatScientificNegative(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchFloatScientificPositive(req *http.Request) (*http.Response, error) {
	if q.srv.FloatScientificPositive == nil {
		return nil, &nonRetriableError{errors.New("fake for method FloatScientificPositive not implemented")}
	}
	respr, errRespr := q.srv.FloatScientificPositive(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetBooleanFalse(req *http.Request) (*http.Response, error) {
	if q.srv.GetBooleanFalse == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetBooleanFalse not implemented")}
	}
	respr, errRespr := q.srv.GetBooleanFalse(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetBooleanNull(req *http.Request) (*http.Response, error) {
	if q.srv.GetBooleanNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetBooleanNull not implemented")}
	}
	qp := req.URL.Query()
	boolQueryUnescaped, err := url.QueryUnescape(qp.Get("boolQuery"))
	if err != nil {
		return nil, err
	}
	boolQueryParam, err := parseOptional(boolQueryUnescaped, strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientGetBooleanNullOptions
	if boolQueryParam != nil {
		options = &urlgroup.QueriesClientGetBooleanNullOptions{
			BoolQuery: boolQueryParam,
		}
	}
	respr, errRespr := q.srv.GetBooleanNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetBooleanTrue(req *http.Request) (*http.Response, error) {
	if q.srv.GetBooleanTrue == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetBooleanTrue not implemented")}
	}
	respr, errRespr := q.srv.GetBooleanTrue(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetIntNegativeOneMillion(req *http.Request) (*http.Response, error) {
	if q.srv.GetIntNegativeOneMillion == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetIntNegativeOneMillion not implemented")}
	}
	respr, errRespr := q.srv.GetIntNegativeOneMillion(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetIntNull(req *http.Request) (*http.Response, error) {
	if q.srv.GetIntNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetIntNull not implemented")}
	}
	qp := req.URL.Query()
	intQueryUnescaped, err := url.QueryUnescape(qp.Get("intQuery"))
	if err != nil {
		return nil, err
	}
	intQueryParam, err := parseOptional(intQueryUnescaped, func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientGetIntNullOptions
	if intQueryParam != nil {
		options = &urlgroup.QueriesClientGetIntNullOptions{
			IntQuery: intQueryParam,
		}
	}
	respr, errRespr := q.srv.GetIntNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetIntOneMillion(req *http.Request) (*http.Response, error) {
	if q.srv.GetIntOneMillion == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetIntOneMillion not implemented")}
	}
	respr, errRespr := q.srv.GetIntOneMillion(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetLongNull(req *http.Request) (*http.Response, error) {
	if q.srv.GetLongNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetLongNull not implemented")}
	}
	qp := req.URL.Query()
	longQueryUnescaped, err := url.QueryUnescape(qp.Get("longQuery"))
	if err != nil {
		return nil, err
	}
	longQueryParam, err := parseOptional(longQueryUnescaped, func(v string) (int64, error) {
		p, parseErr := strconv.ParseInt(v, 10, 64)
		if parseErr != nil {
			return 0, parseErr
		}
		return p, nil
	})
	if err != nil {
		return nil, err
	}
	var options *urlgroup.QueriesClientGetLongNullOptions
	if longQueryParam != nil {
		options = &urlgroup.QueriesClientGetLongNullOptions{
			LongQuery: longQueryParam,
		}
	}
	respr, errRespr := q.srv.GetLongNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetNegativeTenBillion(req *http.Request) (*http.Response, error) {
	if q.srv.GetNegativeTenBillion == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetNegativeTenBillion not implemented")}
	}
	respr, errRespr := q.srv.GetNegativeTenBillion(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchGetTenBillion(req *http.Request) (*http.Response, error) {
	if q.srv.GetTenBillion == nil {
		return nil, &nonRetriableError{errors.New("fake for method GetTenBillion not implemented")}
	}
	respr, errRespr := q.srv.GetTenBillion(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchStringEmpty(req *http.Request) (*http.Response, error) {
	if q.srv.StringEmpty == nil {
		return nil, &nonRetriableError{errors.New("fake for method StringEmpty not implemented")}
	}
	respr, errRespr := q.srv.StringEmpty(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchStringNull(req *http.Request) (*http.Response, error) {
	if q.srv.StringNull == nil {
		return nil, &nonRetriableError{errors.New("fake for method StringNull not implemented")}
	}
	qp := req.URL.Query()
	stringQueryUnescaped, err := url.QueryUnescape(qp.Get("stringQuery"))
	if err != nil {
		return nil, err
	}
	stringQueryParam := getOptional(stringQueryUnescaped)
	var options *urlgroup.QueriesClientStringNullOptions
	if stringQueryParam != nil {
		options = &urlgroup.QueriesClientStringNullOptions{
			StringQuery: stringQueryParam,
		}
	}
	respr, errRespr := q.srv.StringNull(req.Context(), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchStringURLEncoded(req *http.Request) (*http.Response, error) {
	if q.srv.StringURLEncoded == nil {
		return nil, &nonRetriableError{errors.New("fake for method StringURLEncoded not implemented")}
	}
	respr, errRespr := q.srv.StringURLEncoded(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (q *QueriesServerTransport) dispatchStringUnicode(req *http.Request) (*http.Response, error) {
	if q.srv.StringUnicode == nil {
		return nil, &nonRetriableError{errors.New("fake for method StringUnicode not implemented")}
	}
	respr, errRespr := q.srv.StringUnicode(req.Context(), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}
