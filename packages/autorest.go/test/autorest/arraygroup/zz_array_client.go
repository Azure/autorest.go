// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package arraygroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"time"
)

// ArrayClient contains the methods for the Array group.
// Don't use this type directly, use a constructor function instead.
type ArrayClient struct {
	internal *azcore.Client
}

// GetArrayEmpty - Get an empty array []
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetArrayEmptyOptions contains the optional parameters for the ArrayClient.GetArrayEmpty method.
func (client *ArrayClient) GetArrayEmpty(ctx context.Context, options *ArrayClientGetArrayEmptyOptions) (ArrayClientGetArrayEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetArrayEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getArrayEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetArrayEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetArrayEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetArrayEmptyResponse{}, err
	}
	resp, err := client.getArrayEmptyHandleResponse(httpResp)
	return resp, err
}

// getArrayEmptyCreateRequest creates the GetArrayEmpty request.
func (client *ArrayClient) getArrayEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetArrayEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/array/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getArrayEmptyHandleResponse handles the GetArrayEmpty response.
func (client *ArrayClient) getArrayEmptyHandleResponse(resp *http.Response) (ArrayClientGetArrayEmptyResponse, error) {
	result := ArrayClientGetArrayEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArrayArray); err != nil {
		return ArrayClientGetArrayEmptyResponse{}, err
	}
	return result, nil
}

// GetArrayItemEmpty - Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetArrayItemEmptyOptions contains the optional parameters for the ArrayClient.GetArrayItemEmpty method.
func (client *ArrayClient) GetArrayItemEmpty(ctx context.Context, options *ArrayClientGetArrayItemEmptyOptions) (ArrayClientGetArrayItemEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetArrayItemEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getArrayItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetArrayItemEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetArrayItemEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetArrayItemEmptyResponse{}, err
	}
	resp, err := client.getArrayItemEmptyHandleResponse(httpResp)
	return resp, err
}

// getArrayItemEmptyCreateRequest creates the GetArrayItemEmpty request.
func (client *ArrayClient) getArrayItemEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetArrayItemEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/array/itemempty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getArrayItemEmptyHandleResponse handles the GetArrayItemEmpty response.
func (client *ArrayClient) getArrayItemEmptyHandleResponse(resp *http.Response) (ArrayClientGetArrayItemEmptyResponse, error) {
	result := ArrayClientGetArrayItemEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArrayArray); err != nil {
		return ArrayClientGetArrayItemEmptyResponse{}, err
	}
	return result, nil
}

// GetArrayItemNull - Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetArrayItemNullOptions contains the optional parameters for the ArrayClient.GetArrayItemNull method.
func (client *ArrayClient) GetArrayItemNull(ctx context.Context, options *ArrayClientGetArrayItemNullOptions) (ArrayClientGetArrayItemNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetArrayItemNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getArrayItemNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetArrayItemNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetArrayItemNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetArrayItemNullResponse{}, err
	}
	resp, err := client.getArrayItemNullHandleResponse(httpResp)
	return resp, err
}

// getArrayItemNullCreateRequest creates the GetArrayItemNull request.
func (client *ArrayClient) getArrayItemNullCreateRequest(ctx context.Context, _ *ArrayClientGetArrayItemNullOptions) (*policy.Request, error) {
	urlPath := "/array/array/itemnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getArrayItemNullHandleResponse handles the GetArrayItemNull response.
func (client *ArrayClient) getArrayItemNullHandleResponse(resp *http.Response) (ArrayClientGetArrayItemNullResponse, error) {
	result := ArrayClientGetArrayItemNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArrayArray); err != nil {
		return ArrayClientGetArrayItemNullResponse{}, err
	}
	return result, nil
}

// GetArrayNull - Get a null array
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetArrayNullOptions contains the optional parameters for the ArrayClient.GetArrayNull method.
func (client *ArrayClient) GetArrayNull(ctx context.Context, options *ArrayClientGetArrayNullOptions) (ArrayClientGetArrayNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetArrayNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getArrayNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetArrayNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetArrayNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetArrayNullResponse{}, err
	}
	resp, err := client.getArrayNullHandleResponse(httpResp)
	return resp, err
}

// getArrayNullCreateRequest creates the GetArrayNull request.
func (client *ArrayClient) getArrayNullCreateRequest(ctx context.Context, _ *ArrayClientGetArrayNullOptions) (*policy.Request, error) {
	urlPath := "/array/array/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getArrayNullHandleResponse handles the GetArrayNull response.
func (client *ArrayClient) getArrayNullHandleResponse(resp *http.Response) (ArrayClientGetArrayNullResponse, error) {
	result := ArrayClientGetArrayNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArrayArray); err != nil {
		return ArrayClientGetArrayNullResponse{}, err
	}
	return result, nil
}

// GetArrayValid - Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetArrayValidOptions contains the optional parameters for the ArrayClient.GetArrayValid method.
func (client *ArrayClient) GetArrayValid(ctx context.Context, options *ArrayClientGetArrayValidOptions) (ArrayClientGetArrayValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetArrayValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getArrayValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetArrayValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetArrayValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetArrayValidResponse{}, err
	}
	resp, err := client.getArrayValidHandleResponse(httpResp)
	return resp, err
}

// getArrayValidCreateRequest creates the GetArrayValid request.
func (client *ArrayClient) getArrayValidCreateRequest(ctx context.Context, _ *ArrayClientGetArrayValidOptions) (*policy.Request, error) {
	urlPath := "/array/array/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getArrayValidHandleResponse handles the GetArrayValid response.
func (client *ArrayClient) getArrayValidHandleResponse(resp *http.Response) (ArrayClientGetArrayValidResponse, error) {
	result := ArrayClientGetArrayValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArrayArray); err != nil {
		return ArrayClientGetArrayValidResponse{}, err
	}
	return result, nil
}

// GetBase64URL - Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items
// base64url encoded
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetBase64URLOptions contains the optional parameters for the ArrayClient.GetBase64URL method.
func (client *ArrayClient) GetBase64URL(ctx context.Context, options *ArrayClientGetBase64URLOptions) (ArrayClientGetBase64URLResponse, error) {
	var err error
	const operationName = "ArrayClient.GetBase64URL"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBase64URLCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetBase64URLResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetBase64URLResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetBase64URLResponse{}, err
	}
	resp, err := client.getBase64URLHandleResponse(httpResp)
	return resp, err
}

// getBase64URLCreateRequest creates the GetBase64URL request.
func (client *ArrayClient) getBase64URLCreateRequest(ctx context.Context, _ *ArrayClientGetBase64URLOptions) (*policy.Request, error) {
	urlPath := "/array/prim/base64url/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBase64URLHandleResponse handles the GetBase64URL response.
func (client *ArrayClient) getBase64URLHandleResponse(resp *http.Response) (ArrayClientGetBase64URLResponse, error) {
	result := ArrayClientGetBase64URLResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ByteArrayArray); err != nil {
		return ArrayClientGetBase64URLResponse{}, err
	}
	return result, nil
}

// GetBooleanInvalidNull - Get boolean array value [true, null, false]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetBooleanInvalidNullOptions contains the optional parameters for the ArrayClient.GetBooleanInvalidNull
//     method.
func (client *ArrayClient) GetBooleanInvalidNull(ctx context.Context, options *ArrayClientGetBooleanInvalidNullOptions) (ArrayClientGetBooleanInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetBooleanInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBooleanInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetBooleanInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetBooleanInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetBooleanInvalidNullResponse{}, err
	}
	resp, err := client.getBooleanInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getBooleanInvalidNullCreateRequest creates the GetBooleanInvalidNull request.
func (client *ArrayClient) getBooleanInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetBooleanInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/boolean/true.null.false"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBooleanInvalidNullHandleResponse handles the GetBooleanInvalidNull response.
func (client *ArrayClient) getBooleanInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetBooleanInvalidNullResponse, error) {
	result := ArrayClientGetBooleanInvalidNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BoolArray); err != nil {
		return ArrayClientGetBooleanInvalidNullResponse{}, err
	}
	return result, nil
}

// GetBooleanInvalidString - Get boolean array value [true, 'boolean', false]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetBooleanInvalidStringOptions contains the optional parameters for the ArrayClient.GetBooleanInvalidString
//     method.
func (client *ArrayClient) GetBooleanInvalidString(ctx context.Context, options *ArrayClientGetBooleanInvalidStringOptions) (ArrayClientGetBooleanInvalidStringResponse, error) {
	var err error
	const operationName = "ArrayClient.GetBooleanInvalidString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBooleanInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetBooleanInvalidStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetBooleanInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetBooleanInvalidStringResponse{}, err
	}
	resp, err := client.getBooleanInvalidStringHandleResponse(httpResp)
	return resp, err
}

// getBooleanInvalidStringCreateRequest creates the GetBooleanInvalidString request.
func (client *ArrayClient) getBooleanInvalidStringCreateRequest(ctx context.Context, _ *ArrayClientGetBooleanInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/array/prim/boolean/true.boolean.false"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBooleanInvalidStringHandleResponse handles the GetBooleanInvalidString response.
func (client *ArrayClient) getBooleanInvalidStringHandleResponse(resp *http.Response) (ArrayClientGetBooleanInvalidStringResponse, error) {
	result := ArrayClientGetBooleanInvalidStringResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BoolArray); err != nil {
		return ArrayClientGetBooleanInvalidStringResponse{}, err
	}
	return result, nil
}

// GetBooleanTfft - Get boolean array value [true, false, false, true]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetBooleanTfftOptions contains the optional parameters for the ArrayClient.GetBooleanTfft method.
func (client *ArrayClient) GetBooleanTfft(ctx context.Context, options *ArrayClientGetBooleanTfftOptions) (ArrayClientGetBooleanTfftResponse, error) {
	var err error
	const operationName = "ArrayClient.GetBooleanTfft"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBooleanTfftCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetBooleanTfftResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetBooleanTfftResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetBooleanTfftResponse{}, err
	}
	resp, err := client.getBooleanTfftHandleResponse(httpResp)
	return resp, err
}

// getBooleanTfftCreateRequest creates the GetBooleanTfft request.
func (client *ArrayClient) getBooleanTfftCreateRequest(ctx context.Context, _ *ArrayClientGetBooleanTfftOptions) (*policy.Request, error) {
	urlPath := "/array/prim/boolean/tfft"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getBooleanTfftHandleResponse handles the GetBooleanTfft response.
func (client *ArrayClient) getBooleanTfftHandleResponse(resp *http.Response) (ArrayClientGetBooleanTfftResponse, error) {
	result := ArrayClientGetBooleanTfftResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BoolArray); err != nil {
		return ArrayClientGetBooleanTfftResponse{}, err
	}
	return result, nil
}

// GetByteInvalidNull - Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetByteInvalidNullOptions contains the optional parameters for the ArrayClient.GetByteInvalidNull
//     method.
func (client *ArrayClient) GetByteInvalidNull(ctx context.Context, options *ArrayClientGetByteInvalidNullOptions) (ArrayClientGetByteInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetByteInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getByteInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetByteInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetByteInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetByteInvalidNullResponse{}, err
	}
	resp, err := client.getByteInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getByteInvalidNullCreateRequest creates the GetByteInvalidNull request.
func (client *ArrayClient) getByteInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetByteInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/byte/invalidnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getByteInvalidNullHandleResponse handles the GetByteInvalidNull response.
func (client *ArrayClient) getByteInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetByteInvalidNullResponse, error) {
	result := ArrayClientGetByteInvalidNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ByteArrayArray); err != nil {
		return ArrayClientGetByteInvalidNullResponse{}, err
	}
	return result, nil
}

// GetByteValid - Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetByteValidOptions contains the optional parameters for the ArrayClient.GetByteValid method.
func (client *ArrayClient) GetByteValid(ctx context.Context, options *ArrayClientGetByteValidOptions) (ArrayClientGetByteValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetByteValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getByteValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetByteValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetByteValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetByteValidResponse{}, err
	}
	resp, err := client.getByteValidHandleResponse(httpResp)
	return resp, err
}

// getByteValidCreateRequest creates the GetByteValid request.
func (client *ArrayClient) getByteValidCreateRequest(ctx context.Context, _ *ArrayClientGetByteValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/byte/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getByteValidHandleResponse handles the GetByteValid response.
func (client *ArrayClient) getByteValidHandleResponse(resp *http.Response) (ArrayClientGetByteValidResponse, error) {
	result := ArrayClientGetByteValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ByteArrayArray); err != nil {
		return ArrayClientGetByteValidResponse{}, err
	}
	return result, nil
}

// GetComplexEmpty - Get empty array of complex type []
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetComplexEmptyOptions contains the optional parameters for the ArrayClient.GetComplexEmpty method.
func (client *ArrayClient) GetComplexEmpty(ctx context.Context, options *ArrayClientGetComplexEmptyOptions) (ArrayClientGetComplexEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetComplexEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetComplexEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetComplexEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetComplexEmptyResponse{}, err
	}
	resp, err := client.getComplexEmptyHandleResponse(httpResp)
	return resp, err
}

// getComplexEmptyCreateRequest creates the GetComplexEmpty request.
func (client *ArrayClient) getComplexEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetComplexEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/complex/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComplexEmptyHandleResponse handles the GetComplexEmpty response.
func (client *ArrayClient) getComplexEmptyHandleResponse(resp *http.Response) (ArrayClientGetComplexEmptyResponse, error) {
	result := ArrayClientGetComplexEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductArray); err != nil {
		return ArrayClientGetComplexEmptyResponse{}, err
	}
	return result, nil
}

// GetComplexItemEmpty - Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string':
// '6'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetComplexItemEmptyOptions contains the optional parameters for the ArrayClient.GetComplexItemEmpty
//     method.
func (client *ArrayClient) GetComplexItemEmpty(ctx context.Context, options *ArrayClientGetComplexItemEmptyOptions) (ArrayClientGetComplexItemEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetComplexItemEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetComplexItemEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetComplexItemEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetComplexItemEmptyResponse{}, err
	}
	resp, err := client.getComplexItemEmptyHandleResponse(httpResp)
	return resp, err
}

// getComplexItemEmptyCreateRequest creates the GetComplexItemEmpty request.
func (client *ArrayClient) getComplexItemEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetComplexItemEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/complex/itemempty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComplexItemEmptyHandleResponse handles the GetComplexItemEmpty response.
func (client *ArrayClient) getComplexItemEmptyHandleResponse(resp *http.Response) (ArrayClientGetComplexItemEmptyResponse, error) {
	result := ArrayClientGetComplexItemEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductArray); err != nil {
		return ArrayClientGetComplexItemEmptyResponse{}, err
	}
	return result, nil
}

// GetComplexItemNull - Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string':
// '6'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetComplexItemNullOptions contains the optional parameters for the ArrayClient.GetComplexItemNull
//     method.
func (client *ArrayClient) GetComplexItemNull(ctx context.Context, options *ArrayClientGetComplexItemNullOptions) (ArrayClientGetComplexItemNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetComplexItemNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexItemNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetComplexItemNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetComplexItemNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetComplexItemNullResponse{}, err
	}
	resp, err := client.getComplexItemNullHandleResponse(httpResp)
	return resp, err
}

// getComplexItemNullCreateRequest creates the GetComplexItemNull request.
func (client *ArrayClient) getComplexItemNullCreateRequest(ctx context.Context, _ *ArrayClientGetComplexItemNullOptions) (*policy.Request, error) {
	urlPath := "/array/complex/itemnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComplexItemNullHandleResponse handles the GetComplexItemNull response.
func (client *ArrayClient) getComplexItemNullHandleResponse(resp *http.Response) (ArrayClientGetComplexItemNullResponse, error) {
	result := ArrayClientGetComplexItemNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductArray); err != nil {
		return ArrayClientGetComplexItemNullResponse{}, err
	}
	return result, nil
}

// GetComplexNull - Get array of complex type null value
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetComplexNullOptions contains the optional parameters for the ArrayClient.GetComplexNull method.
func (client *ArrayClient) GetComplexNull(ctx context.Context, options *ArrayClientGetComplexNullOptions) (ArrayClientGetComplexNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetComplexNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetComplexNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetComplexNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetComplexNullResponse{}, err
	}
	resp, err := client.getComplexNullHandleResponse(httpResp)
	return resp, err
}

// getComplexNullCreateRequest creates the GetComplexNull request.
func (client *ArrayClient) getComplexNullCreateRequest(ctx context.Context, _ *ArrayClientGetComplexNullOptions) (*policy.Request, error) {
	urlPath := "/array/complex/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComplexNullHandleResponse handles the GetComplexNull response.
func (client *ArrayClient) getComplexNullHandleResponse(resp *http.Response) (ArrayClientGetComplexNullResponse, error) {
	result := ArrayClientGetComplexNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductArray); err != nil {
		return ArrayClientGetComplexNullResponse{}, err
	}
	return result, nil
}

// GetComplexValid - Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer':
// 5, 'string': '6'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetComplexValidOptions contains the optional parameters for the ArrayClient.GetComplexValid method.
func (client *ArrayClient) GetComplexValid(ctx context.Context, options *ArrayClientGetComplexValidOptions) (ArrayClientGetComplexValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetComplexValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetComplexValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetComplexValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetComplexValidResponse{}, err
	}
	resp, err := client.getComplexValidHandleResponse(httpResp)
	return resp, err
}

// getComplexValidCreateRequest creates the GetComplexValid request.
func (client *ArrayClient) getComplexValidCreateRequest(ctx context.Context, _ *ArrayClientGetComplexValidOptions) (*policy.Request, error) {
	urlPath := "/array/complex/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComplexValidHandleResponse handles the GetComplexValid response.
func (client *ArrayClient) getComplexValidHandleResponse(resp *http.Response) (ArrayClientGetComplexValidResponse, error) {
	result := ArrayClientGetComplexValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductArray); err != nil {
		return ArrayClientGetComplexValidResponse{}, err
	}
	return result, nil
}

// GetDateInvalidChars - Get date array value ['2011-03-22', 'date']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateInvalidCharsOptions contains the optional parameters for the ArrayClient.GetDateInvalidChars
//     method.
func (client *ArrayClient) GetDateInvalidChars(ctx context.Context, options *ArrayClientGetDateInvalidCharsOptions) (ArrayClientGetDateInvalidCharsResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateInvalidChars"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateInvalidCharsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateInvalidCharsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateInvalidCharsResponse{}, err
	}
	resp, err := client.getDateInvalidCharsHandleResponse(httpResp)
	return resp, err
}

// getDateInvalidCharsCreateRequest creates the GetDateInvalidChars request.
func (client *ArrayClient) getDateInvalidCharsCreateRequest(ctx context.Context, _ *ArrayClientGetDateInvalidCharsOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date/invalidchars"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateInvalidCharsHandleResponse handles the GetDateInvalidChars response.
func (client *ArrayClient) getDateInvalidCharsHandleResponse(resp *http.Response) (ArrayClientGetDateInvalidCharsResponse, error) {
	result := ArrayClientGetDateInvalidCharsResponse{}
	var aux []*dateType
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateInvalidCharsResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDateInvalidNull - Get date array value ['2012-01-01', null, '1776-07-04']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateInvalidNullOptions contains the optional parameters for the ArrayClient.GetDateInvalidNull
//     method.
func (client *ArrayClient) GetDateInvalidNull(ctx context.Context, options *ArrayClientGetDateInvalidNullOptions) (ArrayClientGetDateInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateInvalidNullResponse{}, err
	}
	resp, err := client.getDateInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getDateInvalidNullCreateRequest creates the GetDateInvalidNull request.
func (client *ArrayClient) getDateInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetDateInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date/invalidnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateInvalidNullHandleResponse handles the GetDateInvalidNull response.
func (client *ArrayClient) getDateInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetDateInvalidNullResponse, error) {
	result := ArrayClientGetDateInvalidNullResponse{}
	var aux []*dateType
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateInvalidNullResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDateTimeInvalidChars - Get date array value ['2000-12-01t00:00:01z', 'date-time']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateTimeInvalidCharsOptions contains the optional parameters for the ArrayClient.GetDateTimeInvalidChars
//     method.
func (client *ArrayClient) GetDateTimeInvalidChars(ctx context.Context, options *ArrayClientGetDateTimeInvalidCharsOptions) (ArrayClientGetDateTimeInvalidCharsResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateTimeInvalidChars"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateTimeInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateTimeInvalidCharsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateTimeInvalidCharsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateTimeInvalidCharsResponse{}, err
	}
	resp, err := client.getDateTimeInvalidCharsHandleResponse(httpResp)
	return resp, err
}

// getDateTimeInvalidCharsCreateRequest creates the GetDateTimeInvalidChars request.
func (client *ArrayClient) getDateTimeInvalidCharsCreateRequest(ctx context.Context, _ *ArrayClientGetDateTimeInvalidCharsOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date-time/invalidchars"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateTimeInvalidCharsHandleResponse handles the GetDateTimeInvalidChars response.
func (client *ArrayClient) getDateTimeInvalidCharsHandleResponse(resp *http.Response) (ArrayClientGetDateTimeInvalidCharsResponse, error) {
	result := ArrayClientGetDateTimeInvalidCharsResponse{}
	var aux []*dateTimeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateTimeInvalidCharsResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDateTimeInvalidNull - Get date array value ['2000-12-01t00:00:01z', null]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateTimeInvalidNullOptions contains the optional parameters for the ArrayClient.GetDateTimeInvalidNull
//     method.
func (client *ArrayClient) GetDateTimeInvalidNull(ctx context.Context, options *ArrayClientGetDateTimeInvalidNullOptions) (ArrayClientGetDateTimeInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateTimeInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateTimeInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateTimeInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateTimeInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateTimeInvalidNullResponse{}, err
	}
	resp, err := client.getDateTimeInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getDateTimeInvalidNullCreateRequest creates the GetDateTimeInvalidNull request.
func (client *ArrayClient) getDateTimeInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetDateTimeInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date-time/invalidnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateTimeInvalidNullHandleResponse handles the GetDateTimeInvalidNull response.
func (client *ArrayClient) getDateTimeInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetDateTimeInvalidNullResponse, error) {
	result := ArrayClientGetDateTimeInvalidNullResponse{}
	var aux []*dateTimeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateTimeInvalidNullResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDateTimeRFC1123Valid - Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT',
// 'Wed, 12 Oct 1492 10:15:01 GMT']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateTimeRFC1123ValidOptions contains the optional parameters for the ArrayClient.GetDateTimeRFC1123Valid
//     method.
func (client *ArrayClient) GetDateTimeRFC1123Valid(ctx context.Context, options *ArrayClientGetDateTimeRFC1123ValidOptions) (ArrayClientGetDateTimeRFC1123ValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateTimeRFC1123Valid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateTimeRFC1123ValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateTimeRFC1123ValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateTimeRFC1123ValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateTimeRFC1123ValidResponse{}, err
	}
	resp, err := client.getDateTimeRFC1123ValidHandleResponse(httpResp)
	return resp, err
}

// getDateTimeRFC1123ValidCreateRequest creates the GetDateTimeRFC1123Valid request.
func (client *ArrayClient) getDateTimeRFC1123ValidCreateRequest(ctx context.Context, _ *ArrayClientGetDateTimeRFC1123ValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date-time-rfc1123/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateTimeRFC1123ValidHandleResponse handles the GetDateTimeRFC1123Valid response.
func (client *ArrayClient) getDateTimeRFC1123ValidHandleResponse(resp *http.Response) (ArrayClientGetDateTimeRFC1123ValidResponse, error) {
	result := ArrayClientGetDateTimeRFC1123ValidResponse{}
	var aux []*dateTimeRFC1123
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateTimeRFC1123ValidResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDateTimeValid - Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateTimeValidOptions contains the optional parameters for the ArrayClient.GetDateTimeValid method.
func (client *ArrayClient) GetDateTimeValid(ctx context.Context, options *ArrayClientGetDateTimeValidOptions) (ArrayClientGetDateTimeValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateTimeValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateTimeValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateTimeValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateTimeValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateTimeValidResponse{}, err
	}
	resp, err := client.getDateTimeValidHandleResponse(httpResp)
	return resp, err
}

// getDateTimeValidCreateRequest creates the GetDateTimeValid request.
func (client *ArrayClient) getDateTimeValidCreateRequest(ctx context.Context, _ *ArrayClientGetDateTimeValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date-time/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateTimeValidHandleResponse handles the GetDateTimeValid response.
func (client *ArrayClient) getDateTimeValidHandleResponse(resp *http.Response) (ArrayClientGetDateTimeValidResponse, error) {
	result := ArrayClientGetDateTimeValidResponse{}
	var aux []*dateTimeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateTimeValidResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDateValid - Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDateValidOptions contains the optional parameters for the ArrayClient.GetDateValid method.
func (client *ArrayClient) GetDateValid(ctx context.Context, options *ArrayClientGetDateValidOptions) (ArrayClientGetDateValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDateValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDateValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDateValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDateValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDateValidResponse{}, err
	}
	resp, err := client.getDateValidHandleResponse(httpResp)
	return resp, err
}

// getDateValidCreateRequest creates the GetDateValid request.
func (client *ArrayClient) getDateValidCreateRequest(ctx context.Context, _ *ArrayClientGetDateValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDateValidHandleResponse handles the GetDateValid response.
func (client *ArrayClient) getDateValidHandleResponse(resp *http.Response) (ArrayClientGetDateValidResponse, error) {
	result := ArrayClientGetDateValidResponse{}
	var aux []*dateType
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return ArrayClientGetDateValidResponse{}, err
	}
	cp := make([]*time.Time, len(aux))
	for i := 0; i < len(aux); i++ {
		cp[i] = (*time.Time)(aux[i])
	}
	result.TimeArray = cp
	return result, nil
}

// GetDictionaryEmpty - Get an array of Dictionaries of type with value []
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDictionaryEmptyOptions contains the optional parameters for the ArrayClient.GetDictionaryEmpty
//     method.
func (client *ArrayClient) GetDictionaryEmpty(ctx context.Context, options *ArrayClientGetDictionaryEmptyOptions) (ArrayClientGetDictionaryEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDictionaryEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDictionaryEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDictionaryEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDictionaryEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDictionaryEmptyResponse{}, err
	}
	resp, err := client.getDictionaryEmptyHandleResponse(httpResp)
	return resp, err
}

// getDictionaryEmptyCreateRequest creates the GetDictionaryEmpty request.
func (client *ArrayClient) getDictionaryEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetDictionaryEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/dictionary/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDictionaryEmptyHandleResponse handles the GetDictionaryEmpty response.
func (client *ArrayClient) getDictionaryEmptyHandleResponse(resp *http.Response) (ArrayClientGetDictionaryEmptyResponse, error) {
	result := ArrayClientGetDictionaryEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MapOfStringArray); err != nil {
		return ArrayClientGetDictionaryEmptyResponse{}, err
	}
	return result, nil
}

// GetDictionaryItemEmpty - Get an array of Dictionaries of type with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7':
// 'seven', '8': 'eight', '9': 'nine'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDictionaryItemEmptyOptions contains the optional parameters for the ArrayClient.GetDictionaryItemEmpty
//     method.
func (client *ArrayClient) GetDictionaryItemEmpty(ctx context.Context, options *ArrayClientGetDictionaryItemEmptyOptions) (ArrayClientGetDictionaryItemEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDictionaryItemEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDictionaryItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDictionaryItemEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDictionaryItemEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDictionaryItemEmptyResponse{}, err
	}
	resp, err := client.getDictionaryItemEmptyHandleResponse(httpResp)
	return resp, err
}

// getDictionaryItemEmptyCreateRequest creates the GetDictionaryItemEmpty request.
func (client *ArrayClient) getDictionaryItemEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetDictionaryItemEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/dictionary/itemempty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDictionaryItemEmptyHandleResponse handles the GetDictionaryItemEmpty response.
func (client *ArrayClient) getDictionaryItemEmptyHandleResponse(resp *http.Response) (ArrayClientGetDictionaryItemEmptyResponse, error) {
	result := ArrayClientGetDictionaryItemEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MapOfStringArray); err != nil {
		return ArrayClientGetDictionaryItemEmptyResponse{}, err
	}
	return result, nil
}

// GetDictionaryItemNull - Get an array of Dictionaries of type with value [{'1': 'one', '2': 'two', '3': 'three'}, null,
// {'7': 'seven', '8': 'eight', '9': 'nine'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDictionaryItemNullOptions contains the optional parameters for the ArrayClient.GetDictionaryItemNull
//     method.
func (client *ArrayClient) GetDictionaryItemNull(ctx context.Context, options *ArrayClientGetDictionaryItemNullOptions) (ArrayClientGetDictionaryItemNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDictionaryItemNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDictionaryItemNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDictionaryItemNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDictionaryItemNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDictionaryItemNullResponse{}, err
	}
	resp, err := client.getDictionaryItemNullHandleResponse(httpResp)
	return resp, err
}

// getDictionaryItemNullCreateRequest creates the GetDictionaryItemNull request.
func (client *ArrayClient) getDictionaryItemNullCreateRequest(ctx context.Context, _ *ArrayClientGetDictionaryItemNullOptions) (*policy.Request, error) {
	urlPath := "/array/dictionary/itemnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDictionaryItemNullHandleResponse handles the GetDictionaryItemNull response.
func (client *ArrayClient) getDictionaryItemNullHandleResponse(resp *http.Response) (ArrayClientGetDictionaryItemNullResponse, error) {
	result := ArrayClientGetDictionaryItemNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MapOfStringArray); err != nil {
		return ArrayClientGetDictionaryItemNullResponse{}, err
	}
	return result, nil
}

// GetDictionaryNull - Get an array of Dictionaries with value null
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDictionaryNullOptions contains the optional parameters for the ArrayClient.GetDictionaryNull method.
func (client *ArrayClient) GetDictionaryNull(ctx context.Context, options *ArrayClientGetDictionaryNullOptions) (ArrayClientGetDictionaryNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDictionaryNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDictionaryNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDictionaryNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDictionaryNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDictionaryNullResponse{}, err
	}
	resp, err := client.getDictionaryNullHandleResponse(httpResp)
	return resp, err
}

// getDictionaryNullCreateRequest creates the GetDictionaryNull request.
func (client *ArrayClient) getDictionaryNullCreateRequest(ctx context.Context, _ *ArrayClientGetDictionaryNullOptions) (*policy.Request, error) {
	urlPath := "/array/dictionary/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDictionaryNullHandleResponse handles the GetDictionaryNull response.
func (client *ArrayClient) getDictionaryNullHandleResponse(resp *http.Response) (ArrayClientGetDictionaryNullResponse, error) {
	result := ArrayClientGetDictionaryNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MapOfStringArray); err != nil {
		return ArrayClientGetDictionaryNullResponse{}, err
	}
	return result, nil
}

// GetDictionaryValid - Get an array of Dictionaries of type with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four',
// '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDictionaryValidOptions contains the optional parameters for the ArrayClient.GetDictionaryValid
//     method.
func (client *ArrayClient) GetDictionaryValid(ctx context.Context, options *ArrayClientGetDictionaryValidOptions) (ArrayClientGetDictionaryValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDictionaryValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDictionaryValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDictionaryValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDictionaryValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDictionaryValidResponse{}, err
	}
	resp, err := client.getDictionaryValidHandleResponse(httpResp)
	return resp, err
}

// getDictionaryValidCreateRequest creates the GetDictionaryValid request.
func (client *ArrayClient) getDictionaryValidCreateRequest(ctx context.Context, _ *ArrayClientGetDictionaryValidOptions) (*policy.Request, error) {
	urlPath := "/array/dictionary/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDictionaryValidHandleResponse handles the GetDictionaryValid response.
func (client *ArrayClient) getDictionaryValidHandleResponse(resp *http.Response) (ArrayClientGetDictionaryValidResponse, error) {
	result := ArrayClientGetDictionaryValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MapOfStringArray); err != nil {
		return ArrayClientGetDictionaryValidResponse{}, err
	}
	return result, nil
}

// GetDoubleInvalidNull - Get float array value [0.0, null, -1.2e20]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDoubleInvalidNullOptions contains the optional parameters for the ArrayClient.GetDoubleInvalidNull
//     method.
func (client *ArrayClient) GetDoubleInvalidNull(ctx context.Context, options *ArrayClientGetDoubleInvalidNullOptions) (ArrayClientGetDoubleInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDoubleInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDoubleInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDoubleInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDoubleInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDoubleInvalidNullResponse{}, err
	}
	resp, err := client.getDoubleInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getDoubleInvalidNullCreateRequest creates the GetDoubleInvalidNull request.
func (client *ArrayClient) getDoubleInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetDoubleInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/double/0.0-null-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDoubleInvalidNullHandleResponse handles the GetDoubleInvalidNull response.
func (client *ArrayClient) getDoubleInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetDoubleInvalidNullResponse, error) {
	result := ArrayClientGetDoubleInvalidNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Float64Array); err != nil {
		return ArrayClientGetDoubleInvalidNullResponse{}, err
	}
	return result, nil
}

// GetDoubleInvalidString - Get boolean array value [1.0, 'number', 0.0]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDoubleInvalidStringOptions contains the optional parameters for the ArrayClient.GetDoubleInvalidString
//     method.
func (client *ArrayClient) GetDoubleInvalidString(ctx context.Context, options *ArrayClientGetDoubleInvalidStringOptions) (ArrayClientGetDoubleInvalidStringResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDoubleInvalidString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDoubleInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDoubleInvalidStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDoubleInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDoubleInvalidStringResponse{}, err
	}
	resp, err := client.getDoubleInvalidStringHandleResponse(httpResp)
	return resp, err
}

// getDoubleInvalidStringCreateRequest creates the GetDoubleInvalidString request.
func (client *ArrayClient) getDoubleInvalidStringCreateRequest(ctx context.Context, _ *ArrayClientGetDoubleInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/array/prim/double/1.number.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDoubleInvalidStringHandleResponse handles the GetDoubleInvalidString response.
func (client *ArrayClient) getDoubleInvalidStringHandleResponse(resp *http.Response) (ArrayClientGetDoubleInvalidStringResponse, error) {
	result := ArrayClientGetDoubleInvalidStringResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Float64Array); err != nil {
		return ArrayClientGetDoubleInvalidStringResponse{}, err
	}
	return result, nil
}

// GetDoubleValid - Get float array value [0, -0.01, 1.2e20]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDoubleValidOptions contains the optional parameters for the ArrayClient.GetDoubleValid method.
func (client *ArrayClient) GetDoubleValid(ctx context.Context, options *ArrayClientGetDoubleValidOptions) (ArrayClientGetDoubleValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDoubleValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDoubleValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDoubleValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDoubleValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDoubleValidResponse{}, err
	}
	resp, err := client.getDoubleValidHandleResponse(httpResp)
	return resp, err
}

// getDoubleValidCreateRequest creates the GetDoubleValid request.
func (client *ArrayClient) getDoubleValidCreateRequest(ctx context.Context, _ *ArrayClientGetDoubleValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/double/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDoubleValidHandleResponse handles the GetDoubleValid response.
func (client *ArrayClient) getDoubleValidHandleResponse(resp *http.Response) (ArrayClientGetDoubleValidResponse, error) {
	result := ArrayClientGetDoubleValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Float64Array); err != nil {
		return ArrayClientGetDoubleValidResponse{}, err
	}
	return result, nil
}

// GetDurationValid - Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetDurationValidOptions contains the optional parameters for the ArrayClient.GetDurationValid method.
func (client *ArrayClient) GetDurationValid(ctx context.Context, options *ArrayClientGetDurationValidOptions) (ArrayClientGetDurationValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetDurationValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getDurationValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetDurationValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetDurationValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetDurationValidResponse{}, err
	}
	resp, err := client.getDurationValidHandleResponse(httpResp)
	return resp, err
}

// getDurationValidCreateRequest creates the GetDurationValid request.
func (client *ArrayClient) getDurationValidCreateRequest(ctx context.Context, _ *ArrayClientGetDurationValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/duration/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDurationValidHandleResponse handles the GetDurationValid response.
func (client *ArrayClient) getDurationValidHandleResponse(resp *http.Response) (ArrayClientGetDurationValidResponse, error) {
	result := ArrayClientGetDurationValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ArrayClientGetDurationValidResponse{}, err
	}
	return result, nil
}

// GetEmpty - Get empty array value []
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetEmptyOptions contains the optional parameters for the ArrayClient.GetEmpty method.
func (client *ArrayClient) GetEmpty(ctx context.Context, options *ArrayClientGetEmptyOptions) (ArrayClientGetEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.GetEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEmptyCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetEmptyResponse{}, err
	}
	resp, err := client.getEmptyHandleResponse(httpResp)
	return resp, err
}

// getEmptyCreateRequest creates the GetEmpty request.
func (client *ArrayClient) getEmptyCreateRequest(ctx context.Context, _ *ArrayClientGetEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEmptyHandleResponse handles the GetEmpty response.
func (client *ArrayClient) getEmptyHandleResponse(resp *http.Response) (ArrayClientGetEmptyResponse, error) {
	result := ArrayClientGetEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32Array); err != nil {
		return ArrayClientGetEmptyResponse{}, err
	}
	return result, nil
}

// GetEnumValid - Get enum array value ['foo1', 'foo2', 'foo3']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetEnumValidOptions contains the optional parameters for the ArrayClient.GetEnumValid method.
func (client *ArrayClient) GetEnumValid(ctx context.Context, options *ArrayClientGetEnumValidOptions) (ArrayClientGetEnumValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetEnumValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEnumValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetEnumValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetEnumValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetEnumValidResponse{}, err
	}
	resp, err := client.getEnumValidHandleResponse(httpResp)
	return resp, err
}

// getEnumValidCreateRequest creates the GetEnumValid request.
func (client *ArrayClient) getEnumValidCreateRequest(ctx context.Context, _ *ArrayClientGetEnumValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/enum/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getEnumValidHandleResponse handles the GetEnumValid response.
func (client *ArrayClient) getEnumValidHandleResponse(resp *http.Response) (ArrayClientGetEnumValidResponse, error) {
	result := ArrayClientGetEnumValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FooEnumArray); err != nil {
		return ArrayClientGetEnumValidResponse{}, err
	}
	return result, nil
}

// GetFloatInvalidNull - Get float array value [0.0, null, -1.2e20]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetFloatInvalidNullOptions contains the optional parameters for the ArrayClient.GetFloatInvalidNull
//     method.
func (client *ArrayClient) GetFloatInvalidNull(ctx context.Context, options *ArrayClientGetFloatInvalidNullOptions) (ArrayClientGetFloatInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetFloatInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFloatInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetFloatInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetFloatInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetFloatInvalidNullResponse{}, err
	}
	resp, err := client.getFloatInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getFloatInvalidNullCreateRequest creates the GetFloatInvalidNull request.
func (client *ArrayClient) getFloatInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetFloatInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/float/0.0-null-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFloatInvalidNullHandleResponse handles the GetFloatInvalidNull response.
func (client *ArrayClient) getFloatInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetFloatInvalidNullResponse, error) {
	result := ArrayClientGetFloatInvalidNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Float32Array); err != nil {
		return ArrayClientGetFloatInvalidNullResponse{}, err
	}
	return result, nil
}

// GetFloatInvalidString - Get boolean array value [1.0, 'number', 0.0]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetFloatInvalidStringOptions contains the optional parameters for the ArrayClient.GetFloatInvalidString
//     method.
func (client *ArrayClient) GetFloatInvalidString(ctx context.Context, options *ArrayClientGetFloatInvalidStringOptions) (ArrayClientGetFloatInvalidStringResponse, error) {
	var err error
	const operationName = "ArrayClient.GetFloatInvalidString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFloatInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetFloatInvalidStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetFloatInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetFloatInvalidStringResponse{}, err
	}
	resp, err := client.getFloatInvalidStringHandleResponse(httpResp)
	return resp, err
}

// getFloatInvalidStringCreateRequest creates the GetFloatInvalidString request.
func (client *ArrayClient) getFloatInvalidStringCreateRequest(ctx context.Context, _ *ArrayClientGetFloatInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/array/prim/float/1.number.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFloatInvalidStringHandleResponse handles the GetFloatInvalidString response.
func (client *ArrayClient) getFloatInvalidStringHandleResponse(resp *http.Response) (ArrayClientGetFloatInvalidStringResponse, error) {
	result := ArrayClientGetFloatInvalidStringResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Float32Array); err != nil {
		return ArrayClientGetFloatInvalidStringResponse{}, err
	}
	return result, nil
}

// GetFloatValid - Get float array value [0, -0.01, 1.2e20]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetFloatValidOptions contains the optional parameters for the ArrayClient.GetFloatValid method.
func (client *ArrayClient) GetFloatValid(ctx context.Context, options *ArrayClientGetFloatValidOptions) (ArrayClientGetFloatValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetFloatValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getFloatValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetFloatValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetFloatValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetFloatValidResponse{}, err
	}
	resp, err := client.getFloatValidHandleResponse(httpResp)
	return resp, err
}

// getFloatValidCreateRequest creates the GetFloatValid request.
func (client *ArrayClient) getFloatValidCreateRequest(ctx context.Context, _ *ArrayClientGetFloatValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/float/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getFloatValidHandleResponse handles the GetFloatValid response.
func (client *ArrayClient) getFloatValidHandleResponse(resp *http.Response) (ArrayClientGetFloatValidResponse, error) {
	result := ArrayClientGetFloatValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Float32Array); err != nil {
		return ArrayClientGetFloatValidResponse{}, err
	}
	return result, nil
}

// GetIntInvalidNull - Get integer array value [1, null, 0]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetIntInvalidNullOptions contains the optional parameters for the ArrayClient.GetIntInvalidNull method.
func (client *ArrayClient) GetIntInvalidNull(ctx context.Context, options *ArrayClientGetIntInvalidNullOptions) (ArrayClientGetIntInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetIntInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getIntInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetIntInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetIntInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetIntInvalidNullResponse{}, err
	}
	resp, err := client.getIntInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getIntInvalidNullCreateRequest creates the GetIntInvalidNull request.
func (client *ArrayClient) getIntInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetIntInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/integer/1.null.zero"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getIntInvalidNullHandleResponse handles the GetIntInvalidNull response.
func (client *ArrayClient) getIntInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetIntInvalidNullResponse, error) {
	result := ArrayClientGetIntInvalidNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32Array); err != nil {
		return ArrayClientGetIntInvalidNullResponse{}, err
	}
	return result, nil
}

// GetIntInvalidString - Get integer array value [1, 'integer', 0]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetIntInvalidStringOptions contains the optional parameters for the ArrayClient.GetIntInvalidString
//     method.
func (client *ArrayClient) GetIntInvalidString(ctx context.Context, options *ArrayClientGetIntInvalidStringOptions) (ArrayClientGetIntInvalidStringResponse, error) {
	var err error
	const operationName = "ArrayClient.GetIntInvalidString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getIntInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetIntInvalidStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetIntInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetIntInvalidStringResponse{}, err
	}
	resp, err := client.getIntInvalidStringHandleResponse(httpResp)
	return resp, err
}

// getIntInvalidStringCreateRequest creates the GetIntInvalidString request.
func (client *ArrayClient) getIntInvalidStringCreateRequest(ctx context.Context, _ *ArrayClientGetIntInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/array/prim/integer/1.integer.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getIntInvalidStringHandleResponse handles the GetIntInvalidString response.
func (client *ArrayClient) getIntInvalidStringHandleResponse(resp *http.Response) (ArrayClientGetIntInvalidStringResponse, error) {
	result := ArrayClientGetIntInvalidStringResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32Array); err != nil {
		return ArrayClientGetIntInvalidStringResponse{}, err
	}
	return result, nil
}

// GetIntegerValid - Get integer array value [1, -1, 3, 300]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetIntegerValidOptions contains the optional parameters for the ArrayClient.GetIntegerValid method.
func (client *ArrayClient) GetIntegerValid(ctx context.Context, options *ArrayClientGetIntegerValidOptions) (ArrayClientGetIntegerValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetIntegerValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getIntegerValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetIntegerValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetIntegerValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetIntegerValidResponse{}, err
	}
	resp, err := client.getIntegerValidHandleResponse(httpResp)
	return resp, err
}

// getIntegerValidCreateRequest creates the GetIntegerValid request.
func (client *ArrayClient) getIntegerValidCreateRequest(ctx context.Context, _ *ArrayClientGetIntegerValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/integer/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getIntegerValidHandleResponse handles the GetIntegerValid response.
func (client *ArrayClient) getIntegerValidHandleResponse(resp *http.Response) (ArrayClientGetIntegerValidResponse, error) {
	result := ArrayClientGetIntegerValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32Array); err != nil {
		return ArrayClientGetIntegerValidResponse{}, err
	}
	return result, nil
}

// GetInvalid - Get invalid array [1, 2, 3
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetInvalidOptions contains the optional parameters for the ArrayClient.GetInvalid method.
func (client *ArrayClient) GetInvalid(ctx context.Context, options *ArrayClientGetInvalidOptions) (ArrayClientGetInvalidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetInvalid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getInvalidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetInvalidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetInvalidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetInvalidResponse{}, err
	}
	resp, err := client.getInvalidHandleResponse(httpResp)
	return resp, err
}

// getInvalidCreateRequest creates the GetInvalid request.
func (client *ArrayClient) getInvalidCreateRequest(ctx context.Context, _ *ArrayClientGetInvalidOptions) (*policy.Request, error) {
	urlPath := "/array/invalid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInvalidHandleResponse handles the GetInvalid response.
func (client *ArrayClient) getInvalidHandleResponse(resp *http.Response) (ArrayClientGetInvalidResponse, error) {
	result := ArrayClientGetInvalidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32Array); err != nil {
		return ArrayClientGetInvalidResponse{}, err
	}
	return result, nil
}

// GetLongInvalidNull - Get long array value [1, null, 0]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetLongInvalidNullOptions contains the optional parameters for the ArrayClient.GetLongInvalidNull
//     method.
func (client *ArrayClient) GetLongInvalidNull(ctx context.Context, options *ArrayClientGetLongInvalidNullOptions) (ArrayClientGetLongInvalidNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetLongInvalidNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getLongInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetLongInvalidNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetLongInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetLongInvalidNullResponse{}, err
	}
	resp, err := client.getLongInvalidNullHandleResponse(httpResp)
	return resp, err
}

// getLongInvalidNullCreateRequest creates the GetLongInvalidNull request.
func (client *ArrayClient) getLongInvalidNullCreateRequest(ctx context.Context, _ *ArrayClientGetLongInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/long/1.null.zero"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLongInvalidNullHandleResponse handles the GetLongInvalidNull response.
func (client *ArrayClient) getLongInvalidNullHandleResponse(resp *http.Response) (ArrayClientGetLongInvalidNullResponse, error) {
	result := ArrayClientGetLongInvalidNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int64Array); err != nil {
		return ArrayClientGetLongInvalidNullResponse{}, err
	}
	return result, nil
}

// GetLongInvalidString - Get long array value [1, 'integer', 0]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetLongInvalidStringOptions contains the optional parameters for the ArrayClient.GetLongInvalidString
//     method.
func (client *ArrayClient) GetLongInvalidString(ctx context.Context, options *ArrayClientGetLongInvalidStringOptions) (ArrayClientGetLongInvalidStringResponse, error) {
	var err error
	const operationName = "ArrayClient.GetLongInvalidString"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getLongInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetLongInvalidStringResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetLongInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetLongInvalidStringResponse{}, err
	}
	resp, err := client.getLongInvalidStringHandleResponse(httpResp)
	return resp, err
}

// getLongInvalidStringCreateRequest creates the GetLongInvalidString request.
func (client *ArrayClient) getLongInvalidStringCreateRequest(ctx context.Context, _ *ArrayClientGetLongInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/array/prim/long/1.integer.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLongInvalidStringHandleResponse handles the GetLongInvalidString response.
func (client *ArrayClient) getLongInvalidStringHandleResponse(resp *http.Response) (ArrayClientGetLongInvalidStringResponse, error) {
	result := ArrayClientGetLongInvalidStringResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int64Array); err != nil {
		return ArrayClientGetLongInvalidStringResponse{}, err
	}
	return result, nil
}

// GetLongValid - Get integer array value [1, -1, 3, 300]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetLongValidOptions contains the optional parameters for the ArrayClient.GetLongValid method.
func (client *ArrayClient) GetLongValid(ctx context.Context, options *ArrayClientGetLongValidOptions) (ArrayClientGetLongValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetLongValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getLongValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetLongValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetLongValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetLongValidResponse{}, err
	}
	resp, err := client.getLongValidHandleResponse(httpResp)
	return resp, err
}

// getLongValidCreateRequest creates the GetLongValid request.
func (client *ArrayClient) getLongValidCreateRequest(ctx context.Context, _ *ArrayClientGetLongValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/long/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLongValidHandleResponse handles the GetLongValid response.
func (client *ArrayClient) getLongValidHandleResponse(resp *http.Response) (ArrayClientGetLongValidResponse, error) {
	result := ArrayClientGetLongValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int64Array); err != nil {
		return ArrayClientGetLongValidResponse{}, err
	}
	return result, nil
}

// GetNull - Get null array value
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetNullOptions contains the optional parameters for the ArrayClient.GetNull method.
func (client *ArrayClient) GetNull(ctx context.Context, options *ArrayClientGetNullOptions) (ArrayClientGetNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetNullResponse{}, err
	}
	resp, err := client.getNullHandleResponse(httpResp)
	return resp, err
}

// getNullCreateRequest creates the GetNull request.
func (client *ArrayClient) getNullCreateRequest(ctx context.Context, _ *ArrayClientGetNullOptions) (*policy.Request, error) {
	urlPath := "/array/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNullHandleResponse handles the GetNull response.
func (client *ArrayClient) getNullHandleResponse(resp *http.Response) (ArrayClientGetNullResponse, error) {
	result := ArrayClientGetNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Int32Array); err != nil {
		return ArrayClientGetNullResponse{}, err
	}
	return result, nil
}

// GetStringEnumValid - Get enum array value ['foo1', 'foo2', 'foo3']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetStringEnumValidOptions contains the optional parameters for the ArrayClient.GetStringEnumValid
//     method.
func (client *ArrayClient) GetStringEnumValid(ctx context.Context, options *ArrayClientGetStringEnumValidOptions) (ArrayClientGetStringEnumValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetStringEnumValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getStringEnumValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetStringEnumValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetStringEnumValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetStringEnumValidResponse{}, err
	}
	resp, err := client.getStringEnumValidHandleResponse(httpResp)
	return resp, err
}

// getStringEnumValidCreateRequest creates the GetStringEnumValid request.
func (client *ArrayClient) getStringEnumValidCreateRequest(ctx context.Context, _ *ArrayClientGetStringEnumValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/string-enum/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStringEnumValidHandleResponse handles the GetStringEnumValid response.
func (client *ArrayClient) getStringEnumValidHandleResponse(resp *http.Response) (ArrayClientGetStringEnumValidResponse, error) {
	result := ArrayClientGetStringEnumValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Enum0Array); err != nil {
		return ArrayClientGetStringEnumValidResponse{}, err
	}
	return result, nil
}

// GetStringValid - Get string array value ['foo1', 'foo2', 'foo3']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetStringValidOptions contains the optional parameters for the ArrayClient.GetStringValid method.
func (client *ArrayClient) GetStringValid(ctx context.Context, options *ArrayClientGetStringValidOptions) (ArrayClientGetStringValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetStringValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getStringValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetStringValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetStringValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetStringValidResponse{}, err
	}
	resp, err := client.getStringValidHandleResponse(httpResp)
	return resp, err
}

// getStringValidCreateRequest creates the GetStringValid request.
func (client *ArrayClient) getStringValidCreateRequest(ctx context.Context, _ *ArrayClientGetStringValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/string/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStringValidHandleResponse handles the GetStringValid response.
func (client *ArrayClient) getStringValidHandleResponse(resp *http.Response) (ArrayClientGetStringValidResponse, error) {
	result := ArrayClientGetStringValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ArrayClientGetStringValidResponse{}, err
	}
	return result, nil
}

// GetStringWithInvalid - Get string array value ['foo', 123, 'foo2']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetStringWithInvalidOptions contains the optional parameters for the ArrayClient.GetStringWithInvalid
//     method.
func (client *ArrayClient) GetStringWithInvalid(ctx context.Context, options *ArrayClientGetStringWithInvalidOptions) (ArrayClientGetStringWithInvalidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetStringWithInvalid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getStringWithInvalidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetStringWithInvalidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetStringWithInvalidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetStringWithInvalidResponse{}, err
	}
	resp, err := client.getStringWithInvalidHandleResponse(httpResp)
	return resp, err
}

// getStringWithInvalidCreateRequest creates the GetStringWithInvalid request.
func (client *ArrayClient) getStringWithInvalidCreateRequest(ctx context.Context, _ *ArrayClientGetStringWithInvalidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/string/foo.123.foo2"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStringWithInvalidHandleResponse handles the GetStringWithInvalid response.
func (client *ArrayClient) getStringWithInvalidHandleResponse(resp *http.Response) (ArrayClientGetStringWithInvalidResponse, error) {
	result := ArrayClientGetStringWithInvalidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ArrayClientGetStringWithInvalidResponse{}, err
	}
	return result, nil
}

// GetStringWithNull - Get string array value ['foo', null, 'foo2']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetStringWithNullOptions contains the optional parameters for the ArrayClient.GetStringWithNull method.
func (client *ArrayClient) GetStringWithNull(ctx context.Context, options *ArrayClientGetStringWithNullOptions) (ArrayClientGetStringWithNullResponse, error) {
	var err error
	const operationName = "ArrayClient.GetStringWithNull"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getStringWithNullCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetStringWithNullResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetStringWithNullResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetStringWithNullResponse{}, err
	}
	resp, err := client.getStringWithNullHandleResponse(httpResp)
	return resp, err
}

// getStringWithNullCreateRequest creates the GetStringWithNull request.
func (client *ArrayClient) getStringWithNullCreateRequest(ctx context.Context, _ *ArrayClientGetStringWithNullOptions) (*policy.Request, error) {
	urlPath := "/array/prim/string/foo.null.foo2"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStringWithNullHandleResponse handles the GetStringWithNull response.
func (client *ArrayClient) getStringWithNullHandleResponse(resp *http.Response) (ArrayClientGetStringWithNullResponse, error) {
	result := ArrayClientGetStringWithNullResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ArrayClientGetStringWithNullResponse{}, err
	}
	return result, nil
}

// GetUUIDInvalidChars - Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetUUIDInvalidCharsOptions contains the optional parameters for the ArrayClient.GetUUIDInvalidChars
//     method.
func (client *ArrayClient) GetUUIDInvalidChars(ctx context.Context, options *ArrayClientGetUUIDInvalidCharsOptions) (ArrayClientGetUUIDInvalidCharsResponse, error) {
	var err error
	const operationName = "ArrayClient.GetUUIDInvalidChars"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getUUIDInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetUUIDInvalidCharsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetUUIDInvalidCharsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetUUIDInvalidCharsResponse{}, err
	}
	resp, err := client.getUUIDInvalidCharsHandleResponse(httpResp)
	return resp, err
}

// getUUIDInvalidCharsCreateRequest creates the GetUUIDInvalidChars request.
func (client *ArrayClient) getUUIDInvalidCharsCreateRequest(ctx context.Context, _ *ArrayClientGetUUIDInvalidCharsOptions) (*policy.Request, error) {
	urlPath := "/array/prim/uuid/invalidchars"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUUIDInvalidCharsHandleResponse handles the GetUUIDInvalidChars response.
func (client *ArrayClient) getUUIDInvalidCharsHandleResponse(resp *http.Response) (ArrayClientGetUUIDInvalidCharsResponse, error) {
	result := ArrayClientGetUUIDInvalidCharsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ArrayClientGetUUIDInvalidCharsResponse{}, err
	}
	return result, nil
}

// GetUUIDValid - Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientGetUUIDValidOptions contains the optional parameters for the ArrayClient.GetUUIDValid method.
func (client *ArrayClient) GetUUIDValid(ctx context.Context, options *ArrayClientGetUUIDValidOptions) (ArrayClientGetUUIDValidResponse, error) {
	var err error
	const operationName = "ArrayClient.GetUUIDValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getUUIDValidCreateRequest(ctx, options)
	if err != nil {
		return ArrayClientGetUUIDValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientGetUUIDValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientGetUUIDValidResponse{}, err
	}
	resp, err := client.getUUIDValidHandleResponse(httpResp)
	return resp, err
}

// getUUIDValidCreateRequest creates the GetUUIDValid request.
func (client *ArrayClient) getUUIDValidCreateRequest(ctx context.Context, _ *ArrayClientGetUUIDValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/uuid/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUUIDValidHandleResponse handles the GetUUIDValid response.
func (client *ArrayClient) getUUIDValidHandleResponse(resp *http.Response) (ArrayClientGetUUIDValidResponse, error) {
	result := ArrayClientGetUUIDValidResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringArray); err != nil {
		return ArrayClientGetUUIDValidResponse{}, err
	}
	return result, nil
}

// PutArrayValid - Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutArrayValidOptions contains the optional parameters for the ArrayClient.PutArrayValid method.
func (client *ArrayClient) PutArrayValid(ctx context.Context, arrayBody [][]*string, options *ArrayClientPutArrayValidOptions) (ArrayClientPutArrayValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutArrayValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putArrayValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutArrayValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutArrayValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutArrayValidResponse{}, err
	}
	return ArrayClientPutArrayValidResponse{}, nil
}

// putArrayValidCreateRequest creates the PutArrayValid request.
func (client *ArrayClient) putArrayValidCreateRequest(ctx context.Context, arrayBody [][]*string, _ *ArrayClientPutArrayValidOptions) (*policy.Request, error) {
	urlPath := "/array/array/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutBooleanTfft - Set array value empty [true, false, false, true]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutBooleanTfftOptions contains the optional parameters for the ArrayClient.PutBooleanTfft method.
func (client *ArrayClient) PutBooleanTfft(ctx context.Context, arrayBody []*bool, options *ArrayClientPutBooleanTfftOptions) (ArrayClientPutBooleanTfftResponse, error) {
	var err error
	const operationName = "ArrayClient.PutBooleanTfft"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putBooleanTfftCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutBooleanTfftResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutBooleanTfftResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutBooleanTfftResponse{}, err
	}
	return ArrayClientPutBooleanTfftResponse{}, nil
}

// putBooleanTfftCreateRequest creates the PutBooleanTfft request.
func (client *ArrayClient) putBooleanTfftCreateRequest(ctx context.Context, arrayBody []*bool, _ *ArrayClientPutBooleanTfftOptions) (*policy.Request, error) {
	urlPath := "/array/prim/boolean/tfft"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutByteValid - Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base
// 64
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutByteValidOptions contains the optional parameters for the ArrayClient.PutByteValid method.
func (client *ArrayClient) PutByteValid(ctx context.Context, arrayBody [][]byte, options *ArrayClientPutByteValidOptions) (ArrayClientPutByteValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutByteValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putByteValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutByteValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutByteValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutByteValidResponse{}, err
	}
	return ArrayClientPutByteValidResponse{}, nil
}

// putByteValidCreateRequest creates the PutByteValid request.
func (client *ArrayClient) putByteValidCreateRequest(ctx context.Context, arrayBody [][]byte, _ *ArrayClientPutByteValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/byte/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutComplexValid - Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'},
// {'integer': 5, 'string': '6'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutComplexValidOptions contains the optional parameters for the ArrayClient.PutComplexValid method.
func (client *ArrayClient) PutComplexValid(ctx context.Context, arrayBody []*Product, options *ArrayClientPutComplexValidOptions) (ArrayClientPutComplexValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutComplexValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putComplexValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutComplexValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutComplexValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutComplexValidResponse{}, err
	}
	return ArrayClientPutComplexValidResponse{}, nil
}

// putComplexValidCreateRequest creates the PutComplexValid request.
func (client *ArrayClient) putComplexValidCreateRequest(ctx context.Context, arrayBody []*Product, _ *ArrayClientPutComplexValidOptions) (*policy.Request, error) {
	urlPath := "/array/complex/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutDateTimeRFC1123Valid - Set array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct
// 1492 10:15:01 GMT']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutDateTimeRFC1123ValidOptions contains the optional parameters for the ArrayClient.PutDateTimeRFC1123Valid
//     method.
func (client *ArrayClient) PutDateTimeRFC1123Valid(ctx context.Context, arrayBody []*time.Time, options *ArrayClientPutDateTimeRFC1123ValidOptions) (ArrayClientPutDateTimeRFC1123ValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutDateTimeRFC1123Valid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putDateTimeRFC1123ValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutDateTimeRFC1123ValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutDateTimeRFC1123ValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutDateTimeRFC1123ValidResponse{}, err
	}
	return ArrayClientPutDateTimeRFC1123ValidResponse{}, nil
}

// putDateTimeRFC1123ValidCreateRequest creates the PutDateTimeRFC1123Valid request.
func (client *ArrayClient) putDateTimeRFC1123ValidCreateRequest(ctx context.Context, arrayBody []*time.Time, _ *ArrayClientPutDateTimeRFC1123ValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date-time-rfc1123/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	aux := make([]*dateTimeRFC1123, len(arrayBody))
	for i := 0; i < len(arrayBody); i++ {
		aux[i] = (*dateTimeRFC1123)(arrayBody[i])
	}
	if err := runtime.MarshalAsJSON(req, aux); err != nil {
		return nil, err
	}
	return req, nil
}

// PutDateTimeValid - Set array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutDateTimeValidOptions contains the optional parameters for the ArrayClient.PutDateTimeValid method.
func (client *ArrayClient) PutDateTimeValid(ctx context.Context, arrayBody []*time.Time, options *ArrayClientPutDateTimeValidOptions) (ArrayClientPutDateTimeValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutDateTimeValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putDateTimeValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutDateTimeValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutDateTimeValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutDateTimeValidResponse{}, err
	}
	return ArrayClientPutDateTimeValidResponse{}, nil
}

// putDateTimeValidCreateRequest creates the PutDateTimeValid request.
func (client *ArrayClient) putDateTimeValidCreateRequest(ctx context.Context, arrayBody []*time.Time, _ *ArrayClientPutDateTimeValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date-time/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutDateValid - Set array value ['2000-12-01', '1980-01-02', '1492-10-12']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutDateValidOptions contains the optional parameters for the ArrayClient.PutDateValid method.
func (client *ArrayClient) PutDateValid(ctx context.Context, arrayBody []*time.Time, options *ArrayClientPutDateValidOptions) (ArrayClientPutDateValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutDateValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putDateValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutDateValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutDateValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutDateValidResponse{}, err
	}
	return ArrayClientPutDateValidResponse{}, nil
}

// putDateValidCreateRequest creates the PutDateValid request.
func (client *ArrayClient) putDateValidCreateRequest(ctx context.Context, arrayBody []*time.Time, _ *ArrayClientPutDateValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/date/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	aux := make([]*dateType, len(arrayBody))
	for i := 0; i < len(arrayBody); i++ {
		aux[i] = (*dateType)(arrayBody[i])
	}
	if err := runtime.MarshalAsJSON(req, aux); err != nil {
		return nil, err
	}
	return req, nil
}

// PutDictionaryValid - Get an array of Dictionaries of type with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four',
// '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutDictionaryValidOptions contains the optional parameters for the ArrayClient.PutDictionaryValid
//     method.
func (client *ArrayClient) PutDictionaryValid(ctx context.Context, arrayBody []map[string]*string, options *ArrayClientPutDictionaryValidOptions) (ArrayClientPutDictionaryValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutDictionaryValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putDictionaryValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutDictionaryValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutDictionaryValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutDictionaryValidResponse{}, err
	}
	return ArrayClientPutDictionaryValidResponse{}, nil
}

// putDictionaryValidCreateRequest creates the PutDictionaryValid request.
func (client *ArrayClient) putDictionaryValidCreateRequest(ctx context.Context, arrayBody []map[string]*string, _ *ArrayClientPutDictionaryValidOptions) (*policy.Request, error) {
	urlPath := "/array/dictionary/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutDoubleValid - Set array value [0, -0.01, 1.2e20]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutDoubleValidOptions contains the optional parameters for the ArrayClient.PutDoubleValid method.
func (client *ArrayClient) PutDoubleValid(ctx context.Context, arrayBody []*float64, options *ArrayClientPutDoubleValidOptions) (ArrayClientPutDoubleValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutDoubleValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putDoubleValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutDoubleValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutDoubleValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutDoubleValidResponse{}, err
	}
	return ArrayClientPutDoubleValidResponse{}, nil
}

// putDoubleValidCreateRequest creates the PutDoubleValid request.
func (client *ArrayClient) putDoubleValidCreateRequest(ctx context.Context, arrayBody []*float64, _ *ArrayClientPutDoubleValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/double/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutDurationValid - Set array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutDurationValidOptions contains the optional parameters for the ArrayClient.PutDurationValid method.
func (client *ArrayClient) PutDurationValid(ctx context.Context, arrayBody []*string, options *ArrayClientPutDurationValidOptions) (ArrayClientPutDurationValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutDurationValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putDurationValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutDurationValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutDurationValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutDurationValidResponse{}, err
	}
	return ArrayClientPutDurationValidResponse{}, nil
}

// putDurationValidCreateRequest creates the PutDurationValid request.
func (client *ArrayClient) putDurationValidCreateRequest(ctx context.Context, arrayBody []*string, _ *ArrayClientPutDurationValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/duration/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutEmpty - Set array value empty []
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutEmptyOptions contains the optional parameters for the ArrayClient.PutEmpty method.
func (client *ArrayClient) PutEmpty(ctx context.Context, arrayBody []*string, options *ArrayClientPutEmptyOptions) (ArrayClientPutEmptyResponse, error) {
	var err error
	const operationName = "ArrayClient.PutEmpty"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putEmptyCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutEmptyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutEmptyResponse{}, err
	}
	return ArrayClientPutEmptyResponse{}, nil
}

// putEmptyCreateRequest creates the PutEmpty request.
func (client *ArrayClient) putEmptyCreateRequest(ctx context.Context, arrayBody []*string, _ *ArrayClientPutEmptyOptions) (*policy.Request, error) {
	urlPath := "/array/empty"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutEnumValid - Set array value ['foo1', 'foo2', 'foo3']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutEnumValidOptions contains the optional parameters for the ArrayClient.PutEnumValid method.
func (client *ArrayClient) PutEnumValid(ctx context.Context, arrayBody []*FooEnum, options *ArrayClientPutEnumValidOptions) (ArrayClientPutEnumValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutEnumValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putEnumValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutEnumValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutEnumValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutEnumValidResponse{}, err
	}
	return ArrayClientPutEnumValidResponse{}, nil
}

// putEnumValidCreateRequest creates the PutEnumValid request.
func (client *ArrayClient) putEnumValidCreateRequest(ctx context.Context, arrayBody []*FooEnum, _ *ArrayClientPutEnumValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/enum/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutFloatValid - Set array value [0, -0.01, 1.2e20]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutFloatValidOptions contains the optional parameters for the ArrayClient.PutFloatValid method.
func (client *ArrayClient) PutFloatValid(ctx context.Context, arrayBody []*float32, options *ArrayClientPutFloatValidOptions) (ArrayClientPutFloatValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutFloatValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putFloatValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutFloatValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutFloatValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutFloatValidResponse{}, err
	}
	return ArrayClientPutFloatValidResponse{}, nil
}

// putFloatValidCreateRequest creates the PutFloatValid request.
func (client *ArrayClient) putFloatValidCreateRequest(ctx context.Context, arrayBody []*float32, _ *ArrayClientPutFloatValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/float/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutIntegerValid - Set array value empty [1, -1, 3, 300]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutIntegerValidOptions contains the optional parameters for the ArrayClient.PutIntegerValid method.
func (client *ArrayClient) PutIntegerValid(ctx context.Context, arrayBody []*int32, options *ArrayClientPutIntegerValidOptions) (ArrayClientPutIntegerValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutIntegerValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putIntegerValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutIntegerValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutIntegerValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutIntegerValidResponse{}, err
	}
	return ArrayClientPutIntegerValidResponse{}, nil
}

// putIntegerValidCreateRequest creates the PutIntegerValid request.
func (client *ArrayClient) putIntegerValidCreateRequest(ctx context.Context, arrayBody []*int32, _ *ArrayClientPutIntegerValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/integer/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutLongValid - Set array value empty [1, -1, 3, 300]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutLongValidOptions contains the optional parameters for the ArrayClient.PutLongValid method.
func (client *ArrayClient) PutLongValid(ctx context.Context, arrayBody []*int64, options *ArrayClientPutLongValidOptions) (ArrayClientPutLongValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutLongValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putLongValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutLongValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutLongValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutLongValidResponse{}, err
	}
	return ArrayClientPutLongValidResponse{}, nil
}

// putLongValidCreateRequest creates the PutLongValid request.
func (client *ArrayClient) putLongValidCreateRequest(ctx context.Context, arrayBody []*int64, _ *ArrayClientPutLongValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/long/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutStringEnumValid - Set array value ['foo1', 'foo2', 'foo3']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutStringEnumValidOptions contains the optional parameters for the ArrayClient.PutStringEnumValid
//     method.
func (client *ArrayClient) PutStringEnumValid(ctx context.Context, arrayBody []*Enum1, options *ArrayClientPutStringEnumValidOptions) (ArrayClientPutStringEnumValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutStringEnumValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putStringEnumValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutStringEnumValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutStringEnumValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutStringEnumValidResponse{}, err
	}
	return ArrayClientPutStringEnumValidResponse{}, nil
}

// putStringEnumValidCreateRequest creates the PutStringEnumValid request.
func (client *ArrayClient) putStringEnumValidCreateRequest(ctx context.Context, arrayBody []*Enum1, _ *ArrayClientPutStringEnumValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/string-enum/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutStringValid - Set array value ['foo1', 'foo2', 'foo3']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutStringValidOptions contains the optional parameters for the ArrayClient.PutStringValid method.
func (client *ArrayClient) PutStringValid(ctx context.Context, arrayBody []*string, options *ArrayClientPutStringValidOptions) (ArrayClientPutStringValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutStringValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putStringValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutStringValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutStringValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutStringValidResponse{}, err
	}
	return ArrayClientPutStringValidResponse{}, nil
}

// putStringValidCreateRequest creates the PutStringValid request.
func (client *ArrayClient) putStringValidCreateRequest(ctx context.Context, arrayBody []*string, _ *ArrayClientPutStringValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/string/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}

// PutUUIDValid - Set array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - ArrayClientPutUUIDValidOptions contains the optional parameters for the ArrayClient.PutUUIDValid method.
func (client *ArrayClient) PutUUIDValid(ctx context.Context, arrayBody []*string, options *ArrayClientPutUUIDValidOptions) (ArrayClientPutUUIDValidResponse, error) {
	var err error
	const operationName = "ArrayClient.PutUUIDValid"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putUUIDValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return ArrayClientPutUUIDValidResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return ArrayClientPutUUIDValidResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return ArrayClientPutUUIDValidResponse{}, err
	}
	return ArrayClientPutUUIDValidResponse{}, nil
}

// putUUIDValidCreateRequest creates the PutUUIDValid request.
func (client *ArrayClient) putUUIDValidCreateRequest(ctx context.Context, arrayBody []*string, _ *ArrayClientPutUUIDValidOptions) (*policy.Request, error) {
	urlPath := "/array/prim/uuid/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, arrayBody); err != nil {
		return nil, err
	}
	return req, nil
}
