//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// PagingClient contains the methods for the Paging group.
// Don't use this type directly, use a constructor function instead.
type PagingClient struct {
	internal *azcore.Client
}

// NewDuplicateParamsPager - Define filter as a query param for all calls. However, the returned next link will also include
// the filter as part of it. Make sure you don't end up duplicating the filter param in the url sent.
//
// Generated from API version 1.0.0
//   - options - PagingClientDuplicateParamsOptions contains the optional parameters for the PagingClient.NewDuplicateParamsPager
//     method.
func (client *PagingClient) NewDuplicateParamsPager(options *PagingClientDuplicateParamsOptions) *runtime.Pager[PagingClientDuplicateParamsResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientDuplicateParamsResponse]{
		More: func(page PagingClientDuplicateParamsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientDuplicateParamsResponse) (PagingClientDuplicateParamsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewDuplicateParamsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.duplicateParamsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientDuplicateParamsResponse{}, err
			}
			return client.duplicateParamsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// duplicateParamsCreateRequest creates the DuplicateParams request.
func (client *PagingClient) duplicateParamsCreateRequest(ctx context.Context, options *PagingClientDuplicateParamsOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/duplicateParams/1"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// duplicateParamsHandleResponse handles the DuplicateParams response.
func (client *PagingClient) duplicateParamsHandleResponse(resp *http.Response) (PagingClientDuplicateParamsResponse, error) {
	result := PagingClientDuplicateParamsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientDuplicateParamsResponse{}, err
	}
	return result, nil
}

// NewFirstResponseEmptyPager - A paging operation whose first response's items list is empty, but still returns a next link.
// Second (and final) call, will give you an items list of 1.
//
// Generated from API version 1.0.0
//   - options - PagingClientFirstResponseEmptyOptions contains the optional parameters for the PagingClient.NewFirstResponseEmptyPager
//     method.
func (client *PagingClient) NewFirstResponseEmptyPager(options *PagingClientFirstResponseEmptyOptions) *runtime.Pager[PagingClientFirstResponseEmptyResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientFirstResponseEmptyResponse]{
		More: func(page PagingClientFirstResponseEmptyResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientFirstResponseEmptyResponse) (PagingClientFirstResponseEmptyResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewFirstResponseEmptyPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.firstResponseEmptyCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientFirstResponseEmptyResponse{}, err
			}
			return client.firstResponseEmptyHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// firstResponseEmptyCreateRequest creates the FirstResponseEmpty request.
func (client *PagingClient) firstResponseEmptyCreateRequest(ctx context.Context, options *PagingClientFirstResponseEmptyOptions) (*policy.Request, error) {
	urlPath := "/paging/firstResponseEmpty/1"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// firstResponseEmptyHandleResponse handles the FirstResponseEmpty response.
func (client *PagingClient) firstResponseEmptyHandleResponse(resp *http.Response) (PagingClientFirstResponseEmptyResponse, error) {
	result := PagingClientFirstResponseEmptyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResultValue); err != nil {
		return PagingClientFirstResponseEmptyResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesPager - A paging operation that includes a nextLink that has 10 pages
//
// Generated from API version 1.0.0
//   - options - PagingClientGetMultiplePagesOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesPager
//     method.
func (client *PagingClient) NewGetMultiplePagesPager(options *PagingClientGetMultiplePagesOptions) *runtime.Pager[PagingClientGetMultiplePagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesResponse]{
		More: func(page PagingClientGetMultiplePagesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesResponse) (PagingClientGetMultiplePagesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesResponse{}, err
			}
			return client.getMultiplePagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *PagingClient) getMultiplePagesCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Maxresults != nil {
		req.Raw().Header["maxresults"] = []string{strconv.FormatInt(int64(*options.Maxresults), 10)}
	}
	if options != nil && options.Timeout != nil {
		req.Raw().Header["timeout"] = []string{strconv.FormatInt(int64(*options.Timeout), 10)}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *PagingClient) getMultiplePagesHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesResponse, error) {
	result := PagingClientGetMultiplePagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesFailurePager - A paging operation that receives a 400 on the second call
//
// Generated from API version 1.0.0
//   - options - PagingClientGetMultiplePagesFailureOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesFailurePager
//     method.
func (client *PagingClient) NewGetMultiplePagesFailurePager(options *PagingClientGetMultiplePagesFailureOptions) *runtime.Pager[PagingClientGetMultiplePagesFailureResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesFailureResponse]{
		More: func(page PagingClientGetMultiplePagesFailureResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesFailureResponse) (PagingClientGetMultiplePagesFailureResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesFailurePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesFailureCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesFailureResponse{}, err
			}
			return client.getMultiplePagesFailureHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *PagingClient) getMultiplePagesFailureCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesFailureOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/failure"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *PagingClient) getMultiplePagesFailureHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFailureResponse, error) {
	result := PagingClientGetMultiplePagesFailureResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesFailureResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesFailureURIPager - A paging operation that receives an invalid nextLink
//
// Generated from API version 1.0.0
//   - options - PagingClientGetMultiplePagesFailureURIOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesFailureURIPager
//     method.
func (client *PagingClient) NewGetMultiplePagesFailureURIPager(options *PagingClientGetMultiplePagesFailureURIOptions) *runtime.Pager[PagingClientGetMultiplePagesFailureURIResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesFailureURIResponse]{
		More: func(page PagingClientGetMultiplePagesFailureURIResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesFailureURIResponse) (PagingClientGetMultiplePagesFailureURIResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesFailureURIPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesFailureURICreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesFailureURIResponse{}, err
			}
			return client.getMultiplePagesFailureURIHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesFailureURICreateRequest creates the GetMultiplePagesFailureURI request.
func (client *PagingClient) getMultiplePagesFailureURICreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesFailureURIOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesFailureURIHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *PagingClient) getMultiplePagesFailureURIHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFailureURIResponse, error) {
	result := PagingClientGetMultiplePagesFailureURIResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesFailureURIResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesFragmentNextLinkPager - A paging operation that doesn't return a full URL, just a fragment
//
// Generated from API version 1.0.0
//   - apiVersion - Sets the api version to use.
//   - tenant - Sets the tenant to use.
//   - options - PagingClientGetMultiplePagesFragmentNextLinkOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesFragmentNextLinkPager
//     method.
func (client *PagingClient) NewGetMultiplePagesFragmentNextLinkPager(apiVersion string, tenant string, options *PagingClientGetMultiplePagesFragmentNextLinkOptions) *runtime.Pager[PagingClientGetMultiplePagesFragmentNextLinkResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesFragmentNextLinkResponse]{
		More: func(page PagingClientGetMultiplePagesFragmentNextLinkResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesFragmentNextLinkResponse) (PagingClientGetMultiplePagesFragmentNextLinkResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesFragmentNextLinkPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesFragmentNextLinkCreateRequest(ctx, apiVersion, tenant, options)
			}, &runtime.FetcherForNextLinkOptions{
				NextReq: func(ctx context.Context, encodedNextLink string) (*policy.Request, error) {
					return client.nextFragmentCreateRequest(ctx, apiVersion, tenant, encodedNextLink)
				},
			})
			if err != nil {
				return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, err
			}
			return client.getMultiplePagesFragmentNextLinkHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *PagingClient) getMultiplePagesFragmentNextLinkCreateRequest(ctx context.Context, apiVersion string, tenant string, options *PagingClientGetMultiplePagesFragmentNextLinkOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	if tenant == "" {
		return nil, errors.New("parameter tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", apiVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *PagingClient) getMultiplePagesFragmentNextLinkHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFragmentNextLinkResponse, error) {
	result := PagingClientGetMultiplePagesFragmentNextLinkResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesFragmentWithGroupingNextLinkPager - A paging operation that doesn't return a full URL, just a fragment
// with parameters grouped
//
// Generated from API version 1.0.0
//   - CustomParameterGroup - CustomParameterGroup contains a group of parameters for the PagingClient.GetMultiplePagesFragmentWithGroupingNextLink
//     method.
//   - options - PagingClientGetMultiplePagesFragmentWithGroupingNextLinkOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesFragmentWithGroupingNextLinkPager
//     method.
func (client *PagingClient) NewGetMultiplePagesFragmentWithGroupingNextLinkPager(customParameterGroup CustomParameterGroup, options *PagingClientGetMultiplePagesFragmentWithGroupingNextLinkOptions) *runtime.Pager[PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse]{
		More: func(page PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse) (PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesFragmentWithGroupingNextLinkPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx, customParameterGroup, options)
			}, &runtime.FetcherForNextLinkOptions{
				NextReq: func(ctx context.Context, encodedNextLink string) (*policy.Request, error) {
					return client.nextFragmentWithGroupingCreateRequest(ctx, encodedNextLink, customParameterGroup)
				},
			})
			if err != nil {
				return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, err
			}
			return client.getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx context.Context, customParameterGroup CustomParameterGroup, options *PagingClientGetMultiplePagesFragmentWithGroupingNextLinkOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	if customParameterGroup.Tenant == "" {
		return nil, errors.New("parameter customParameterGroup.Tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", customParameterGroup.APIVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse, error) {
	result := PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, err
	}
	return result, nil
}

// BeginGetMultiplePagesLRO - A long-running paging operation that includes a nextLink that has 10 pages
//
// Generated from API version 1.0.0
//   - options - PagingClientBeginGetMultiplePagesLROOptions contains the optional parameters for the PagingClient.BeginGetMultiplePagesLRO
//     method.
func (client *PagingClient) BeginGetMultiplePagesLRO(ctx context.Context, options *PagingClientBeginGetMultiplePagesLROOptions) (*runtime.Poller[*runtime.Pager[PagingClientGetMultiplePagesLROResponse]], error) {
	pager := runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesLROResponse]{
		More: func(page PagingClientGetMultiplePagesLROResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesLROResponse) (PagingClientGetMultiplePagesLROResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.BeginGetMultiplePagesLRO")
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), *page.NextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesLROCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesLROResponse{}, err
			}
			return client.getMultiplePagesLROHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
	if options == nil || options.ResumeToken == "" {
		resp, err := client.getMultiplePagesLRO(ctx, options)
		if err != nil {
			return nil, err
		}
		poller, err := runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[*runtime.Pager[PagingClientGetMultiplePagesLROResponse]]{
			Response: &pager,
			Tracer:   client.internal.Tracer(),
		})
		return poller, err
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[*runtime.Pager[PagingClientGetMultiplePagesLROResponse]]{
			Response: &pager,
			Tracer:   client.internal.Tracer(),
		})
	}
}

// GetMultiplePagesLRO - A long-running paging operation that includes a nextLink that has 10 pages
//
// Generated from API version 1.0.0
func (client *PagingClient) getMultiplePagesLRO(ctx context.Context, options *PagingClientBeginGetMultiplePagesLROOptions) (*http.Response, error) {
	var err error
	const operationName = "PagingClient.BeginGetMultiplePagesLRO"
	ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, operationName)
	ctx, endSpan := runtime.StartSpan(ctx, operationName, client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getMultiplePagesLROCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return nil, err
	}
	return httpResp, nil
}

// getMultiplePagesLROCreateRequest creates the GetMultiplePagesLRO request.
func (client *PagingClient) getMultiplePagesLROCreateRequest(ctx context.Context, options *PagingClientBeginGetMultiplePagesLROOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/lro"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Maxresults != nil {
		req.Raw().Header["maxresults"] = []string{strconv.FormatInt(int64(*options.Maxresults), 10)}
	}
	if options != nil && options.Timeout != nil {
		req.Raw().Header["timeout"] = []string{strconv.FormatInt(int64(*options.Timeout), 10)}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesLROHandleResponse handles the GetMultiplePagesLRO response.
func (client *PagingClient) getMultiplePagesLROHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesLROResponse, error) {
	result := PagingClientGetMultiplePagesLROResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesLROResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesRetryFirstPager - A paging operation that fails on the first call with 500 and then retries and then
// get a response including a nextLink that has 10 pages
//
// Generated from API version 1.0.0
//   - options - PagingClientGetMultiplePagesRetryFirstOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesRetryFirstPager
//     method.
func (client *PagingClient) NewGetMultiplePagesRetryFirstPager(options *PagingClientGetMultiplePagesRetryFirstOptions) *runtime.Pager[PagingClientGetMultiplePagesRetryFirstResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesRetryFirstResponse]{
		More: func(page PagingClientGetMultiplePagesRetryFirstResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesRetryFirstResponse) (PagingClientGetMultiplePagesRetryFirstResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesRetryFirstPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesRetryFirstCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesRetryFirstResponse{}, err
			}
			return client.getMultiplePagesRetryFirstHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *PagingClient) getMultiplePagesRetryFirstCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesRetryFirstOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *PagingClient) getMultiplePagesRetryFirstHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesRetryFirstResponse, error) {
	result := PagingClientGetMultiplePagesRetryFirstResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesRetryFirstResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesRetrySecondPager - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call
// fails first with 500. The client should retry and finish all 10 pages eventually.
//
// Generated from API version 1.0.0
//   - options - PagingClientGetMultiplePagesRetrySecondOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesRetrySecondPager
//     method.
func (client *PagingClient) NewGetMultiplePagesRetrySecondPager(options *PagingClientGetMultiplePagesRetrySecondOptions) *runtime.Pager[PagingClientGetMultiplePagesRetrySecondResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesRetrySecondResponse]{
		More: func(page PagingClientGetMultiplePagesRetrySecondResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesRetrySecondResponse) (PagingClientGetMultiplePagesRetrySecondResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesRetrySecondPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesRetrySecondCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesRetrySecondResponse{}, err
			}
			return client.getMultiplePagesRetrySecondHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *PagingClient) getMultiplePagesRetrySecondCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesRetrySecondOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *PagingClient) getMultiplePagesRetrySecondHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesRetrySecondResponse, error) {
	result := PagingClientGetMultiplePagesRetrySecondResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesRetrySecondResponse{}, err
	}
	return result, nil
}

// NewGetMultiplePagesWithOffsetPager - A paging operation that includes a nextLink that has 10 pages
//
// Generated from API version 1.0.0
//   - options - PagingClientGetMultiplePagesWithOffsetOptions contains the optional parameters for the PagingClient.NewGetMultiplePagesWithOffsetPager
//     method.
func (client *PagingClient) NewGetMultiplePagesWithOffsetPager(options PagingClientGetMultiplePagesWithOffsetOptions) *runtime.Pager[PagingClientGetMultiplePagesWithOffsetResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetMultiplePagesWithOffsetResponse]{
		More: func(page PagingClientGetMultiplePagesWithOffsetResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetMultiplePagesWithOffsetResponse) (PagingClientGetMultiplePagesWithOffsetResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetMultiplePagesWithOffsetPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getMultiplePagesWithOffsetCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetMultiplePagesWithOffsetResponse{}, err
			}
			return client.getMultiplePagesWithOffsetHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *PagingClient) getMultiplePagesWithOffsetCreateRequest(ctx context.Context, options PagingClientGetMultiplePagesWithOffsetOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(options.Offset), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options.Maxresults != nil {
		req.Raw().Header["maxresults"] = []string{strconv.FormatInt(int64(*options.Maxresults), 10)}
	}
	if options.Timeout != nil {
		req.Raw().Header["timeout"] = []string{strconv.FormatInt(int64(*options.Timeout), 10)}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *PagingClient) getMultiplePagesWithOffsetHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesWithOffsetResponse, error) {
	result := PagingClientGetMultiplePagesWithOffsetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesWithOffsetResponse{}, err
	}
	return result, nil
}

// NewGetNoItemNamePagesPager - A paging operation that must return result of the default 'value' node.
//
// Generated from API version 1.0.0
//   - options - PagingClientGetNoItemNamePagesOptions contains the optional parameters for the PagingClient.NewGetNoItemNamePagesPager
//     method.
func (client *PagingClient) NewGetNoItemNamePagesPager(options *PagingClientGetNoItemNamePagesOptions) *runtime.Pager[PagingClientGetNoItemNamePagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetNoItemNamePagesResponse]{
		More: func(page PagingClientGetNoItemNamePagesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetNoItemNamePagesResponse) (PagingClientGetNoItemNamePagesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetNoItemNamePagesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getNoItemNamePagesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetNoItemNamePagesResponse{}, err
			}
			return client.getNoItemNamePagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *PagingClient) getNoItemNamePagesCreateRequest(ctx context.Context, options *PagingClientGetNoItemNamePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/noitemname"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *PagingClient) getNoItemNamePagesHandleResponse(resp *http.Response) (PagingClientGetNoItemNamePagesResponse, error) {
	result := PagingClientGetNoItemNamePagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResultValue); err != nil {
		return PagingClientGetNoItemNamePagesResponse{}, err
	}
	return result, nil
}

// NewGetNullNextLinkNamePagesPager - A paging operation that must ignore any kind of nextLink, and stop after page 1.
//
// Generated from API version 1.0.0
//   - options - PagingClientGetNullNextLinkNamePagesOptions contains the optional parameters for the PagingClient.NewGetNullNextLinkNamePagesPager
//     method.
func (client *PagingClient) NewGetNullNextLinkNamePagesPager(options *PagingClientGetNullNextLinkNamePagesOptions) *runtime.Pager[PagingClientGetNullNextLinkNamePagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetNullNextLinkNamePagesResponse]{
		More: func(page PagingClientGetNullNextLinkNamePagesResponse) bool {
			return false
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetNullNextLinkNamePagesResponse) (PagingClientGetNullNextLinkNamePagesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetNullNextLinkNamePagesPager")
			req, err := client.getNullNextLinkNamePagesCreateRequest(ctx, options)
			if err != nil {
				return PagingClientGetNullNextLinkNamePagesResponse{}, err
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return PagingClientGetNullNextLinkNamePagesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PagingClientGetNullNextLinkNamePagesResponse{}, runtime.NewResponseError(resp)
			}
			return client.getNullNextLinkNamePagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *PagingClient) getNullNextLinkNamePagesCreateRequest(ctx context.Context, options *PagingClientGetNullNextLinkNamePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/nullnextlink"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *PagingClient) getNullNextLinkNamePagesHandleResponse(resp *http.Response) (PagingClientGetNullNextLinkNamePagesResponse, error) {
	result := PagingClientGetNullNextLinkNamePagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, err
	}
	return result, nil
}

// NewGetODataMultiplePagesPager - A paging operation that includes a nextLink in odata format that has 10 pages
//
// Generated from API version 1.0.0
//   - options - PagingClientGetODataMultiplePagesOptions contains the optional parameters for the PagingClient.NewGetODataMultiplePagesPager
//     method.
func (client *PagingClient) NewGetODataMultiplePagesPager(options *PagingClientGetODataMultiplePagesOptions) *runtime.Pager[PagingClientGetODataMultiplePagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetODataMultiplePagesResponse]{
		More: func(page PagingClientGetODataMultiplePagesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetODataMultiplePagesResponse) (PagingClientGetODataMultiplePagesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetODataMultiplePagesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getODataMultiplePagesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetODataMultiplePagesResponse{}, err
			}
			return client.getODataMultiplePagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getODataMultiplePagesCreateRequest creates the GetODataMultiplePages request.
func (client *PagingClient) getODataMultiplePagesCreateRequest(ctx context.Context, options *PagingClientGetODataMultiplePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/odata"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Maxresults != nil {
		req.Raw().Header["maxresults"] = []string{strconv.FormatInt(int64(*options.Maxresults), 10)}
	}
	if options != nil && options.Timeout != nil {
		req.Raw().Header["timeout"] = []string{strconv.FormatInt(int64(*options.Timeout), 10)}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getODataMultiplePagesHandleResponse handles the GetODataMultiplePages response.
func (client *PagingClient) getODataMultiplePagesHandleResponse(resp *http.Response) (PagingClientGetODataMultiplePagesResponse, error) {
	result := PagingClientGetODataMultiplePagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientGetODataMultiplePagesResponse{}, err
	}
	return result, nil
}

// NewGetPagingModelWithItemNameWithXMSClientNamePager - A paging operation that returns a paging model whose item name is
// is overriden by x-ms-client-name 'indexes'.
//
// Generated from API version 1.0.0
//   - options - PagingClientGetPagingModelWithItemNameWithXMSClientNameOptions contains the optional parameters for the PagingClient.NewGetPagingModelWithItemNameWithXMSClientNamePager
//     method.
func (client *PagingClient) NewGetPagingModelWithItemNameWithXMSClientNamePager(options *PagingClientGetPagingModelWithItemNameWithXMSClientNameOptions) *runtime.Pager[PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse]{
		More: func(page PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse) (PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetPagingModelWithItemNameWithXMSClientNamePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getPagingModelWithItemNameWithXMSClientNameCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, err
			}
			return client.getPagingModelWithItemNameWithXMSClientNameHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getPagingModelWithItemNameWithXMSClientNameCreateRequest creates the GetPagingModelWithItemNameWithXMSClientName request.
func (client *PagingClient) getPagingModelWithItemNameWithXMSClientNameCreateRequest(ctx context.Context, options *PagingClientGetPagingModelWithItemNameWithXMSClientNameOptions) (*policy.Request, error) {
	urlPath := "/paging/itemNameWithXMSClientName"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPagingModelWithItemNameWithXMSClientNameHandleResponse handles the GetPagingModelWithItemNameWithXMSClientName response.
func (client *PagingClient) getPagingModelWithItemNameWithXMSClientNameHandleResponse(resp *http.Response) (PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse, error) {
	result := PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResultValueWithXMSClientName); err != nil {
		return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, err
	}
	return result, nil
}

// NewGetSinglePagesPager - A paging operation that finishes on the first call without a nextlink
//
// Generated from API version 1.0.0
//   - options - PagingClientGetSinglePagesOptions contains the optional parameters for the PagingClient.NewGetSinglePagesPager
//     method.
func (client *PagingClient) NewGetSinglePagesPager(options *PagingClientGetSinglePagesOptions) *runtime.Pager[PagingClientGetSinglePagesResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetSinglePagesResponse]{
		More: func(page PagingClientGetSinglePagesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetSinglePagesResponse) (PagingClientGetSinglePagesResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetSinglePagesPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getSinglePagesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetSinglePagesResponse{}, err
			}
			return client.getSinglePagesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getSinglePagesCreateRequest creates the GetSinglePages request.
func (client *PagingClient) getSinglePagesCreateRequest(ctx context.Context, options *PagingClientGetSinglePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/single"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSinglePagesHandleResponse handles the GetSinglePages response.
func (client *PagingClient) getSinglePagesHandleResponse(resp *http.Response) (PagingClientGetSinglePagesResponse, error) {
	result := PagingClientGetSinglePagesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetSinglePagesResponse{}, err
	}
	return result, nil
}

// NewGetSinglePagesFailurePager - A paging operation that receives a 400 on the first call
//
// Generated from API version 1.0.0
//   - options - PagingClientGetSinglePagesFailureOptions contains the optional parameters for the PagingClient.NewGetSinglePagesFailurePager
//     method.
func (client *PagingClient) NewGetSinglePagesFailurePager(options *PagingClientGetSinglePagesFailureOptions) *runtime.Pager[PagingClientGetSinglePagesFailureResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetSinglePagesFailureResponse]{
		More: func(page PagingClientGetSinglePagesFailureResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetSinglePagesFailureResponse) (PagingClientGetSinglePagesFailureResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetSinglePagesFailurePager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getSinglePagesFailureCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return PagingClientGetSinglePagesFailureResponse{}, err
			}
			return client.getSinglePagesFailureHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *PagingClient) getSinglePagesFailureCreateRequest(ctx context.Context, options *PagingClientGetSinglePagesFailureOptions) (*policy.Request, error) {
	urlPath := "/paging/single/failure"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *PagingClient) getSinglePagesFailureHandleResponse(resp *http.Response) (PagingClientGetSinglePagesFailureResponse, error) {
	result := PagingClientGetSinglePagesFailureResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetSinglePagesFailureResponse{}, err
	}
	return result, nil
}

// NewGetWithQueryParamsPager - A paging operation that includes a next operation. It has a different query parameter from
// it's next operation nextOperationWithQueryParams. Returns a ProductResult
//
// Generated from API version 1.0.0
//   - requiredQueryParameter - A required integer query parameter. Put in value '100' to pass test.
//   - options - PagingClientGetWithQueryParamsOptions contains the optional parameters for the PagingClient.NewGetWithQueryParamsPager
//     method.
func (client *PagingClient) NewGetWithQueryParamsPager(requiredQueryParameter int32, options *PagingClientGetWithQueryParamsOptions) *runtime.Pager[PagingClientGetWithQueryParamsResponse] {
	return runtime.NewPager(runtime.PagingHandler[PagingClientGetWithQueryParamsResponse]{
		More: func(page PagingClientGetWithQueryParamsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PagingClientGetWithQueryParamsResponse) (PagingClientGetWithQueryParamsResponse, error) {
			ctx = context.WithValue(ctx, runtime.CtxAPINameKey{}, "PagingClient.NewGetWithQueryParamsPager")
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getWithQueryParamsCreateRequest(ctx, requiredQueryParameter, options)
			}, &runtime.FetcherForNextLinkOptions{
				NextReq: func(ctx context.Context, encodedNextLink string) (*policy.Request, error) {
					return client.nextOperationWithQueryParamsCreateRequest(ctx)
				},
			})
			if err != nil {
				return PagingClientGetWithQueryParamsResponse{}, err
			}
			return client.getWithQueryParamsHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getWithQueryParamsCreateRequest creates the GetWithQueryParams request.
func (client *PagingClient) getWithQueryParamsCreateRequest(ctx context.Context, requiredQueryParameter int32, options *PagingClientGetWithQueryParamsOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/getWithQueryParams"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("requiredQueryParameter", strconv.FormatInt(int64(requiredQueryParameter), 10))
	reqQP.Set("queryConstant", "true")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWithQueryParamsHandleResponse handles the GetWithQueryParams response.
func (client *PagingClient) getWithQueryParamsHandleResponse(resp *http.Response) (PagingClientGetWithQueryParamsResponse, error) {
	result := PagingClientGetWithQueryParamsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetWithQueryParamsResponse{}, err
	}
	return result, nil
}

// nextFragmentCreateRequest creates the nextFragmentCreateRequest request.
func (client *PagingClient) nextFragmentCreateRequest(ctx context.Context, apiVersion string, tenant string, nextLink string) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	if tenant == "" {
		return nil, errors.New("parameter tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", apiVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// nextFragmentWithGroupingCreateRequest creates the nextFragmentWithGroupingCreateRequest request.
func (client *PagingClient) nextFragmentWithGroupingCreateRequest(ctx context.Context, nextLink string, customParameterGroup CustomParameterGroup) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	if customParameterGroup.Tenant == "" {
		return nil, errors.New("parameter customParameterGroup.Tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", customParameterGroup.APIVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// nextOperationWithQueryParamsCreateRequest creates the nextOperationWithQueryParamsCreateRequest request.
func (client *PagingClient) nextOperationWithQueryParamsCreateRequest(ctx context.Context) (*policy.Request, error) {
	urlPath := "/paging/multiple/nextOperationWithQueryParams"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("queryConstant", "true")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}
