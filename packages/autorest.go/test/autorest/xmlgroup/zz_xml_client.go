//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// XMLClient contains the methods for the XML group.
// Don't use this type directly, use a constructor function instead.
type XMLClient struct {
	internal *azcore.Client
}

// GetACLs - Gets storage ACLs for a container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetACLsOptions contains the optional parameters for the XMLClient.GetACLs method.
func (client *XMLClient) GetACLs(ctx context.Context, options *XMLClientGetACLsOptions) (resp XMLClientGetACLsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetACLs", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getACLsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getACLsHandleResponse(httpResp)
}

// getACLsCreateRequest creates the GetACLs request.
func (client *XMLClient) getACLsCreateRequest(ctx context.Context, options *XMLClientGetACLsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getACLsHandleResponse handles the GetACLs response.
func (client *XMLClient) getACLsHandleResponse(resp *http.Response) (XMLClientGetACLsResponse, error) {
	result := XMLClientGetACLsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetACLsResponse{}, err
	}
	return result, nil
}

// GetBytes - Get an XML document with binary property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetBytesOptions contains the optional parameters for the XMLClient.GetBytes method.
func (client *XMLClient) GetBytes(ctx context.Context, options *XMLClientGetBytesOptions) (resp XMLClientGetBytesResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetBytes", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getBytesCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getBytesHandleResponse(httpResp)
}

// getBytesCreateRequest creates the GetBytes request.
func (client *XMLClient) getBytesCreateRequest(ctx context.Context, options *XMLClientGetBytesOptions) (*policy.Request, error) {
	urlPath := "/xml/bytes"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getBytesHandleResponse handles the GetBytes response.
func (client *XMLClient) getBytesHandleResponse(resp *http.Response) (XMLClientGetBytesResponse, error) {
	result := XMLClientGetBytesResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ModelWithByteProperty); err != nil {
		return XMLClientGetBytesResponse{}, err
	}
	return result, nil
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetComplexTypeRefNoMetaOptions contains the optional parameters for the XMLClient.GetComplexTypeRefNoMeta
//     method.
func (client *XMLClient) GetComplexTypeRefNoMeta(ctx context.Context, options *XMLClientGetComplexTypeRefNoMetaOptions) (resp XMLClientGetComplexTypeRefNoMetaResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetComplexTypeRefNoMeta", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexTypeRefNoMetaCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getComplexTypeRefNoMetaHandleResponse(httpResp)
}

// getComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *XMLClient) getComplexTypeRefNoMetaCreateRequest(ctx context.Context, options *XMLClientGetComplexTypeRefNoMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleResponse(resp *http.Response) (XMLClientGetComplexTypeRefNoMetaResponse, error) {
	result := XMLClientGetComplexTypeRefNoMetaResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.RootWithRefAndNoMeta); err != nil {
		return XMLClientGetComplexTypeRefNoMetaResponse{}, err
	}
	return result, nil
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetComplexTypeRefWithMetaOptions contains the optional parameters for the XMLClient.GetComplexTypeRefWithMeta
//     method.
func (client *XMLClient) GetComplexTypeRefWithMeta(ctx context.Context, options *XMLClientGetComplexTypeRefWithMetaOptions) (resp XMLClientGetComplexTypeRefWithMetaResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetComplexTypeRefWithMeta", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getComplexTypeRefWithMetaCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getComplexTypeRefWithMetaHandleResponse(httpResp)
}

// getComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *XMLClient) getComplexTypeRefWithMetaCreateRequest(ctx context.Context, options *XMLClientGetComplexTypeRefWithMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleResponse(resp *http.Response) (XMLClientGetComplexTypeRefWithMetaResponse, error) {
	result := XMLClientGetComplexTypeRefWithMetaResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.RootWithRefAndMeta); err != nil {
		return XMLClientGetComplexTypeRefWithMetaResponse{}, err
	}
	return result, nil
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyChildElementOptions contains the optional parameters for the XMLClient.GetEmptyChildElement
//     method.
func (client *XMLClient) GetEmptyChildElement(ctx context.Context, options *XMLClientGetEmptyChildElementOptions) (resp XMLClientGetEmptyChildElementResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetEmptyChildElement", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEmptyChildElementCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getEmptyChildElementHandleResponse(httpResp)
}

// getEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *XMLClient) getEmptyChildElementCreateRequest(ctx context.Context, options *XMLClientGetEmptyChildElementOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *XMLClient) getEmptyChildElementHandleResponse(resp *http.Response) (XMLClientGetEmptyChildElementResponse, error) {
	result := XMLClientGetEmptyChildElementResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.Banana); err != nil {
		return XMLClientGetEmptyChildElementResponse{}, err
	}
	return result, nil
}

// GetEmptyList - Get an empty list.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyListOptions contains the optional parameters for the XMLClient.GetEmptyList method.
func (client *XMLClient) GetEmptyList(ctx context.Context, options *XMLClientGetEmptyListOptions) (resp XMLClientGetEmptyListResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetEmptyList", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEmptyListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getEmptyListHandleResponse(httpResp)
}

// getEmptyListCreateRequest creates the GetEmptyList request.
func (client *XMLClient) getEmptyListCreateRequest(ctx context.Context, options *XMLClientGetEmptyListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyListHandleResponse handles the GetEmptyList response.
func (client *XMLClient) getEmptyListHandleResponse(resp *http.Response) (XMLClientGetEmptyListResponse, error) {
	result := XMLClientGetEmptyListResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.Slideshow); err != nil {
		return XMLClientGetEmptyListResponse{}, err
	}
	return result, nil
}

// GetEmptyRootList - Gets an empty list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyRootListOptions contains the optional parameters for the XMLClient.GetEmptyRootList method.
func (client *XMLClient) GetEmptyRootList(ctx context.Context, options *XMLClientGetEmptyRootListOptions) (resp XMLClientGetEmptyRootListResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetEmptyRootList", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEmptyRootListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getEmptyRootListHandleResponse(httpResp)
}

// getEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *XMLClient) getEmptyRootListCreateRequest(ctx context.Context, options *XMLClientGetEmptyRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *XMLClient) getEmptyRootListHandleResponse(resp *http.Response) (XMLClientGetEmptyRootListResponse, error) {
	result := XMLClientGetEmptyRootListResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetEmptyRootListResponse{}, err
	}
	return result, nil
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyWrappedListsOptions contains the optional parameters for the XMLClient.GetEmptyWrappedLists
//     method.
func (client *XMLClient) GetEmptyWrappedLists(ctx context.Context, options *XMLClientGetEmptyWrappedListsOptions) (resp XMLClientGetEmptyWrappedListsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetEmptyWrappedLists", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getEmptyWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getEmptyWrappedListsHandleResponse(httpResp)
}

// getEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *XMLClient) getEmptyWrappedListsCreateRequest(ctx context.Context, options *XMLClientGetEmptyWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *XMLClient) getEmptyWrappedListsHandleResponse(resp *http.Response) (XMLClientGetEmptyWrappedListsResponse, error) {
	result := XMLClientGetEmptyWrappedListsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.AppleBarrel); err != nil {
		return XMLClientGetEmptyWrappedListsResponse{}, err
	}
	return result, nil
}

// GetHeaders - Get strongly-typed response headers.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetHeadersOptions contains the optional parameters for the XMLClient.GetHeaders method.
func (client *XMLClient) GetHeaders(ctx context.Context, options *XMLClientGetHeadersOptions) (resp XMLClientGetHeadersResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetHeaders", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getHeadersCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getHeadersHandleResponse(httpResp)
}

// getHeadersCreateRequest creates the GetHeaders request.
func (client *XMLClient) getHeadersCreateRequest(ctx context.Context, options *XMLClientGetHeadersOptions) (*policy.Request, error) {
	urlPath := "/xml/headers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// getHeadersHandleResponse handles the GetHeaders response.
func (client *XMLClient) getHeadersHandleResponse(resp *http.Response) (XMLClientGetHeadersResponse, error) {
	result := XMLClientGetHeadersResponse{}
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return result, nil
}

// GetRootList - Gets a list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetRootListOptions contains the optional parameters for the XMLClient.GetRootList method.
func (client *XMLClient) GetRootList(ctx context.Context, options *XMLClientGetRootListOptions) (resp XMLClientGetRootListResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetRootList", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getRootListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getRootListHandleResponse(httpResp)
}

// getRootListCreateRequest creates the GetRootList request.
func (client *XMLClient) getRootListCreateRequest(ctx context.Context, options *XMLClientGetRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRootListHandleResponse handles the GetRootList response.
func (client *XMLClient) getRootListHandleResponse(resp *http.Response) (XMLClientGetRootListResponse, error) {
	result := XMLClientGetRootListResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetRootListResponse{}, err
	}
	return result, nil
}

// GetRootListSingleItem - Gets a list with a single item.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetRootListSingleItemOptions contains the optional parameters for the XMLClient.GetRootListSingleItem
//     method.
func (client *XMLClient) GetRootListSingleItem(ctx context.Context, options *XMLClientGetRootListSingleItemOptions) (resp XMLClientGetRootListSingleItemResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetRootListSingleItem", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getRootListSingleItemCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getRootListSingleItemHandleResponse(httpResp)
}

// getRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *XMLClient) getRootListSingleItemCreateRequest(ctx context.Context, options *XMLClientGetRootListSingleItemOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *XMLClient) getRootListSingleItemHandleResponse(resp *http.Response) (XMLClientGetRootListSingleItemResponse, error) {
	result := XMLClientGetRootListSingleItemResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetRootListSingleItemResponse{}, err
	}
	return result, nil
}

// GetServiceProperties - Gets storage service properties.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetServicePropertiesOptions contains the optional parameters for the XMLClient.GetServiceProperties
//     method.
func (client *XMLClient) GetServiceProperties(ctx context.Context, options *XMLClientGetServicePropertiesOptions) (resp XMLClientGetServicePropertiesResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetServiceProperties", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getServicePropertiesCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getServicePropertiesHandleResponse(httpResp)
}

// getServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *XMLClient) getServicePropertiesCreateRequest(ctx context.Context, options *XMLClientGetServicePropertiesOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *XMLClient) getServicePropertiesHandleResponse(resp *http.Response) (XMLClientGetServicePropertiesResponse, error) {
	result := XMLClientGetServicePropertiesResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.StorageServiceProperties); err != nil {
		return XMLClientGetServicePropertiesResponse{}, err
	}
	return result, nil
}

// GetSimple - Get a simple XML document
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetSimpleOptions contains the optional parameters for the XMLClient.GetSimple method.
func (client *XMLClient) GetSimple(ctx context.Context, options *XMLClientGetSimpleOptions) (resp XMLClientGetSimpleResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetSimple", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getSimpleCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getSimpleHandleResponse(httpResp)
}

// getSimpleCreateRequest creates the GetSimple request.
func (client *XMLClient) getSimpleCreateRequest(ctx context.Context, options *XMLClientGetSimpleOptions) (*policy.Request, error) {
	urlPath := "/xml/simple"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getSimpleHandleResponse handles the GetSimple response.
func (client *XMLClient) getSimpleHandleResponse(resp *http.Response) (XMLClientGetSimpleResponse, error) {
	result := XMLClientGetSimpleResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.Slideshow); err != nil {
		return XMLClientGetSimpleResponse{}, err
	}
	return result, nil
}

// GetURI - Get an XML document with uri property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetURIOptions contains the optional parameters for the XMLClient.GetURI method.
func (client *XMLClient) GetURI(ctx context.Context, options *XMLClientGetURIOptions) (resp XMLClientGetURIResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetURI", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getURICreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getURIHandleResponse(httpResp)
}

// getURICreateRequest creates the GetURI request.
func (client *XMLClient) getURICreateRequest(ctx context.Context, options *XMLClientGetURIOptions) (*policy.Request, error) {
	urlPath := "/xml/url"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getURIHandleResponse handles the GetURI response.
func (client *XMLClient) getURIHandleResponse(resp *http.Response) (XMLClientGetURIResponse, error) {
	result := XMLClientGetURIResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ModelWithURLProperty); err != nil {
		return XMLClientGetURIResponse{}, err
	}
	return result, nil
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetWrappedListsOptions contains the optional parameters for the XMLClient.GetWrappedLists method.
func (client *XMLClient) GetWrappedLists(ctx context.Context, options *XMLClientGetWrappedListsOptions) (resp XMLClientGetWrappedListsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetWrappedLists", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getWrappedListsHandleResponse(httpResp)
}

// getWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *XMLClient) getWrappedListsCreateRequest(ctx context.Context, options *XMLClientGetWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *XMLClient) getWrappedListsHandleResponse(resp *http.Response) (XMLClientGetWrappedListsResponse, error) {
	result := XMLClientGetWrappedListsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.AppleBarrel); err != nil {
		return XMLClientGetWrappedListsResponse{}, err
	}
	return result, nil
}

// GetXMsText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language'
// property being 'english' and its 'content' property being 'I am text'
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetXMsTextOptions contains the optional parameters for the XMLClient.GetXMsText method.
func (client *XMLClient) GetXMsText(ctx context.Context, options *XMLClientGetXMsTextOptions) (resp XMLClientGetXMsTextResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.GetXMsText", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.getXMsTextCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.getXMsTextHandleResponse(httpResp)
}

// getXMsTextCreateRequest creates the GetXMsText request.
func (client *XMLClient) getXMsTextCreateRequest(ctx context.Context, options *XMLClientGetXMsTextOptions) (*policy.Request, error) {
	urlPath := "/xml/x-ms-text"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getXMsTextHandleResponse handles the GetXMsText response.
func (client *XMLClient) getXMsTextHandleResponse(resp *http.Response) (XMLClientGetXMsTextResponse, error) {
	result := XMLClientGetXMsTextResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ObjectWithXMsTextProperty); err != nil {
		return XMLClientGetXMsTextResponse{}, err
	}
	return result, nil
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientJSONInputOptions contains the optional parameters for the XMLClient.JSONInput method.
func (client *XMLClient) JSONInput(ctx context.Context, properties JSONInput, options *XMLClientJSONInputOptions) (resp XMLClientJSONInputResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.JSONInput", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.jsonInputCreateRequest(ctx, properties, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// jsonInputCreateRequest creates the JSONInput request.
func (client *XMLClient) jsonInputCreateRequest(ctx context.Context, properties JSONInput, options *XMLClientJSONInputOptions) (*policy.Request, error) {
	urlPath := "/xml/jsoninput"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if err := runtime.MarshalAsJSON(req, properties); err != nil {
		return nil, err
	}
	return req, nil
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientJSONOutputOptions contains the optional parameters for the XMLClient.JSONOutput method.
func (client *XMLClient) JSONOutput(ctx context.Context, options *XMLClientJSONOutputOptions) (resp XMLClientJSONOutputResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.JSONOutput", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.jsonOutputCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.jsonOutputHandleResponse(httpResp)
}

// jsonOutputCreateRequest creates the JSONOutput request.
func (client *XMLClient) jsonOutputCreateRequest(ctx context.Context, options *XMLClientJSONOutputOptions) (*policy.Request, error) {
	urlPath := "/xml/jsonoutput"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// jsonOutputHandleResponse handles the JSONOutput response.
func (client *XMLClient) jsonOutputHandleResponse(resp *http.Response) (XMLClientJSONOutputResponse, error) {
	result := XMLClientJSONOutputResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.JSONOutput); err != nil {
		return XMLClientJSONOutputResponse{}, err
	}
	return result, nil
}

// ListBlobs - Lists blobs in a storage container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientListBlobsOptions contains the optional parameters for the XMLClient.ListBlobs method.
func (client *XMLClient) ListBlobs(ctx context.Context, options *XMLClientListBlobsOptions) (resp XMLClientListBlobsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.ListBlobs", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listBlobsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.listBlobsHandleResponse(httpResp)
}

// listBlobsCreateRequest creates the ListBlobs request.
func (client *XMLClient) listBlobsCreateRequest(ctx context.Context, options *XMLClientListBlobsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "list")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listBlobsHandleResponse handles the ListBlobs response.
func (client *XMLClient) listBlobsHandleResponse(resp *http.Response) (XMLClientListBlobsResponse, error) {
	result := XMLClientListBlobsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ListBlobsResponse); err != nil {
		return XMLClientListBlobsResponse{}, err
	}
	return result, nil
}

// ListContainers - Lists containers in a storage account.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientListContainersOptions contains the optional parameters for the XMLClient.ListContainers method.
func (client *XMLClient) ListContainers(ctx context.Context, options *XMLClientListContainersOptions) (resp XMLClientListContainersResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.ListContainers", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.listContainersCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return client.listContainersHandleResponse(httpResp)
}

// listContainersCreateRequest creates the ListContainers request.
func (client *XMLClient) listContainersCreateRequest(ctx context.Context, options *XMLClientListContainersOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "list")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listContainersHandleResponse handles the ListContainers response.
func (client *XMLClient) listContainersHandleResponse(resp *http.Response) (XMLClientListContainersResponse, error) {
	result := XMLClientListContainersResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ListContainersResponse); err != nil {
		return XMLClientListContainersResponse{}, err
	}
	return result, nil
}

// PutACLs - Puts storage ACLs for a container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutACLsOptions contains the optional parameters for the XMLClient.PutACLs method.
func (client *XMLClient) PutACLs(ctx context.Context, properties []*SignedIdentifier, options *XMLClientPutACLsOptions) (resp XMLClientPutACLsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutACLs", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putACLsCreateRequest(ctx, properties, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putACLsCreateRequest creates the PutACLs request.
func (client *XMLClient) putACLsCreateRequest(ctx context.Context, properties []*SignedIdentifier, options *XMLClientPutACLsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	type wrapper struct {
		XMLName    xml.Name             `xml:"SignedIdentifiers"`
		Properties *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	if err := runtime.MarshalAsXML(req, wrapper{Properties: &properties}); err != nil {
		return nil, err
	}
	return req, nil
}

// PutBinary - Put an XML document with binary property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutBinaryOptions contains the optional parameters for the XMLClient.PutBinary method.
func (client *XMLClient) PutBinary(ctx context.Context, slideshow ModelWithByteProperty, options *XMLClientPutBinaryOptions) (resp XMLClientPutBinaryResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutBinary", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putBinaryCreateRequest(ctx, slideshow, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putBinaryCreateRequest creates the PutBinary request.
func (client *XMLClient) putBinaryCreateRequest(ctx context.Context, slideshow ModelWithByteProperty, options *XMLClientPutBinaryOptions) (*policy.Request, error) {
	urlPath := "/xml/bytes"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if err := runtime.MarshalAsXML(req, slideshow); err != nil {
		return nil, err
	}
	return req, nil
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutComplexTypeRefNoMetaOptions contains the optional parameters for the XMLClient.PutComplexTypeRefNoMeta
//     method.
func (client *XMLClient) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta, options *XMLClientPutComplexTypeRefNoMetaOptions) (resp XMLClientPutComplexTypeRefNoMetaResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutComplexTypeRefNoMeta", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putComplexTypeRefNoMetaCreateRequest(ctx, model, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *XMLClient) putComplexTypeRefNoMetaCreateRequest(ctx context.Context, model RootWithRefAndNoMeta, options *XMLClientPutComplexTypeRefNoMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if err := runtime.MarshalAsXML(req, model); err != nil {
		return nil, err
	}
	return req, nil
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutComplexTypeRefWithMetaOptions contains the optional parameters for the XMLClient.PutComplexTypeRefWithMeta
//     method.
func (client *XMLClient) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta, options *XMLClientPutComplexTypeRefWithMetaOptions) (resp XMLClientPutComplexTypeRefWithMetaResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutComplexTypeRefWithMeta", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putComplexTypeRefWithMetaCreateRequest(ctx, model, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *XMLClient) putComplexTypeRefWithMetaCreateRequest(ctx context.Context, model RootWithRefAndMeta, options *XMLClientPutComplexTypeRefWithMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if err := runtime.MarshalAsXML(req, model); err != nil {
		return nil, err
	}
	return req, nil
}

// PutEmptyChildElement - Puts a value with an empty child element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyChildElementOptions contains the optional parameters for the XMLClient.PutEmptyChildElement
//     method.
func (client *XMLClient) PutEmptyChildElement(ctx context.Context, banana Banana, options *XMLClientPutEmptyChildElementOptions) (resp XMLClientPutEmptyChildElementResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutEmptyChildElement", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putEmptyChildElementCreateRequest(ctx, banana, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *XMLClient) putEmptyChildElementCreateRequest(ctx context.Context, banana Banana, options *XMLClientPutEmptyChildElementOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if err := runtime.MarshalAsXML(req, banana); err != nil {
		return nil, err
	}
	return req, nil
}

// PutEmptyList - Puts an empty list.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyListOptions contains the optional parameters for the XMLClient.PutEmptyList method.
func (client *XMLClient) PutEmptyList(ctx context.Context, slideshow Slideshow, options *XMLClientPutEmptyListOptions) (resp XMLClientPutEmptyListResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutEmptyList", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putEmptyListCreateRequest(ctx, slideshow, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putEmptyListCreateRequest creates the PutEmptyList request.
func (client *XMLClient) putEmptyListCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLClientPutEmptyListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if err := runtime.MarshalAsXML(req, slideshow); err != nil {
		return nil, err
	}
	return req, nil
}

// PutEmptyRootList - Puts an empty list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyRootListOptions contains the optional parameters for the XMLClient.PutEmptyRootList method.
func (client *XMLClient) PutEmptyRootList(ctx context.Context, bananas []*Banana, options *XMLClientPutEmptyRootListOptions) (resp XMLClientPutEmptyRootListResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutEmptyRootList", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putEmptyRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *XMLClient) putEmptyRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutEmptyRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	if err := runtime.MarshalAsXML(req, wrapper{Bananas: &bananas}); err != nil {
		return nil, err
	}
	return req, nil
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyWrappedListsOptions contains the optional parameters for the XMLClient.PutEmptyWrappedLists
//     method.
func (client *XMLClient) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel, options *XMLClientPutEmptyWrappedListsOptions) (resp XMLClientPutEmptyWrappedListsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutEmptyWrappedLists", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putEmptyWrappedListsCreateRequest(ctx, appleBarrel, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *XMLClient) putEmptyWrappedListsCreateRequest(ctx context.Context, appleBarrel AppleBarrel, options *XMLClientPutEmptyWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if err := runtime.MarshalAsXML(req, appleBarrel); err != nil {
		return nil, err
	}
	return req, nil
}

// PutRootList - Puts a list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutRootListOptions contains the optional parameters for the XMLClient.PutRootList method.
func (client *XMLClient) PutRootList(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListOptions) (resp XMLClientPutRootListResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutRootList", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putRootListCreateRequest creates the PutRootList request.
func (client *XMLClient) putRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	if err := runtime.MarshalAsXML(req, wrapper{Bananas: &bananas}); err != nil {
		return nil, err
	}
	return req, nil
}

// PutRootListSingleItem - Puts a list with a single item.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutRootListSingleItemOptions contains the optional parameters for the XMLClient.PutRootListSingleItem
//     method.
func (client *XMLClient) PutRootListSingleItem(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListSingleItemOptions) (resp XMLClientPutRootListSingleItemResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutRootListSingleItem", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putRootListSingleItemCreateRequest(ctx, bananas, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *XMLClient) putRootListSingleItemCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListSingleItemOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	if err := runtime.MarshalAsXML(req, wrapper{Bananas: &bananas}); err != nil {
		return nil, err
	}
	return req, nil
}

// PutServiceProperties - Puts storage service properties.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutServicePropertiesOptions contains the optional parameters for the XMLClient.PutServiceProperties
//     method.
func (client *XMLClient) PutServiceProperties(ctx context.Context, properties StorageServiceProperties, options *XMLClientPutServicePropertiesOptions) (resp XMLClientPutServicePropertiesResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutServiceProperties", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putServicePropertiesCreateRequest(ctx, properties, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *XMLClient) putServicePropertiesCreateRequest(ctx context.Context, properties StorageServiceProperties, options *XMLClientPutServicePropertiesOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if err := runtime.MarshalAsXML(req, properties); err != nil {
		return nil, err
	}
	return req, nil
}

// PutSimple - Put a simple XML document
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutSimpleOptions contains the optional parameters for the XMLClient.PutSimple method.
func (client *XMLClient) PutSimple(ctx context.Context, slideshow Slideshow, options *XMLClientPutSimpleOptions) (resp XMLClientPutSimpleResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutSimple", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putSimpleCreateRequest(ctx, slideshow, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putSimpleCreateRequest creates the PutSimple request.
func (client *XMLClient) putSimpleCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLClientPutSimpleOptions) (*policy.Request, error) {
	urlPath := "/xml/simple"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if err := runtime.MarshalAsXML(req, slideshow); err != nil {
		return nil, err
	}
	return req, nil
}

// PutURI - Put an XML document with uri property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutURIOptions contains the optional parameters for the XMLClient.PutURI method.
func (client *XMLClient) PutURI(ctx context.Context, model ModelWithURLProperty, options *XMLClientPutURIOptions) (resp XMLClientPutURIResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutURI", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putURICreateRequest(ctx, model, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putURICreateRequest creates the PutURI request.
func (client *XMLClient) putURICreateRequest(ctx context.Context, model ModelWithURLProperty, options *XMLClientPutURIOptions) (*policy.Request, error) {
	urlPath := "/xml/url"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if err := runtime.MarshalAsXML(req, model); err != nil {
		return nil, err
	}
	return req, nil
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutWrappedListsOptions contains the optional parameters for the XMLClient.PutWrappedLists method.
func (client *XMLClient) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel, options *XMLClientPutWrappedListsOptions) (resp XMLClientPutWrappedListsResponse, err error) {
	ctx, endSpan := runtime.StartSpan(ctx, "XMLClient.PutWrappedLists", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.putWrappedListsCreateRequest(ctx, wrappedLists, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return
}

// putWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *XMLClient) putWrappedListsCreateRequest(ctx context.Context, wrappedLists AppleBarrel, options *XMLClientPutWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if err := runtime.MarshalAsXML(req, wrappedLists); err != nil {
		return nil, err
	}
	return req, nil
}
