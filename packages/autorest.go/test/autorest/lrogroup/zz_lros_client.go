//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// LROsClient contains the methods for the LROs group.
// Don't use this type directly, use a constructor function instead.
type LROsClient struct {
	internal *azcore.Client
}

// BeginDelete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this
// value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDelete202NoRetry204Options contains the optional parameters for the LROsClient.BeginDelete202NoRetry204
//     method.
func (client *LROsClient) BeginDelete202NoRetry204(ctx context.Context, options *LROsClientBeginDelete202NoRetry204Options) (resp *runtime.Poller[LROsClientDelete202NoRetry204Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDelete202NoRetry204", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.delete202NoRetry204(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDelete202NoRetry204Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDelete202NoRetry204Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) delete202NoRetry204(ctx context.Context, options *LROsClientBeginDelete202NoRetry204Options) (resp *http.Response, err error) {
	req, err := client.delete202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// delete202NoRetry204CreateRequest creates the Delete202NoRetry204 request.
func (client *LROsClient) delete202NoRetry204CreateRequest(ctx context.Context, options *LROsClientBeginDelete202NoRetry204Options) (*policy.Request, error) {
	urlPath := "/lro/delete/202/noretry/204"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDelete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDelete202Retry200Options contains the optional parameters for the LROsClient.BeginDelete202Retry200
//     method.
func (client *LROsClient) BeginDelete202Retry200(ctx context.Context, options *LROsClientBeginDelete202Retry200Options) (resp *runtime.Poller[LROsClientDelete202Retry200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDelete202Retry200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.delete202Retry200(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDelete202Retry200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDelete202Retry200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) delete202Retry200(ctx context.Context, options *LROsClientBeginDelete202Retry200Options) (resp *http.Response, err error) {
	req, err := client.delete202Retry200CreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// delete202Retry200CreateRequest creates the Delete202Retry200 request.
func (client *LROsClient) delete202Retry200CreateRequest(ctx context.Context, options *LROsClientBeginDelete202Retry200Options) (*policy.Request, error) {
	urlPath := "/lro/delete/202/retry/200"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDelete204Succeeded - Long running delete succeeds and returns right away
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDelete204SucceededOptions contains the optional parameters for the LROsClient.BeginDelete204Succeeded
//     method.
func (client *LROsClient) BeginDelete204Succeeded(ctx context.Context, options *LROsClientBeginDelete204SucceededOptions) (resp *runtime.Poller[LROsClientDelete204SucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDelete204Succeeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.delete204Succeeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDelete204SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDelete204SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Delete204Succeeded - Long running delete succeeds and returns right away
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) delete204Succeeded(ctx context.Context, options *LROsClientBeginDelete204SucceededOptions) (resp *http.Response, err error) {
	req, err := client.delete204SucceededCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *LROsClient) delete204SucceededCreateRequest(ctx context.Context, options *LROsClientBeginDelete204SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/delete/204/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial
// request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteAsyncNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncNoHeaderInRetry
//     method.
func (client *LROsClient) BeginDeleteAsyncNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (resp *runtime.Poller[LROsClientDeleteAsyncNoHeaderInRetryResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteAsyncNoHeaderInRetry", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteAsyncNoHeaderInRetry(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteAsyncNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteAsyncNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial
// request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteAsyncNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (resp *http.Response, err error) {
	req, err := client.deleteAsyncNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteAsyncNoHeaderInRetryCreateRequest creates the DeleteAsyncNoHeaderInRetry request.
func (client *LROsClient) deleteAsyncNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/noheader/202/204"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteAsyncNoRetrySucceededOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncNoRetrySucceeded
//     method.
func (client *LROsClient) BeginDeleteAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (resp *runtime.Poller[LROsClientDeleteAsyncNoRetrySucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteAsyncNoRetrySucceeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteAsyncNoRetrySucceeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteAsyncNoRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteAsyncNoRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (resp *http.Response, err error) {
	req, err := client.deleteAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteAsyncNoRetrySucceededCreateRequest creates the DeleteAsyncNoRetrySucceeded request.
func (client *LROsClient) deleteAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/noretry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteAsyncRetryFailedOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncRetryFailed
//     method.
func (client *LROsClient) BeginDeleteAsyncRetryFailed(ctx context.Context, options *LROsClientBeginDeleteAsyncRetryFailedOptions) (resp *runtime.Poller[LROsClientDeleteAsyncRetryFailedResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteAsyncRetryFailed", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteAsyncRetryFailed(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteAsyncRetryFailedResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteAsyncRetryFailedResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated
// in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteAsyncRetryFailed(ctx context.Context, options *LROsClientBeginDeleteAsyncRetryFailedOptions) (resp *http.Response, err error) {
	req, err := client.deleteAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteAsyncRetryFailedCreateRequest creates the DeleteAsyncRetryFailed request.
func (client *LROsClient) deleteAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncRetryFailedOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/retry/failed"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteAsyncRetrySucceededOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncRetrySucceeded
//     method.
func (client *LROsClient) BeginDeleteAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrySucceededOptions) (resp *runtime.Poller[LROsClientDeleteAsyncRetrySucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteAsyncRetrySucceeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteAsyncRetrySucceeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteAsyncRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteAsyncRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrySucceededOptions) (resp *http.Response, err error) {
	req, err := client.deleteAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteAsyncRetrySucceededCreateRequest creates the DeleteAsyncRetrySucceeded request.
func (client *LROsClient) deleteAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/retry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteAsyncRetrycanceledOptions contains the optional parameters for the LROsClient.BeginDeleteAsyncRetrycanceled
//     method.
func (client *LROsClient) BeginDeleteAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrycanceledOptions) (resp *runtime.Poller[LROsClientDeleteAsyncRetrycanceledResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteAsyncRetrycanceled", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteAsyncRetrycanceled(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteAsyncRetrycanceledResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteAsyncRetrycanceledResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrycanceledOptions) (resp *http.Response, err error) {
	req, err := client.deleteAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteAsyncRetrycanceledCreateRequest creates the DeleteAsyncRetrycanceled request.
func (client *LROsClient) deleteAsyncRetrycanceledCreateRequest(ctx context.Context, options *LROsClientBeginDeleteAsyncRetrycanceledOptions) (*policy.Request, error) {
	urlPath := "/lro/deleteasync/retry/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent
// calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginDeleteNoHeaderInRetry
//     method.
func (client *LROsClient) BeginDeleteNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteNoHeaderInRetryOptions) (resp *runtime.Poller[LROsClientDeleteNoHeaderInRetryResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteNoHeaderInRetry", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteNoHeaderInRetry(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent
// calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteNoHeaderInRetry(ctx context.Context, options *LROsClientBeginDeleteNoHeaderInRetryOptions) (resp *http.Response, err error) {
	req, err := client.deleteNoHeaderInRetryCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteNoHeaderInRetryCreateRequest creates the DeleteNoHeaderInRetry request.
func (client *LROsClient) deleteNoHeaderInRetryCreateRequest(ctx context.Context, options *LROsClientBeginDeleteNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/delete/noheader"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions contains the optional parameters for the LROsClient.BeginDeleteProvisioning202Accepted200Succeeded
//     method.
func (client *LROsClient) BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (resp *runtime.Poller[LROsClientDeleteProvisioning202Accepted200SucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteProvisioning202Accepted200Succeeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteProvisioning202Accepted200Succeeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteProvisioning202Accepted200SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteProvisioning202Accepted200SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteProvisioning202Accepted200Succeeded(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (resp *http.Response, err error) {
	req, err := client.deleteProvisioning202Accepted200SucceededCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteProvisioning202Accepted200SucceededCreateRequest creates the DeleteProvisioning202Accepted200Succeeded request.
func (client *LROsClient) deleteProvisioning202Accepted200SucceededCreateRequest(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/delete/provisioning/202/accepted/200/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteProvisioning202DeletingFailed200Options contains the optional parameters for the LROsClient.BeginDeleteProvisioning202DeletingFailed200
//     method.
func (client *LROsClient) BeginDeleteProvisioning202DeletingFailed200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (resp *runtime.Poller[LROsClientDeleteProvisioning202DeletingFailed200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteProvisioning202DeletingFailed200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteProvisioning202DeletingFailed200(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteProvisioning202DeletingFailed200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteProvisioning202DeletingFailed200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteProvisioning202DeletingFailed200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (resp *http.Response, err error) {
	req, err := client.deleteProvisioning202DeletingFailed200CreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteProvisioning202DeletingFailed200CreateRequest creates the DeleteProvisioning202DeletingFailed200 request.
func (client *LROsClient) deleteProvisioning202DeletingFailed200CreateRequest(ctx context.Context, options *LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (*policy.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/failed"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginDeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’
// with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginDeleteProvisioning202Deletingcanceled200Options contains the optional parameters for the LROsClient.BeginDeleteProvisioning202Deletingcanceled200
//     method.
func (client *LROsClient) BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (resp *runtime.Poller[LROsClientDeleteProvisioning202Deletingcanceled200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginDeleteProvisioning202Deletingcanceled200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.deleteProvisioning202Deletingcanceled200(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientDeleteProvisioning202Deletingcanceled200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientDeleteProvisioning202Deletingcanceled200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) deleteProvisioning202Deletingcanceled200(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (resp *http.Response, err error) {
	req, err := client.deleteProvisioning202Deletingcanceled200CreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// deleteProvisioning202Deletingcanceled200CreateRequest creates the DeleteProvisioning202Deletingcanceled200 request.
func (client *LROsClient) deleteProvisioning202Deletingcanceled200CreateRequest(ctx context.Context, options *LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (*policy.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPatch200SucceededIgnoreHeaders - Long running put request, service returns a 200 to the initial request with location
// header. We should not have any subsequent calls after receiving this first response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to patch
//   - options - LROsClientBeginPatch200SucceededIgnoreHeadersOptions contains the optional parameters for the LROsClient.BeginPatch200SucceededIgnoreHeaders
//     method.
func (client *LROsClient) BeginPatch200SucceededIgnoreHeaders(ctx context.Context, product Product, options *LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (resp *runtime.Poller[LROsClientPatch200SucceededIgnoreHeadersResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPatch200SucceededIgnoreHeaders", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.patch200SucceededIgnoreHeaders(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPatch200SucceededIgnoreHeadersResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPatch200SucceededIgnoreHeadersResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Patch200SucceededIgnoreHeaders - Long running put request, service returns a 200 to the initial request with location header.
// We should not have any subsequent calls after receiving this first response.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) patch200SucceededIgnoreHeaders(ctx context.Context, product Product, options *LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (resp *http.Response, err error) {
	req, err := client.patch200SucceededIgnoreHeadersCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// patch200SucceededIgnoreHeadersCreateRequest creates the Patch200SucceededIgnoreHeaders request.
func (client *LROsClient) patch200SucceededIgnoreHeadersCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (*policy.Request, error) {
	urlPath := "/lro/patch/200/succeeded/ignoreheaders"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPatch201RetryWithAsyncHeader - Long running patch request, service returns a 201 to the initial request with async
// header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to patch
//   - options - LROsClientBeginPatch201RetryWithAsyncHeaderOptions contains the optional parameters for the LROsClient.BeginPatch201RetryWithAsyncHeader
//     method.
func (client *LROsClient) BeginPatch201RetryWithAsyncHeader(ctx context.Context, product Product, options *LROsClientBeginPatch201RetryWithAsyncHeaderOptions) (resp *runtime.Poller[LROsClientPatch201RetryWithAsyncHeaderResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPatch201RetryWithAsyncHeader", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.patch201RetryWithAsyncHeader(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPatch201RetryWithAsyncHeaderResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
			Tracer:        client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPatch201RetryWithAsyncHeaderResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Patch201RetryWithAsyncHeader - Long running patch request, service returns a 201 to the initial request with async header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) patch201RetryWithAsyncHeader(ctx context.Context, product Product, options *LROsClientBeginPatch201RetryWithAsyncHeaderOptions) (resp *http.Response, err error) {
	req, err := client.patch201RetryWithAsyncHeaderCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// patch201RetryWithAsyncHeaderCreateRequest creates the Patch201RetryWithAsyncHeader request.
func (client *LROsClient) patch201RetryWithAsyncHeaderCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPatch201RetryWithAsyncHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/patch/201/retry/onlyAsyncHeader"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPatch202RetryWithAsyncAndLocationHeader - Long running patch request, service returns a 202 to the initial request
// with async and location header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to patch
//   - options - LROsClientBeginPatch202RetryWithAsyncAndLocationHeaderOptions contains the optional parameters for the LROsClient.BeginPatch202RetryWithAsyncAndLocationHeader
//     method.
func (client *LROsClient) BeginPatch202RetryWithAsyncAndLocationHeader(ctx context.Context, product Product, options *LROsClientBeginPatch202RetryWithAsyncAndLocationHeaderOptions) (resp *runtime.Poller[LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPatch202RetryWithAsyncAndLocationHeader", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.patch202RetryWithAsyncAndLocationHeader(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Patch202RetryWithAsyncAndLocationHeader - Long running patch request, service returns a 202 to the initial request with
// async and location header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) patch202RetryWithAsyncAndLocationHeader(ctx context.Context, product Product, options *LROsClientBeginPatch202RetryWithAsyncAndLocationHeaderOptions) (resp *http.Response, err error) {
	req, err := client.patch202RetryWithAsyncAndLocationHeaderCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// patch202RetryWithAsyncAndLocationHeaderCreateRequest creates the Patch202RetryWithAsyncAndLocationHeader request.
func (client *LROsClient) patch202RetryWithAsyncAndLocationHeaderCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPatch202RetryWithAsyncAndLocationHeaderOptions) (*policy.Request, error) {
	urlPath := "/lro/patch/202/retry/asyncAndLocationHeader"
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPost200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header.
// Poll returns a 200 with a response body after success.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPost200WithPayloadOptions contains the optional parameters for the LROsClient.BeginPost200WithPayload
//     method.
func (client *LROsClient) BeginPost200WithPayload(ctx context.Context, options *LROsClientBeginPost200WithPayloadOptions) (resp *runtime.Poller[LROsClientPost200WithPayloadResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPost200WithPayload", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.post200WithPayload(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPost200WithPayloadResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPost200WithPayloadResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll
// returns a 200 with a response body after success.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) post200WithPayload(ctx context.Context, options *LROsClientBeginPost200WithPayloadOptions) (resp *http.Response, err error) {
	req, err := client.post200WithPayloadCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// post200WithPayloadCreateRequest creates the Post200WithPayload request.
func (client *LROsClient) post200WithPayloadCreateRequest(ctx context.Context, options *LROsClientBeginPost200WithPayloadOptions) (*policy.Request, error) {
	urlPath := "/lro/post/payload/200"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPost202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with
// body [{ 'id': '100', 'name': 'foo' }].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPost202ListOptions contains the optional parameters for the LROsClient.BeginPost202List method.
func (client *LROsClient) BeginPost202List(ctx context.Context, options *LROsClientBeginPost202ListOptions) (resp *runtime.Poller[LROsClientPost202ListResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPost202List", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.post202List(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPost202ListResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPost202ListResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Post202List - Long running put request, service returns a 202 with empty body to first request, returns a 200 with body
// [{ 'id': '100', 'name': 'foo' }].
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) post202List(ctx context.Context, options *LROsClientBeginPost202ListOptions) (resp *http.Response, err error) {
	req, err := client.post202ListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// post202ListCreateRequest creates the Post202List request.
func (client *LROsClient) post202ListCreateRequest(ctx context.Context, options *LROsClientBeginPost202ListOptions) (*policy.Request, error) {
	urlPath := "/lro/list"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPost202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header,
// 204 with noresponse body after success
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPost202NoRetry204Options contains the optional parameters for the LROsClient.BeginPost202NoRetry204
//     method.
func (client *LROsClient) BeginPost202NoRetry204(ctx context.Context, options *LROsClientBeginPost202NoRetry204Options) (resp *runtime.Poller[LROsClientPost202NoRetry204Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPost202NoRetry204", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.post202NoRetry204(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPost202NoRetry204Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPost202NoRetry204Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204
// with noresponse body after success
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) post202NoRetry204(ctx context.Context, options *LROsClientBeginPost202NoRetry204Options) (resp *http.Response, err error) {
	req, err := client.post202NoRetry204CreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// post202NoRetry204CreateRequest creates the Post202NoRetry204 request.
func (client *LROsClient) post202NoRetry204CreateRequest(ctx context.Context, options *LROsClientBeginPost202NoRetry204Options) (*policy.Request, error) {
	urlPath := "/lro/post/202/noretry/204"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		if err := runtime.MarshalAsJSON(req, *options.Product); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// BeginPost202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
// headers, Polls return a 200 with a response body after success
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPost202Retry200Options contains the optional parameters for the LROsClient.BeginPost202Retry200
//     method.
func (client *LROsClient) BeginPost202Retry200(ctx context.Context, options *LROsClientBeginPost202Retry200Options) (resp *runtime.Poller[LROsClientPost202Retry200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPost202Retry200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.post202Retry200(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPost202Retry200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPost202Retry200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
// headers, Polls return a 200 with a response body after success
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) post202Retry200(ctx context.Context, options *LROsClientBeginPost202Retry200Options) (resp *http.Response, err error) {
	req, err := client.post202Retry200CreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// post202Retry200CreateRequest creates the Post202Retry200 request.
func (client *LROsClient) post202Retry200CreateRequest(ctx context.Context, options *LROsClientBeginPost202Retry200Options) (*policy.Request, error) {
	urlPath := "/lro/post/202/retry/200"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		if err := runtime.MarshalAsJSON(req, *options.Product); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// BeginPostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostAsyncNoRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPostAsyncNoRetrySucceeded
//     method.
func (client *LROsClient) BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncNoRetrySucceededOptions) (resp *runtime.Poller[LROsClientPostAsyncNoRetrySucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostAsyncNoRetrySucceeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postAsyncNoRetrySucceeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostAsyncNoRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostAsyncNoRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postAsyncNoRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncNoRetrySucceededOptions) (resp *http.Response, err error) {
	req, err := client.postAsyncNoRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postAsyncNoRetrySucceededCreateRequest creates the PostAsyncNoRetrySucceeded request.
func (client *LROsClient) postAsyncNoRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncNoRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/noretry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		if err := runtime.MarshalAsJSON(req, *options.Product); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// BeginPostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostAsyncRetryFailedOptions contains the optional parameters for the LROsClient.BeginPostAsyncRetryFailed
//     method.
func (client *LROsClient) BeginPostAsyncRetryFailed(ctx context.Context, options *LROsClientBeginPostAsyncRetryFailedOptions) (resp *runtime.Poller[LROsClientPostAsyncRetryFailedResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostAsyncRetryFailed", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postAsyncRetryFailed(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostAsyncRetryFailedResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostAsyncRetryFailedResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postAsyncRetryFailed(ctx context.Context, options *LROsClientBeginPostAsyncRetryFailedOptions) (resp *http.Response, err error) {
	req, err := client.postAsyncRetryFailedCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postAsyncRetryFailedCreateRequest creates the PostAsyncRetryFailed request.
func (client *LROsClient) postAsyncRetryFailedCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncRetryFailedOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/retry/failed"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		if err := runtime.MarshalAsJSON(req, *options.Product); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// BeginPostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostAsyncRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPostAsyncRetrySucceeded
//     method.
func (client *LROsClient) BeginPostAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncRetrySucceededOptions) (resp *runtime.Poller[LROsClientPostAsyncRetrySucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostAsyncRetrySucceeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postAsyncRetrySucceeded(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostAsyncRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostAsyncRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postAsyncRetrySucceeded(ctx context.Context, options *LROsClientBeginPostAsyncRetrySucceededOptions) (resp *http.Response, err error) {
	req, err := client.postAsyncRetrySucceededCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postAsyncRetrySucceededCreateRequest creates the PostAsyncRetrySucceeded request.
func (client *LROsClient) postAsyncRetrySucceededCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/retry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		if err := runtime.MarshalAsJSON(req, *options.Product); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// BeginPostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostAsyncRetrycanceledOptions contains the optional parameters for the LROsClient.BeginPostAsyncRetrycanceled
//     method.
func (client *LROsClient) BeginPostAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginPostAsyncRetrycanceledOptions) (resp *runtime.Poller[LROsClientPostAsyncRetrycanceledResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostAsyncRetrycanceled", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postAsyncRetrycanceled(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostAsyncRetrycanceledResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostAsyncRetrycanceledResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postAsyncRetrycanceled(ctx context.Context, options *LROsClientBeginPostAsyncRetrycanceledOptions) (resp *http.Response, err error) {
	req, err := client.postAsyncRetrycanceledCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postAsyncRetrycanceledCreateRequest creates the PostAsyncRetrycanceled request.
func (client *LROsClient) postAsyncRetrycanceledCreateRequest(ctx context.Context, options *LROsClientBeginPostAsyncRetrycanceledOptions) (*policy.Request, error) {
	urlPath := "/lro/postasync/retry/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.Product != nil {
		if err := runtime.MarshalAsJSON(req, *options.Product); err != nil {
			return nil, err
		}
		return req, nil
	}
	return req, nil
}

// BeginPostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with
// both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions contains the optional parameters for the LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet
//     method.
func (client *LROsClient) BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (resp *runtime.Poller[LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postDoubleHeadersFinalAzureHeaderGet(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
			Tracer:        client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both
// Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (resp *http.Response, err error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postDoubleHeadersFinalAzureHeaderGetCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGet request.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetCreateRequest(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (*policy.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGet"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request
// with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final
// object
// if you support initial Autorest behavior.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions contains the optional parameters for the LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault
//     method.
func (client *LROsClient) BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (resp *runtime.Poller[LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postDoubleHeadersFinalAzureHeaderGetDefault(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with
// both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
// if you support initial Autorest behavior.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (resp *http.Response, err error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGetDefault request.
func (client *LROsClient) postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (*policy.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both
// Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - LROsClientBeginPostDoubleHeadersFinalLocationGetOptions contains the optional parameters for the LROsClient.BeginPostDoubleHeadersFinalLocationGet
//     method.
func (client *LROsClient) BeginPostDoubleHeadersFinalLocationGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (resp *runtime.Poller[LROsClientPostDoubleHeadersFinalLocationGetResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPostDoubleHeadersFinalLocationGet", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.postDoubleHeadersFinalLocationGet(ctx, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPostDoubleHeadersFinalLocationGetResponse]{
			FinalStateVia: runtime.FinalStateViaLocation,
			Tracer:        client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPostDoubleHeadersFinalLocationGetResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location
// and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) postDoubleHeadersFinalLocationGet(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (resp *http.Response, err error) {
	req, err := client.postDoubleHeadersFinalLocationGetCreateRequest(ctx, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// postDoubleHeadersFinalLocationGetCreateRequest creates the PostDoubleHeadersFinalLocationGet request.
func (client *LROsClient) postDoubleHeadersFinalLocationGetCreateRequest(ctx context.Context, options *LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (*policy.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalLocationGet"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// BeginPut200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut200Acceptedcanceled200Options contains the optional parameters for the LROsClient.BeginPut200Acceptedcanceled200
//     method.
func (client *LROsClient) BeginPut200Acceptedcanceled200(ctx context.Context, product Product, options *LROsClientBeginPut200Acceptedcanceled200Options) (resp *runtime.Poller[LROsClientPut200Acceptedcanceled200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut200Acceptedcanceled200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put200Acceptedcanceled200(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut200Acceptedcanceled200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut200Acceptedcanceled200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put200Acceptedcanceled200(ctx context.Context, product Product, options *LROsClientBeginPut200Acceptedcanceled200Options) (resp *http.Response, err error) {
	req, err := client.put200Acceptedcanceled200CreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put200Acceptedcanceled200CreateRequest creates the Put200Acceptedcanceled200 request.
func (client *LROsClient) put200Acceptedcanceled200CreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut200Acceptedcanceled200Options) (*policy.Request, error) {
	urlPath := "/lro/put/200/accepted/canceled/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut200SucceededOptions contains the optional parameters for the LROsClient.BeginPut200Succeeded
//     method.
func (client *LROsClient) BeginPut200Succeeded(ctx context.Context, product Product, options *LROsClientBeginPut200SucceededOptions) (resp *runtime.Poller[LROsClientPut200SucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut200Succeeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put200Succeeded(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut200SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut200SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put200Succeeded(ctx context.Context, product Product, options *LROsClientBeginPut200SucceededOptions) (resp *http.Response, err error) {
	req, err := client.put200SucceededCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put200SucceededCreateRequest creates the Put200Succeeded request.
func (client *LROsClient) put200SucceededCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut200SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/put/200/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that
// does not contain ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut200SucceededNoStateOptions contains the optional parameters for the LROsClient.BeginPut200SucceededNoState
//     method.
func (client *LROsClient) BeginPut200SucceededNoState(ctx context.Context, product Product, options *LROsClientBeginPut200SucceededNoStateOptions) (resp *runtime.Poller[LROsClientPut200SucceededNoStateResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut200SucceededNoState", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put200SucceededNoState(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut200SucceededNoStateResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut200SucceededNoStateResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does
// not contain ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put200SucceededNoState(ctx context.Context, product Product, options *LROsClientBeginPut200SucceededNoStateOptions) (resp *http.Response, err error) {
	req, err := client.put200SucceededNoStateCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put200SucceededNoStateCreateRequest creates the Put200SucceededNoState request.
func (client *LROsClient) put200SucceededNoStateCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut200SucceededNoStateOptions) (*policy.Request, error) {
	urlPath := "/lro/put/200/succeeded/nostate"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut200UpdatingSucceeded204Options contains the optional parameters for the LROsClient.BeginPut200UpdatingSucceeded204
//     method.
func (client *LROsClient) BeginPut200UpdatingSucceeded204(ctx context.Context, product Product, options *LROsClientBeginPut200UpdatingSucceeded204Options) (resp *runtime.Poller[LROsClientPut200UpdatingSucceeded204Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut200UpdatingSucceeded204", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put200UpdatingSucceeded204(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut200UpdatingSucceeded204Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut200UpdatingSucceeded204Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put200UpdatingSucceeded204(ctx context.Context, product Product, options *LROsClientBeginPut200UpdatingSucceeded204Options) (resp *http.Response, err error) {
	req, err := client.put200UpdatingSucceeded204CreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put200UpdatingSucceeded204CreateRequest creates the Put200UpdatingSucceeded204 request.
func (client *LROsClient) put200UpdatingSucceeded204CreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut200UpdatingSucceeded204Options) (*policy.Request, error) {
	urlPath := "/lro/put/200/updating/succeeded/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut201CreatingFailed200Options contains the optional parameters for the LROsClient.BeginPut201CreatingFailed200
//     method.
func (client *LROsClient) BeginPut201CreatingFailed200(ctx context.Context, product Product, options *LROsClientBeginPut201CreatingFailed200Options) (resp *runtime.Poller[LROsClientPut201CreatingFailed200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut201CreatingFailed200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put201CreatingFailed200(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut201CreatingFailed200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut201CreatingFailed200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains
// ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put201CreatingFailed200(ctx context.Context, product Product, options *LROsClientBeginPut201CreatingFailed200Options) (resp *http.Response, err error) {
	req, err := client.put201CreatingFailed200CreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put201CreatingFailed200CreateRequest creates the Put201CreatingFailed200 request.
func (client *LROsClient) put201CreatingFailed200CreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut201CreatingFailed200Options) (*policy.Request, error) {
	urlPath := "/lro/put/201/created/failed/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut201CreatingSucceeded200Options contains the optional parameters for the LROsClient.BeginPut201CreatingSucceeded200
//     method.
func (client *LROsClient) BeginPut201CreatingSucceeded200(ctx context.Context, product Product, options *LROsClientBeginPut201CreatingSucceeded200Options) (resp *runtime.Poller[LROsClientPut201CreatingSucceeded200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut201CreatingSucceeded200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put201CreatingSucceeded200(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut201CreatingSucceeded200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut201CreatingSucceeded200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put201CreatingSucceeded200(ctx context.Context, product Product, options *LROsClientBeginPut201CreatingSucceeded200Options) (resp *http.Response, err error) {
	req, err := client.put201CreatingSucceeded200CreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put201CreatingSucceeded200CreateRequest creates the Put201CreatingSucceeded200 request.
func (client *LROsClient) put201CreatingSucceeded200CreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut201CreatingSucceeded200Options) (*policy.Request, error) {
	urlPath := "/lro/put/201/creating/succeeded/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut201SucceededOptions contains the optional parameters for the LROsClient.BeginPut201Succeeded
//     method.
func (client *LROsClient) BeginPut201Succeeded(ctx context.Context, product Product, options *LROsClientBeginPut201SucceededOptions) (resp *runtime.Poller[LROsClientPut201SucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut201Succeeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put201Succeeded(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut201SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut201SucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put201Succeeded - Long running put request, service returns a 201 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put201Succeeded(ctx context.Context, product Product, options *LROsClientBeginPut201SucceededOptions) (resp *http.Response, err error) {
	req, err := client.put201SucceededCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put201SucceededCreateRequest creates the Put201Succeeded request.
func (client *LROsClient) put201SucceededCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut201SucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/put/201/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPut202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that
// points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPut202Retry200Options contains the optional parameters for the LROsClient.BeginPut202Retry200
//     method.
func (client *LROsClient) BeginPut202Retry200(ctx context.Context, product Product, options *LROsClientBeginPut202Retry200Options) (resp *runtime.Poller[LROsClientPut202Retry200Response], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPut202Retry200", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.put202Retry200(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPut202Retry200Response]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPut202Retry200Response]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points
// to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) put202Retry200(ctx context.Context, product Product, options *LROsClientBeginPut202Retry200Options) (resp *http.Response, err error) {
	req, err := client.put202Retry200CreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// put202Retry200CreateRequest creates the Put202Retry200 request.
func (client *LROsClient) put202Retry200CreateRequest(ctx context.Context, product Product, options *LROsClientBeginPut202Retry200Options) (*policy.Request, error) {
	urlPath := "/lro/put/202/retry/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
// header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPutAsyncNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginPutAsyncNoHeaderInRetry
//     method.
func (client *LROsClient) BeginPutAsyncNoHeaderInRetry(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoHeaderInRetryOptions) (resp *runtime.Poller[LROsClientPutAsyncNoHeaderInRetryResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncNoHeaderInRetry", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncNoHeaderInRetry(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation
// header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncNoHeaderInRetry(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoHeaderInRetryOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncNoHeaderInRetryCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncNoHeaderInRetryCreateRequest creates the PutAsyncNoHeaderInRetry request.
func (client *LROsClient) putAsyncNoHeaderInRetryCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/noheader/201/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPutAsyncNoRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPutAsyncNoRetrySucceeded
//     method.
func (client *LROsClient) BeginPutAsyncNoRetrySucceeded(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoRetrySucceededOptions) (resp *runtime.Poller[LROsClientPutAsyncNoRetrySucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncNoRetrySucceeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncNoRetrySucceeded(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncNoRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncNoRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncNoRetrySucceeded(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoRetrySucceededOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncNoRetrySucceededCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncNoRetrySucceededCreateRequest creates the PutAsyncNoRetrySucceeded request.
func (client *LROsClient) putAsyncNoRetrySucceededCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/noretry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPutAsyncNoRetrycanceledOptions contains the optional parameters for the LROsClient.BeginPutAsyncNoRetrycanceled
//     method.
func (client *LROsClient) BeginPutAsyncNoRetrycanceled(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoRetrycanceledOptions) (resp *runtime.Poller[LROsClientPutAsyncNoRetrycanceledResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncNoRetrycanceled", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncNoRetrycanceled(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncNoRetrycanceledResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncNoRetrycanceledResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncNoRetrycanceled(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoRetrycanceledOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncNoRetrycanceledCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncNoRetrycanceledCreateRequest creates the PutAsyncNoRetrycanceled request.
func (client *LROsClient) putAsyncNoRetrycanceledCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPutAsyncNoRetrycanceledOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/noretry/canceled"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - sku - Sku to put
//   - options - LROsClientBeginPutAsyncNonResourceOptions contains the optional parameters for the LROsClient.BeginPutAsyncNonResource
//     method.
func (client *LROsClient) BeginPutAsyncNonResource(ctx context.Context, sku SKU, options *LROsClientBeginPutAsyncNonResourceOptions) (resp *runtime.Poller[LROsClientPutAsyncNonResourceResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncNonResource", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncNonResource(ctx, sku, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncNonResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncNonResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncNonResource(ctx context.Context, sku SKU, options *LROsClientBeginPutAsyncNonResourceOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncNonResourceCreateRequest(ctx, sku, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncNonResourceCreateRequest creates the PutAsyncNonResource request.
func (client *LROsClient) putAsyncNonResourceCreateRequest(ctx context.Context, sku SKU, options *LROsClientBeginPutAsyncNonResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putnonresourceasync/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, sku); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPutAsyncRetryFailedOptions contains the optional parameters for the LROsClient.BeginPutAsyncRetryFailed
//     method.
func (client *LROsClient) BeginPutAsyncRetryFailed(ctx context.Context, product Product, options *LROsClientBeginPutAsyncRetryFailedOptions) (resp *runtime.Poller[LROsClientPutAsyncRetryFailedResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncRetryFailed", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncRetryFailed(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncRetryFailedResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncRetryFailedResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncRetryFailed(ctx context.Context, product Product, options *LROsClientBeginPutAsyncRetryFailedOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncRetryFailedCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncRetryFailedCreateRequest creates the PutAsyncRetryFailed request.
func (client *LROsClient) putAsyncRetryFailedCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPutAsyncRetryFailedOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/retry/failed"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPutAsyncRetrySucceededOptions contains the optional parameters for the LROsClient.BeginPutAsyncRetrySucceeded
//     method.
func (client *LROsClient) BeginPutAsyncRetrySucceeded(ctx context.Context, product Product, options *LROsClientBeginPutAsyncRetrySucceededOptions) (resp *runtime.Poller[LROsClientPutAsyncRetrySucceededResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncRetrySucceeded", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncRetrySucceeded(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncRetrySucceededResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncRetrySucceeded(ctx context.Context, product Product, options *LROsClientBeginPutAsyncRetrySucceededOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncRetrySucceededCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncRetrySucceededCreateRequest creates the PutAsyncRetrySucceeded request.
func (client *LROsClient) putAsyncRetrySucceededCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPutAsyncRetrySucceededOptions) (*policy.Request, error) {
	urlPath := "/lro/putasync/retry/succeeded"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutAsyncSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Sub Product to put
//   - options - LROsClientBeginPutAsyncSubResourceOptions contains the optional parameters for the LROsClient.BeginPutAsyncSubResource
//     method.
func (client *LROsClient) BeginPutAsyncSubResource(ctx context.Context, product SubProduct, options *LROsClientBeginPutAsyncSubResourceOptions) (resp *runtime.Poller[LROsClientPutAsyncSubResourceResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutAsyncSubResource", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putAsyncSubResource(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutAsyncSubResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutAsyncSubResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutAsyncSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putAsyncSubResource(ctx context.Context, product SubProduct, options *LROsClientBeginPutAsyncSubResourceOptions) (resp *http.Response, err error) {
	req, err := client.putAsyncSubResourceCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putAsyncSubResourceCreateRequest creates the PutAsyncSubResource request.
func (client *LROsClient) putAsyncSubResourceCreateRequest(ctx context.Context, product SubProduct, options *LROsClientBeginPutAsyncSubResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putsubresourceasync/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header.
// Subsequent calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Product to put
//   - options - LROsClientBeginPutNoHeaderInRetryOptions contains the optional parameters for the LROsClient.BeginPutNoHeaderInRetry
//     method.
func (client *LROsClient) BeginPutNoHeaderInRetry(ctx context.Context, product Product, options *LROsClientBeginPutNoHeaderInRetryOptions) (resp *runtime.Poller[LROsClientPutNoHeaderInRetryResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutNoHeaderInRetry", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putNoHeaderInRetry(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutNoHeaderInRetryResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent
// calls to operation status do not contain location header.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putNoHeaderInRetry(ctx context.Context, product Product, options *LROsClientBeginPutNoHeaderInRetryOptions) (resp *http.Response, err error) {
	req, err := client.putNoHeaderInRetryCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putNoHeaderInRetryCreateRequest creates the PutNoHeaderInRetry request.
func (client *LROsClient) putNoHeaderInRetryCreateRequest(ctx context.Context, product Product, options *LROsClientBeginPutNoHeaderInRetryOptions) (*policy.Request, error) {
	urlPath := "/lro/put/noheader/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - sku - sku to put
//   - options - LROsClientBeginPutNonResourceOptions contains the optional parameters for the LROsClient.BeginPutNonResource
//     method.
func (client *LROsClient) BeginPutNonResource(ctx context.Context, sku SKU, options *LROsClientBeginPutNonResourceOptions) (resp *runtime.Poller[LROsClientPutNonResourceResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutNonResource", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putNonResource(ctx, sku, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutNonResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutNonResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutNonResource - Long running put request with non resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putNonResource(ctx context.Context, sku SKU, options *LROsClientBeginPutNonResourceOptions) (resp *http.Response, err error) {
	req, err := client.putNonResourceCreateRequest(ctx, sku, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putNonResourceCreateRequest creates the PutNonResource request.
func (client *LROsClient) putNonResourceCreateRequest(ctx context.Context, sku SKU, options *LROsClientBeginPutNonResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putnonresource/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, sku); err != nil {
		return nil, err
	}
	return req, nil
}

// BeginPutSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - product - Sub Product to put
//   - options - LROsClientBeginPutSubResourceOptions contains the optional parameters for the LROsClient.BeginPutSubResource
//     method.
func (client *LROsClient) BeginPutSubResource(ctx context.Context, product SubProduct, options *LROsClientBeginPutSubResourceOptions) (resp *runtime.Poller[LROsClientPutSubResourceResponse], err error) {
	if options == nil || options.ResumeToken == "" {
		ctx, endSpan := runtime.StartSpan(ctx, "LROsClient.BeginPutSubResource", client.internal.Tracer(), nil)
		defer func() { endSpan(err) }()
		resp, err := client.putSubResource(ctx, product, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[LROsClientPutSubResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	} else {
		return runtime.NewPollerFromResumeToken(options.ResumeToken, client.internal.Pipeline(), &runtime.NewPollerFromResumeTokenOptions[LROsClientPutSubResourceResponse]{
			Tracer: client.internal.Tracer(),
		})
	}
}

// PutSubResource - Long running put request with sub resource.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
func (client *LROsClient) putSubResource(ctx context.Context, product SubProduct, options *LROsClientBeginPutSubResourceOptions) (resp *http.Response, err error) {
	req, err := client.putSubResourceCreateRequest(ctx, product, options)
	if err != nil {
		return
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return
	}
	return httpResp, nil
}

// putSubResourceCreateRequest creates the PutSubResource request.
func (client *LROsClient) putSubResourceCreateRequest(ctx context.Context, product SubProduct, options *LROsClientBeginPutSubResourceOptions) (*policy.Request, error) {
	urlPath := "/lro/putsubresource/202/200"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, product); err != nil {
		return nil, err
	}
	return req, nil
}
