// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"errors"
	"fmt"
	"generatortests/lrogroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// LROsServer is a fake server for instances of the lrogroup.LROsClient type.
type LROsServer struct {
	// BeginDelete202NoRetry204 is the fake for method LROsClient.BeginDelete202NoRetry204
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDelete202NoRetry204 func(ctx context.Context, options *lrogroup.LROsClientBeginDelete202NoRetry204Options) (resp azfake.PollerResponder[lrogroup.LROsClientDelete202NoRetry204Response], errResp azfake.ErrorResponder)

	// BeginDelete202Retry200 is the fake for method LROsClient.BeginDelete202Retry200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDelete202Retry200 func(ctx context.Context, options *lrogroup.LROsClientBeginDelete202Retry200Options) (resp azfake.PollerResponder[lrogroup.LROsClientDelete202Retry200Response], errResp azfake.ErrorResponder)

	// BeginDelete204Succeeded is the fake for method LROsClient.BeginDelete204Succeeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusNoContent
	BeginDelete204Succeeded func(ctx context.Context, options *lrogroup.LROsClientBeginDelete204SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDelete204SucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncNoHeaderInRetry is the fake for method LROsClient.BeginDeleteAsyncNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteAsyncNoHeaderInRetry func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncNoRetrySucceeded is the fake for method LROsClient.BeginDeleteAsyncNoRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteAsyncNoRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRetryFailed is the fake for method LROsClient.BeginDeleteAsyncRetryFailed
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteAsyncRetryFailed func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncRetryFailedOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetryFailedResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRetrySucceeded is the fake for method LROsClient.BeginDeleteAsyncRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteAsyncRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRetrycanceled is the fake for method LROsClient.BeginDeleteAsyncRetrycanceled
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteAsyncRetrycanceled func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncRetrycanceledOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrycanceledResponse], errResp azfake.ErrorResponder)

	// BeginDeleteNoHeaderInRetry is the fake for method LROsClient.BeginDeleteNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginDeleteNoHeaderInRetry func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginDeleteProvisioning202Accepted200Succeeded is the fake for method LROsClient.BeginDeleteProvisioning202Accepted200Succeeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDeleteProvisioning202Accepted200Succeeded func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Accepted200SucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteProvisioning202DeletingFailed200 is the fake for method LROsClient.BeginDeleteProvisioning202DeletingFailed200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDeleteProvisioning202DeletingFailed200 func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202DeletingFailed200Response], errResp azfake.ErrorResponder)

	// BeginDeleteProvisioning202Deletingcanceled200 is the fake for method LROsClient.BeginDeleteProvisioning202Deletingcanceled200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDeleteProvisioning202Deletingcanceled200 func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Deletingcanceled200Response], errResp azfake.ErrorResponder)

	// BeginPatch200SucceededIgnoreHeaders is the fake for method LROsClient.BeginPatch200SucceededIgnoreHeaders
	// HTTP status codes to indicate success: http.StatusOK
	BeginPatch200SucceededIgnoreHeaders func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPatch200SucceededIgnoreHeadersResponse], errResp azfake.ErrorResponder)

	// BeginPatch201RetryWithAsyncHeader is the fake for method LROsClient.BeginPatch201RetryWithAsyncHeader
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPatch201RetryWithAsyncHeader func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPatch201RetryWithAsyncHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPatch201RetryWithAsyncHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPatch202RetryWithAsyncAndLocationHeader is the fake for method LROsClient.BeginPatch202RetryWithAsyncAndLocationHeader
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPatch202RetryWithAsyncAndLocationHeader func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPatch202RetryWithAsyncAndLocationHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPost200WithPayload is the fake for method LROsClient.BeginPost200WithPayload
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPost200WithPayload func(ctx context.Context, options *lrogroup.LROsClientBeginPost200WithPayloadOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPost200WithPayloadResponse], errResp azfake.ErrorResponder)

	// BeginPost202List is the fake for method LROsClient.BeginPost202List
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPost202List func(ctx context.Context, options *lrogroup.LROsClientBeginPost202ListOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPost202ListResponse], errResp azfake.ErrorResponder)

	// BeginPost202NoRetry204 is the fake for method LROsClient.BeginPost202NoRetry204
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPost202NoRetry204 func(ctx context.Context, options *lrogroup.LROsClientBeginPost202NoRetry204Options) (resp azfake.PollerResponder[lrogroup.LROsClientPost202NoRetry204Response], errResp azfake.ErrorResponder)

	// BeginPost202Retry200 is the fake for method LROsClient.BeginPost202Retry200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginPost202Retry200 func(ctx context.Context, options *lrogroup.LROsClientBeginPost202Retry200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPost202Retry200Response], errResp azfake.ErrorResponder)

	// BeginPostAsyncNoRetrySucceeded is the fake for method LROsClient.BeginPostAsyncNoRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostAsyncNoRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncNoRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncNoRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRetryFailed is the fake for method LROsClient.BeginPostAsyncRetryFailed
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginPostAsyncRetryFailed func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncRetryFailedOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetryFailedResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRetrySucceeded is the fake for method LROsClient.BeginPostAsyncRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostAsyncRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRetrycanceled is the fake for method LROsClient.BeginPostAsyncRetrycanceled
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted, http.StatusNoContent
	BeginPostAsyncRetrycanceled func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncRetrycanceledOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrycanceledResponse], errResp azfake.ErrorResponder)

	// BeginPostDoubleHeadersFinalAzureHeaderGet is the fake for method LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostDoubleHeadersFinalAzureHeaderGet func(ctx context.Context, options *lrogroup.LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse], errResp azfake.ErrorResponder)

	// BeginPostDoubleHeadersFinalAzureHeaderGetDefault is the fake for method LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostDoubleHeadersFinalAzureHeaderGetDefault func(ctx context.Context, options *lrogroup.LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse], errResp azfake.ErrorResponder)

	// BeginPostDoubleHeadersFinalLocationGet is the fake for method LROsClient.BeginPostDoubleHeadersFinalLocationGet
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostDoubleHeadersFinalLocationGet func(ctx context.Context, options *lrogroup.LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalLocationGetResponse], errResp azfake.ErrorResponder)

	// BeginPut200Acceptedcanceled200 is the fake for method LROsClient.BeginPut200Acceptedcanceled200
	// HTTP status codes to indicate success: http.StatusOK
	BeginPut200Acceptedcanceled200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200Acceptedcanceled200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut200Acceptedcanceled200Response], errResp azfake.ErrorResponder)

	// BeginPut200Succeeded is the fake for method LROsClient.BeginPut200Succeeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusNoContent
	BeginPut200Succeeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPut200SucceededResponse], errResp azfake.ErrorResponder)

	// BeginPut200SucceededNoState is the fake for method LROsClient.BeginPut200SucceededNoState
	// HTTP status codes to indicate success: http.StatusOK
	BeginPut200SucceededNoState func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200SucceededNoStateOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPut200SucceededNoStateResponse], errResp azfake.ErrorResponder)

	// BeginPut200UpdatingSucceeded204 is the fake for method LROsClient.BeginPut200UpdatingSucceeded204
	// HTTP status codes to indicate success: http.StatusOK
	BeginPut200UpdatingSucceeded204 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200UpdatingSucceeded204Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut200UpdatingSucceeded204Response], errResp azfake.ErrorResponder)

	// BeginPut201CreatingFailed200 is the fake for method LROsClient.BeginPut201CreatingFailed200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPut201CreatingFailed200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut201CreatingFailed200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut201CreatingFailed200Response], errResp azfake.ErrorResponder)

	// BeginPut201CreatingSucceeded200 is the fake for method LROsClient.BeginPut201CreatingSucceeded200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPut201CreatingSucceeded200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut201CreatingSucceeded200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut201CreatingSucceeded200Response], errResp azfake.ErrorResponder)

	// BeginPut201Succeeded is the fake for method LROsClient.BeginPut201Succeeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPut201Succeeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut201SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPut201SucceededResponse], errResp azfake.ErrorResponder)

	// BeginPut202Retry200 is the fake for method LROsClient.BeginPut202Retry200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPut202Retry200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut202Retry200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut202Retry200Response], errResp azfake.ErrorResponder)

	// BeginPutAsyncNoHeaderInRetry is the fake for method LROsClient.BeginPutAsyncNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutAsyncNoHeaderInRetry func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncNoRetrySucceeded is the fake for method LROsClient.BeginPutAsyncNoRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncNoRetrySucceeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncNoRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncNoRetrycanceled is the fake for method LROsClient.BeginPutAsyncNoRetrycanceled
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncNoRetrycanceled func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncNoRetrycanceledOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrycanceledResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncNonResource is the fake for method LROsClient.BeginPutAsyncNonResource
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPutAsyncNonResource func(ctx context.Context, sku lrogroup.SKU, options *lrogroup.LROsClientBeginPutAsyncNonResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNonResourceResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRetryFailed is the fake for method LROsClient.BeginPutAsyncRetryFailed
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRetryFailed func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncRetryFailedOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetryFailedResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRetrySucceeded is the fake for method LROsClient.BeginPutAsyncRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRetrySucceeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncSubResource is the fake for method LROsClient.BeginPutAsyncSubResource
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPutAsyncSubResource func(ctx context.Context, product lrogroup.SubProduct, options *lrogroup.LROsClientBeginPutAsyncSubResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncSubResourceResponse], errResp azfake.ErrorResponder)

	// BeginPutNoHeaderInRetry is the fake for method LROsClient.BeginPutNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPutNoHeaderInRetry func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginPutNonResource is the fake for method LROsClient.BeginPutNonResource
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPutNonResource func(ctx context.Context, sku lrogroup.SKU, options *lrogroup.LROsClientBeginPutNonResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutNonResourceResponse], errResp azfake.ErrorResponder)

	// BeginPutSubResource is the fake for method LROsClient.BeginPutSubResource
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPutSubResource func(ctx context.Context, product lrogroup.SubProduct, options *lrogroup.LROsClientBeginPutSubResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutSubResourceResponse], errResp azfake.ErrorResponder)
}

// NewLROsServerTransport creates a new instance of LROsServerTransport with the provided implementation.
// The returned LROsServerTransport instance is connected to an instance of lrogroup.LROsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewLROsServerTransport(srv *LROsServer) *LROsServerTransport {
	return &LROsServerTransport{
		srv:                                              srv,
		beginDelete202NoRetry204:                         newTracker[azfake.PollerResponder[lrogroup.LROsClientDelete202NoRetry204Response]](),
		beginDelete202Retry200:                           newTracker[azfake.PollerResponder[lrogroup.LROsClientDelete202Retry200Response]](),
		beginDelete204Succeeded:                          newTracker[azfake.PollerResponder[lrogroup.LROsClientDelete204SucceededResponse]](),
		beginDeleteAsyncNoHeaderInRetry:                  newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoHeaderInRetryResponse]](),
		beginDeleteAsyncNoRetrySucceeded:                 newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoRetrySucceededResponse]](),
		beginDeleteAsyncRetryFailed:                      newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetryFailedResponse]](),
		beginDeleteAsyncRetrySucceeded:                   newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrySucceededResponse]](),
		beginDeleteAsyncRetrycanceled:                    newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrycanceledResponse]](),
		beginDeleteNoHeaderInRetry:                       newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteNoHeaderInRetryResponse]](),
		beginDeleteProvisioning202Accepted200Succeeded:   newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Accepted200SucceededResponse]](),
		beginDeleteProvisioning202DeletingFailed200:      newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202DeletingFailed200Response]](),
		beginDeleteProvisioning202Deletingcanceled200:    newTracker[azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Deletingcanceled200Response]](),
		beginPatch200SucceededIgnoreHeaders:              newTracker[azfake.PollerResponder[lrogroup.LROsClientPatch200SucceededIgnoreHeadersResponse]](),
		beginPatch201RetryWithAsyncHeader:                newTracker[azfake.PollerResponder[lrogroup.LROsClientPatch201RetryWithAsyncHeaderResponse]](),
		beginPatch202RetryWithAsyncAndLocationHeader:     newTracker[azfake.PollerResponder[lrogroup.LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse]](),
		beginPost200WithPayload:                          newTracker[azfake.PollerResponder[lrogroup.LROsClientPost200WithPayloadResponse]](),
		beginPost202List:                                 newTracker[azfake.PollerResponder[lrogroup.LROsClientPost202ListResponse]](),
		beginPost202NoRetry204:                           newTracker[azfake.PollerResponder[lrogroup.LROsClientPost202NoRetry204Response]](),
		beginPost202Retry200:                             newTracker[azfake.PollerResponder[lrogroup.LROsClientPost202Retry200Response]](),
		beginPostAsyncNoRetrySucceeded:                   newTracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncNoRetrySucceededResponse]](),
		beginPostAsyncRetryFailed:                        newTracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetryFailedResponse]](),
		beginPostAsyncRetrySucceeded:                     newTracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrySucceededResponse]](),
		beginPostAsyncRetrycanceled:                      newTracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrycanceledResponse]](),
		beginPostDoubleHeadersFinalAzureHeaderGet:        newTracker[azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse]](),
		beginPostDoubleHeadersFinalAzureHeaderGetDefault: newTracker[azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse]](),
		beginPostDoubleHeadersFinalLocationGet:           newTracker[azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalLocationGetResponse]](),
		beginPut200Acceptedcanceled200:                   newTracker[azfake.PollerResponder[lrogroup.LROsClientPut200Acceptedcanceled200Response]](),
		beginPut200Succeeded:                             newTracker[azfake.PollerResponder[lrogroup.LROsClientPut200SucceededResponse]](),
		beginPut200SucceededNoState:                      newTracker[azfake.PollerResponder[lrogroup.LROsClientPut200SucceededNoStateResponse]](),
		beginPut200UpdatingSucceeded204:                  newTracker[azfake.PollerResponder[lrogroup.LROsClientPut200UpdatingSucceeded204Response]](),
		beginPut201CreatingFailed200:                     newTracker[azfake.PollerResponder[lrogroup.LROsClientPut201CreatingFailed200Response]](),
		beginPut201CreatingSucceeded200:                  newTracker[azfake.PollerResponder[lrogroup.LROsClientPut201CreatingSucceeded200Response]](),
		beginPut201Succeeded:                             newTracker[azfake.PollerResponder[lrogroup.LROsClientPut201SucceededResponse]](),
		beginPut202Retry200:                              newTracker[azfake.PollerResponder[lrogroup.LROsClientPut202Retry200Response]](),
		beginPutAsyncNoHeaderInRetry:                     newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoHeaderInRetryResponse]](),
		beginPutAsyncNoRetrySucceeded:                    newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrySucceededResponse]](),
		beginPutAsyncNoRetrycanceled:                     newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrycanceledResponse]](),
		beginPutAsyncNonResource:                         newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNonResourceResponse]](),
		beginPutAsyncRetryFailed:                         newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetryFailedResponse]](),
		beginPutAsyncRetrySucceeded:                      newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetrySucceededResponse]](),
		beginPutAsyncSubResource:                         newTracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncSubResourceResponse]](),
		beginPutNoHeaderInRetry:                          newTracker[azfake.PollerResponder[lrogroup.LROsClientPutNoHeaderInRetryResponse]](),
		beginPutNonResource:                              newTracker[azfake.PollerResponder[lrogroup.LROsClientPutNonResourceResponse]](),
		beginPutSubResource:                              newTracker[azfake.PollerResponder[lrogroup.LROsClientPutSubResourceResponse]](),
	}
}

// LROsServerTransport connects instances of lrogroup.LROsClient to instances of LROsServer.
// Don't use this type directly, use NewLROsServerTransport instead.
type LROsServerTransport struct {
	srv                                              *LROsServer
	beginDelete202NoRetry204                         *tracker[azfake.PollerResponder[lrogroup.LROsClientDelete202NoRetry204Response]]
	beginDelete202Retry200                           *tracker[azfake.PollerResponder[lrogroup.LROsClientDelete202Retry200Response]]
	beginDelete204Succeeded                          *tracker[azfake.PollerResponder[lrogroup.LROsClientDelete204SucceededResponse]]
	beginDeleteAsyncNoHeaderInRetry                  *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoHeaderInRetryResponse]]
	beginDeleteAsyncNoRetrySucceeded                 *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoRetrySucceededResponse]]
	beginDeleteAsyncRetryFailed                      *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetryFailedResponse]]
	beginDeleteAsyncRetrySucceeded                   *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrySucceededResponse]]
	beginDeleteAsyncRetrycanceled                    *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrycanceledResponse]]
	beginDeleteNoHeaderInRetry                       *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteNoHeaderInRetryResponse]]
	beginDeleteProvisioning202Accepted200Succeeded   *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Accepted200SucceededResponse]]
	beginDeleteProvisioning202DeletingFailed200      *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202DeletingFailed200Response]]
	beginDeleteProvisioning202Deletingcanceled200    *tracker[azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Deletingcanceled200Response]]
	beginPatch200SucceededIgnoreHeaders              *tracker[azfake.PollerResponder[lrogroup.LROsClientPatch200SucceededIgnoreHeadersResponse]]
	beginPatch201RetryWithAsyncHeader                *tracker[azfake.PollerResponder[lrogroup.LROsClientPatch201RetryWithAsyncHeaderResponse]]
	beginPatch202RetryWithAsyncAndLocationHeader     *tracker[azfake.PollerResponder[lrogroup.LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse]]
	beginPost200WithPayload                          *tracker[azfake.PollerResponder[lrogroup.LROsClientPost200WithPayloadResponse]]
	beginPost202List                                 *tracker[azfake.PollerResponder[lrogroup.LROsClientPost202ListResponse]]
	beginPost202NoRetry204                           *tracker[azfake.PollerResponder[lrogroup.LROsClientPost202NoRetry204Response]]
	beginPost202Retry200                             *tracker[azfake.PollerResponder[lrogroup.LROsClientPost202Retry200Response]]
	beginPostAsyncNoRetrySucceeded                   *tracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncNoRetrySucceededResponse]]
	beginPostAsyncRetryFailed                        *tracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetryFailedResponse]]
	beginPostAsyncRetrySucceeded                     *tracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrySucceededResponse]]
	beginPostAsyncRetrycanceled                      *tracker[azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrycanceledResponse]]
	beginPostDoubleHeadersFinalAzureHeaderGet        *tracker[azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse]]
	beginPostDoubleHeadersFinalAzureHeaderGetDefault *tracker[azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse]]
	beginPostDoubleHeadersFinalLocationGet           *tracker[azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalLocationGetResponse]]
	beginPut200Acceptedcanceled200                   *tracker[azfake.PollerResponder[lrogroup.LROsClientPut200Acceptedcanceled200Response]]
	beginPut200Succeeded                             *tracker[azfake.PollerResponder[lrogroup.LROsClientPut200SucceededResponse]]
	beginPut200SucceededNoState                      *tracker[azfake.PollerResponder[lrogroup.LROsClientPut200SucceededNoStateResponse]]
	beginPut200UpdatingSucceeded204                  *tracker[azfake.PollerResponder[lrogroup.LROsClientPut200UpdatingSucceeded204Response]]
	beginPut201CreatingFailed200                     *tracker[azfake.PollerResponder[lrogroup.LROsClientPut201CreatingFailed200Response]]
	beginPut201CreatingSucceeded200                  *tracker[azfake.PollerResponder[lrogroup.LROsClientPut201CreatingSucceeded200Response]]
	beginPut201Succeeded                             *tracker[azfake.PollerResponder[lrogroup.LROsClientPut201SucceededResponse]]
	beginPut202Retry200                              *tracker[azfake.PollerResponder[lrogroup.LROsClientPut202Retry200Response]]
	beginPutAsyncNoHeaderInRetry                     *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoHeaderInRetryResponse]]
	beginPutAsyncNoRetrySucceeded                    *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrySucceededResponse]]
	beginPutAsyncNoRetrycanceled                     *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrycanceledResponse]]
	beginPutAsyncNonResource                         *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncNonResourceResponse]]
	beginPutAsyncRetryFailed                         *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetryFailedResponse]]
	beginPutAsyncRetrySucceeded                      *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetrySucceededResponse]]
	beginPutAsyncSubResource                         *tracker[azfake.PollerResponder[lrogroup.LROsClientPutAsyncSubResourceResponse]]
	beginPutNoHeaderInRetry                          *tracker[azfake.PollerResponder[lrogroup.LROsClientPutNoHeaderInRetryResponse]]
	beginPutNonResource                              *tracker[azfake.PollerResponder[lrogroup.LROsClientPutNonResourceResponse]]
	beginPutSubResource                              *tracker[azfake.PollerResponder[lrogroup.LROsClientPutSubResourceResponse]]
}

// Do implements the policy.Transporter interface for LROsServerTransport.
func (l *LROsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return l.dispatchToMethodFake(req, method)
}

func (l *LROsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var res result
		switch method {
		case "LROsClient.BeginDelete202NoRetry204":
			res.resp, res.err = l.dispatchBeginDelete202NoRetry204(req)
		case "LROsClient.BeginDelete202Retry200":
			res.resp, res.err = l.dispatchBeginDelete202Retry200(req)
		case "LROsClient.BeginDelete204Succeeded":
			res.resp, res.err = l.dispatchBeginDelete204Succeeded(req)
		case "LROsClient.BeginDeleteAsyncNoHeaderInRetry":
			res.resp, res.err = l.dispatchBeginDeleteAsyncNoHeaderInRetry(req)
		case "LROsClient.BeginDeleteAsyncNoRetrySucceeded":
			res.resp, res.err = l.dispatchBeginDeleteAsyncNoRetrySucceeded(req)
		case "LROsClient.BeginDeleteAsyncRetryFailed":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRetryFailed(req)
		case "LROsClient.BeginDeleteAsyncRetrySucceeded":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRetrySucceeded(req)
		case "LROsClient.BeginDeleteAsyncRetrycanceled":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRetrycanceled(req)
		case "LROsClient.BeginDeleteNoHeaderInRetry":
			res.resp, res.err = l.dispatchBeginDeleteNoHeaderInRetry(req)
		case "LROsClient.BeginDeleteProvisioning202Accepted200Succeeded":
			res.resp, res.err = l.dispatchBeginDeleteProvisioning202Accepted200Succeeded(req)
		case "LROsClient.BeginDeleteProvisioning202DeletingFailed200":
			res.resp, res.err = l.dispatchBeginDeleteProvisioning202DeletingFailed200(req)
		case "LROsClient.BeginDeleteProvisioning202Deletingcanceled200":
			res.resp, res.err = l.dispatchBeginDeleteProvisioning202Deletingcanceled200(req)
		case "LROsClient.BeginPatch200SucceededIgnoreHeaders":
			res.resp, res.err = l.dispatchBeginPatch200SucceededIgnoreHeaders(req)
		case "LROsClient.BeginPatch201RetryWithAsyncHeader":
			res.resp, res.err = l.dispatchBeginPatch201RetryWithAsyncHeader(req)
		case "LROsClient.BeginPatch202RetryWithAsyncAndLocationHeader":
			res.resp, res.err = l.dispatchBeginPatch202RetryWithAsyncAndLocationHeader(req)
		case "LROsClient.BeginPost200WithPayload":
			res.resp, res.err = l.dispatchBeginPost200WithPayload(req)
		case "LROsClient.BeginPost202List":
			res.resp, res.err = l.dispatchBeginPost202List(req)
		case "LROsClient.BeginPost202NoRetry204":
			res.resp, res.err = l.dispatchBeginPost202NoRetry204(req)
		case "LROsClient.BeginPost202Retry200":
			res.resp, res.err = l.dispatchBeginPost202Retry200(req)
		case "LROsClient.BeginPostAsyncNoRetrySucceeded":
			res.resp, res.err = l.dispatchBeginPostAsyncNoRetrySucceeded(req)
		case "LROsClient.BeginPostAsyncRetryFailed":
			res.resp, res.err = l.dispatchBeginPostAsyncRetryFailed(req)
		case "LROsClient.BeginPostAsyncRetrySucceeded":
			res.resp, res.err = l.dispatchBeginPostAsyncRetrySucceeded(req)
		case "LROsClient.BeginPostAsyncRetrycanceled":
			res.resp, res.err = l.dispatchBeginPostAsyncRetrycanceled(req)
		case "LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet":
			res.resp, res.err = l.dispatchBeginPostDoubleHeadersFinalAzureHeaderGet(req)
		case "LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault":
			res.resp, res.err = l.dispatchBeginPostDoubleHeadersFinalAzureHeaderGetDefault(req)
		case "LROsClient.BeginPostDoubleHeadersFinalLocationGet":
			res.resp, res.err = l.dispatchBeginPostDoubleHeadersFinalLocationGet(req)
		case "LROsClient.BeginPut200Acceptedcanceled200":
			res.resp, res.err = l.dispatchBeginPut200Acceptedcanceled200(req)
		case "LROsClient.BeginPut200Succeeded":
			res.resp, res.err = l.dispatchBeginPut200Succeeded(req)
		case "LROsClient.BeginPut200SucceededNoState":
			res.resp, res.err = l.dispatchBeginPut200SucceededNoState(req)
		case "LROsClient.BeginPut200UpdatingSucceeded204":
			res.resp, res.err = l.dispatchBeginPut200UpdatingSucceeded204(req)
		case "LROsClient.BeginPut201CreatingFailed200":
			res.resp, res.err = l.dispatchBeginPut201CreatingFailed200(req)
		case "LROsClient.BeginPut201CreatingSucceeded200":
			res.resp, res.err = l.dispatchBeginPut201CreatingSucceeded200(req)
		case "LROsClient.BeginPut201Succeeded":
			res.resp, res.err = l.dispatchBeginPut201Succeeded(req)
		case "LROsClient.BeginPut202Retry200":
			res.resp, res.err = l.dispatchBeginPut202Retry200(req)
		case "LROsClient.BeginPutAsyncNoHeaderInRetry":
			res.resp, res.err = l.dispatchBeginPutAsyncNoHeaderInRetry(req)
		case "LROsClient.BeginPutAsyncNoRetrySucceeded":
			res.resp, res.err = l.dispatchBeginPutAsyncNoRetrySucceeded(req)
		case "LROsClient.BeginPutAsyncNoRetrycanceled":
			res.resp, res.err = l.dispatchBeginPutAsyncNoRetrycanceled(req)
		case "LROsClient.BeginPutAsyncNonResource":
			res.resp, res.err = l.dispatchBeginPutAsyncNonResource(req)
		case "LROsClient.BeginPutAsyncRetryFailed":
			res.resp, res.err = l.dispatchBeginPutAsyncRetryFailed(req)
		case "LROsClient.BeginPutAsyncRetrySucceeded":
			res.resp, res.err = l.dispatchBeginPutAsyncRetrySucceeded(req)
		case "LROsClient.BeginPutAsyncSubResource":
			res.resp, res.err = l.dispatchBeginPutAsyncSubResource(req)
		case "LROsClient.BeginPutNoHeaderInRetry":
			res.resp, res.err = l.dispatchBeginPutNoHeaderInRetry(req)
		case "LROsClient.BeginPutNonResource":
			res.resp, res.err = l.dispatchBeginPutNonResource(req)
		case "LROsClient.BeginPutSubResource":
			res.resp, res.err = l.dispatchBeginPutSubResource(req)
		default:
			res.err = fmt.Errorf("unhandled API %s", method)
		}

		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (l *LROsServerTransport) dispatchBeginDelete202NoRetry204(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202NoRetry204 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete202NoRetry204 not implemented")}
	}
	beginDelete202NoRetry204 := l.beginDelete202NoRetry204.get(req)
	if beginDelete202NoRetry204 == nil {
		respr, errRespr := l.srv.BeginDelete202NoRetry204(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete202NoRetry204 = &respr
		l.beginDelete202NoRetry204.add(req, beginDelete202NoRetry204)
	}

	resp, err := server.PollerResponderNext(beginDelete202NoRetry204, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginDelete202NoRetry204.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete202NoRetry204) {
		l.beginDelete202NoRetry204.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDelete202Retry200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202Retry200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete202Retry200 not implemented")}
	}
	beginDelete202Retry200 := l.beginDelete202Retry200.get(req)
	if beginDelete202Retry200 == nil {
		respr, errRespr := l.srv.BeginDelete202Retry200(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete202Retry200 = &respr
		l.beginDelete202Retry200.add(req, beginDelete202Retry200)
	}

	resp, err := server.PollerResponderNext(beginDelete202Retry200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginDelete202Retry200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete202Retry200) {
		l.beginDelete202Retry200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDelete204Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete204Succeeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete204Succeeded not implemented")}
	}
	beginDelete204Succeeded := l.beginDelete204Succeeded.get(req)
	if beginDelete204Succeeded == nil {
		respr, errRespr := l.srv.BeginDelete204Succeeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete204Succeeded = &respr
		l.beginDelete204Succeeded.add(req, beginDelete204Succeeded)
	}

	resp, err := server.PollerResponderNext(beginDelete204Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusNoContent}, resp.StatusCode) {
		l.beginDelete204Succeeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete204Succeeded) {
		l.beginDelete204Succeeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncNoHeaderInRetry not implemented")}
	}
	beginDeleteAsyncNoHeaderInRetry := l.beginDeleteAsyncNoHeaderInRetry.get(req)
	if beginDeleteAsyncNoHeaderInRetry == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncNoHeaderInRetry(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncNoHeaderInRetry = &respr
		l.beginDeleteAsyncNoHeaderInRetry.add(req, beginDeleteAsyncNoHeaderInRetry)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginDeleteAsyncNoHeaderInRetry.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncNoHeaderInRetry) {
		l.beginDeleteAsyncNoHeaderInRetry.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncNoRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncNoRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncNoRetrySucceeded not implemented")}
	}
	beginDeleteAsyncNoRetrySucceeded := l.beginDeleteAsyncNoRetrySucceeded.get(req)
	if beginDeleteAsyncNoRetrySucceeded == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncNoRetrySucceeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncNoRetrySucceeded = &respr
		l.beginDeleteAsyncNoRetrySucceeded.add(req, beginDeleteAsyncNoRetrySucceeded)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncNoRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginDeleteAsyncNoRetrySucceeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncNoRetrySucceeded) {
		l.beginDeleteAsyncNoRetrySucceeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncRetryFailed(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRetryFailed == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRetryFailed not implemented")}
	}
	beginDeleteAsyncRetryFailed := l.beginDeleteAsyncRetryFailed.get(req)
	if beginDeleteAsyncRetryFailed == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRetryFailed(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRetryFailed = &respr
		l.beginDeleteAsyncRetryFailed.add(req, beginDeleteAsyncRetryFailed)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRetryFailed, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginDeleteAsyncRetryFailed.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRetryFailed) {
		l.beginDeleteAsyncRetryFailed.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRetrySucceeded not implemented")}
	}
	beginDeleteAsyncRetrySucceeded := l.beginDeleteAsyncRetrySucceeded.get(req)
	if beginDeleteAsyncRetrySucceeded == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRetrySucceeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRetrySucceeded = &respr
		l.beginDeleteAsyncRetrySucceeded.add(req, beginDeleteAsyncRetrySucceeded)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginDeleteAsyncRetrySucceeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRetrySucceeded) {
		l.beginDeleteAsyncRetrySucceeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncRetrycanceled(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRetrycanceled == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRetrycanceled not implemented")}
	}
	beginDeleteAsyncRetrycanceled := l.beginDeleteAsyncRetrycanceled.get(req)
	if beginDeleteAsyncRetrycanceled == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRetrycanceled(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRetrycanceled = &respr
		l.beginDeleteAsyncRetrycanceled.add(req, beginDeleteAsyncRetrycanceled)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRetrycanceled, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginDeleteAsyncRetrycanceled.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRetrycanceled) {
		l.beginDeleteAsyncRetrycanceled.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteNoHeaderInRetry not implemented")}
	}
	beginDeleteNoHeaderInRetry := l.beginDeleteNoHeaderInRetry.get(req)
	if beginDeleteNoHeaderInRetry == nil {
		respr, errRespr := l.srv.BeginDeleteNoHeaderInRetry(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteNoHeaderInRetry = &respr
		l.beginDeleteNoHeaderInRetry.add(req, beginDeleteNoHeaderInRetry)
	}

	resp, err := server.PollerResponderNext(beginDeleteNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginDeleteNoHeaderInRetry.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteNoHeaderInRetry) {
		l.beginDeleteNoHeaderInRetry.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteProvisioning202Accepted200Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteProvisioning202Accepted200Succeeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteProvisioning202Accepted200Succeeded not implemented")}
	}
	beginDeleteProvisioning202Accepted200Succeeded := l.beginDeleteProvisioning202Accepted200Succeeded.get(req)
	if beginDeleteProvisioning202Accepted200Succeeded == nil {
		respr, errRespr := l.srv.BeginDeleteProvisioning202Accepted200Succeeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteProvisioning202Accepted200Succeeded = &respr
		l.beginDeleteProvisioning202Accepted200Succeeded.add(req, beginDeleteProvisioning202Accepted200Succeeded)
	}

	resp, err := server.PollerResponderNext(beginDeleteProvisioning202Accepted200Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteProvisioning202Accepted200Succeeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteProvisioning202Accepted200Succeeded) {
		l.beginDeleteProvisioning202Accepted200Succeeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteProvisioning202DeletingFailed200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteProvisioning202DeletingFailed200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteProvisioning202DeletingFailed200 not implemented")}
	}
	beginDeleteProvisioning202DeletingFailed200 := l.beginDeleteProvisioning202DeletingFailed200.get(req)
	if beginDeleteProvisioning202DeletingFailed200 == nil {
		respr, errRespr := l.srv.BeginDeleteProvisioning202DeletingFailed200(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteProvisioning202DeletingFailed200 = &respr
		l.beginDeleteProvisioning202DeletingFailed200.add(req, beginDeleteProvisioning202DeletingFailed200)
	}

	resp, err := server.PollerResponderNext(beginDeleteProvisioning202DeletingFailed200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteProvisioning202DeletingFailed200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteProvisioning202DeletingFailed200) {
		l.beginDeleteProvisioning202DeletingFailed200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteProvisioning202Deletingcanceled200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteProvisioning202Deletingcanceled200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteProvisioning202Deletingcanceled200 not implemented")}
	}
	beginDeleteProvisioning202Deletingcanceled200 := l.beginDeleteProvisioning202Deletingcanceled200.get(req)
	if beginDeleteProvisioning202Deletingcanceled200 == nil {
		respr, errRespr := l.srv.BeginDeleteProvisioning202Deletingcanceled200(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteProvisioning202Deletingcanceled200 = &respr
		l.beginDeleteProvisioning202Deletingcanceled200.add(req, beginDeleteProvisioning202Deletingcanceled200)
	}

	resp, err := server.PollerResponderNext(beginDeleteProvisioning202Deletingcanceled200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteProvisioning202Deletingcanceled200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteProvisioning202Deletingcanceled200) {
		l.beginDeleteProvisioning202Deletingcanceled200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPatch200SucceededIgnoreHeaders(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPatch200SucceededIgnoreHeaders == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPatch200SucceededIgnoreHeaders not implemented")}
	}
	beginPatch200SucceededIgnoreHeaders := l.beginPatch200SucceededIgnoreHeaders.get(req)
	if beginPatch200SucceededIgnoreHeaders == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPatch200SucceededIgnoreHeaders(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPatch200SucceededIgnoreHeaders = &respr
		l.beginPatch200SucceededIgnoreHeaders.add(req, beginPatch200SucceededIgnoreHeaders)
	}

	resp, err := server.PollerResponderNext(beginPatch200SucceededIgnoreHeaders, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPatch200SucceededIgnoreHeaders.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPatch200SucceededIgnoreHeaders) {
		l.beginPatch200SucceededIgnoreHeaders.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPatch201RetryWithAsyncHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPatch201RetryWithAsyncHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPatch201RetryWithAsyncHeader not implemented")}
	}
	beginPatch201RetryWithAsyncHeader := l.beginPatch201RetryWithAsyncHeader.get(req)
	if beginPatch201RetryWithAsyncHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPatch201RetryWithAsyncHeader(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPatch201RetryWithAsyncHeader = &respr
		l.beginPatch201RetryWithAsyncHeader.add(req, beginPatch201RetryWithAsyncHeader)
	}

	resp, err := server.PollerResponderNext(beginPatch201RetryWithAsyncHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPatch201RetryWithAsyncHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPatch201RetryWithAsyncHeader) {
		l.beginPatch201RetryWithAsyncHeader.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPatch202RetryWithAsyncAndLocationHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPatch202RetryWithAsyncAndLocationHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPatch202RetryWithAsyncAndLocationHeader not implemented")}
	}
	beginPatch202RetryWithAsyncAndLocationHeader := l.beginPatch202RetryWithAsyncAndLocationHeader.get(req)
	if beginPatch202RetryWithAsyncAndLocationHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPatch202RetryWithAsyncAndLocationHeader(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPatch202RetryWithAsyncAndLocationHeader = &respr
		l.beginPatch202RetryWithAsyncAndLocationHeader.add(req, beginPatch202RetryWithAsyncAndLocationHeader)
	}

	resp, err := server.PollerResponderNext(beginPatch202RetryWithAsyncAndLocationHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPatch202RetryWithAsyncAndLocationHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPatch202RetryWithAsyncAndLocationHeader) {
		l.beginPatch202RetryWithAsyncAndLocationHeader.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost200WithPayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost200WithPayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost200WithPayload not implemented")}
	}
	beginPost200WithPayload := l.beginPost200WithPayload.get(req)
	if beginPost200WithPayload == nil {
		respr, errRespr := l.srv.BeginPost200WithPayload(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost200WithPayload = &respr
		l.beginPost200WithPayload.add(req, beginPost200WithPayload)
	}

	resp, err := server.PollerResponderNext(beginPost200WithPayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPost200WithPayload.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost200WithPayload) {
		l.beginPost200WithPayload.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost202List(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202List == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202List not implemented")}
	}
	beginPost202List := l.beginPost202List.get(req)
	if beginPost202List == nil {
		respr, errRespr := l.srv.BeginPost202List(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost202List = &respr
		l.beginPost202List.add(req, beginPost202List)
	}

	resp, err := server.PollerResponderNext(beginPost202List, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPost202List.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost202List) {
		l.beginPost202List.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost202NoRetry204(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202NoRetry204 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202NoRetry204 not implemented")}
	}
	beginPost202NoRetry204 := l.beginPost202NoRetry204.get(req)
	if beginPost202NoRetry204 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPost202NoRetry204Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPost202NoRetry204Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202NoRetry204(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost202NoRetry204 = &respr
		l.beginPost202NoRetry204.add(req, beginPost202NoRetry204)
	}

	resp, err := server.PollerResponderNext(beginPost202NoRetry204, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPost202NoRetry204.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost202NoRetry204) {
		l.beginPost202NoRetry204.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost202Retry200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202Retry200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202Retry200 not implemented")}
	}
	beginPost202Retry200 := l.beginPost202Retry200.get(req)
	if beginPost202Retry200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPost202Retry200Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPost202Retry200Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202Retry200(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost202Retry200 = &respr
		l.beginPost202Retry200.add(req, beginPost202Retry200)
	}

	resp, err := server.PollerResponderNext(beginPost202Retry200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginPost202Retry200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost202Retry200) {
		l.beginPost202Retry200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncNoRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncNoRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncNoRetrySucceeded not implemented")}
	}
	beginPostAsyncNoRetrySucceeded := l.beginPostAsyncNoRetrySucceeded.get(req)
	if beginPostAsyncNoRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncNoRetrySucceededOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncNoRetrySucceededOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncNoRetrySucceeded(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncNoRetrySucceeded = &respr
		l.beginPostAsyncNoRetrySucceeded.add(req, beginPostAsyncNoRetrySucceeded)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncNoRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPostAsyncNoRetrySucceeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncNoRetrySucceeded) {
		l.beginPostAsyncNoRetrySucceeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncRetryFailed(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRetryFailed == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRetryFailed not implemented")}
	}
	beginPostAsyncRetryFailed := l.beginPostAsyncRetryFailed.get(req)
	if beginPostAsyncRetryFailed == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncRetryFailedOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncRetryFailedOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRetryFailed(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRetryFailed = &respr
		l.beginPostAsyncRetryFailed.add(req, beginPostAsyncRetryFailed)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRetryFailed, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginPostAsyncRetryFailed.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRetryFailed) {
		l.beginPostAsyncRetryFailed.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRetrySucceeded not implemented")}
	}
	beginPostAsyncRetrySucceeded := l.beginPostAsyncRetrySucceeded.get(req)
	if beginPostAsyncRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncRetrySucceededOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncRetrySucceededOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRetrySucceeded(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRetrySucceeded = &respr
		l.beginPostAsyncRetrySucceeded.add(req, beginPostAsyncRetrySucceeded)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPostAsyncRetrySucceeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRetrySucceeded) {
		l.beginPostAsyncRetrySucceeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncRetrycanceled(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRetrycanceled == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRetrycanceled not implemented")}
	}
	beginPostAsyncRetrycanceled := l.beginPostAsyncRetrycanceled.get(req)
	if beginPostAsyncRetrycanceled == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncRetrycanceledOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncRetrycanceledOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRetrycanceled(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRetrycanceled = &respr
		l.beginPostAsyncRetrycanceled.add(req, beginPostAsyncRetrycanceled)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRetrycanceled, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		l.beginPostAsyncRetrycanceled.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRetrycanceled) {
		l.beginPostAsyncRetrycanceled.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostDoubleHeadersFinalAzureHeaderGet(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostDoubleHeadersFinalAzureHeaderGet == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostDoubleHeadersFinalAzureHeaderGet not implemented")}
	}
	beginPostDoubleHeadersFinalAzureHeaderGet := l.beginPostDoubleHeadersFinalAzureHeaderGet.get(req)
	if beginPostDoubleHeadersFinalAzureHeaderGet == nil {
		respr, errRespr := l.srv.BeginPostDoubleHeadersFinalAzureHeaderGet(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostDoubleHeadersFinalAzureHeaderGet = &respr
		l.beginPostDoubleHeadersFinalAzureHeaderGet.add(req, beginPostDoubleHeadersFinalAzureHeaderGet)
	}

	resp, err := server.PollerResponderNext(beginPostDoubleHeadersFinalAzureHeaderGet, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPostDoubleHeadersFinalAzureHeaderGet.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostDoubleHeadersFinalAzureHeaderGet) {
		l.beginPostDoubleHeadersFinalAzureHeaderGet.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostDoubleHeadersFinalAzureHeaderGetDefault(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostDoubleHeadersFinalAzureHeaderGetDefault == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostDoubleHeadersFinalAzureHeaderGetDefault not implemented")}
	}
	beginPostDoubleHeadersFinalAzureHeaderGetDefault := l.beginPostDoubleHeadersFinalAzureHeaderGetDefault.get(req)
	if beginPostDoubleHeadersFinalAzureHeaderGetDefault == nil {
		respr, errRespr := l.srv.BeginPostDoubleHeadersFinalAzureHeaderGetDefault(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostDoubleHeadersFinalAzureHeaderGetDefault = &respr
		l.beginPostDoubleHeadersFinalAzureHeaderGetDefault.add(req, beginPostDoubleHeadersFinalAzureHeaderGetDefault)
	}

	resp, err := server.PollerResponderNext(beginPostDoubleHeadersFinalAzureHeaderGetDefault, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPostDoubleHeadersFinalAzureHeaderGetDefault.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostDoubleHeadersFinalAzureHeaderGetDefault) {
		l.beginPostDoubleHeadersFinalAzureHeaderGetDefault.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostDoubleHeadersFinalLocationGet(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostDoubleHeadersFinalLocationGet == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostDoubleHeadersFinalLocationGet not implemented")}
	}
	beginPostDoubleHeadersFinalLocationGet := l.beginPostDoubleHeadersFinalLocationGet.get(req)
	if beginPostDoubleHeadersFinalLocationGet == nil {
		respr, errRespr := l.srv.BeginPostDoubleHeadersFinalLocationGet(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostDoubleHeadersFinalLocationGet = &respr
		l.beginPostDoubleHeadersFinalLocationGet.add(req, beginPostDoubleHeadersFinalLocationGet)
	}

	resp, err := server.PollerResponderNext(beginPostDoubleHeadersFinalLocationGet, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPostDoubleHeadersFinalLocationGet.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostDoubleHeadersFinalLocationGet) {
		l.beginPostDoubleHeadersFinalLocationGet.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200Acceptedcanceled200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200Acceptedcanceled200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut200Acceptedcanceled200 not implemented")}
	}
	beginPut200Acceptedcanceled200 := l.beginPut200Acceptedcanceled200.get(req)
	if beginPut200Acceptedcanceled200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200Acceptedcanceled200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut200Acceptedcanceled200 = &respr
		l.beginPut200Acceptedcanceled200.add(req, beginPut200Acceptedcanceled200)
	}

	resp, err := server.PollerResponderNext(beginPut200Acceptedcanceled200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPut200Acceptedcanceled200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut200Acceptedcanceled200) {
		l.beginPut200Acceptedcanceled200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200Succeeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut200Succeeded not implemented")}
	}
	beginPut200Succeeded := l.beginPut200Succeeded.get(req)
	if beginPut200Succeeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200Succeeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut200Succeeded = &respr
		l.beginPut200Succeeded.add(req, beginPut200Succeeded)
	}

	resp, err := server.PollerResponderNext(beginPut200Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusNoContent}, resp.StatusCode) {
		l.beginPut200Succeeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut200Succeeded) {
		l.beginPut200Succeeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200SucceededNoState(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200SucceededNoState == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut200SucceededNoState not implemented")}
	}
	beginPut200SucceededNoState := l.beginPut200SucceededNoState.get(req)
	if beginPut200SucceededNoState == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200SucceededNoState(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut200SucceededNoState = &respr
		l.beginPut200SucceededNoState.add(req, beginPut200SucceededNoState)
	}

	resp, err := server.PollerResponderNext(beginPut200SucceededNoState, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPut200SucceededNoState.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut200SucceededNoState) {
		l.beginPut200SucceededNoState.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200UpdatingSucceeded204(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200UpdatingSucceeded204 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut200UpdatingSucceeded204 not implemented")}
	}
	beginPut200UpdatingSucceeded204 := l.beginPut200UpdatingSucceeded204.get(req)
	if beginPut200UpdatingSucceeded204 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200UpdatingSucceeded204(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut200UpdatingSucceeded204 = &respr
		l.beginPut200UpdatingSucceeded204.add(req, beginPut200UpdatingSucceeded204)
	}

	resp, err := server.PollerResponderNext(beginPut200UpdatingSucceeded204, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPut200UpdatingSucceeded204.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut200UpdatingSucceeded204) {
		l.beginPut200UpdatingSucceeded204.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut201CreatingFailed200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut201CreatingFailed200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut201CreatingFailed200 not implemented")}
	}
	beginPut201CreatingFailed200 := l.beginPut201CreatingFailed200.get(req)
	if beginPut201CreatingFailed200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut201CreatingFailed200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut201CreatingFailed200 = &respr
		l.beginPut201CreatingFailed200.add(req, beginPut201CreatingFailed200)
	}

	resp, err := server.PollerResponderNext(beginPut201CreatingFailed200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPut201CreatingFailed200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut201CreatingFailed200) {
		l.beginPut201CreatingFailed200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut201CreatingSucceeded200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut201CreatingSucceeded200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut201CreatingSucceeded200 not implemented")}
	}
	beginPut201CreatingSucceeded200 := l.beginPut201CreatingSucceeded200.get(req)
	if beginPut201CreatingSucceeded200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut201CreatingSucceeded200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut201CreatingSucceeded200 = &respr
		l.beginPut201CreatingSucceeded200.add(req, beginPut201CreatingSucceeded200)
	}

	resp, err := server.PollerResponderNext(beginPut201CreatingSucceeded200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPut201CreatingSucceeded200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut201CreatingSucceeded200) {
		l.beginPut201CreatingSucceeded200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut201Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut201Succeeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut201Succeeded not implemented")}
	}
	beginPut201Succeeded := l.beginPut201Succeeded.get(req)
	if beginPut201Succeeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut201Succeeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut201Succeeded = &respr
		l.beginPut201Succeeded.add(req, beginPut201Succeeded)
	}

	resp, err := server.PollerResponderNext(beginPut201Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPut201Succeeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut201Succeeded) {
		l.beginPut201Succeeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut202Retry200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut202Retry200 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut202Retry200 not implemented")}
	}
	beginPut202Retry200 := l.beginPut202Retry200.get(req)
	if beginPut202Retry200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut202Retry200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut202Retry200 = &respr
		l.beginPut202Retry200.add(req, beginPut202Retry200)
	}

	resp, err := server.PollerResponderNext(beginPut202Retry200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPut202Retry200.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut202Retry200) {
		l.beginPut202Retry200.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncNoHeaderInRetry not implemented")}
	}
	beginPutAsyncNoHeaderInRetry := l.beginPutAsyncNoHeaderInRetry.get(req)
	if beginPutAsyncNoHeaderInRetry == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNoHeaderInRetry(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncNoHeaderInRetry = &respr
		l.beginPutAsyncNoHeaderInRetry.add(req, beginPutAsyncNoHeaderInRetry)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPutAsyncNoHeaderInRetry.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncNoHeaderInRetry) {
		l.beginPutAsyncNoHeaderInRetry.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNoRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNoRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncNoRetrySucceeded not implemented")}
	}
	beginPutAsyncNoRetrySucceeded := l.beginPutAsyncNoRetrySucceeded.get(req)
	if beginPutAsyncNoRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNoRetrySucceeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncNoRetrySucceeded = &respr
		l.beginPutAsyncNoRetrySucceeded.add(req, beginPutAsyncNoRetrySucceeded)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncNoRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncNoRetrySucceeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncNoRetrySucceeded) {
		l.beginPutAsyncNoRetrySucceeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNoRetrycanceled(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNoRetrycanceled == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncNoRetrycanceled not implemented")}
	}
	beginPutAsyncNoRetrycanceled := l.beginPutAsyncNoRetrycanceled.get(req)
	if beginPutAsyncNoRetrycanceled == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNoRetrycanceled(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncNoRetrycanceled = &respr
		l.beginPutAsyncNoRetrycanceled.add(req, beginPutAsyncNoRetrycanceled)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncNoRetrycanceled, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncNoRetrycanceled.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncNoRetrycanceled) {
		l.beginPutAsyncNoRetrycanceled.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNonResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNonResource == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncNonResource not implemented")}
	}
	beginPutAsyncNonResource := l.beginPutAsyncNonResource.get(req)
	if beginPutAsyncNonResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SKU](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNonResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncNonResource = &respr
		l.beginPutAsyncNonResource.add(req, beginPutAsyncNonResource)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncNonResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPutAsyncNonResource.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncNonResource) {
		l.beginPutAsyncNonResource.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncRetryFailed(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRetryFailed == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRetryFailed not implemented")}
	}
	beginPutAsyncRetryFailed := l.beginPutAsyncRetryFailed.get(req)
	if beginPutAsyncRetryFailed == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRetryFailed(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRetryFailed = &respr
		l.beginPutAsyncRetryFailed.add(req, beginPutAsyncRetryFailed)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRetryFailed, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRetryFailed.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRetryFailed) {
		l.beginPutAsyncRetryFailed.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRetrySucceeded not implemented")}
	}
	beginPutAsyncRetrySucceeded := l.beginPutAsyncRetrySucceeded.get(req)
	if beginPutAsyncRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRetrySucceeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRetrySucceeded = &respr
		l.beginPutAsyncRetrySucceeded.add(req, beginPutAsyncRetrySucceeded)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRetrySucceeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRetrySucceeded) {
		l.beginPutAsyncRetrySucceeded.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncSubResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncSubResource == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncSubResource not implemented")}
	}
	beginPutAsyncSubResource := l.beginPutAsyncSubResource.get(req)
	if beginPutAsyncSubResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SubProduct](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncSubResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncSubResource = &respr
		l.beginPutAsyncSubResource.add(req, beginPutAsyncSubResource)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncSubResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPutAsyncSubResource.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncSubResource) {
		l.beginPutAsyncSubResource.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNoHeaderInRetry not implemented")}
	}
	beginPutNoHeaderInRetry := l.beginPutNoHeaderInRetry.get(req)
	if beginPutNoHeaderInRetry == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNoHeaderInRetry(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutNoHeaderInRetry = &respr
		l.beginPutNoHeaderInRetry.add(req, beginPutNoHeaderInRetry)
	}

	resp, err := server.PollerResponderNext(beginPutNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPutNoHeaderInRetry.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutNoHeaderInRetry) {
		l.beginPutNoHeaderInRetry.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutNonResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonResource == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonResource not implemented")}
	}
	beginPutNonResource := l.beginPutNonResource.get(req)
	if beginPutNonResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SKU](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutNonResource = &respr
		l.beginPutNonResource.add(req, beginPutNonResource)
	}

	resp, err := server.PollerResponderNext(beginPutNonResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPutNonResource.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutNonResource) {
		l.beginPutNonResource.remove(req)
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutSubResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutSubResource == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutSubResource not implemented")}
	}
	beginPutSubResource := l.beginPutSubResource.get(req)
	if beginPutSubResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SubProduct](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutSubResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutSubResource = &respr
		l.beginPutSubResource.add(req, beginPutSubResource)
	}

	resp, err := server.PollerResponderNext(beginPutSubResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		l.beginPutSubResource.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutSubResource) {
		l.beginPutSubResource.remove(req)
	}

	return resp, nil
}
