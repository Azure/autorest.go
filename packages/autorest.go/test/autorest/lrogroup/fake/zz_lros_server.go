//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package fake

import (
	"context"
	"errors"
	"fmt"
	"generatortests/lrogroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// LROsServer is a fake server for instances of the lrogroup.LROsClient type.
type LROsServer struct {
	// BeginDelete202NoRetry204 is the fake for method LROsClient.BeginDelete202NoRetry204
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDelete202NoRetry204 func(ctx context.Context, options *lrogroup.LROsClientBeginDelete202NoRetry204Options) (resp azfake.PollerResponder[lrogroup.LROsClientDelete202NoRetry204Response], errResp azfake.ErrorResponder)

	// BeginDelete202Retry200 is the fake for method LROsClient.BeginDelete202Retry200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDelete202Retry200 func(ctx context.Context, options *lrogroup.LROsClientBeginDelete202Retry200Options) (resp azfake.PollerResponder[lrogroup.LROsClientDelete202Retry200Response], errResp azfake.ErrorResponder)

	// BeginDelete204Succeeded is the fake for method LROsClient.BeginDelete204Succeeded
	// HTTP status codes to indicate success: http.StatusNoContent
	BeginDelete204Succeeded func(ctx context.Context, options *lrogroup.LROsClientBeginDelete204SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDelete204SucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncNoHeaderInRetry is the fake for method LROsClient.BeginDeleteAsyncNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginDeleteAsyncNoHeaderInRetry func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncNoRetrySucceeded is the fake for method LROsClient.BeginDeleteAsyncNoRetrySucceeded
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncNoRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncNoRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRetryFailed is the fake for method LROsClient.BeginDeleteAsyncRetryFailed
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRetryFailed func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncRetryFailedOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetryFailedResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRetrySucceeded is the fake for method LROsClient.BeginDeleteAsyncRetrySucceeded
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRetrycanceled is the fake for method LROsClient.BeginDeleteAsyncRetrycanceled
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRetrycanceled func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteAsyncRetrycanceledOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrycanceledResponse], errResp azfake.ErrorResponder)

	// BeginDeleteNoHeaderInRetry is the fake for method LROsClient.BeginDeleteNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusAccepted, http.StatusNoContent
	BeginDeleteNoHeaderInRetry func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginDeleteProvisioning202Accepted200Succeeded is the fake for method LROsClient.BeginDeleteProvisioning202Accepted200Succeeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDeleteProvisioning202Accepted200Succeeded func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteProvisioning202Accepted200SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Accepted200SucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteProvisioning202DeletingFailed200 is the fake for method LROsClient.BeginDeleteProvisioning202DeletingFailed200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDeleteProvisioning202DeletingFailed200 func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteProvisioning202DeletingFailed200Options) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202DeletingFailed200Response], errResp azfake.ErrorResponder)

	// BeginDeleteProvisioning202Deletingcanceled200 is the fake for method LROsClient.BeginDeleteProvisioning202Deletingcanceled200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginDeleteProvisioning202Deletingcanceled200 func(ctx context.Context, options *lrogroup.LROsClientBeginDeleteProvisioning202Deletingcanceled200Options) (resp azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Deletingcanceled200Response], errResp azfake.ErrorResponder)

	// BeginPatch200SucceededIgnoreHeaders is the fake for method LROsClient.BeginPatch200SucceededIgnoreHeaders
	// HTTP status codes to indicate success: http.StatusOK
	BeginPatch200SucceededIgnoreHeaders func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPatch200SucceededIgnoreHeadersOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPatch200SucceededIgnoreHeadersResponse], errResp azfake.ErrorResponder)

	// BeginPatch201RetryWithAsyncHeader is the fake for method LROsClient.BeginPatch201RetryWithAsyncHeader
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPatch201RetryWithAsyncHeader func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPatch201RetryWithAsyncHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPatch201RetryWithAsyncHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPatch202RetryWithAsyncAndLocationHeader is the fake for method LROsClient.BeginPatch202RetryWithAsyncAndLocationHeader
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPatch202RetryWithAsyncAndLocationHeader func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPatch202RetryWithAsyncAndLocationHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPost200WithPayload is the fake for method LROsClient.BeginPost200WithPayload
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPost200WithPayload func(ctx context.Context, options *lrogroup.LROsClientBeginPost200WithPayloadOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPost200WithPayloadResponse], errResp azfake.ErrorResponder)

	// BeginPost202List is the fake for method LROsClient.BeginPost202List
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPost202List func(ctx context.Context, options *lrogroup.LROsClientBeginPost202ListOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPost202ListResponse], errResp azfake.ErrorResponder)

	// BeginPost202NoRetry204 is the fake for method LROsClient.BeginPost202NoRetry204
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202NoRetry204 func(ctx context.Context, options *lrogroup.LROsClientBeginPost202NoRetry204Options) (resp azfake.PollerResponder[lrogroup.LROsClientPost202NoRetry204Response], errResp azfake.ErrorResponder)

	// BeginPost202Retry200 is the fake for method LROsClient.BeginPost202Retry200
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202Retry200 func(ctx context.Context, options *lrogroup.LROsClientBeginPost202Retry200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPost202Retry200Response], errResp azfake.ErrorResponder)

	// BeginPostAsyncNoRetrySucceeded is the fake for method LROsClient.BeginPostAsyncNoRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostAsyncNoRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncNoRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncNoRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRetryFailed is the fake for method LROsClient.BeginPostAsyncRetryFailed
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRetryFailed func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncRetryFailedOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetryFailedResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRetrySucceeded is the fake for method LROsClient.BeginPostAsyncRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	BeginPostAsyncRetrySucceeded func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRetrycanceled is the fake for method LROsClient.BeginPostAsyncRetrycanceled
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRetrycanceled func(ctx context.Context, options *lrogroup.LROsClientBeginPostAsyncRetrycanceledOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrycanceledResponse], errResp azfake.ErrorResponder)

	// BeginPostDoubleHeadersFinalAzureHeaderGet is the fake for method LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostDoubleHeadersFinalAzureHeaderGet func(ctx context.Context, options *lrogroup.LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse], errResp azfake.ErrorResponder)

	// BeginPostDoubleHeadersFinalAzureHeaderGetDefault is the fake for method LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostDoubleHeadersFinalAzureHeaderGetDefault func(ctx context.Context, options *lrogroup.LROsClientBeginPostDoubleHeadersFinalAzureHeaderGetDefaultOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse], errResp azfake.ErrorResponder)

	// BeginPostDoubleHeadersFinalLocationGet is the fake for method LROsClient.BeginPostDoubleHeadersFinalLocationGet
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostDoubleHeadersFinalLocationGet func(ctx context.Context, options *lrogroup.LROsClientBeginPostDoubleHeadersFinalLocationGetOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalLocationGetResponse], errResp azfake.ErrorResponder)

	// BeginPut200Acceptedcanceled200 is the fake for method LROsClient.BeginPut200Acceptedcanceled200
	// HTTP status codes to indicate success: http.StatusOK
	BeginPut200Acceptedcanceled200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200Acceptedcanceled200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut200Acceptedcanceled200Response], errResp azfake.ErrorResponder)

	// BeginPut200Succeeded is the fake for method LROsClient.BeginPut200Succeeded
	// HTTP status codes to indicate success: http.StatusOK, http.StatusNoContent
	BeginPut200Succeeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPut200SucceededResponse], errResp azfake.ErrorResponder)

	// BeginPut200SucceededNoState is the fake for method LROsClient.BeginPut200SucceededNoState
	// HTTP status codes to indicate success: http.StatusOK
	BeginPut200SucceededNoState func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200SucceededNoStateOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPut200SucceededNoStateResponse], errResp azfake.ErrorResponder)

	// BeginPut200UpdatingSucceeded204 is the fake for method LROsClient.BeginPut200UpdatingSucceeded204
	// HTTP status codes to indicate success: http.StatusOK
	BeginPut200UpdatingSucceeded204 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut200UpdatingSucceeded204Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut200UpdatingSucceeded204Response], errResp azfake.ErrorResponder)

	// BeginPut201CreatingFailed200 is the fake for method LROsClient.BeginPut201CreatingFailed200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPut201CreatingFailed200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut201CreatingFailed200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut201CreatingFailed200Response], errResp azfake.ErrorResponder)

	// BeginPut201CreatingSucceeded200 is the fake for method LROsClient.BeginPut201CreatingSucceeded200
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPut201CreatingSucceeded200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut201CreatingSucceeded200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut201CreatingSucceeded200Response], errResp azfake.ErrorResponder)

	// BeginPut201Succeeded is the fake for method LROsClient.BeginPut201Succeeded
	// HTTP status codes to indicate success: http.StatusCreated
	BeginPut201Succeeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut201SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPut201SucceededResponse], errResp azfake.ErrorResponder)

	// BeginPut202Retry200 is the fake for method LROsClient.BeginPut202Retry200
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPut202Retry200 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPut202Retry200Options) (resp azfake.PollerResponder[lrogroup.LROsClientPut202Retry200Response], errResp azfake.ErrorResponder)

	// BeginPutAsyncNoHeaderInRetry is the fake for method LROsClient.BeginPutAsyncNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusCreated
	BeginPutAsyncNoHeaderInRetry func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncNoRetrySucceeded is the fake for method LROsClient.BeginPutAsyncNoRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncNoRetrySucceeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncNoRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncNoRetrycanceled is the fake for method LROsClient.BeginPutAsyncNoRetrycanceled
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncNoRetrycanceled func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncNoRetrycanceledOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrycanceledResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncNonResource is the fake for method LROsClient.BeginPutAsyncNonResource
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPutAsyncNonResource func(ctx context.Context, sku lrogroup.SKU, options *lrogroup.LROsClientBeginPutAsyncNonResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncNonResourceResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRetryFailed is the fake for method LROsClient.BeginPutAsyncRetryFailed
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRetryFailed func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncRetryFailedOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetryFailedResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRetrySucceeded is the fake for method LROsClient.BeginPutAsyncRetrySucceeded
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRetrySucceeded func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutAsyncRetrySucceededOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetrySucceededResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncSubResource is the fake for method LROsClient.BeginPutAsyncSubResource
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPutAsyncSubResource func(ctx context.Context, product lrogroup.SubProduct, options *lrogroup.LROsClientBeginPutAsyncSubResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutAsyncSubResourceResponse], errResp azfake.ErrorResponder)

	// BeginPutNoHeaderInRetry is the fake for method LROsClient.BeginPutNoHeaderInRetry
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPutNoHeaderInRetry func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROsClientBeginPutNoHeaderInRetryOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutNoHeaderInRetryResponse], errResp azfake.ErrorResponder)

	// BeginPutNonResource is the fake for method LROsClient.BeginPutNonResource
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPutNonResource func(ctx context.Context, sku lrogroup.SKU, options *lrogroup.LROsClientBeginPutNonResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutNonResourceResponse], errResp azfake.ErrorResponder)

	// BeginPutSubResource is the fake for method LROsClient.BeginPutSubResource
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPutSubResource func(ctx context.Context, product lrogroup.SubProduct, options *lrogroup.LROsClientBeginPutSubResourceOptions) (resp azfake.PollerResponder[lrogroup.LROsClientPutSubResourceResponse], errResp azfake.ErrorResponder)
}

// NewLROsServerTransport creates a new instance of LROsServerTransport with the provided implementation.
// The returned LROsServerTransport instance is connected to an instance of lrogroup.LROsClient by way of the
// undefined.Transporter field.
func NewLROsServerTransport(srv *LROsServer) *LROsServerTransport {
	return &LROsServerTransport{srv: srv}
}

// LROsServerTransport connects instances of lrogroup.LROsClient to instances of LROsServer.
// Don't use this type directly, use NewLROsServerTransport instead.
type LROsServerTransport struct {
	srv                                              *LROsServer
	beginDelete202NoRetry204                         *azfake.PollerResponder[lrogroup.LROsClientDelete202NoRetry204Response]
	beginDelete202Retry200                           *azfake.PollerResponder[lrogroup.LROsClientDelete202Retry200Response]
	beginDelete204Succeeded                          *azfake.PollerResponder[lrogroup.LROsClientDelete204SucceededResponse]
	beginDeleteAsyncNoHeaderInRetry                  *azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoHeaderInRetryResponse]
	beginDeleteAsyncNoRetrySucceeded                 *azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncNoRetrySucceededResponse]
	beginDeleteAsyncRetryFailed                      *azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetryFailedResponse]
	beginDeleteAsyncRetrySucceeded                   *azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrySucceededResponse]
	beginDeleteAsyncRetrycanceled                    *azfake.PollerResponder[lrogroup.LROsClientDeleteAsyncRetrycanceledResponse]
	beginDeleteNoHeaderInRetry                       *azfake.PollerResponder[lrogroup.LROsClientDeleteNoHeaderInRetryResponse]
	beginDeleteProvisioning202Accepted200Succeeded   *azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Accepted200SucceededResponse]
	beginDeleteProvisioning202DeletingFailed200      *azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202DeletingFailed200Response]
	beginDeleteProvisioning202Deletingcanceled200    *azfake.PollerResponder[lrogroup.LROsClientDeleteProvisioning202Deletingcanceled200Response]
	beginPatch200SucceededIgnoreHeaders              *azfake.PollerResponder[lrogroup.LROsClientPatch200SucceededIgnoreHeadersResponse]
	beginPatch201RetryWithAsyncHeader                *azfake.PollerResponder[lrogroup.LROsClientPatch201RetryWithAsyncHeaderResponse]
	beginPatch202RetryWithAsyncAndLocationHeader     *azfake.PollerResponder[lrogroup.LROsClientPatch202RetryWithAsyncAndLocationHeaderResponse]
	beginPost200WithPayload                          *azfake.PollerResponder[lrogroup.LROsClientPost200WithPayloadResponse]
	beginPost202List                                 *azfake.PollerResponder[lrogroup.LROsClientPost202ListResponse]
	beginPost202NoRetry204                           *azfake.PollerResponder[lrogroup.LROsClientPost202NoRetry204Response]
	beginPost202Retry200                             *azfake.PollerResponder[lrogroup.LROsClientPost202Retry200Response]
	beginPostAsyncNoRetrySucceeded                   *azfake.PollerResponder[lrogroup.LROsClientPostAsyncNoRetrySucceededResponse]
	beginPostAsyncRetryFailed                        *azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetryFailedResponse]
	beginPostAsyncRetrySucceeded                     *azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrySucceededResponse]
	beginPostAsyncRetrycanceled                      *azfake.PollerResponder[lrogroup.LROsClientPostAsyncRetrycanceledResponse]
	beginPostDoubleHeadersFinalAzureHeaderGet        *azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetResponse]
	beginPostDoubleHeadersFinalAzureHeaderGetDefault *azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalAzureHeaderGetDefaultResponse]
	beginPostDoubleHeadersFinalLocationGet           *azfake.PollerResponder[lrogroup.LROsClientPostDoubleHeadersFinalLocationGetResponse]
	beginPut200Acceptedcanceled200                   *azfake.PollerResponder[lrogroup.LROsClientPut200Acceptedcanceled200Response]
	beginPut200Succeeded                             *azfake.PollerResponder[lrogroup.LROsClientPut200SucceededResponse]
	beginPut200SucceededNoState                      *azfake.PollerResponder[lrogroup.LROsClientPut200SucceededNoStateResponse]
	beginPut200UpdatingSucceeded204                  *azfake.PollerResponder[lrogroup.LROsClientPut200UpdatingSucceeded204Response]
	beginPut201CreatingFailed200                     *azfake.PollerResponder[lrogroup.LROsClientPut201CreatingFailed200Response]
	beginPut201CreatingSucceeded200                  *azfake.PollerResponder[lrogroup.LROsClientPut201CreatingSucceeded200Response]
	beginPut201Succeeded                             *azfake.PollerResponder[lrogroup.LROsClientPut201SucceededResponse]
	beginPut202Retry200                              *azfake.PollerResponder[lrogroup.LROsClientPut202Retry200Response]
	beginPutAsyncNoHeaderInRetry                     *azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoHeaderInRetryResponse]
	beginPutAsyncNoRetrySucceeded                    *azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrySucceededResponse]
	beginPutAsyncNoRetrycanceled                     *azfake.PollerResponder[lrogroup.LROsClientPutAsyncNoRetrycanceledResponse]
	beginPutAsyncNonResource                         *azfake.PollerResponder[lrogroup.LROsClientPutAsyncNonResourceResponse]
	beginPutAsyncRetryFailed                         *azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetryFailedResponse]
	beginPutAsyncRetrySucceeded                      *azfake.PollerResponder[lrogroup.LROsClientPutAsyncRetrySucceededResponse]
	beginPutAsyncSubResource                         *azfake.PollerResponder[lrogroup.LROsClientPutAsyncSubResourceResponse]
	beginPutNoHeaderInRetry                          *azfake.PollerResponder[lrogroup.LROsClientPutNoHeaderInRetryResponse]
	beginPutNonResource                              *azfake.PollerResponder[lrogroup.LROsClientPutNonResourceResponse]
	beginPutSubResource                              *azfake.PollerResponder[lrogroup.LROsClientPutSubResourceResponse]
}

// Do implements the policy.Transporter interface for LROsServerTransport.
func (l *LROsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "LROsClient.BeginDelete202NoRetry204":
		resp, err = l.dispatchBeginDelete202NoRetry204(req)
	case "LROsClient.BeginDelete202Retry200":
		resp, err = l.dispatchBeginDelete202Retry200(req)
	case "LROsClient.BeginDelete204Succeeded":
		resp, err = l.dispatchBeginDelete204Succeeded(req)
	case "LROsClient.BeginDeleteAsyncNoHeaderInRetry":
		resp, err = l.dispatchBeginDeleteAsyncNoHeaderInRetry(req)
	case "LROsClient.BeginDeleteAsyncNoRetrySucceeded":
		resp, err = l.dispatchBeginDeleteAsyncNoRetrySucceeded(req)
	case "LROsClient.BeginDeleteAsyncRetryFailed":
		resp, err = l.dispatchBeginDeleteAsyncRetryFailed(req)
	case "LROsClient.BeginDeleteAsyncRetrySucceeded":
		resp, err = l.dispatchBeginDeleteAsyncRetrySucceeded(req)
	case "LROsClient.BeginDeleteAsyncRetrycanceled":
		resp, err = l.dispatchBeginDeleteAsyncRetrycanceled(req)
	case "LROsClient.BeginDeleteNoHeaderInRetry":
		resp, err = l.dispatchBeginDeleteNoHeaderInRetry(req)
	case "LROsClient.BeginDeleteProvisioning202Accepted200Succeeded":
		resp, err = l.dispatchBeginDeleteProvisioning202Accepted200Succeeded(req)
	case "LROsClient.BeginDeleteProvisioning202DeletingFailed200":
		resp, err = l.dispatchBeginDeleteProvisioning202DeletingFailed200(req)
	case "LROsClient.BeginDeleteProvisioning202Deletingcanceled200":
		resp, err = l.dispatchBeginDeleteProvisioning202Deletingcanceled200(req)
	case "LROsClient.BeginPatch200SucceededIgnoreHeaders":
		resp, err = l.dispatchBeginPatch200SucceededIgnoreHeaders(req)
	case "LROsClient.BeginPatch201RetryWithAsyncHeader":
		resp, err = l.dispatchBeginPatch201RetryWithAsyncHeader(req)
	case "LROsClient.BeginPatch202RetryWithAsyncAndLocationHeader":
		resp, err = l.dispatchBeginPatch202RetryWithAsyncAndLocationHeader(req)
	case "LROsClient.BeginPost200WithPayload":
		resp, err = l.dispatchBeginPost200WithPayload(req)
	case "LROsClient.BeginPost202List":
		resp, err = l.dispatchBeginPost202List(req)
	case "LROsClient.BeginPost202NoRetry204":
		resp, err = l.dispatchBeginPost202NoRetry204(req)
	case "LROsClient.BeginPost202Retry200":
		resp, err = l.dispatchBeginPost202Retry200(req)
	case "LROsClient.BeginPostAsyncNoRetrySucceeded":
		resp, err = l.dispatchBeginPostAsyncNoRetrySucceeded(req)
	case "LROsClient.BeginPostAsyncRetryFailed":
		resp, err = l.dispatchBeginPostAsyncRetryFailed(req)
	case "LROsClient.BeginPostAsyncRetrySucceeded":
		resp, err = l.dispatchBeginPostAsyncRetrySucceeded(req)
	case "LROsClient.BeginPostAsyncRetrycanceled":
		resp, err = l.dispatchBeginPostAsyncRetrycanceled(req)
	case "LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGet":
		resp, err = l.dispatchBeginPostDoubleHeadersFinalAzureHeaderGet(req)
	case "LROsClient.BeginPostDoubleHeadersFinalAzureHeaderGetDefault":
		resp, err = l.dispatchBeginPostDoubleHeadersFinalAzureHeaderGetDefault(req)
	case "LROsClient.BeginPostDoubleHeadersFinalLocationGet":
		resp, err = l.dispatchBeginPostDoubleHeadersFinalLocationGet(req)
	case "LROsClient.BeginPut200Acceptedcanceled200":
		resp, err = l.dispatchBeginPut200Acceptedcanceled200(req)
	case "LROsClient.BeginPut200Succeeded":
		resp, err = l.dispatchBeginPut200Succeeded(req)
	case "LROsClient.BeginPut200SucceededNoState":
		resp, err = l.dispatchBeginPut200SucceededNoState(req)
	case "LROsClient.BeginPut200UpdatingSucceeded204":
		resp, err = l.dispatchBeginPut200UpdatingSucceeded204(req)
	case "LROsClient.BeginPut201CreatingFailed200":
		resp, err = l.dispatchBeginPut201CreatingFailed200(req)
	case "LROsClient.BeginPut201CreatingSucceeded200":
		resp, err = l.dispatchBeginPut201CreatingSucceeded200(req)
	case "LROsClient.BeginPut201Succeeded":
		resp, err = l.dispatchBeginPut201Succeeded(req)
	case "LROsClient.BeginPut202Retry200":
		resp, err = l.dispatchBeginPut202Retry200(req)
	case "LROsClient.BeginPutAsyncNoHeaderInRetry":
		resp, err = l.dispatchBeginPutAsyncNoHeaderInRetry(req)
	case "LROsClient.BeginPutAsyncNoRetrySucceeded":
		resp, err = l.dispatchBeginPutAsyncNoRetrySucceeded(req)
	case "LROsClient.BeginPutAsyncNoRetrycanceled":
		resp, err = l.dispatchBeginPutAsyncNoRetrycanceled(req)
	case "LROsClient.BeginPutAsyncNonResource":
		resp, err = l.dispatchBeginPutAsyncNonResource(req)
	case "LROsClient.BeginPutAsyncRetryFailed":
		resp, err = l.dispatchBeginPutAsyncRetryFailed(req)
	case "LROsClient.BeginPutAsyncRetrySucceeded":
		resp, err = l.dispatchBeginPutAsyncRetrySucceeded(req)
	case "LROsClient.BeginPutAsyncSubResource":
		resp, err = l.dispatchBeginPutAsyncSubResource(req)
	case "LROsClient.BeginPutNoHeaderInRetry":
		resp, err = l.dispatchBeginPutNoHeaderInRetry(req)
	case "LROsClient.BeginPutNonResource":
		resp, err = l.dispatchBeginPutNonResource(req)
	case "LROsClient.BeginPutSubResource":
		resp, err = l.dispatchBeginPutSubResource(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDelete202NoRetry204(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202NoRetry204 == nil {
		return nil, &nonRetriableError{errors.New("method BeginDelete202NoRetry204 not implemented")}
	}
	if l.beginDelete202NoRetry204 == nil {
		respr, errRespr := l.srv.BeginDelete202NoRetry204(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDelete202NoRetry204 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDelete202NoRetry204, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDelete202NoRetry204) {
		l.beginDelete202NoRetry204 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDelete202Retry200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202Retry200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginDelete202Retry200 not implemented")}
	}
	if l.beginDelete202Retry200 == nil {
		respr, errRespr := l.srv.BeginDelete202Retry200(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDelete202Retry200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDelete202Retry200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDelete202Retry200) {
		l.beginDelete202Retry200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDelete204Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete204Succeeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginDelete204Succeeded not implemented")}
	}
	if l.beginDelete204Succeeded == nil {
		respr, errRespr := l.srv.BeginDelete204Succeeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDelete204Succeeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDelete204Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDelete204Succeeded) {
		l.beginDelete204Succeeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteAsyncNoHeaderInRetry not implemented")}
	}
	if l.beginDeleteAsyncNoHeaderInRetry == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncNoHeaderInRetry(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncNoHeaderInRetry = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncNoHeaderInRetry) {
		l.beginDeleteAsyncNoHeaderInRetry = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncNoRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncNoRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteAsyncNoRetrySucceeded not implemented")}
	}
	if l.beginDeleteAsyncNoRetrySucceeded == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncNoRetrySucceeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncNoRetrySucceeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncNoRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncNoRetrySucceeded) {
		l.beginDeleteAsyncNoRetrySucceeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncRetryFailed(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRetryFailed == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteAsyncRetryFailed not implemented")}
	}
	if l.beginDeleteAsyncRetryFailed == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRetryFailed(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRetryFailed = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRetryFailed, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRetryFailed) {
		l.beginDeleteAsyncRetryFailed = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteAsyncRetrySucceeded not implemented")}
	}
	if l.beginDeleteAsyncRetrySucceeded == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRetrySucceeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRetrySucceeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRetrySucceeded) {
		l.beginDeleteAsyncRetrySucceeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteAsyncRetrycanceled(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRetrycanceled == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteAsyncRetrycanceled not implemented")}
	}
	if l.beginDeleteAsyncRetrycanceled == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRetrycanceled(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRetrycanceled = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRetrycanceled, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRetrycanceled) {
		l.beginDeleteAsyncRetrycanceled = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteNoHeaderInRetry not implemented")}
	}
	if l.beginDeleteNoHeaderInRetry == nil {
		respr, errRespr := l.srv.BeginDeleteNoHeaderInRetry(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteNoHeaderInRetry = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteNoHeaderInRetry) {
		l.beginDeleteNoHeaderInRetry = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteProvisioning202Accepted200Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteProvisioning202Accepted200Succeeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteProvisioning202Accepted200Succeeded not implemented")}
	}
	if l.beginDeleteProvisioning202Accepted200Succeeded == nil {
		respr, errRespr := l.srv.BeginDeleteProvisioning202Accepted200Succeeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteProvisioning202Accepted200Succeeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteProvisioning202Accepted200Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteProvisioning202Accepted200Succeeded) {
		l.beginDeleteProvisioning202Accepted200Succeeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteProvisioning202DeletingFailed200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteProvisioning202DeletingFailed200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteProvisioning202DeletingFailed200 not implemented")}
	}
	if l.beginDeleteProvisioning202DeletingFailed200 == nil {
		respr, errRespr := l.srv.BeginDeleteProvisioning202DeletingFailed200(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteProvisioning202DeletingFailed200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteProvisioning202DeletingFailed200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteProvisioning202DeletingFailed200) {
		l.beginDeleteProvisioning202DeletingFailed200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginDeleteProvisioning202Deletingcanceled200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteProvisioning202Deletingcanceled200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginDeleteProvisioning202Deletingcanceled200 not implemented")}
	}
	if l.beginDeleteProvisioning202Deletingcanceled200 == nil {
		respr, errRespr := l.srv.BeginDeleteProvisioning202Deletingcanceled200(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteProvisioning202Deletingcanceled200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteProvisioning202Deletingcanceled200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteProvisioning202Deletingcanceled200) {
		l.beginDeleteProvisioning202Deletingcanceled200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPatch200SucceededIgnoreHeaders(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPatch200SucceededIgnoreHeaders == nil {
		return nil, &nonRetriableError{errors.New("method BeginPatch200SucceededIgnoreHeaders not implemented")}
	}
	if l.beginPatch200SucceededIgnoreHeaders == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPatch200SucceededIgnoreHeaders(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPatch200SucceededIgnoreHeaders = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPatch200SucceededIgnoreHeaders, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPatch200SucceededIgnoreHeaders) {
		l.beginPatch200SucceededIgnoreHeaders = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPatch201RetryWithAsyncHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPatch201RetryWithAsyncHeader == nil {
		return nil, &nonRetriableError{errors.New("method BeginPatch201RetryWithAsyncHeader not implemented")}
	}
	if l.beginPatch201RetryWithAsyncHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPatch201RetryWithAsyncHeader(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPatch201RetryWithAsyncHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPatch201RetryWithAsyncHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPatch201RetryWithAsyncHeader) {
		l.beginPatch201RetryWithAsyncHeader = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPatch202RetryWithAsyncAndLocationHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPatch202RetryWithAsyncAndLocationHeader == nil {
		return nil, &nonRetriableError{errors.New("method BeginPatch202RetryWithAsyncAndLocationHeader not implemented")}
	}
	if l.beginPatch202RetryWithAsyncAndLocationHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPatch202RetryWithAsyncAndLocationHeader(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPatch202RetryWithAsyncAndLocationHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPatch202RetryWithAsyncAndLocationHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPatch202RetryWithAsyncAndLocationHeader) {
		l.beginPatch202RetryWithAsyncAndLocationHeader = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost200WithPayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost200WithPayload == nil {
		return nil, &nonRetriableError{errors.New("method BeginPost200WithPayload not implemented")}
	}
	if l.beginPost200WithPayload == nil {
		respr, errRespr := l.srv.BeginPost200WithPayload(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost200WithPayload = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost200WithPayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost200WithPayload) {
		l.beginPost200WithPayload = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost202List(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202List == nil {
		return nil, &nonRetriableError{errors.New("method BeginPost202List not implemented")}
	}
	if l.beginPost202List == nil {
		respr, errRespr := l.srv.BeginPost202List(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost202List = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost202List, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost202List) {
		l.beginPost202List = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost202NoRetry204(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202NoRetry204 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPost202NoRetry204 not implemented")}
	}
	if l.beginPost202NoRetry204 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPost202NoRetry204Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPost202NoRetry204Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202NoRetry204(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost202NoRetry204 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost202NoRetry204, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost202NoRetry204) {
		l.beginPost202NoRetry204 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPost202Retry200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202Retry200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPost202Retry200 not implemented")}
	}
	if l.beginPost202Retry200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPost202Retry200Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPost202Retry200Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202Retry200(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost202Retry200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost202Retry200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost202Retry200) {
		l.beginPost202Retry200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncNoRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncNoRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostAsyncNoRetrySucceeded not implemented")}
	}
	if l.beginPostAsyncNoRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncNoRetrySucceededOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncNoRetrySucceededOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncNoRetrySucceeded(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncNoRetrySucceeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncNoRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncNoRetrySucceeded) {
		l.beginPostAsyncNoRetrySucceeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncRetryFailed(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRetryFailed == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostAsyncRetryFailed not implemented")}
	}
	if l.beginPostAsyncRetryFailed == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncRetryFailedOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncRetryFailedOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRetryFailed(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRetryFailed = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRetryFailed, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRetryFailed) {
		l.beginPostAsyncRetryFailed = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostAsyncRetrySucceeded not implemented")}
	}
	if l.beginPostAsyncRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncRetrySucceededOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncRetrySucceededOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRetrySucceeded(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRetrySucceeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRetrySucceeded) {
		l.beginPostAsyncRetrySucceeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostAsyncRetrycanceled(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRetrycanceled == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostAsyncRetrycanceled not implemented")}
	}
	if l.beginPostAsyncRetrycanceled == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROsClientBeginPostAsyncRetrycanceledOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROsClientBeginPostAsyncRetrycanceledOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRetrycanceled(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRetrycanceled = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRetrycanceled, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRetrycanceled) {
		l.beginPostAsyncRetrycanceled = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostDoubleHeadersFinalAzureHeaderGet(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostDoubleHeadersFinalAzureHeaderGet == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostDoubleHeadersFinalAzureHeaderGet not implemented")}
	}
	if l.beginPostDoubleHeadersFinalAzureHeaderGet == nil {
		respr, errRespr := l.srv.BeginPostDoubleHeadersFinalAzureHeaderGet(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostDoubleHeadersFinalAzureHeaderGet = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostDoubleHeadersFinalAzureHeaderGet, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostDoubleHeadersFinalAzureHeaderGet) {
		l.beginPostDoubleHeadersFinalAzureHeaderGet = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostDoubleHeadersFinalAzureHeaderGetDefault(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostDoubleHeadersFinalAzureHeaderGetDefault == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostDoubleHeadersFinalAzureHeaderGetDefault not implemented")}
	}
	if l.beginPostDoubleHeadersFinalAzureHeaderGetDefault == nil {
		respr, errRespr := l.srv.BeginPostDoubleHeadersFinalAzureHeaderGetDefault(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostDoubleHeadersFinalAzureHeaderGetDefault = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostDoubleHeadersFinalAzureHeaderGetDefault, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostDoubleHeadersFinalAzureHeaderGetDefault) {
		l.beginPostDoubleHeadersFinalAzureHeaderGetDefault = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPostDoubleHeadersFinalLocationGet(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostDoubleHeadersFinalLocationGet == nil {
		return nil, &nonRetriableError{errors.New("method BeginPostDoubleHeadersFinalLocationGet not implemented")}
	}
	if l.beginPostDoubleHeadersFinalLocationGet == nil {
		respr, errRespr := l.srv.BeginPostDoubleHeadersFinalLocationGet(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostDoubleHeadersFinalLocationGet = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostDoubleHeadersFinalLocationGet, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostDoubleHeadersFinalLocationGet) {
		l.beginPostDoubleHeadersFinalLocationGet = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200Acceptedcanceled200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200Acceptedcanceled200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut200Acceptedcanceled200 not implemented")}
	}
	if l.beginPut200Acceptedcanceled200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200Acceptedcanceled200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut200Acceptedcanceled200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut200Acceptedcanceled200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut200Acceptedcanceled200) {
		l.beginPut200Acceptedcanceled200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200Succeeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut200Succeeded not implemented")}
	}
	if l.beginPut200Succeeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200Succeeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut200Succeeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut200Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut200Succeeded) {
		l.beginPut200Succeeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200SucceededNoState(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200SucceededNoState == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut200SucceededNoState not implemented")}
	}
	if l.beginPut200SucceededNoState == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200SucceededNoState(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut200SucceededNoState = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut200SucceededNoState, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut200SucceededNoState) {
		l.beginPut200SucceededNoState = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut200UpdatingSucceeded204(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200UpdatingSucceeded204 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut200UpdatingSucceeded204 not implemented")}
	}
	if l.beginPut200UpdatingSucceeded204 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200UpdatingSucceeded204(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut200UpdatingSucceeded204 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut200UpdatingSucceeded204, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut200UpdatingSucceeded204) {
		l.beginPut200UpdatingSucceeded204 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut201CreatingFailed200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut201CreatingFailed200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut201CreatingFailed200 not implemented")}
	}
	if l.beginPut201CreatingFailed200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut201CreatingFailed200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut201CreatingFailed200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut201CreatingFailed200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut201CreatingFailed200) {
		l.beginPut201CreatingFailed200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut201CreatingSucceeded200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut201CreatingSucceeded200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut201CreatingSucceeded200 not implemented")}
	}
	if l.beginPut201CreatingSucceeded200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut201CreatingSucceeded200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut201CreatingSucceeded200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut201CreatingSucceeded200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut201CreatingSucceeded200) {
		l.beginPut201CreatingSucceeded200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut201Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut201Succeeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut201Succeeded not implemented")}
	}
	if l.beginPut201Succeeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut201Succeeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut201Succeeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut201Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut201Succeeded) {
		l.beginPut201Succeeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPut202Retry200(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut202Retry200 == nil {
		return nil, &nonRetriableError{errors.New("method BeginPut202Retry200 not implemented")}
	}
	if l.beginPut202Retry200 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut202Retry200(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut202Retry200 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut202Retry200, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut202Retry200) {
		l.beginPut202Retry200 = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncNoHeaderInRetry not implemented")}
	}
	if l.beginPutAsyncNoHeaderInRetry == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNoHeaderInRetry(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncNoHeaderInRetry = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncNoHeaderInRetry) {
		l.beginPutAsyncNoHeaderInRetry = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNoRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNoRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncNoRetrySucceeded not implemented")}
	}
	if l.beginPutAsyncNoRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNoRetrySucceeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncNoRetrySucceeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncNoRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncNoRetrySucceeded) {
		l.beginPutAsyncNoRetrySucceeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNoRetrycanceled(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNoRetrycanceled == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncNoRetrycanceled not implemented")}
	}
	if l.beginPutAsyncNoRetrycanceled == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNoRetrycanceled(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncNoRetrycanceled = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncNoRetrycanceled, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncNoRetrycanceled) {
		l.beginPutAsyncNoRetrycanceled = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncNonResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncNonResource == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncNonResource not implemented")}
	}
	if l.beginPutAsyncNonResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SKU](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncNonResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncNonResource = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncNonResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncNonResource) {
		l.beginPutAsyncNonResource = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncRetryFailed(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRetryFailed == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncRetryFailed not implemented")}
	}
	if l.beginPutAsyncRetryFailed == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRetryFailed(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRetryFailed = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRetryFailed, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRetryFailed) {
		l.beginPutAsyncRetryFailed = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncRetrySucceeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRetrySucceeded == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncRetrySucceeded not implemented")}
	}
	if l.beginPutAsyncRetrySucceeded == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRetrySucceeded(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRetrySucceeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRetrySucceeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRetrySucceeded) {
		l.beginPutAsyncRetrySucceeded = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutAsyncSubResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncSubResource == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutAsyncSubResource not implemented")}
	}
	if l.beginPutAsyncSubResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SubProduct](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncSubResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncSubResource = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncSubResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncSubResource) {
		l.beginPutAsyncSubResource = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutNoHeaderInRetry(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNoHeaderInRetry == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutNoHeaderInRetry not implemented")}
	}
	if l.beginPutNoHeaderInRetry == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNoHeaderInRetry(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutNoHeaderInRetry = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutNoHeaderInRetry, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutNoHeaderInRetry) {
		l.beginPutNoHeaderInRetry = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutNonResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonResource == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutNonResource not implemented")}
	}
	if l.beginPutNonResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SKU](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutNonResource = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutNonResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutNonResource) {
		l.beginPutNonResource = nil
	}

	return resp, nil
}

func (l *LROsServerTransport) dispatchBeginPutSubResource(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutSubResource == nil {
		return nil, &nonRetriableError{errors.New("method BeginPutSubResource not implemented")}
	}
	if l.beginPutSubResource == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.SubProduct](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutSubResource(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutSubResource = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutSubResource, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutSubResource) {
		l.beginPutSubResource = nil
	}

	return resp, nil
}
