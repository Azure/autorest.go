//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"errors"
	"fmt"
	"generatortests/lrogroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// LROSADsServer is a fake server for instances of the lrogroup.LROSADsClient type.
type LROSADsServer struct {
	// BeginDelete202NonRetry400 is the fake for method LROSADsClient.BeginDelete202NonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDelete202NonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginDelete202NonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientDelete202NonRetry400Response], errResp azfake.ErrorResponder)

	// BeginDelete202RetryInvalidHeader is the fake for method LROSADsClient.BeginDelete202RetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDelete202RetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDelete202RetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginDelete204Succeeded is the fake for method LROSADsClient.BeginDelete204Succeeded
	// HTTP status codes to indicate success: http.StatusNoContent
	BeginDelete204Succeeded func(ctx context.Context, options *lrogroup.LROSADsClientBeginDelete204SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDelete204SucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetry400 is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetry400Response], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetryInvalidHeader is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetryInvalidJSONPolling is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidJSONPolling
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetryInvalidJSONPolling func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetryNoStatus is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetryNoStatus
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetryNoStatus func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse], errResp azfake.ErrorResponder)

	// BeginDeleteNonRetry400 is the fake for method LROSADsClient.BeginDeleteNonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteNonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteNonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteNonRetry400Response], errResp azfake.ErrorResponder)

	// BeginPost202NoLocation is the fake for method LROSADsClient.BeginPost202NoLocation
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202NoLocation func(ctx context.Context, options *lrogroup.LROSADsClientBeginPost202NoLocationOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPost202NoLocationResponse], errResp azfake.ErrorResponder)

	// BeginPost202NonRetry400 is the fake for method LROSADsClient.BeginPost202NonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202NonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginPost202NonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPost202NonRetry400Response], errResp azfake.ErrorResponder)

	// BeginPost202RetryInvalidHeader is the fake for method LROSADsClient.BeginPost202RetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202RetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginPost202RetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPost202RetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetry400 is the fake for method LROSADsClient.BeginPostAsyncRelativeRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetry400Response], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetryInvalidHeader is the fake for method LROSADsClient.BeginPostAsyncRelativeRetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetryInvalidJSONPolling is the fake for method LROSADsClient.BeginPostAsyncRelativeRetryInvalidJSONPolling
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetryInvalidJSONPolling func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetryNoPayload is the fake for method LROSADsClient.BeginPostAsyncRelativeRetryNoPayload
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetryNoPayload func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryNoPayloadResponse], errResp azfake.ErrorResponder)

	// BeginPostNonRetry400 is the fake for method LROSADsClient.BeginPostNonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostNonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostNonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostNonRetry400Response], errResp azfake.ErrorResponder)

	// BeginPut200InvalidJSON is the fake for method LROSADsClient.BeginPut200InvalidJSON
	// HTTP status codes to indicate success: http.StatusOK, http.StatusNoContent
	BeginPut200InvalidJSON func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPut200InvalidJSONOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPut200InvalidJSONResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetry400 is the fake for method LROSADsClient.BeginPutAsyncRelativeRetry400
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetry400 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetry400Response], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryInvalidHeader is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryInvalidHeader func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryInvalidJSONPolling is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryInvalidJSONPolling
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryInvalidJSONPolling func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryNoStatus is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryNoStatus
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryNoStatus func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryNoStatusPayload is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryNoStatusPayload
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryNoStatusPayload func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse], errResp azfake.ErrorResponder)

	// BeginPutError201NoProvisioningStatePayload is the fake for method LROSADsClient.BeginPutError201NoProvisioningStatePayload
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutError201NoProvisioningStatePayload func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutError201NoProvisioningStatePayloadResponse], errResp azfake.ErrorResponder)

	// BeginPutNonRetry201Creating400 is the fake for method LROSADsClient.BeginPutNonRetry201Creating400
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutNonRetry201Creating400 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutNonRetry201Creating400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400Response], errResp azfake.ErrorResponder)

	// BeginPutNonRetry201Creating400InvalidJSON is the fake for method LROSADsClient.BeginPutNonRetry201Creating400InvalidJSON
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutNonRetry201Creating400InvalidJSON func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400InvalidJSONResponse], errResp azfake.ErrorResponder)

	// BeginPutNonRetry400 is the fake for method LROSADsClient.BeginPutNonRetry400
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutNonRetry400 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutNonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry400Response], errResp azfake.ErrorResponder)
}

// NewLROSADsServerTransport creates a new instance of LROSADsServerTransport with the provided implementation.
// The returned LROSADsServerTransport instance is connected to an instance of lrogroup.LROSADsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewLROSADsServerTransport(srv *LROSADsServer) *LROSADsServerTransport {
	return &LROSADsServerTransport{srv: srv}
}

// LROSADsServerTransport connects instances of lrogroup.LROSADsClient to instances of LROSADsServer.
// Don't use this type directly, use NewLROSADsServerTransport instead.
type LROSADsServerTransport struct {
	srv                                             *LROSADsServer
	beginDelete202NonRetry400                       *azfake.PollerResponder[lrogroup.LROSADsClientDelete202NonRetry400Response]
	beginDelete202RetryInvalidHeader                *azfake.PollerResponder[lrogroup.LROSADsClientDelete202RetryInvalidHeaderResponse]
	beginDelete204Succeeded                         *azfake.PollerResponder[lrogroup.LROSADsClientDelete204SucceededResponse]
	beginDeleteAsyncRelativeRetry400                *azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetry400Response]
	beginDeleteAsyncRelativeRetryInvalidHeader      *azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse]
	beginDeleteAsyncRelativeRetryInvalidJSONPolling *azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse]
	beginDeleteAsyncRelativeRetryNoStatus           *azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse]
	beginDeleteNonRetry400                          *azfake.PollerResponder[lrogroup.LROSADsClientDeleteNonRetry400Response]
	beginPost202NoLocation                          *azfake.PollerResponder[lrogroup.LROSADsClientPost202NoLocationResponse]
	beginPost202NonRetry400                         *azfake.PollerResponder[lrogroup.LROSADsClientPost202NonRetry400Response]
	beginPost202RetryInvalidHeader                  *azfake.PollerResponder[lrogroup.LROSADsClientPost202RetryInvalidHeaderResponse]
	beginPostAsyncRelativeRetry400                  *azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetry400Response]
	beginPostAsyncRelativeRetryInvalidHeader        *azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse]
	beginPostAsyncRelativeRetryInvalidJSONPolling   *azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse]
	beginPostAsyncRelativeRetryNoPayload            *azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryNoPayloadResponse]
	beginPostNonRetry400                            *azfake.PollerResponder[lrogroup.LROSADsClientPostNonRetry400Response]
	beginPut200InvalidJSON                          *azfake.PollerResponder[lrogroup.LROSADsClientPut200InvalidJSONResponse]
	beginPutAsyncRelativeRetry400                   *azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetry400Response]
	beginPutAsyncRelativeRetryInvalidHeader         *azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse]
	beginPutAsyncRelativeRetryInvalidJSONPolling    *azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse]
	beginPutAsyncRelativeRetryNoStatus              *azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusResponse]
	beginPutAsyncRelativeRetryNoStatusPayload       *azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse]
	beginPutError201NoProvisioningStatePayload      *azfake.PollerResponder[lrogroup.LROSADsClientPutError201NoProvisioningStatePayloadResponse]
	beginPutNonRetry201Creating400                  *azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400Response]
	beginPutNonRetry201Creating400InvalidJSON       *azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400InvalidJSONResponse]
	beginPutNonRetry400                             *azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry400Response]
}

// Do implements the policy.Transporter interface for LROSADsServerTransport.
func (l *LROSADsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "LROSADsClient.BeginDelete202NonRetry400":
		resp, err = l.dispatchBeginDelete202NonRetry400(req)
	case "LROSADsClient.BeginDelete202RetryInvalidHeader":
		resp, err = l.dispatchBeginDelete202RetryInvalidHeader(req)
	case "LROSADsClient.BeginDelete204Succeeded":
		resp, err = l.dispatchBeginDelete204Succeeded(req)
	case "LROSADsClient.BeginDeleteAsyncRelativeRetry400":
		resp, err = l.dispatchBeginDeleteAsyncRelativeRetry400(req)
	case "LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidHeader":
		resp, err = l.dispatchBeginDeleteAsyncRelativeRetryInvalidHeader(req)
	case "LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidJSONPolling":
		resp, err = l.dispatchBeginDeleteAsyncRelativeRetryInvalidJSONPolling(req)
	case "LROSADsClient.BeginDeleteAsyncRelativeRetryNoStatus":
		resp, err = l.dispatchBeginDeleteAsyncRelativeRetryNoStatus(req)
	case "LROSADsClient.BeginDeleteNonRetry400":
		resp, err = l.dispatchBeginDeleteNonRetry400(req)
	case "LROSADsClient.BeginPost202NoLocation":
		resp, err = l.dispatchBeginPost202NoLocation(req)
	case "LROSADsClient.BeginPost202NonRetry400":
		resp, err = l.dispatchBeginPost202NonRetry400(req)
	case "LROSADsClient.BeginPost202RetryInvalidHeader":
		resp, err = l.dispatchBeginPost202RetryInvalidHeader(req)
	case "LROSADsClient.BeginPostAsyncRelativeRetry400":
		resp, err = l.dispatchBeginPostAsyncRelativeRetry400(req)
	case "LROSADsClient.BeginPostAsyncRelativeRetryInvalidHeader":
		resp, err = l.dispatchBeginPostAsyncRelativeRetryInvalidHeader(req)
	case "LROSADsClient.BeginPostAsyncRelativeRetryInvalidJSONPolling":
		resp, err = l.dispatchBeginPostAsyncRelativeRetryInvalidJSONPolling(req)
	case "LROSADsClient.BeginPostAsyncRelativeRetryNoPayload":
		resp, err = l.dispatchBeginPostAsyncRelativeRetryNoPayload(req)
	case "LROSADsClient.BeginPostNonRetry400":
		resp, err = l.dispatchBeginPostNonRetry400(req)
	case "LROSADsClient.BeginPut200InvalidJSON":
		resp, err = l.dispatchBeginPut200InvalidJSON(req)
	case "LROSADsClient.BeginPutAsyncRelativeRetry400":
		resp, err = l.dispatchBeginPutAsyncRelativeRetry400(req)
	case "LROSADsClient.BeginPutAsyncRelativeRetryInvalidHeader":
		resp, err = l.dispatchBeginPutAsyncRelativeRetryInvalidHeader(req)
	case "LROSADsClient.BeginPutAsyncRelativeRetryInvalidJSONPolling":
		resp, err = l.dispatchBeginPutAsyncRelativeRetryInvalidJSONPolling(req)
	case "LROSADsClient.BeginPutAsyncRelativeRetryNoStatus":
		resp, err = l.dispatchBeginPutAsyncRelativeRetryNoStatus(req)
	case "LROSADsClient.BeginPutAsyncRelativeRetryNoStatusPayload":
		resp, err = l.dispatchBeginPutAsyncRelativeRetryNoStatusPayload(req)
	case "LROSADsClient.BeginPutError201NoProvisioningStatePayload":
		resp, err = l.dispatchBeginPutError201NoProvisioningStatePayload(req)
	case "LROSADsClient.BeginPutNonRetry201Creating400":
		resp, err = l.dispatchBeginPutNonRetry201Creating400(req)
	case "LROSADsClient.BeginPutNonRetry201Creating400InvalidJSON":
		resp, err = l.dispatchBeginPutNonRetry201Creating400InvalidJSON(req)
	case "LROSADsClient.BeginPutNonRetry400":
		resp, err = l.dispatchBeginPutNonRetry400(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDelete202NonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202NonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete202NonRetry400 not implemented")}
	}
	if l.beginDelete202NonRetry400 == nil {
		respr, errRespr := l.srv.BeginDelete202NonRetry400(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDelete202NonRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDelete202NonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDelete202NonRetry400) {
		l.beginDelete202NonRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDelete202RetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202RetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete202RetryInvalidHeader not implemented")}
	}
	if l.beginDelete202RetryInvalidHeader == nil {
		respr, errRespr := l.srv.BeginDelete202RetryInvalidHeader(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDelete202RetryInvalidHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDelete202RetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDelete202RetryInvalidHeader) {
		l.beginDelete202RetryInvalidHeader = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDelete204Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete204Succeeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete204Succeeded not implemented")}
	}
	if l.beginDelete204Succeeded == nil {
		respr, errRespr := l.srv.BeginDelete204Succeeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDelete204Succeeded = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDelete204Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDelete204Succeeded) {
		l.beginDelete204Succeeded = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetry400 not implemented")}
	}
	if l.beginDeleteAsyncRelativeRetry400 == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetry400(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRelativeRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRelativeRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRelativeRetry400) {
		l.beginDeleteAsyncRelativeRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetryInvalidHeader not implemented")}
	}
	if l.beginDeleteAsyncRelativeRetryInvalidHeader == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetryInvalidHeader(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRelativeRetryInvalidHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRelativeRetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRelativeRetryInvalidHeader) {
		l.beginDeleteAsyncRelativeRetryInvalidHeader = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetryInvalidJSONPolling(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetryInvalidJSONPolling == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetryInvalidJSONPolling not implemented")}
	}
	if l.beginDeleteAsyncRelativeRetryInvalidJSONPolling == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetryInvalidJSONPolling(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRelativeRetryInvalidJSONPolling = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRelativeRetryInvalidJSONPolling, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRelativeRetryInvalidJSONPolling) {
		l.beginDeleteAsyncRelativeRetryInvalidJSONPolling = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetryNoStatus(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetryNoStatus == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetryNoStatus not implemented")}
	}
	if l.beginDeleteAsyncRelativeRetryNoStatus == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetryNoStatus(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteAsyncRelativeRetryNoStatus = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteAsyncRelativeRetryNoStatus, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteAsyncRelativeRetryNoStatus) {
		l.beginDeleteAsyncRelativeRetryNoStatus = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteNonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteNonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteNonRetry400 not implemented")}
	}
	if l.beginDeleteNonRetry400 == nil {
		respr, errRespr := l.srv.BeginDeleteNonRetry400(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginDeleteNonRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginDeleteNonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginDeleteNonRetry400) {
		l.beginDeleteNonRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPost202NoLocation(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202NoLocation == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202NoLocation not implemented")}
	}
	if l.beginPost202NoLocation == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPost202NoLocationOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPost202NoLocationOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202NoLocation(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost202NoLocation = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost202NoLocation, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost202NoLocation) {
		l.beginPost202NoLocation = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPost202NonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202NonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202NonRetry400 not implemented")}
	}
	if l.beginPost202NonRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPost202NonRetry400Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPost202NonRetry400Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202NonRetry400(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost202NonRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost202NonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost202NonRetry400) {
		l.beginPost202NonRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPost202RetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202RetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202RetryInvalidHeader not implemented")}
	}
	if l.beginPost202RetryInvalidHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPost202RetryInvalidHeaderOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPost202RetryInvalidHeaderOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202RetryInvalidHeader(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPost202RetryInvalidHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPost202RetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPost202RetryInvalidHeader) {
		l.beginPost202RetryInvalidHeader = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetry400 not implemented")}
	}
	if l.beginPostAsyncRelativeRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetry400Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetry400Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetry400(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRelativeRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRelativeRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRelativeRetry400) {
		l.beginPostAsyncRelativeRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetryInvalidHeader not implemented")}
	}
	if l.beginPostAsyncRelativeRetryInvalidHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetryInvalidHeader(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRelativeRetryInvalidHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRelativeRetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRelativeRetryInvalidHeader) {
		l.beginPostAsyncRelativeRetryInvalidHeader = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetryInvalidJSONPolling(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetryInvalidJSONPolling == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetryInvalidJSONPolling not implemented")}
	}
	if l.beginPostAsyncRelativeRetryInvalidJSONPolling == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetryInvalidJSONPolling(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRelativeRetryInvalidJSONPolling = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRelativeRetryInvalidJSONPolling, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRelativeRetryInvalidJSONPolling) {
		l.beginPostAsyncRelativeRetryInvalidJSONPolling = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetryNoPayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetryNoPayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetryNoPayload not implemented")}
	}
	if l.beginPostAsyncRelativeRetryNoPayload == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetryNoPayload(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostAsyncRelativeRetryNoPayload = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostAsyncRelativeRetryNoPayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostAsyncRelativeRetryNoPayload) {
		l.beginPostAsyncRelativeRetryNoPayload = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostNonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostNonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostNonRetry400 not implemented")}
	}
	if l.beginPostNonRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostNonRetry400Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostNonRetry400Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostNonRetry400(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPostNonRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPostNonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPostNonRetry400) {
		l.beginPostNonRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPut200InvalidJSON(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200InvalidJSON == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut200InvalidJSON not implemented")}
	}
	if l.beginPut200InvalidJSON == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200InvalidJSON(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPut200InvalidJSON = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPut200InvalidJSON, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusNoContent}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPut200InvalidJSON) {
		l.beginPut200InvalidJSON = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetry400 not implemented")}
	}
	if l.beginPutAsyncRelativeRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetry400(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRelativeRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRelativeRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRelativeRetry400) {
		l.beginPutAsyncRelativeRetry400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryInvalidHeader not implemented")}
	}
	if l.beginPutAsyncRelativeRetryInvalidHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryInvalidHeader(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRelativeRetryInvalidHeader = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRelativeRetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRelativeRetryInvalidHeader) {
		l.beginPutAsyncRelativeRetryInvalidHeader = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryInvalidJSONPolling(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryInvalidJSONPolling == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryInvalidJSONPolling not implemented")}
	}
	if l.beginPutAsyncRelativeRetryInvalidJSONPolling == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryInvalidJSONPolling(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRelativeRetryInvalidJSONPolling = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRelativeRetryInvalidJSONPolling, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRelativeRetryInvalidJSONPolling) {
		l.beginPutAsyncRelativeRetryInvalidJSONPolling = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryNoStatus(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryNoStatus == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryNoStatus not implemented")}
	}
	if l.beginPutAsyncRelativeRetryNoStatus == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryNoStatus(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRelativeRetryNoStatus = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRelativeRetryNoStatus, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRelativeRetryNoStatus) {
		l.beginPutAsyncRelativeRetryNoStatus = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryNoStatusPayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryNoStatusPayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryNoStatusPayload not implemented")}
	}
	if l.beginPutAsyncRelativeRetryNoStatusPayload == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryNoStatusPayload(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutAsyncRelativeRetryNoStatusPayload = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutAsyncRelativeRetryNoStatusPayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutAsyncRelativeRetryNoStatusPayload) {
		l.beginPutAsyncRelativeRetryNoStatusPayload = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutError201NoProvisioningStatePayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutError201NoProvisioningStatePayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutError201NoProvisioningStatePayload not implemented")}
	}
	if l.beginPutError201NoProvisioningStatePayload == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutError201NoProvisioningStatePayload(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutError201NoProvisioningStatePayload = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutError201NoProvisioningStatePayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutError201NoProvisioningStatePayload) {
		l.beginPutError201NoProvisioningStatePayload = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutNonRetry201Creating400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonRetry201Creating400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonRetry201Creating400 not implemented")}
	}
	if l.beginPutNonRetry201Creating400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonRetry201Creating400(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutNonRetry201Creating400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutNonRetry201Creating400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutNonRetry201Creating400) {
		l.beginPutNonRetry201Creating400 = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutNonRetry201Creating400InvalidJSON(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonRetry201Creating400InvalidJSON == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonRetry201Creating400InvalidJSON not implemented")}
	}
	if l.beginPutNonRetry201Creating400InvalidJSON == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonRetry201Creating400InvalidJSON(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutNonRetry201Creating400InvalidJSON = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutNonRetry201Creating400InvalidJSON, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutNonRetry201Creating400InvalidJSON) {
		l.beginPutNonRetry201Creating400InvalidJSON = nil
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutNonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonRetry400 not implemented")}
	}
	if l.beginPutNonRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonRetry400(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		l.beginPutNonRetry400 = &respr
	}

	resp, err := server.PollerResponderNext(l.beginPutNonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(l.beginPutNonRetry400) {
		l.beginPutNonRetry400 = nil
	}

	return resp, nil
}
