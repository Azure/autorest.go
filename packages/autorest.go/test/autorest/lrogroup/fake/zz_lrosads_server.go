// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"context"
	"errors"
	"fmt"
	"generatortests/lrogroup"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// LROSADsServer is a fake server for instances of the lrogroup.LROSADsClient type.
type LROSADsServer struct {
	// BeginDelete202NonRetry400 is the fake for method LROSADsClient.BeginDelete202NonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDelete202NonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginDelete202NonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientDelete202NonRetry400Response], errResp azfake.ErrorResponder)

	// BeginDelete202RetryInvalidHeader is the fake for method LROSADsClient.BeginDelete202RetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDelete202RetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginDelete202RetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDelete202RetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginDelete204Succeeded is the fake for method LROSADsClient.BeginDelete204Succeeded
	// HTTP status codes to indicate success: http.StatusNoContent
	BeginDelete204Succeeded func(ctx context.Context, options *lrogroup.LROSADsClientBeginDelete204SucceededOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDelete204SucceededResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetry400 is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetry400Response], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetryInvalidHeader is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetryInvalidJSONPolling is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidJSONPolling
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetryInvalidJSONPolling func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetryInvalidJSONPollingOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse], errResp azfake.ErrorResponder)

	// BeginDeleteAsyncRelativeRetryNoStatus is the fake for method LROSADsClient.BeginDeleteAsyncRelativeRetryNoStatus
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteAsyncRelativeRetryNoStatus func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteAsyncRelativeRetryNoStatusOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse], errResp azfake.ErrorResponder)

	// BeginDeleteNonRetry400 is the fake for method LROSADsClient.BeginDeleteNonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginDeleteNonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginDeleteNonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientDeleteNonRetry400Response], errResp azfake.ErrorResponder)

	// BeginPost202NoLocation is the fake for method LROSADsClient.BeginPost202NoLocation
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202NoLocation func(ctx context.Context, options *lrogroup.LROSADsClientBeginPost202NoLocationOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPost202NoLocationResponse], errResp azfake.ErrorResponder)

	// BeginPost202NonRetry400 is the fake for method LROSADsClient.BeginPost202NonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202NonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginPost202NonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPost202NonRetry400Response], errResp azfake.ErrorResponder)

	// BeginPost202RetryInvalidHeader is the fake for method LROSADsClient.BeginPost202RetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPost202RetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginPost202RetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPost202RetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetry400 is the fake for method LROSADsClient.BeginPostAsyncRelativeRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetry400Response], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetryInvalidHeader is the fake for method LROSADsClient.BeginPostAsyncRelativeRetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetryInvalidHeader func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetryInvalidJSONPolling is the fake for method LROSADsClient.BeginPostAsyncRelativeRetryInvalidJSONPolling
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetryInvalidJSONPolling func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse], errResp azfake.ErrorResponder)

	// BeginPostAsyncRelativeRetryNoPayload is the fake for method LROSADsClient.BeginPostAsyncRelativeRetryNoPayload
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostAsyncRelativeRetryNoPayload func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryNoPayloadResponse], errResp azfake.ErrorResponder)

	// BeginPostNonRetry400 is the fake for method LROSADsClient.BeginPostNonRetry400
	// HTTP status codes to indicate success: http.StatusAccepted
	BeginPostNonRetry400 func(ctx context.Context, options *lrogroup.LROSADsClientBeginPostNonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPostNonRetry400Response], errResp azfake.ErrorResponder)

	// BeginPut200InvalidJSON is the fake for method LROSADsClient.BeginPut200InvalidJSON
	// HTTP status codes to indicate success: http.StatusOK, http.StatusNoContent
	BeginPut200InvalidJSON func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPut200InvalidJSONOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPut200InvalidJSONResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetry400 is the fake for method LROSADsClient.BeginPutAsyncRelativeRetry400
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetry400 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetry400Response], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryInvalidHeader is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryInvalidHeader
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryInvalidHeader func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryInvalidHeaderOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryInvalidJSONPolling is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryInvalidJSONPolling
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryInvalidJSONPolling func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryInvalidJSONPollingOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryNoStatus is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryNoStatus
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryNoStatus func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryNoStatusOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusResponse], errResp azfake.ErrorResponder)

	// BeginPutAsyncRelativeRetryNoStatusPayload is the fake for method LROSADsClient.BeginPutAsyncRelativeRetryNoStatusPayload
	// HTTP status codes to indicate success: http.StatusOK
	BeginPutAsyncRelativeRetryNoStatusPayload func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutAsyncRelativeRetryNoStatusPayloadOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse], errResp azfake.ErrorResponder)

	// BeginPutError201NoProvisioningStatePayload is the fake for method LROSADsClient.BeginPutError201NoProvisioningStatePayload
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutError201NoProvisioningStatePayload func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutError201NoProvisioningStatePayloadOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutError201NoProvisioningStatePayloadResponse], errResp azfake.ErrorResponder)

	// BeginPutNonRetry201Creating400 is the fake for method LROSADsClient.BeginPutNonRetry201Creating400
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutNonRetry201Creating400 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutNonRetry201Creating400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400Response], errResp azfake.ErrorResponder)

	// BeginPutNonRetry201Creating400InvalidJSON is the fake for method LROSADsClient.BeginPutNonRetry201Creating400InvalidJSON
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutNonRetry201Creating400InvalidJSON func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutNonRetry201Creating400InvalidJSONOptions) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400InvalidJSONResponse], errResp azfake.ErrorResponder)

	// BeginPutNonRetry400 is the fake for method LROSADsClient.BeginPutNonRetry400
	// HTTP status codes to indicate success: http.StatusOK, http.StatusCreated
	BeginPutNonRetry400 func(ctx context.Context, product lrogroup.Product, options *lrogroup.LROSADsClientBeginPutNonRetry400Options) (resp azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry400Response], errResp azfake.ErrorResponder)
}

// NewLROSADsServerTransport creates a new instance of LROSADsServerTransport with the provided implementation.
// The returned LROSADsServerTransport instance is connected to an instance of lrogroup.LROSADsClient via the
// azcore.ClientOptions.Transporter field in the client's constructor parameters.
func NewLROSADsServerTransport(srv *LROSADsServer) *LROSADsServerTransport {
	return &LROSADsServerTransport{
		srv:                                             srv,
		beginDelete202NonRetry400:                       newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDelete202NonRetry400Response]](),
		beginDelete202RetryInvalidHeader:                newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDelete202RetryInvalidHeaderResponse]](),
		beginDelete204Succeeded:                         newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDelete204SucceededResponse]](),
		beginDeleteAsyncRelativeRetry400:                newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetry400Response]](),
		beginDeleteAsyncRelativeRetryInvalidHeader:      newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse]](),
		beginDeleteAsyncRelativeRetryInvalidJSONPolling: newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse]](),
		beginDeleteAsyncRelativeRetryNoStatus:           newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse]](),
		beginDeleteNonRetry400:                          newTracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteNonRetry400Response]](),
		beginPost202NoLocation:                          newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPost202NoLocationResponse]](),
		beginPost202NonRetry400:                         newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPost202NonRetry400Response]](),
		beginPost202RetryInvalidHeader:                  newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPost202RetryInvalidHeaderResponse]](),
		beginPostAsyncRelativeRetry400:                  newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetry400Response]](),
		beginPostAsyncRelativeRetryInvalidHeader:        newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse]](),
		beginPostAsyncRelativeRetryInvalidJSONPolling:   newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse]](),
		beginPostAsyncRelativeRetryNoPayload:            newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryNoPayloadResponse]](),
		beginPostNonRetry400:                            newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPostNonRetry400Response]](),
		beginPut200InvalidJSON:                          newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPut200InvalidJSONResponse]](),
		beginPutAsyncRelativeRetry400:                   newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetry400Response]](),
		beginPutAsyncRelativeRetryInvalidHeader:         newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse]](),
		beginPutAsyncRelativeRetryInvalidJSONPolling:    newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse]](),
		beginPutAsyncRelativeRetryNoStatus:              newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusResponse]](),
		beginPutAsyncRelativeRetryNoStatusPayload:       newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse]](),
		beginPutError201NoProvisioningStatePayload:      newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutError201NoProvisioningStatePayloadResponse]](),
		beginPutNonRetry201Creating400:                  newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400Response]](),
		beginPutNonRetry201Creating400InvalidJSON:       newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400InvalidJSONResponse]](),
		beginPutNonRetry400:                             newTracker[azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry400Response]](),
	}
}

// LROSADsServerTransport connects instances of lrogroup.LROSADsClient to instances of LROSADsServer.
// Don't use this type directly, use NewLROSADsServerTransport instead.
type LROSADsServerTransport struct {
	srv                                             *LROSADsServer
	beginDelete202NonRetry400                       *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDelete202NonRetry400Response]]
	beginDelete202RetryInvalidHeader                *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDelete202RetryInvalidHeaderResponse]]
	beginDelete204Succeeded                         *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDelete204SucceededResponse]]
	beginDeleteAsyncRelativeRetry400                *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetry400Response]]
	beginDeleteAsyncRelativeRetryInvalidHeader      *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidHeaderResponse]]
	beginDeleteAsyncRelativeRetryInvalidJSONPolling *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryInvalidJSONPollingResponse]]
	beginDeleteAsyncRelativeRetryNoStatus           *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteAsyncRelativeRetryNoStatusResponse]]
	beginDeleteNonRetry400                          *tracker[azfake.PollerResponder[lrogroup.LROSADsClientDeleteNonRetry400Response]]
	beginPost202NoLocation                          *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPost202NoLocationResponse]]
	beginPost202NonRetry400                         *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPost202NonRetry400Response]]
	beginPost202RetryInvalidHeader                  *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPost202RetryInvalidHeaderResponse]]
	beginPostAsyncRelativeRetry400                  *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetry400Response]]
	beginPostAsyncRelativeRetryInvalidHeader        *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidHeaderResponse]]
	beginPostAsyncRelativeRetryInvalidJSONPolling   *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryInvalidJSONPollingResponse]]
	beginPostAsyncRelativeRetryNoPayload            *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPostAsyncRelativeRetryNoPayloadResponse]]
	beginPostNonRetry400                            *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPostNonRetry400Response]]
	beginPut200InvalidJSON                          *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPut200InvalidJSONResponse]]
	beginPutAsyncRelativeRetry400                   *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetry400Response]]
	beginPutAsyncRelativeRetryInvalidHeader         *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidHeaderResponse]]
	beginPutAsyncRelativeRetryInvalidJSONPolling    *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryInvalidJSONPollingResponse]]
	beginPutAsyncRelativeRetryNoStatus              *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusResponse]]
	beginPutAsyncRelativeRetryNoStatusPayload       *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutAsyncRelativeRetryNoStatusPayloadResponse]]
	beginPutError201NoProvisioningStatePayload      *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutError201NoProvisioningStatePayloadResponse]]
	beginPutNonRetry201Creating400                  *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400Response]]
	beginPutNonRetry201Creating400InvalidJSON       *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry201Creating400InvalidJSONResponse]]
	beginPutNonRetry400                             *tracker[azfake.PollerResponder[lrogroup.LROSADsClientPutNonRetry400Response]]
}

// Do implements the policy.Transporter interface for LROSADsServerTransport.
func (l *LROSADsServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	return l.dispatchToMethodFake(req, method)
}

func (l *LROSADsServerTransport) dispatchToMethodFake(req *http.Request, method string) (*http.Response, error) {
	resultChan := make(chan result)
	defer close(resultChan)

	go func() {
		var res result
		switch method {
		case "LROSADsClient.BeginDelete202NonRetry400":
			res.resp, res.err = l.dispatchBeginDelete202NonRetry400(req)
		case "LROSADsClient.BeginDelete202RetryInvalidHeader":
			res.resp, res.err = l.dispatchBeginDelete202RetryInvalidHeader(req)
		case "LROSADsClient.BeginDelete204Succeeded":
			res.resp, res.err = l.dispatchBeginDelete204Succeeded(req)
		case "LROSADsClient.BeginDeleteAsyncRelativeRetry400":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRelativeRetry400(req)
		case "LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidHeader":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRelativeRetryInvalidHeader(req)
		case "LROSADsClient.BeginDeleteAsyncRelativeRetryInvalidJSONPolling":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRelativeRetryInvalidJSONPolling(req)
		case "LROSADsClient.BeginDeleteAsyncRelativeRetryNoStatus":
			res.resp, res.err = l.dispatchBeginDeleteAsyncRelativeRetryNoStatus(req)
		case "LROSADsClient.BeginDeleteNonRetry400":
			res.resp, res.err = l.dispatchBeginDeleteNonRetry400(req)
		case "LROSADsClient.BeginPost202NoLocation":
			res.resp, res.err = l.dispatchBeginPost202NoLocation(req)
		case "LROSADsClient.BeginPost202NonRetry400":
			res.resp, res.err = l.dispatchBeginPost202NonRetry400(req)
		case "LROSADsClient.BeginPost202RetryInvalidHeader":
			res.resp, res.err = l.dispatchBeginPost202RetryInvalidHeader(req)
		case "LROSADsClient.BeginPostAsyncRelativeRetry400":
			res.resp, res.err = l.dispatchBeginPostAsyncRelativeRetry400(req)
		case "LROSADsClient.BeginPostAsyncRelativeRetryInvalidHeader":
			res.resp, res.err = l.dispatchBeginPostAsyncRelativeRetryInvalidHeader(req)
		case "LROSADsClient.BeginPostAsyncRelativeRetryInvalidJSONPolling":
			res.resp, res.err = l.dispatchBeginPostAsyncRelativeRetryInvalidJSONPolling(req)
		case "LROSADsClient.BeginPostAsyncRelativeRetryNoPayload":
			res.resp, res.err = l.dispatchBeginPostAsyncRelativeRetryNoPayload(req)
		case "LROSADsClient.BeginPostNonRetry400":
			res.resp, res.err = l.dispatchBeginPostNonRetry400(req)
		case "LROSADsClient.BeginPut200InvalidJSON":
			res.resp, res.err = l.dispatchBeginPut200InvalidJSON(req)
		case "LROSADsClient.BeginPutAsyncRelativeRetry400":
			res.resp, res.err = l.dispatchBeginPutAsyncRelativeRetry400(req)
		case "LROSADsClient.BeginPutAsyncRelativeRetryInvalidHeader":
			res.resp, res.err = l.dispatchBeginPutAsyncRelativeRetryInvalidHeader(req)
		case "LROSADsClient.BeginPutAsyncRelativeRetryInvalidJSONPolling":
			res.resp, res.err = l.dispatchBeginPutAsyncRelativeRetryInvalidJSONPolling(req)
		case "LROSADsClient.BeginPutAsyncRelativeRetryNoStatus":
			res.resp, res.err = l.dispatchBeginPutAsyncRelativeRetryNoStatus(req)
		case "LROSADsClient.BeginPutAsyncRelativeRetryNoStatusPayload":
			res.resp, res.err = l.dispatchBeginPutAsyncRelativeRetryNoStatusPayload(req)
		case "LROSADsClient.BeginPutError201NoProvisioningStatePayload":
			res.resp, res.err = l.dispatchBeginPutError201NoProvisioningStatePayload(req)
		case "LROSADsClient.BeginPutNonRetry201Creating400":
			res.resp, res.err = l.dispatchBeginPutNonRetry201Creating400(req)
		case "LROSADsClient.BeginPutNonRetry201Creating400InvalidJSON":
			res.resp, res.err = l.dispatchBeginPutNonRetry201Creating400InvalidJSON(req)
		case "LROSADsClient.BeginPutNonRetry400":
			res.resp, res.err = l.dispatchBeginPutNonRetry400(req)
		default:
			res.err = fmt.Errorf("unhandled API %s", method)
		}

		select {
		case resultChan <- res:
		case <-req.Context().Done():
		}
	}()

	select {
	case <-req.Context().Done():
		return nil, req.Context().Err()
	case res := <-resultChan:
		return res.resp, res.err
	}
}

func (l *LROSADsServerTransport) dispatchBeginDelete202NonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202NonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete202NonRetry400 not implemented")}
	}
	beginDelete202NonRetry400 := l.beginDelete202NonRetry400.get(req)
	if beginDelete202NonRetry400 == nil {
		respr, errRespr := l.srv.BeginDelete202NonRetry400(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete202NonRetry400 = &respr
		l.beginDelete202NonRetry400.add(req, beginDelete202NonRetry400)
	}

	resp, err := server.PollerResponderNext(beginDelete202NonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDelete202NonRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete202NonRetry400) {
		l.beginDelete202NonRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDelete202RetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete202RetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete202RetryInvalidHeader not implemented")}
	}
	beginDelete202RetryInvalidHeader := l.beginDelete202RetryInvalidHeader.get(req)
	if beginDelete202RetryInvalidHeader == nil {
		respr, errRespr := l.srv.BeginDelete202RetryInvalidHeader(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete202RetryInvalidHeader = &respr
		l.beginDelete202RetryInvalidHeader.add(req, beginDelete202RetryInvalidHeader)
	}

	resp, err := server.PollerResponderNext(beginDelete202RetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDelete202RetryInvalidHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete202RetryInvalidHeader) {
		l.beginDelete202RetryInvalidHeader.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDelete204Succeeded(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDelete204Succeeded == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDelete204Succeeded not implemented")}
	}
	beginDelete204Succeeded := l.beginDelete204Succeeded.get(req)
	if beginDelete204Succeeded == nil {
		respr, errRespr := l.srv.BeginDelete204Succeeded(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDelete204Succeeded = &respr
		l.beginDelete204Succeeded.add(req, beginDelete204Succeeded)
	}

	resp, err := server.PollerResponderNext(beginDelete204Succeeded, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusNoContent}, resp.StatusCode) {
		l.beginDelete204Succeeded.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDelete204Succeeded) {
		l.beginDelete204Succeeded.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetry400 not implemented")}
	}
	beginDeleteAsyncRelativeRetry400 := l.beginDeleteAsyncRelativeRetry400.get(req)
	if beginDeleteAsyncRelativeRetry400 == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetry400(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRelativeRetry400 = &respr
		l.beginDeleteAsyncRelativeRetry400.add(req, beginDeleteAsyncRelativeRetry400)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRelativeRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteAsyncRelativeRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRelativeRetry400) {
		l.beginDeleteAsyncRelativeRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetryInvalidHeader not implemented")}
	}
	beginDeleteAsyncRelativeRetryInvalidHeader := l.beginDeleteAsyncRelativeRetryInvalidHeader.get(req)
	if beginDeleteAsyncRelativeRetryInvalidHeader == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetryInvalidHeader(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRelativeRetryInvalidHeader = &respr
		l.beginDeleteAsyncRelativeRetryInvalidHeader.add(req, beginDeleteAsyncRelativeRetryInvalidHeader)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRelativeRetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteAsyncRelativeRetryInvalidHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRelativeRetryInvalidHeader) {
		l.beginDeleteAsyncRelativeRetryInvalidHeader.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetryInvalidJSONPolling(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetryInvalidJSONPolling == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetryInvalidJSONPolling not implemented")}
	}
	beginDeleteAsyncRelativeRetryInvalidJSONPolling := l.beginDeleteAsyncRelativeRetryInvalidJSONPolling.get(req)
	if beginDeleteAsyncRelativeRetryInvalidJSONPolling == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetryInvalidJSONPolling(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRelativeRetryInvalidJSONPolling = &respr
		l.beginDeleteAsyncRelativeRetryInvalidJSONPolling.add(req, beginDeleteAsyncRelativeRetryInvalidJSONPolling)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRelativeRetryInvalidJSONPolling, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteAsyncRelativeRetryInvalidJSONPolling.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRelativeRetryInvalidJSONPolling) {
		l.beginDeleteAsyncRelativeRetryInvalidJSONPolling.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteAsyncRelativeRetryNoStatus(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteAsyncRelativeRetryNoStatus == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteAsyncRelativeRetryNoStatus not implemented")}
	}
	beginDeleteAsyncRelativeRetryNoStatus := l.beginDeleteAsyncRelativeRetryNoStatus.get(req)
	if beginDeleteAsyncRelativeRetryNoStatus == nil {
		respr, errRespr := l.srv.BeginDeleteAsyncRelativeRetryNoStatus(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteAsyncRelativeRetryNoStatus = &respr
		l.beginDeleteAsyncRelativeRetryNoStatus.add(req, beginDeleteAsyncRelativeRetryNoStatus)
	}

	resp, err := server.PollerResponderNext(beginDeleteAsyncRelativeRetryNoStatus, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteAsyncRelativeRetryNoStatus.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteAsyncRelativeRetryNoStatus) {
		l.beginDeleteAsyncRelativeRetryNoStatus.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginDeleteNonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginDeleteNonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginDeleteNonRetry400 not implemented")}
	}
	beginDeleteNonRetry400 := l.beginDeleteNonRetry400.get(req)
	if beginDeleteNonRetry400 == nil {
		respr, errRespr := l.srv.BeginDeleteNonRetry400(req.Context(), nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginDeleteNonRetry400 = &respr
		l.beginDeleteNonRetry400.add(req, beginDeleteNonRetry400)
	}

	resp, err := server.PollerResponderNext(beginDeleteNonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginDeleteNonRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginDeleteNonRetry400) {
		l.beginDeleteNonRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPost202NoLocation(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202NoLocation == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202NoLocation not implemented")}
	}
	beginPost202NoLocation := l.beginPost202NoLocation.get(req)
	if beginPost202NoLocation == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPost202NoLocationOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPost202NoLocationOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202NoLocation(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost202NoLocation = &respr
		l.beginPost202NoLocation.add(req, beginPost202NoLocation)
	}

	resp, err := server.PollerResponderNext(beginPost202NoLocation, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPost202NoLocation.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost202NoLocation) {
		l.beginPost202NoLocation.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPost202NonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202NonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202NonRetry400 not implemented")}
	}
	beginPost202NonRetry400 := l.beginPost202NonRetry400.get(req)
	if beginPost202NonRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPost202NonRetry400Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPost202NonRetry400Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202NonRetry400(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost202NonRetry400 = &respr
		l.beginPost202NonRetry400.add(req, beginPost202NonRetry400)
	}

	resp, err := server.PollerResponderNext(beginPost202NonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPost202NonRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost202NonRetry400) {
		l.beginPost202NonRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPost202RetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPost202RetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPost202RetryInvalidHeader not implemented")}
	}
	beginPost202RetryInvalidHeader := l.beginPost202RetryInvalidHeader.get(req)
	if beginPost202RetryInvalidHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPost202RetryInvalidHeaderOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPost202RetryInvalidHeaderOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPost202RetryInvalidHeader(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPost202RetryInvalidHeader = &respr
		l.beginPost202RetryInvalidHeader.add(req, beginPost202RetryInvalidHeader)
	}

	resp, err := server.PollerResponderNext(beginPost202RetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPost202RetryInvalidHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPost202RetryInvalidHeader) {
		l.beginPost202RetryInvalidHeader.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetry400 not implemented")}
	}
	beginPostAsyncRelativeRetry400 := l.beginPostAsyncRelativeRetry400.get(req)
	if beginPostAsyncRelativeRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetry400Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetry400Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetry400(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRelativeRetry400 = &respr
		l.beginPostAsyncRelativeRetry400.add(req, beginPostAsyncRelativeRetry400)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRelativeRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPostAsyncRelativeRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRelativeRetry400) {
		l.beginPostAsyncRelativeRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetryInvalidHeader not implemented")}
	}
	beginPostAsyncRelativeRetryInvalidHeader := l.beginPostAsyncRelativeRetryInvalidHeader.get(req)
	if beginPostAsyncRelativeRetryInvalidHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidHeaderOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetryInvalidHeader(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRelativeRetryInvalidHeader = &respr
		l.beginPostAsyncRelativeRetryInvalidHeader.add(req, beginPostAsyncRelativeRetryInvalidHeader)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRelativeRetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPostAsyncRelativeRetryInvalidHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRelativeRetryInvalidHeader) {
		l.beginPostAsyncRelativeRetryInvalidHeader.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetryInvalidJSONPolling(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetryInvalidJSONPolling == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetryInvalidJSONPolling not implemented")}
	}
	beginPostAsyncRelativeRetryInvalidJSONPolling := l.beginPostAsyncRelativeRetryInvalidJSONPolling.get(req)
	if beginPostAsyncRelativeRetryInvalidJSONPolling == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetryInvalidJSONPollingOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetryInvalidJSONPolling(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRelativeRetryInvalidJSONPolling = &respr
		l.beginPostAsyncRelativeRetryInvalidJSONPolling.add(req, beginPostAsyncRelativeRetryInvalidJSONPolling)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRelativeRetryInvalidJSONPolling, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPostAsyncRelativeRetryInvalidJSONPolling.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRelativeRetryInvalidJSONPolling) {
		l.beginPostAsyncRelativeRetryInvalidJSONPolling.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostAsyncRelativeRetryNoPayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostAsyncRelativeRetryNoPayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostAsyncRelativeRetryNoPayload not implemented")}
	}
	beginPostAsyncRelativeRetryNoPayload := l.beginPostAsyncRelativeRetryNoPayload.get(req)
	if beginPostAsyncRelativeRetryNoPayload == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostAsyncRelativeRetryNoPayloadOptions{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostAsyncRelativeRetryNoPayload(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostAsyncRelativeRetryNoPayload = &respr
		l.beginPostAsyncRelativeRetryNoPayload.add(req, beginPostAsyncRelativeRetryNoPayload)
	}

	resp, err := server.PollerResponderNext(beginPostAsyncRelativeRetryNoPayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPostAsyncRelativeRetryNoPayload.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostAsyncRelativeRetryNoPayload) {
		l.beginPostAsyncRelativeRetryNoPayload.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPostNonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPostNonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPostNonRetry400 not implemented")}
	}
	beginPostNonRetry400 := l.beginPostNonRetry400.get(req)
	if beginPostNonRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		var options *lrogroup.LROSADsClientBeginPostNonRetry400Options
		if !reflect.ValueOf(body).IsZero() {
			options = &lrogroup.LROSADsClientBeginPostNonRetry400Options{
				Product: &body,
			}
		}
		respr, errRespr := l.srv.BeginPostNonRetry400(req.Context(), options)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPostNonRetry400 = &respr
		l.beginPostNonRetry400.add(req, beginPostNonRetry400)
	}

	resp, err := server.PollerResponderNext(beginPostNonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusAccepted}, resp.StatusCode) {
		l.beginPostNonRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPostNonRetry400) {
		l.beginPostNonRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPut200InvalidJSON(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPut200InvalidJSON == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPut200InvalidJSON not implemented")}
	}
	beginPut200InvalidJSON := l.beginPut200InvalidJSON.get(req)
	if beginPut200InvalidJSON == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPut200InvalidJSON(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPut200InvalidJSON = &respr
		l.beginPut200InvalidJSON.add(req, beginPut200InvalidJSON)
	}

	resp, err := server.PollerResponderNext(beginPut200InvalidJSON, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusNoContent}, resp.StatusCode) {
		l.beginPut200InvalidJSON.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusNoContent", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPut200InvalidJSON) {
		l.beginPut200InvalidJSON.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetry400 not implemented")}
	}
	beginPutAsyncRelativeRetry400 := l.beginPutAsyncRelativeRetry400.get(req)
	if beginPutAsyncRelativeRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetry400(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRelativeRetry400 = &respr
		l.beginPutAsyncRelativeRetry400.add(req, beginPutAsyncRelativeRetry400)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRelativeRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRelativeRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRelativeRetry400) {
		l.beginPutAsyncRelativeRetry400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryInvalidHeader(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryInvalidHeader == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryInvalidHeader not implemented")}
	}
	beginPutAsyncRelativeRetryInvalidHeader := l.beginPutAsyncRelativeRetryInvalidHeader.get(req)
	if beginPutAsyncRelativeRetryInvalidHeader == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryInvalidHeader(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRelativeRetryInvalidHeader = &respr
		l.beginPutAsyncRelativeRetryInvalidHeader.add(req, beginPutAsyncRelativeRetryInvalidHeader)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRelativeRetryInvalidHeader, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRelativeRetryInvalidHeader.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRelativeRetryInvalidHeader) {
		l.beginPutAsyncRelativeRetryInvalidHeader.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryInvalidJSONPolling(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryInvalidJSONPolling == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryInvalidJSONPolling not implemented")}
	}
	beginPutAsyncRelativeRetryInvalidJSONPolling := l.beginPutAsyncRelativeRetryInvalidJSONPolling.get(req)
	if beginPutAsyncRelativeRetryInvalidJSONPolling == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryInvalidJSONPolling(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRelativeRetryInvalidJSONPolling = &respr
		l.beginPutAsyncRelativeRetryInvalidJSONPolling.add(req, beginPutAsyncRelativeRetryInvalidJSONPolling)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRelativeRetryInvalidJSONPolling, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRelativeRetryInvalidJSONPolling.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRelativeRetryInvalidJSONPolling) {
		l.beginPutAsyncRelativeRetryInvalidJSONPolling.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryNoStatus(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryNoStatus == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryNoStatus not implemented")}
	}
	beginPutAsyncRelativeRetryNoStatus := l.beginPutAsyncRelativeRetryNoStatus.get(req)
	if beginPutAsyncRelativeRetryNoStatus == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryNoStatus(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRelativeRetryNoStatus = &respr
		l.beginPutAsyncRelativeRetryNoStatus.add(req, beginPutAsyncRelativeRetryNoStatus)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRelativeRetryNoStatus, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRelativeRetryNoStatus.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRelativeRetryNoStatus) {
		l.beginPutAsyncRelativeRetryNoStatus.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutAsyncRelativeRetryNoStatusPayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutAsyncRelativeRetryNoStatusPayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutAsyncRelativeRetryNoStatusPayload not implemented")}
	}
	beginPutAsyncRelativeRetryNoStatusPayload := l.beginPutAsyncRelativeRetryNoStatusPayload.get(req)
	if beginPutAsyncRelativeRetryNoStatusPayload == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutAsyncRelativeRetryNoStatusPayload(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutAsyncRelativeRetryNoStatusPayload = &respr
		l.beginPutAsyncRelativeRetryNoStatusPayload.add(req, beginPutAsyncRelativeRetryNoStatusPayload)
	}

	resp, err := server.PollerResponderNext(beginPutAsyncRelativeRetryNoStatusPayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		l.beginPutAsyncRelativeRetryNoStatusPayload.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutAsyncRelativeRetryNoStatusPayload) {
		l.beginPutAsyncRelativeRetryNoStatusPayload.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutError201NoProvisioningStatePayload(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutError201NoProvisioningStatePayload == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutError201NoProvisioningStatePayload not implemented")}
	}
	beginPutError201NoProvisioningStatePayload := l.beginPutError201NoProvisioningStatePayload.get(req)
	if beginPutError201NoProvisioningStatePayload == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutError201NoProvisioningStatePayload(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutError201NoProvisioningStatePayload = &respr
		l.beginPutError201NoProvisioningStatePayload.add(req, beginPutError201NoProvisioningStatePayload)
	}

	resp, err := server.PollerResponderNext(beginPutError201NoProvisioningStatePayload, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPutError201NoProvisioningStatePayload.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutError201NoProvisioningStatePayload) {
		l.beginPutError201NoProvisioningStatePayload.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutNonRetry201Creating400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonRetry201Creating400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonRetry201Creating400 not implemented")}
	}
	beginPutNonRetry201Creating400 := l.beginPutNonRetry201Creating400.get(req)
	if beginPutNonRetry201Creating400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonRetry201Creating400(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutNonRetry201Creating400 = &respr
		l.beginPutNonRetry201Creating400.add(req, beginPutNonRetry201Creating400)
	}

	resp, err := server.PollerResponderNext(beginPutNonRetry201Creating400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPutNonRetry201Creating400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutNonRetry201Creating400) {
		l.beginPutNonRetry201Creating400.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutNonRetry201Creating400InvalidJSON(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonRetry201Creating400InvalidJSON == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonRetry201Creating400InvalidJSON not implemented")}
	}
	beginPutNonRetry201Creating400InvalidJSON := l.beginPutNonRetry201Creating400InvalidJSON.get(req)
	if beginPutNonRetry201Creating400InvalidJSON == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonRetry201Creating400InvalidJSON(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutNonRetry201Creating400InvalidJSON = &respr
		l.beginPutNonRetry201Creating400InvalidJSON.add(req, beginPutNonRetry201Creating400InvalidJSON)
	}

	resp, err := server.PollerResponderNext(beginPutNonRetry201Creating400InvalidJSON, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPutNonRetry201Creating400InvalidJSON.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutNonRetry201Creating400InvalidJSON) {
		l.beginPutNonRetry201Creating400InvalidJSON.remove(req)
	}

	return resp, nil
}

func (l *LROSADsServerTransport) dispatchBeginPutNonRetry400(req *http.Request) (*http.Response, error) {
	if l.srv.BeginPutNonRetry400 == nil {
		return nil, &nonRetriableError{errors.New("fake for method BeginPutNonRetry400 not implemented")}
	}
	beginPutNonRetry400 := l.beginPutNonRetry400.get(req)
	if beginPutNonRetry400 == nil {
		body, err := server.UnmarshalRequestAsJSON[lrogroup.Product](req)
		if err != nil {
			return nil, err
		}
		respr, errRespr := l.srv.BeginPutNonRetry400(req.Context(), body, nil)
		if respErr := server.GetError(errRespr, req); respErr != nil {
			return nil, respErr
		}
		beginPutNonRetry400 = &respr
		l.beginPutNonRetry400.add(req, beginPutNonRetry400)
	}

	resp, err := server.PollerResponderNext(beginPutNonRetry400, req)
	if err != nil {
		return nil, err
	}

	if !contains([]int{http.StatusOK, http.StatusCreated}, resp.StatusCode) {
		l.beginPutNonRetry400.remove(req)
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusCreated", resp.StatusCode)}
	}
	if !server.PollerResponderMore(beginPutNonRetry400) {
		l.beginPutNonRetry400.remove(req)
	}

	return resp, nil
}
