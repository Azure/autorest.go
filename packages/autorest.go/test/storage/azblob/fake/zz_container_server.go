//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package fake

import (
	"azblob"
	"context"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"io"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// ContainerServer is a fake server for instances of the azblob.ContainerClient type.
type ContainerServer struct {
	// AcquireLease is the fake for method ContainerClient.AcquireLease
	// HTTP status codes to indicate success: http.StatusCreated
	AcquireLease func(ctx context.Context, containerName string, comp azblob.Enum16, restype azblob.Enum11, options *azblob.ContainerClientAcquireLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientAcquireLeaseResponse], errResp azfake.ErrorResponder)

	// BreakLease is the fake for method ContainerClient.BreakLease
	// HTTP status codes to indicate success: http.StatusAccepted
	BreakLease func(ctx context.Context, containerName string, comp azblob.Enum16, restype azblob.Enum11, options *azblob.ContainerClientBreakLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientBreakLeaseResponse], errResp azfake.ErrorResponder)

	// ChangeLease is the fake for method ContainerClient.ChangeLease
	// HTTP status codes to indicate success: http.StatusOK
	ChangeLease func(ctx context.Context, containerName string, comp azblob.Enum16, restype azblob.Enum11, leaseID string, proposedLeaseID string, options *azblob.ContainerClientChangeLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientChangeLeaseResponse], errResp azfake.ErrorResponder)

	// Create is the fake for method ContainerClient.Create
	// HTTP status codes to indicate success: http.StatusCreated
	Create func(ctx context.Context, containerName string, restype azblob.Enum11, options *azblob.ContainerClientCreateOptions, containerCpkScopeInfo *azblob.ContainerCpkScopeInfo) (resp azfake.Responder[azblob.ContainerClientCreateResponse], errResp azfake.ErrorResponder)

	// Delete is the fake for method ContainerClient.Delete
	// HTTP status codes to indicate success: http.StatusAccepted
	Delete func(ctx context.Context, containerName string, restype azblob.Enum11, options *azblob.ContainerClientDeleteOptions, leaseAccessConditions *azblob.LeaseAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientDeleteResponse], errResp azfake.ErrorResponder)

	// FilterBlobs is the fake for method ContainerClient.FilterBlobs
	// HTTP status codes to indicate success: http.StatusOK
	FilterBlobs func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum10, options *azblob.ContainerClientFilterBlobsOptions) (resp azfake.Responder[azblob.ContainerClientFilterBlobsResponse], errResp azfake.ErrorResponder)

	// GetAccessPolicy is the fake for method ContainerClient.GetAccessPolicy
	// HTTP status codes to indicate success: http.StatusOK
	GetAccessPolicy func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum13, options *azblob.ContainerClientGetAccessPolicyOptions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ContainerClientGetAccessPolicyResponse], errResp azfake.ErrorResponder)

	// GetAccountInfo is the fake for method ContainerClient.GetAccountInfo
	// HTTP status codes to indicate success: http.StatusOK
	GetAccountInfo func(ctx context.Context, containerName string, restype azblob.Enum8, comp azblob.Enum1, options *azblob.ContainerClientGetAccountInfoOptions) (resp azfake.Responder[azblob.ContainerClientGetAccountInfoResponse], errResp azfake.ErrorResponder)

	// GetProperties is the fake for method ContainerClient.GetProperties
	// HTTP status codes to indicate success: http.StatusOK
	GetProperties func(ctx context.Context, containerName string, restype azblob.Enum11, options *azblob.ContainerClientGetPropertiesOptions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ContainerClientGetPropertiesResponse], errResp azfake.ErrorResponder)

	// NewListBlobFlatSegmentPager is the fake for method ContainerClient.NewListBlobFlatSegmentPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBlobFlatSegmentPager func(containerName string, restype azblob.Enum11, comp azblob.Enum5, options *azblob.ContainerClientListBlobFlatSegmentOptions) (resp azfake.PagerResponder[azblob.ContainerClientListBlobFlatSegmentResponse])

	// NewListBlobHierarchySegmentPager is the fake for method ContainerClient.NewListBlobHierarchySegmentPager
	// HTTP status codes to indicate success: http.StatusOK
	NewListBlobHierarchySegmentPager func(containerName string, restype azblob.Enum11, comp azblob.Enum5, delimiter string, options *azblob.ContainerClientListBlobHierarchySegmentOptions) (resp azfake.PagerResponder[azblob.ContainerClientListBlobHierarchySegmentResponse])

	// ReleaseLease is the fake for method ContainerClient.ReleaseLease
	// HTTP status codes to indicate success: http.StatusOK
	ReleaseLease func(ctx context.Context, containerName string, comp azblob.Enum16, restype azblob.Enum11, leaseID string, options *azblob.ContainerClientReleaseLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientReleaseLeaseResponse], errResp azfake.ErrorResponder)

	// Rename is the fake for method ContainerClient.Rename
	// HTTP status codes to indicate success: http.StatusOK
	Rename func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum15, sourceContainerName string, options *azblob.ContainerClientRenameOptions) (resp azfake.Responder[azblob.ContainerClientRenameResponse], errResp azfake.ErrorResponder)

	// RenewLease is the fake for method ContainerClient.RenewLease
	// HTTP status codes to indicate success: http.StatusOK
	RenewLease func(ctx context.Context, containerName string, comp azblob.Enum16, restype azblob.Enum11, leaseID string, options *azblob.ContainerClientRenewLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientRenewLeaseResponse], errResp azfake.ErrorResponder)

	// Restore is the fake for method ContainerClient.Restore
	// HTTP status codes to indicate success: http.StatusCreated
	Restore func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum14, options *azblob.ContainerClientRestoreOptions) (resp azfake.Responder[azblob.ContainerClientRestoreResponse], errResp azfake.ErrorResponder)

	// SetAccessPolicy is the fake for method ContainerClient.SetAccessPolicy
	// HTTP status codes to indicate success: http.StatusOK
	SetAccessPolicy func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum13, options *azblob.ContainerClientSetAccessPolicyOptions, leaseAccessConditions *azblob.LeaseAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientSetAccessPolicyResponse], errResp azfake.ErrorResponder)

	// SetMetadata is the fake for method ContainerClient.SetMetadata
	// HTTP status codes to indicate success: http.StatusOK
	SetMetadata func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum12, options *azblob.ContainerClientSetMetadataOptions, leaseAccessConditions *azblob.LeaseAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ContainerClientSetMetadataResponse], errResp azfake.ErrorResponder)

	// SubmitBatch is the fake for method ContainerClient.SubmitBatch
	// HTTP status codes to indicate success: http.StatusAccepted
	SubmitBatch func(ctx context.Context, containerName string, restype azblob.Enum11, comp azblob.Enum9, contentLength int64, multipartContentType string, body io.ReadSeekCloser, options *azblob.ContainerClientSubmitBatchOptions) (resp azfake.Responder[azblob.ContainerClientSubmitBatchResponse], errResp azfake.ErrorResponder)
}

// NewContainerServerTransport creates a new instance of ContainerServerTransport with the provided implementation.
// The returned ContainerServerTransport instance is connected to an instance of azblob.ContainerClient by way of the
// undefined.Transporter field.
func NewContainerServerTransport(srv *ContainerServer) *ContainerServerTransport {
	return &ContainerServerTransport{srv: srv}
}

// ContainerServerTransport connects instances of azblob.ContainerClient to instances of ContainerServer.
// Don't use this type directly, use NewContainerServerTransport instead.
type ContainerServerTransport struct {
	srv                              *ContainerServer
	newListBlobFlatSegmentPager      *azfake.PagerResponder[azblob.ContainerClientListBlobFlatSegmentResponse]
	newListBlobHierarchySegmentPager *azfake.PagerResponder[azblob.ContainerClientListBlobHierarchySegmentResponse]
}

// Do implements the policy.Transporter interface for ContainerServerTransport.
func (c *ContainerServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "ContainerClient.AcquireLease":
		resp, err = c.dispatchAcquireLease(req)
	case "ContainerClient.BreakLease":
		resp, err = c.dispatchBreakLease(req)
	case "ContainerClient.ChangeLease":
		resp, err = c.dispatchChangeLease(req)
	case "ContainerClient.Create":
		resp, err = c.dispatchCreate(req)
	case "ContainerClient.Delete":
		resp, err = c.dispatchDelete(req)
	case "ContainerClient.FilterBlobs":
		resp, err = c.dispatchFilterBlobs(req)
	case "ContainerClient.GetAccessPolicy":
		resp, err = c.dispatchGetAccessPolicy(req)
	case "ContainerClient.GetAccountInfo":
		resp, err = c.dispatchGetAccountInfo(req)
	case "ContainerClient.GetProperties":
		resp, err = c.dispatchGetProperties(req)
	case "ContainerClient.NewListBlobFlatSegmentPager":
		resp, err = c.dispatchNewListBlobFlatSegmentPager(req)
	case "ContainerClient.NewListBlobHierarchySegmentPager":
		resp, err = c.dispatchNewListBlobHierarchySegmentPager(req)
	case "ContainerClient.ReleaseLease":
		resp, err = c.dispatchReleaseLease(req)
	case "ContainerClient.Rename":
		resp, err = c.dispatchRename(req)
	case "ContainerClient.RenewLease":
		resp, err = c.dispatchRenewLease(req)
	case "ContainerClient.Restore":
		resp, err = c.dispatchRestore(req)
	case "ContainerClient.SetAccessPolicy":
		resp, err = c.dispatchSetAccessPolicy(req)
	case "ContainerClient.SetMetadata":
		resp, err = c.dispatchSetMetadata(req)
	case "ContainerClient.SubmitBatch":
		resp, err = c.dispatchSubmitBatch(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (c *ContainerServerTransport) dispatchAcquireLease(req *http.Request) (*http.Response, error) {
	if c.srv.AcquireLease == nil {
		return nil, &nonRetriableError{errors.New("method AcquireLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	durationParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-lease-duration"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	proposedLeaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-proposed-lease-id"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientAcquireLeaseOptions
	if timeoutParam != nil || durationParam != nil || proposedLeaseIDParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientAcquireLeaseOptions{
			Timeout:         timeoutParam,
			Duration:        durationParam,
			ProposedLeaseID: proposedLeaseIDParam,
			RequestID:       requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.AcquireLease(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum16(qp.Get("comp")), azblob.Enum11(qp.Get("restype")), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseID; val != nil {
		resp.Header.Set("x-ms-lease-id", *val)
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchBreakLease(req *http.Request) (*http.Response, error) {
	if c.srv.BreakLease == nil {
		return nil, &nonRetriableError{errors.New("method BreakLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	breakPeriodParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-lease-break-period"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientBreakLeaseOptions
	if timeoutParam != nil || breakPeriodParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientBreakLeaseOptions{
			Timeout:     timeoutParam,
			BreakPeriod: breakPeriodParam,
			RequestID:   requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.BreakLease(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum16(qp.Get("comp")), azblob.Enum11(qp.Get("restype")), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseTime; val != nil {
		resp.Header.Set("x-ms-lease-time", strconv.FormatInt(int64(*val), 10))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchChangeLease(req *http.Request) (*http.Response, error) {
	if c.srv.ChangeLease == nil {
		return nil, &nonRetriableError{errors.New("method ChangeLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientChangeLeaseOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientChangeLeaseOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.ChangeLease(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum16(qp.Get("comp")), azblob.Enum11(qp.Get("restype")), getHeaderValue(req.Header, "x-ms-lease-id"), getHeaderValue(req.Header, "x-ms-proposed-lease-id"), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseID; val != nil {
		resp.Header.Set("x-ms-lease-id", *val)
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchCreate(req *http.Request) (*http.Response, error) {
	if c.srv.Create == nil {
		return nil, &nonRetriableError{errors.New("method Create not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var metadataParam map[string]*string
	for hh := range req.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if metadataParam == nil {
				metadataParam = map[string]*string{}
			}
			metadataParam[hh[len("x-ms-meta-"):]] = to.Ptr(getHeaderValue(req.Header, hh))
		}
	}
	accessParam := getOptional(azblob.PublicAccessType(getHeaderValue(req.Header, "x-ms-blob-public-access")))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	defaultEncryptionScopeParam := getOptional(getHeaderValue(req.Header, "x-ms-default-encryption-scope"))
	preventEncryptionScopeOverrideParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-deny-encryption-scope-override"), strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	var options *azblob.ContainerClientCreateOptions
	if timeoutParam != nil || metadataParam != nil || accessParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientCreateOptions{
			Timeout:   timeoutParam,
			Metadata:  metadataParam,
			Access:    accessParam,
			RequestID: requestIDParam,
		}
	}
	var containerCpkScopeInfo *azblob.ContainerCpkScopeInfo
	if defaultEncryptionScopeParam != nil || preventEncryptionScopeOverrideParam != nil {
		containerCpkScopeInfo = &azblob.ContainerCpkScopeInfo{
			DefaultEncryptionScope:         defaultEncryptionScopeParam,
			PreventEncryptionScopeOverride: preventEncryptionScopeOverrideParam,
		}
	}
	respr, errRespr := c.srv.Create(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), options, containerCpkScopeInfo)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchDelete(req *http.Request) (*http.Response, error) {
	if c.srv.Delete == nil {
		return nil, &nonRetriableError{errors.New("method Delete not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientDeleteOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientDeleteOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.Delete(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), options, leaseAccessConditions, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchFilterBlobs(req *http.Request) (*http.Response, error) {
	if c.srv.FilterBlobs == nil {
		return nil, &nonRetriableError{errors.New("method FilterBlobs not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	whereParam := getOptional(qp.Get("where"))
	markerParam := getOptional(qp.Get("marker"))
	maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	elements := strings.Split(qp.Get("include"), ",")
	includeParam := make([]azblob.FilterBlobsIncludeItem, len(elements))
	for i := 0; i < len(elements); i++ {
		includeParam[i] = azblob.FilterBlobsIncludeItem(elements[i])
	}
	var options *azblob.ContainerClientFilterBlobsOptions
	if timeoutParam != nil || requestIDParam != nil || whereParam != nil || markerParam != nil || maxresultsParam != nil || len(includeParam) > 0 {
		options = &azblob.ContainerClientFilterBlobsOptions{
			Timeout:    timeoutParam,
			RequestID:  requestIDParam,
			Where:      whereParam,
			Marker:     markerParam,
			Maxresults: maxresultsParam,
			Include:    includeParam,
		}
	}
	respr, errRespr := c.srv.FilterBlobs(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum10(qp.Get("comp")), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsXML(respContent, server.GetResponse(respr).FilterBlobSegment, req)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchGetAccessPolicy(req *http.Request) (*http.Response, error) {
	if c.srv.GetAccessPolicy == nil {
		return nil, &nonRetriableError{errors.New("method GetAccessPolicy not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientGetAccessPolicyOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientGetAccessPolicyOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := c.srv.GetAccessPolicy(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum13(qp.Get("comp")), options, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsXML(respContent, server.GetResponse(respr), req)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).BlobPublicAccess; val != nil {
		resp.Header.Set("x-ms-blob-public-access", string(*val))
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchGetAccountInfo(req *http.Request) (*http.Response, error) {
	if c.srv.GetAccountInfo == nil {
		return nil, &nonRetriableError{errors.New("method GetAccountInfo not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	respr, errRespr := c.srv.GetAccountInfo(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum8(qp.Get("restype")), azblob.Enum1(qp.Get("comp")), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).SKUName; val != nil {
		resp.Header.Set("x-ms-sku-name", string(*val))
	}
	if val := server.GetResponse(respr).AccountKind; val != nil {
		resp.Header.Set("x-ms-account-kind", string(*val))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchGetProperties(req *http.Request) (*http.Response, error) {
	if c.srv.GetProperties == nil {
		return nil, &nonRetriableError{errors.New("method GetProperties not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientGetPropertiesOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientGetPropertiesOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := c.srv.GetProperties(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), options, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	for k, v := range server.GetResponse(respr).Metadata {
		if v != nil {
			resp.Header.Set("x-ms-meta-"+k, *v)
		}
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseDuration; val != nil {
		resp.Header.Set("x-ms-lease-duration", string(*val))
	}
	if val := server.GetResponse(respr).LeaseState; val != nil {
		resp.Header.Set("x-ms-lease-state", string(*val))
	}
	if val := server.GetResponse(respr).LeaseStatus; val != nil {
		resp.Header.Set("x-ms-lease-status", string(*val))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).BlobPublicAccess; val != nil {
		resp.Header.Set("x-ms-blob-public-access", string(*val))
	}
	if val := server.GetResponse(respr).HasImmutabilityPolicy; val != nil {
		resp.Header.Set("x-ms-has-immutability-policy", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).HasLegalHold; val != nil {
		resp.Header.Set("x-ms-has-legal-hold", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).DefaultEncryptionScope; val != nil {
		resp.Header.Set("x-ms-default-encryption-scope", *val)
	}
	if val := server.GetResponse(respr).DenyEncryptionScopeOverride; val != nil {
		resp.Header.Set("x-ms-deny-encryption-scope-override", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).IsImmutableStorageWithVersioningEnabled; val != nil {
		resp.Header.Set("x-ms-immutable-storage-with-versioning-enabled", strconv.FormatBool(*val))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchNewListBlobFlatSegmentPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListBlobFlatSegmentPager == nil {
		return nil, &nonRetriableError{errors.New("method NewListBlobFlatSegmentPager not implemented")}
	}
	if c.newListBlobFlatSegmentPager == nil {
		const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		prefixParam := getOptional(qp.Get("prefix"))
		markerParam := getOptional(qp.Get("marker"))
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, parseErr := strconv.ParseInt(v, 10, 32)
			if parseErr != nil {
				return 0, parseErr
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		elements := strings.Split(qp.Get("include"), ",")
		includeParam := make([]azblob.ListBlobsIncludeItem, len(elements))
		for i := 0; i < len(elements); i++ {
			includeParam[i] = azblob.ListBlobsIncludeItem(elements[i])
		}
		timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
			p, parseErr := strconv.ParseInt(v, 10, 32)
			if parseErr != nil {
				return 0, parseErr
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
		var options *azblob.ContainerClientListBlobFlatSegmentOptions
		if prefixParam != nil || markerParam != nil || maxresultsParam != nil || len(includeParam) > 0 || timeoutParam != nil || requestIDParam != nil {
			options = &azblob.ContainerClientListBlobFlatSegmentOptions{
				Prefix:     prefixParam,
				Marker:     markerParam,
				Maxresults: maxresultsParam,
				Include:    includeParam,
				Timeout:    timeoutParam,
				RequestID:  requestIDParam,
			}
		}
		resp := c.srv.NewListBlobFlatSegmentPager(matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum5(qp.Get("comp")), options)
		c.newListBlobFlatSegmentPager = &resp
		server.PagerResponderInjectNextLinks(c.newListBlobFlatSegmentPager, req, func(page *azblob.ContainerClientListBlobFlatSegmentResponse, createLink func() string) {
			page.NextMarker = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(c.newListBlobFlatSegmentPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(c.newListBlobFlatSegmentPager) {
		c.newListBlobFlatSegmentPager = nil
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchNewListBlobHierarchySegmentPager(req *http.Request) (*http.Response, error) {
	if c.srv.NewListBlobHierarchySegmentPager == nil {
		return nil, &nonRetriableError{errors.New("method NewListBlobHierarchySegmentPager not implemented")}
	}
	if c.newListBlobHierarchySegmentPager == nil {
		const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
		regex := regexp.MustCompile(regexStr)
		matches := regex.FindStringSubmatch(req.URL.Path)
		if matches == nil || len(matches) < 1 {
			return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
		}
		qp := req.URL.Query()
		prefixParam := getOptional(qp.Get("prefix"))
		markerParam := getOptional(qp.Get("marker"))
		maxresultsParam, err := parseOptional(qp.Get("maxresults"), func(v string) (int32, error) {
			p, parseErr := strconv.ParseInt(v, 10, 32)
			if parseErr != nil {
				return 0, parseErr
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		elements := strings.Split(qp.Get("include"), ",")
		includeParam := make([]azblob.ListBlobsIncludeItem, len(elements))
		for i := 0; i < len(elements); i++ {
			includeParam[i] = azblob.ListBlobsIncludeItem(elements[i])
		}
		timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
			p, parseErr := strconv.ParseInt(v, 10, 32)
			if parseErr != nil {
				return 0, parseErr
			}
			return int32(p), nil
		})
		if err != nil {
			return nil, err
		}
		requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
		var options *azblob.ContainerClientListBlobHierarchySegmentOptions
		if prefixParam != nil || markerParam != nil || maxresultsParam != nil || len(includeParam) > 0 || timeoutParam != nil || requestIDParam != nil {
			options = &azblob.ContainerClientListBlobHierarchySegmentOptions{
				Prefix:     prefixParam,
				Marker:     markerParam,
				Maxresults: maxresultsParam,
				Include:    includeParam,
				Timeout:    timeoutParam,
				RequestID:  requestIDParam,
			}
		}
		resp := c.srv.NewListBlobHierarchySegmentPager(matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum5(qp.Get("comp")), qp.Get("delimiter"), options)
		c.newListBlobHierarchySegmentPager = &resp
		server.PagerResponderInjectNextLinks(c.newListBlobHierarchySegmentPager, req, func(page *azblob.ContainerClientListBlobHierarchySegmentResponse, createLink func() string) {
			page.NextMarker = to.Ptr(createLink())
		})
	}
	resp, err := server.PagerResponderNext(c.newListBlobHierarchySegmentPager, req)
	if err != nil {
		return nil, err
	}
	if !contains([]int{http.StatusOK}, resp.StatusCode) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", resp.StatusCode)}
	}
	if !server.PagerResponderMore(c.newListBlobHierarchySegmentPager) {
		c.newListBlobHierarchySegmentPager = nil
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchReleaseLease(req *http.Request) (*http.Response, error) {
	if c.srv.ReleaseLease == nil {
		return nil, &nonRetriableError{errors.New("method ReleaseLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientReleaseLeaseOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientReleaseLeaseOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.ReleaseLease(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum16(qp.Get("comp")), azblob.Enum11(qp.Get("restype")), getHeaderValue(req.Header, "x-ms-lease-id"), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchRename(req *http.Request) (*http.Response, error) {
	if c.srv.Rename == nil {
		return nil, &nonRetriableError{errors.New("method Rename not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	sourceLeaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-source-lease-id"))
	var options *azblob.ContainerClientRenameOptions
	if timeoutParam != nil || requestIDParam != nil || sourceLeaseIDParam != nil {
		options = &azblob.ContainerClientRenameOptions{
			Timeout:       timeoutParam,
			RequestID:     requestIDParam,
			SourceLeaseID: sourceLeaseIDParam,
		}
	}
	respr, errRespr := c.srv.Rename(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum15(qp.Get("comp")), getHeaderValue(req.Header, "x-ms-source-container-name"), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchRenewLease(req *http.Request) (*http.Response, error) {
	if c.srv.RenewLease == nil {
		return nil, &nonRetriableError{errors.New("method RenewLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientRenewLeaseOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientRenewLeaseOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.RenewLease(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum16(qp.Get("comp")), azblob.Enum11(qp.Get("restype")), getHeaderValue(req.Header, "x-ms-lease-id"), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseID; val != nil {
		resp.Header.Set("x-ms-lease-id", *val)
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchRestore(req *http.Request) (*http.Response, error) {
	if c.srv.Restore == nil {
		return nil, &nonRetriableError{errors.New("method Restore not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	deletedContainerNameParam := getOptional(getHeaderValue(req.Header, "x-ms-deleted-container-name"))
	deletedContainerVersionParam := getOptional(getHeaderValue(req.Header, "x-ms-deleted-container-version"))
	var options *azblob.ContainerClientRestoreOptions
	if timeoutParam != nil || requestIDParam != nil || deletedContainerNameParam != nil || deletedContainerVersionParam != nil {
		options = &azblob.ContainerClientRestoreOptions{
			Timeout:                 timeoutParam,
			RequestID:               requestIDParam,
			DeletedContainerName:    deletedContainerNameParam,
			DeletedContainerVersion: deletedContainerVersionParam,
		}
	}
	respr, errRespr := c.srv.Restore(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum14(qp.Get("comp")), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchSetAccessPolicy(req *http.Request) (*http.Response, error) {
	if c.srv.SetAccessPolicy == nil {
		return nil, &nonRetriableError{errors.New("method SetAccessPolicy not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsXML[[]*azblob.SignedIdentifier](req)
	if err != nil {
		return nil, err
	}
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	accessParam := getOptional(azblob.PublicAccessType(getHeaderValue(req.Header, "x-ms-blob-public-access")))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientSetAccessPolicyOptions
	if timeoutParam != nil || accessParam != nil || requestIDParam != nil || len(body) > 0 {
		options = &azblob.ContainerClientSetAccessPolicyOptions{
			Timeout:      timeoutParam,
			Access:       accessParam,
			RequestID:    requestIDParam,
			ContainerACL: body,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.SetAccessPolicy(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum13(qp.Get("comp")), options, leaseAccessConditions, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchSetMetadata(req *http.Request) (*http.Response, error) {
	if c.srv.SetMetadata == nil {
		return nil, &nonRetriableError{errors.New("method SetMetadata not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	var metadataParam map[string]*string
	for hh := range req.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if metadataParam == nil {
				metadataParam = map[string]*string{}
			}
			metadataParam[hh[len("x-ms-meta-"):]] = to.Ptr(getHeaderValue(req.Header, hh))
		}
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientSetMetadataOptions
	if timeoutParam != nil || metadataParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientSetMetadataOptions{
			Timeout:   timeoutParam,
			Metadata:  metadataParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince: ifModifiedSinceParam,
		}
	}
	respr, errRespr := c.srv.SetMetadata(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum12(qp.Get("comp")), options, leaseAccessConditions, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (c *ContainerServerTransport) dispatchSubmitBatch(req *http.Request) (*http.Response, error) {
	if c.srv.SubmitBatch == nil {
		return nil, &nonRetriableError{errors.New("method SubmitBatch not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 1 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	contentLengthParam, err := strconv.ParseInt(getHeaderValue(req.Header, "Content-Length"), 10, 64)
	if err != nil {
		return nil, err
	}
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ContainerClientSubmitBatchOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ContainerClientSubmitBatchOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	respr, errRespr := c.srv.SubmitBatch(req.Context(), matches[regex.SubexpIndex("containerName")], azblob.Enum11(qp.Get("restype")), azblob.Enum9(qp.Get("comp")), contentLengthParam, getHeaderValue(req.Header, "Content-Type"), req.Body.(io.ReadSeekCloser), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, &server.ResponseOptions{
		Body:        server.GetResponse(respr).Body,
		ContentType: "application/octet-stream",
	})
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ContentType; val != nil {
		resp.Header.Set("Content-Type", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	return resp, nil
}
