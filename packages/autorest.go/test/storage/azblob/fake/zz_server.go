//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package fake

import (
	"azblob"
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	azfake "github.com/Azure/azure-sdk-for-go/sdk/azcore/fake"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/fake/server"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// Server is a fake server for instances of the azblob.Client type.
type Server struct {
	// AbortCopyFromURL is the fake for method Client.AbortCopyFromURL
	// HTTP status codes to indicate success: http.StatusNoContent
	AbortCopyFromURL func(ctx context.Context, containerName string, blob string, comp azblob.Enum27, copyActionAbortConstant azblob.Enum28, copyID string, options *azblob.ClientAbortCopyFromURLOptions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ClientAbortCopyFromURLResponse], errResp azfake.ErrorResponder)

	// AcquireLease is the fake for method Client.AcquireLease
	// HTTP status codes to indicate success: http.StatusCreated
	AcquireLease func(ctx context.Context, containerName string, blob string, comp azblob.Enum16, options *azblob.ClientAcquireLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientAcquireLeaseResponse], errResp azfake.ErrorResponder)

	// BreakLease is the fake for method Client.BreakLease
	// HTTP status codes to indicate success: http.StatusAccepted
	BreakLease func(ctx context.Context, containerName string, blob string, comp azblob.Enum16, options *azblob.ClientBreakLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientBreakLeaseResponse], errResp azfake.ErrorResponder)

	// ChangeLease is the fake for method Client.ChangeLease
	// HTTP status codes to indicate success: http.StatusOK
	ChangeLease func(ctx context.Context, containerName string, blob string, comp azblob.Enum16, leaseID string, proposedLeaseID string, options *azblob.ClientChangeLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientChangeLeaseResponse], errResp azfake.ErrorResponder)

	// CopyFromURL is the fake for method Client.CopyFromURL
	// HTTP status codes to indicate success: http.StatusAccepted
	CopyFromURL func(ctx context.Context, containerName string, blob string, xmsRequiresSync azblob.Enum26, copySource string, options *azblob.ClientCopyFromURLOptions, sourceModifiedAccessConditions *azblob.SourceModifiedAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions, leaseAccessConditions *azblob.LeaseAccessConditions, cpkScopeInfo *azblob.CpkScopeInfo) (resp azfake.Responder[azblob.ClientCopyFromURLResponse], errResp azfake.ErrorResponder)

	// CreateSnapshot is the fake for method Client.CreateSnapshot
	// HTTP status codes to indicate success: http.StatusCreated
	CreateSnapshot func(ctx context.Context, containerName string, blob string, comp azblob.Enum25, options *azblob.ClientCreateSnapshotOptions, cpkInfo *azblob.CpkInfo, cpkScopeInfo *azblob.CpkScopeInfo, modifiedAccessConditions *azblob.ModifiedAccessConditions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ClientCreateSnapshotResponse], errResp azfake.ErrorResponder)

	// Delete is the fake for method Client.Delete
	// HTTP status codes to indicate success: http.StatusAccepted
	Delete func(ctx context.Context, containerName string, blob string, options *azblob.ClientDeleteOptions, leaseAccessConditions *azblob.LeaseAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientDeleteResponse], errResp azfake.ErrorResponder)

	// DeleteImmutabilityPolicy is the fake for method Client.DeleteImmutabilityPolicy
	// HTTP status codes to indicate success: http.StatusOK
	DeleteImmutabilityPolicy func(ctx context.Context, containerName string, blob string, comp azblob.Enum23, options *azblob.ClientDeleteImmutabilityPolicyOptions) (resp azfake.Responder[azblob.ClientDeleteImmutabilityPolicyResponse], errResp azfake.ErrorResponder)

	// Download is the fake for method Client.Download
	// HTTP status codes to indicate success: http.StatusOK, http.StatusPartialContent
	Download func(ctx context.Context, containerName string, blob string, options *azblob.ClientDownloadOptions, leaseAccessConditions *azblob.LeaseAccessConditions, cpkInfo *azblob.CpkInfo, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientDownloadResponse], errResp azfake.ErrorResponder)

	// GetAccountInfo is the fake for method Client.GetAccountInfo
	// HTTP status codes to indicate success: http.StatusOK
	GetAccountInfo func(ctx context.Context, containerName string, blob string, restype azblob.Enum8, comp azblob.Enum1, options *azblob.ClientGetAccountInfoOptions) (resp azfake.Responder[azblob.ClientGetAccountInfoResponse], errResp azfake.ErrorResponder)

	// GetProperties is the fake for method Client.GetProperties
	// HTTP status codes to indicate success: http.StatusOK
	GetProperties func(ctx context.Context, containerName string, blob string, options *azblob.ClientGetPropertiesOptions, leaseAccessConditions *azblob.LeaseAccessConditions, cpkInfo *azblob.CpkInfo, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientGetPropertiesResponse], errResp azfake.ErrorResponder)

	// GetTags is the fake for method Client.GetTags
	// HTTP status codes to indicate success: http.StatusOK
	GetTags func(ctx context.Context, containerName string, blob string, comp azblob.Enum39, options *azblob.ClientGetTagsOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ClientGetTagsResponse], errResp azfake.ErrorResponder)

	// Query is the fake for method Client.Query
	// HTTP status codes to indicate success: http.StatusOK, http.StatusPartialContent
	Query func(ctx context.Context, containerName string, blob string, comp azblob.Enum37, options *azblob.ClientQueryOptions, leaseAccessConditions *azblob.LeaseAccessConditions, cpkInfo *azblob.CpkInfo, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientQueryResponse], errResp azfake.ErrorResponder)

	// ReleaseLease is the fake for method Client.ReleaseLease
	// HTTP status codes to indicate success: http.StatusOK
	ReleaseLease func(ctx context.Context, containerName string, blob string, comp azblob.Enum16, leaseID string, options *azblob.ClientReleaseLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientReleaseLeaseResponse], errResp azfake.ErrorResponder)

	// RenewLease is the fake for method Client.RenewLease
	// HTTP status codes to indicate success: http.StatusOK
	RenewLease func(ctx context.Context, containerName string, blob string, comp azblob.Enum16, leaseID string, options *azblob.ClientRenewLeaseOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientRenewLeaseResponse], errResp azfake.ErrorResponder)

	// SetExpiry is the fake for method Client.SetExpiry
	// HTTP status codes to indicate success: http.StatusOK
	SetExpiry func(ctx context.Context, containerName string, blob string, comp azblob.Enum21, expiryOptions azblob.BlobExpiryOptions, options *azblob.ClientSetExpiryOptions) (resp azfake.Responder[azblob.ClientSetExpiryResponse], errResp azfake.ErrorResponder)

	// SetHTTPHeaders is the fake for method Client.SetHTTPHeaders
	// HTTP status codes to indicate success: http.StatusOK
	SetHTTPHeaders func(ctx context.Context, containerName string, blob string, comp azblob.Enum1, options *azblob.ClientSetHTTPHeadersOptions, blobHTTPHeaders *azblob.BlobHTTPHeaders, leaseAccessConditions *azblob.LeaseAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientSetHTTPHeadersResponse], errResp azfake.ErrorResponder)

	// SetImmutabilityPolicy is the fake for method Client.SetImmutabilityPolicy
	// HTTP status codes to indicate success: http.StatusOK
	SetImmutabilityPolicy func(ctx context.Context, containerName string, blob string, comp azblob.Enum23, options *azblob.ClientSetImmutabilityPolicyOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientSetImmutabilityPolicyResponse], errResp azfake.ErrorResponder)

	// SetLegalHold is the fake for method Client.SetLegalHold
	// HTTP status codes to indicate success: http.StatusOK
	SetLegalHold func(ctx context.Context, containerName string, blob string, comp azblob.Enum24, legalHold bool, options *azblob.ClientSetLegalHoldOptions) (resp azfake.Responder[azblob.ClientSetLegalHoldResponse], errResp azfake.ErrorResponder)

	// SetMetadata is the fake for method Client.SetMetadata
	// HTTP status codes to indicate success: http.StatusOK
	SetMetadata func(ctx context.Context, containerName string, blob string, comp azblob.Enum12, options *azblob.ClientSetMetadataOptions, leaseAccessConditions *azblob.LeaseAccessConditions, cpkInfo *azblob.CpkInfo, cpkScopeInfo *azblob.CpkScopeInfo, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientSetMetadataResponse], errResp azfake.ErrorResponder)

	// SetTags is the fake for method Client.SetTags
	// HTTP status codes to indicate success: http.StatusNoContent
	SetTags func(ctx context.Context, containerName string, blob string, comp azblob.Enum39, options *azblob.ClientSetTagsOptions, modifiedAccessConditions *azblob.ModifiedAccessConditions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ClientSetTagsResponse], errResp azfake.ErrorResponder)

	// SetTier is the fake for method Client.SetTier
	// HTTP status codes to indicate success: http.StatusOK, http.StatusAccepted
	SetTier func(ctx context.Context, containerName string, blob string, comp azblob.Enum29, tier azblob.AccessTier, options *azblob.ClientSetTierOptions, leaseAccessConditions *azblob.LeaseAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions) (resp azfake.Responder[azblob.ClientSetTierResponse], errResp azfake.ErrorResponder)

	// StartCopyFromURL is the fake for method Client.StartCopyFromURL
	// HTTP status codes to indicate success: http.StatusAccepted
	StartCopyFromURL func(ctx context.Context, containerName string, blob string, copySource string, options *azblob.ClientStartCopyFromURLOptions, sourceModifiedAccessConditions *azblob.SourceModifiedAccessConditions, modifiedAccessConditions *azblob.ModifiedAccessConditions, leaseAccessConditions *azblob.LeaseAccessConditions) (resp azfake.Responder[azblob.ClientStartCopyFromURLResponse], errResp azfake.ErrorResponder)

	// Undelete is the fake for method Client.Undelete
	// HTTP status codes to indicate success: http.StatusOK
	Undelete func(ctx context.Context, containerName string, blob string, comp azblob.Enum14, options *azblob.ClientUndeleteOptions) (resp azfake.Responder[azblob.ClientUndeleteResponse], errResp azfake.ErrorResponder)
}

// NewServerTransport creates a new instance of ServerTransport with the provided implementation.
// The returned ServerTransport instance is connected to an instance of azblob.Client by way of the
// undefined.Transporter field.
func NewServerTransport(srv *Server) *ServerTransport {
	return &ServerTransport{srv: srv}
}

// ServerTransport connects instances of azblob.Client to instances of Server.
// Don't use this type directly, use NewServerTransport instead.
type ServerTransport struct {
	srv *Server
}

// Do implements the policy.Transporter interface for ServerTransport.
func (s *ServerTransport) Do(req *http.Request) (*http.Response, error) {
	rawMethod := req.Context().Value(runtime.CtxAPINameKey{})
	method, ok := rawMethod.(string)
	if !ok {
		return nil, nonRetriableError{errors.New("unable to dispatch request, missing value for CtxAPINameKey")}
	}

	var resp *http.Response
	var err error

	switch method {
	case "Client.AbortCopyFromURL":
		resp, err = s.dispatchAbortCopyFromURL(req)
	case "Client.AcquireLease":
		resp, err = s.dispatchAcquireLease(req)
	case "Client.BreakLease":
		resp, err = s.dispatchBreakLease(req)
	case "Client.ChangeLease":
		resp, err = s.dispatchChangeLease(req)
	case "Client.CopyFromURL":
		resp, err = s.dispatchCopyFromURL(req)
	case "Client.CreateSnapshot":
		resp, err = s.dispatchCreateSnapshot(req)
	case "Client.Delete":
		resp, err = s.dispatchDelete(req)
	case "Client.DeleteImmutabilityPolicy":
		resp, err = s.dispatchDeleteImmutabilityPolicy(req)
	case "Client.Download":
		resp, err = s.dispatchDownload(req)
	case "Client.GetAccountInfo":
		resp, err = s.dispatchGetAccountInfo(req)
	case "Client.GetProperties":
		resp, err = s.dispatchGetProperties(req)
	case "Client.GetTags":
		resp, err = s.dispatchGetTags(req)
	case "Client.Query":
		resp, err = s.dispatchQuery(req)
	case "Client.ReleaseLease":
		resp, err = s.dispatchReleaseLease(req)
	case "Client.RenewLease":
		resp, err = s.dispatchRenewLease(req)
	case "Client.SetExpiry":
		resp, err = s.dispatchSetExpiry(req)
	case "Client.SetHTTPHeaders":
		resp, err = s.dispatchSetHTTPHeaders(req)
	case "Client.SetImmutabilityPolicy":
		resp, err = s.dispatchSetImmutabilityPolicy(req)
	case "Client.SetLegalHold":
		resp, err = s.dispatchSetLegalHold(req)
	case "Client.SetMetadata":
		resp, err = s.dispatchSetMetadata(req)
	case "Client.SetTags":
		resp, err = s.dispatchSetTags(req)
	case "Client.SetTier":
		resp, err = s.dispatchSetTier(req)
	case "Client.StartCopyFromURL":
		resp, err = s.dispatchStartCopyFromURL(req)
	case "Client.Undelete":
		resp, err = s.dispatchUndelete(req)
	default:
		err = fmt.Errorf("unhandled API %s", method)
	}

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (s *ServerTransport) dispatchAbortCopyFromURL(req *http.Request) (*http.Response, error) {
	if s.srv.AbortCopyFromURL == nil {
		return nil, &nonRetriableError{errors.New("method AbortCopyFromURL not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientAbortCopyFromURLOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientAbortCopyFromURLOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := s.srv.AbortCopyFromURL(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum27(qp.Get("comp")), azblob.Enum28(getHeaderValue(req.Header, "x-ms-copy-action")), qp.Get("copyid"), options, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchAcquireLease(req *http.Request) (*http.Response, error) {
	if s.srv.AcquireLease == nil {
		return nil, &nonRetriableError{errors.New("method AcquireLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	durationParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-lease-duration"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	proposedLeaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-proposed-lease-id"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientAcquireLeaseOptions
	if timeoutParam != nil || durationParam != nil || proposedLeaseIDParam != nil || requestIDParam != nil {
		options = &azblob.ClientAcquireLeaseOptions{
			Timeout:         timeoutParam,
			Duration:        durationParam,
			ProposedLeaseID: proposedLeaseIDParam,
			RequestID:       requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.AcquireLease(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum16(qp.Get("comp")), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseID; val != nil {
		resp.Header.Set("x-ms-lease-id", *val)
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchBreakLease(req *http.Request) (*http.Response, error) {
	if s.srv.BreakLease == nil {
		return nil, &nonRetriableError{errors.New("method BreakLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	breakPeriodParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-lease-break-period"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientBreakLeaseOptions
	if timeoutParam != nil || breakPeriodParam != nil || requestIDParam != nil {
		options = &azblob.ClientBreakLeaseOptions{
			Timeout:     timeoutParam,
			BreakPeriod: breakPeriodParam,
			RequestID:   requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.BreakLease(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum16(qp.Get("comp")), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseTime; val != nil {
		resp.Header.Set("x-ms-lease-time", strconv.FormatInt(int64(*val), 10))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchChangeLease(req *http.Request) (*http.Response, error) {
	if s.srv.ChangeLease == nil {
		return nil, &nonRetriableError{errors.New("method ChangeLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientChangeLeaseOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientChangeLeaseOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.ChangeLease(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum16(qp.Get("comp")), getHeaderValue(req.Header, "x-ms-lease-id"), getHeaderValue(req.Header, "x-ms-proposed-lease-id"), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).LeaseID; val != nil {
		resp.Header.Set("x-ms-lease-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchCopyFromURL(req *http.Request) (*http.Response, error) {
	if s.srv.CopyFromURL == nil {
		return nil, &nonRetriableError{errors.New("method CopyFromURL not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var metadataParam map[string]*string
	for hh := range req.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if metadataParam == nil {
				metadataParam = map[string]*string{}
			}
			metadataParam[hh[len("x-ms-meta-"):]] = to.Ptr(getHeaderValue(req.Header, hh))
		}
	}
	tierParam := getOptional(azblob.AccessTier(getHeaderValue(req.Header, "x-ms-access-tier")))
	sourceIfModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-source-if-modified-since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	sourceIfUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-source-if-unmodified-since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	sourceIfMatchParam := getOptional(getHeaderValue(req.Header, "x-ms-source-if-match"))
	sourceIfNoneMatchParam := getOptional(getHeaderValue(req.Header, "x-ms-source-if-none-match"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	sourceContentMD5Param, err := base64.StdEncoding.DecodeString(getHeaderValue(req.Header, "x-ms-source-content-md5"))
	if err != nil {
		return nil, err
	}
	blobTagsStringParam := getOptional(getHeaderValue(req.Header, "x-ms-tags"))
	immutabilityPolicyExpiryParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-immutability-policy-until-date"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	immutabilityPolicyModeParam := getOptional(azblob.BlobImmutabilityPolicyMode(getHeaderValue(req.Header, "x-ms-immutability-policy-mode")))
	legalHoldParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-legal-hold"), strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	copySourceAuthorizationParam := getOptional(getHeaderValue(req.Header, "x-ms-copy-source-authorization"))
	encryptionScopeParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-scope"))
	copySourceTagsParam := getOptional(azblob.BlobCopySourceTags(getHeaderValue(req.Header, "x-ms-copy-source-tag-option")))
	var options *azblob.ClientCopyFromURLOptions
	if timeoutParam != nil || metadataParam != nil || tierParam != nil || requestIDParam != nil || sourceContentMD5Param != nil || blobTagsStringParam != nil || immutabilityPolicyExpiryParam != nil || immutabilityPolicyModeParam != nil || legalHoldParam != nil || copySourceAuthorizationParam != nil || copySourceTagsParam != nil {
		options = &azblob.ClientCopyFromURLOptions{
			Timeout:                  timeoutParam,
			Metadata:                 metadataParam,
			Tier:                     tierParam,
			RequestID:                requestIDParam,
			SourceContentMD5:         sourceContentMD5Param,
			BlobTagsString:           blobTagsStringParam,
			ImmutabilityPolicyExpiry: immutabilityPolicyExpiryParam,
			ImmutabilityPolicyMode:   immutabilityPolicyModeParam,
			LegalHold:                legalHoldParam,
			CopySourceAuthorization:  copySourceAuthorizationParam,
			CopySourceTags:           copySourceTagsParam,
		}
	}
	var sourceModifiedAccessConditions *azblob.SourceModifiedAccessConditions
	if sourceIfModifiedSinceParam != nil || sourceIfUnmodifiedSinceParam != nil || sourceIfMatchParam != nil || sourceIfNoneMatchParam != nil {
		sourceModifiedAccessConditions = &azblob.SourceModifiedAccessConditions{
			SourceIfModifiedSince:   sourceIfModifiedSinceParam,
			SourceIfUnmodifiedSince: sourceIfUnmodifiedSinceParam,
			SourceIfMatch:           sourceIfMatchParam,
			SourceIfNoneMatch:       sourceIfNoneMatchParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var cpkScopeInfo *azblob.CpkScopeInfo
	if encryptionScopeParam != nil {
		cpkScopeInfo = &azblob.CpkScopeInfo{
			EncryptionScope: encryptionScopeParam,
		}
	}
	respr, errRespr := s.srv.CopyFromURL(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum26(getHeaderValue(req.Header, "x-ms-requires-sync")), getHeaderValue(req.Header, "x-ms-copy-source"), options, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions, cpkScopeInfo)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).VersionID; val != nil {
		resp.Header.Set("x-ms-version-id", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CopyID; val != nil {
		resp.Header.Set("x-ms-copy-id", *val)
	}
	if val := server.GetResponse(respr).CopyStatus; val != nil {
		resp.Header.Set("x-ms-copy-status", "success")
	}
	if val := server.GetResponse(respr).ContentMD5; val != nil {
		resp.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).XMSContentCRC64; val != nil {
		resp.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).EncryptionScope; val != nil {
		resp.Header.Set("x-ms-encryption-scope", *val)
	}
	return resp, nil
}

func (s *ServerTransport) dispatchCreateSnapshot(req *http.Request) (*http.Response, error) {
	if s.srv.CreateSnapshot == nil {
		return nil, &nonRetriableError{errors.New("method CreateSnapshot not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var metadataParam map[string]*string
	for hh := range req.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if metadataParam == nil {
				metadataParam = map[string]*string{}
			}
			metadataParam[hh[len("x-ms-meta-"):]] = to.Ptr(getHeaderValue(req.Header, hh))
		}
	}
	encryptionKeyParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key"))
	encryptionKeySHA256Param := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key-sha256"))
	encryptionAlgorithmParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-algorithm"))
	encryptionScopeParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-scope"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientCreateSnapshotOptions
	if timeoutParam != nil || metadataParam != nil || requestIDParam != nil {
		options = &azblob.ClientCreateSnapshotOptions{
			Timeout:   timeoutParam,
			Metadata:  metadataParam,
			RequestID: requestIDParam,
		}
	}
	var cpkInfo *azblob.CpkInfo
	if encryptionKeyParam != nil || encryptionKeySHA256Param != nil || encryptionAlgorithmParam != nil {
		cpkInfo = &azblob.CpkInfo{
			EncryptionKey:       encryptionKeyParam,
			EncryptionKeySHA256: encryptionKeySHA256Param,
			EncryptionAlgorithm: encryptionAlgorithmParam,
		}
	}
	var cpkScopeInfo *azblob.CpkScopeInfo
	if encryptionScopeParam != nil {
		cpkScopeInfo = &azblob.CpkScopeInfo{
			EncryptionScope: encryptionScopeParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := s.srv.CreateSnapshot(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum25(qp.Get("comp")), options, cpkInfo, cpkScopeInfo, modifiedAccessConditions, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusCreated}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusCreated", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).Snapshot; val != nil {
		resp.Header.Set("x-ms-snapshot", *val)
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).VersionID; val != nil {
		resp.Header.Set("x-ms-version-id", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).IsServerEncrypted; val != nil {
		resp.Header.Set("x-ms-request-server-encrypted", strconv.FormatBool(*val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDelete(req *http.Request) (*http.Response, error) {
	if s.srv.Delete == nil {
		return nil, &nonRetriableError{errors.New("method Delete not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	snapshotParam := getOptional(qp.Get("snapshot"))
	versionIDParam := getOptional(qp.Get("versionid"))
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	deleteSnapshotsParam := getOptional(azblob.DeleteSnapshotsOptionType(getHeaderValue(req.Header, "x-ms-delete-snapshots")))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	blobDeleteTypeParam := getOptional(qp.Get("deletetype"))
	var options *azblob.ClientDeleteOptions
	if snapshotParam != nil || versionIDParam != nil || timeoutParam != nil || deleteSnapshotsParam != nil || requestIDParam != nil || blobDeleteTypeParam != nil {
		options = &azblob.ClientDeleteOptions{
			Snapshot:        snapshotParam,
			VersionID:       versionIDParam,
			Timeout:         timeoutParam,
			DeleteSnapshots: deleteSnapshotsParam,
			RequestID:       requestIDParam,
			BlobDeleteType:  blobDeleteTypeParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.Delete(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], options, leaseAccessConditions, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDeleteImmutabilityPolicy(req *http.Request) (*http.Response, error) {
	if s.srv.DeleteImmutabilityPolicy == nil {
		return nil, &nonRetriableError{errors.New("method DeleteImmutabilityPolicy not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientDeleteImmutabilityPolicyOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientDeleteImmutabilityPolicyOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	respr, errRespr := s.srv.DeleteImmutabilityPolicy(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum23(qp.Get("comp")), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchDownload(req *http.Request) (*http.Response, error) {
	if s.srv.Download == nil {
		return nil, &nonRetriableError{errors.New("method Download not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	snapshotParam := getOptional(qp.Get("snapshot"))
	versionIDParam := getOptional(qp.Get("versionid"))
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	rangeParam := getOptional(getHeaderValue(req.Header, "x-ms-range"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	rangeGetContentMD5Param, err := parseOptional(getHeaderValue(req.Header, "x-ms-range-get-content-md5"), strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	rangeGetContentCRC64Param, err := parseOptional(getHeaderValue(req.Header, "x-ms-range-get-content-crc64"), strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	encryptionKeyParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key"))
	encryptionKeySHA256Param := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key-sha256"))
	encryptionAlgorithmParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-algorithm"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientDownloadOptions
	if snapshotParam != nil || versionIDParam != nil || timeoutParam != nil || rangeParam != nil || rangeGetContentMD5Param != nil || rangeGetContentCRC64Param != nil || requestIDParam != nil {
		options = &azblob.ClientDownloadOptions{
			Snapshot:             snapshotParam,
			VersionID:            versionIDParam,
			Timeout:              timeoutParam,
			Range:                rangeParam,
			RangeGetContentMD5:   rangeGetContentMD5Param,
			RangeGetContentCRC64: rangeGetContentCRC64Param,
			RequestID:            requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var cpkInfo *azblob.CpkInfo
	if encryptionKeyParam != nil || encryptionKeySHA256Param != nil || encryptionAlgorithmParam != nil {
		cpkInfo = &azblob.CpkInfo{
			EncryptionKey:       encryptionKeyParam,
			EncryptionKeySHA256: encryptionKeySHA256Param,
			EncryptionAlgorithm: encryptionAlgorithmParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.Download(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], options, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK, http.StatusPartialContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusPartialContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, &server.ResponseOptions{
		Body:        server.GetResponse(respr).Body,
		ContentType: "application/octet-stream",
	})
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CreationTime; val != nil {
		resp.Header.Set("x-ms-creation-time", val.Format(time.RFC1123))
	}
	for k, v := range server.GetResponse(respr).Metadata {
		if v != nil {
			resp.Header.Set("x-ms-meta-"+k, *v)
		}
	}
	if val := server.GetResponse(respr).ObjectReplicationPolicyID; val != nil {
		resp.Header.Set("x-ms-or-policy-id", *val)
	}
	for k, v := range server.GetResponse(respr).ObjectReplicationRules {
		if v != nil {
			resp.Header.Set("x-ms-or-"+k, *v)
		}
	}
	if val := server.GetResponse(respr).ContentLength; val != nil {
		resp.Header.Set("Content-Length", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).ContentType; val != nil {
		resp.Header.Set("Content-Type", *val)
	}
	if val := server.GetResponse(respr).ContentRange; val != nil {
		resp.Header.Set("Content-Range", *val)
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).ContentMD5; val != nil {
		resp.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).ContentEncoding; val != nil {
		resp.Header.Set("Content-Encoding", *val)
	}
	if val := server.GetResponse(respr).CacheControl; val != nil {
		resp.Header.Set("Cache-Control", *val)
	}
	if val := server.GetResponse(respr).ContentDisposition; val != nil {
		resp.Header.Set("Content-Disposition", *val)
	}
	if val := server.GetResponse(respr).ContentLanguage; val != nil {
		resp.Header.Set("Content-Language", *val)
	}
	if val := server.GetResponse(respr).BlobSequenceNumber; val != nil {
		resp.Header.Set("x-ms-blob-sequence-number", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).BlobType; val != nil {
		resp.Header.Set("x-ms-blob-type", string(*val))
	}
	if val := server.GetResponse(respr).CopyCompletionTime; val != nil {
		resp.Header.Set("x-ms-copy-completion-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CopyStatusDescription; val != nil {
		resp.Header.Set("x-ms-copy-status-description", *val)
	}
	if val := server.GetResponse(respr).CopyID; val != nil {
		resp.Header.Set("x-ms-copy-id", *val)
	}
	if val := server.GetResponse(respr).CopyProgress; val != nil {
		resp.Header.Set("x-ms-copy-progress", *val)
	}
	if val := server.GetResponse(respr).CopySource; val != nil {
		resp.Header.Set("x-ms-copy-source", *val)
	}
	if val := server.GetResponse(respr).CopyStatus; val != nil {
		resp.Header.Set("x-ms-copy-status", string(*val))
	}
	if val := server.GetResponse(respr).LeaseDuration; val != nil {
		resp.Header.Set("x-ms-lease-duration", string(*val))
	}
	if val := server.GetResponse(respr).LeaseState; val != nil {
		resp.Header.Set("x-ms-lease-state", string(*val))
	}
	if val := server.GetResponse(respr).LeaseStatus; val != nil {
		resp.Header.Set("x-ms-lease-status", string(*val))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).VersionID; val != nil {
		resp.Header.Set("x-ms-version-id", *val)
	}
	if val := server.GetResponse(respr).IsCurrentVersion; val != nil {
		resp.Header.Set("x-ms-is-current-version", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).AcceptRanges; val != nil {
		resp.Header.Set("Accept-Ranges", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).BlobCommittedBlockCount; val != nil {
		resp.Header.Set("x-ms-blob-committed-block-count", strconv.FormatInt(int64(*val), 10))
	}
	if val := server.GetResponse(respr).IsServerEncrypted; val != nil {
		resp.Header.Set("x-ms-server-encrypted", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).EncryptionKeySHA256; val != nil {
		resp.Header.Set("x-ms-encryption-key-sha256", *val)
	}
	if val := server.GetResponse(respr).EncryptionScope; val != nil {
		resp.Header.Set("x-ms-encryption-scope", *val)
	}
	if val := server.GetResponse(respr).BlobContentMD5; val != nil {
		resp.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).TagCount; val != nil {
		resp.Header.Set("x-ms-tag-count", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).IsSealed; val != nil {
		resp.Header.Set("x-ms-blob-sealed", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).LastAccessed; val != nil {
		resp.Header.Set("x-ms-last-access-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ImmutabilityPolicyExpiresOn; val != nil {
		resp.Header.Set("x-ms-immutability-policy-until-date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ImmutabilityPolicyMode; val != nil {
		resp.Header.Set("x-ms-immutability-policy-mode", string(*val))
	}
	if val := server.GetResponse(respr).LegalHold; val != nil {
		resp.Header.Set("x-ms-legal-hold", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).ContentCRC64; val != nil {
		resp.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetAccountInfo(req *http.Request) (*http.Response, error) {
	if s.srv.GetAccountInfo == nil {
		return nil, &nonRetriableError{errors.New("method GetAccountInfo not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	respr, errRespr := s.srv.GetAccountInfo(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum8(qp.Get("restype")), azblob.Enum1(qp.Get("comp")), nil)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).SKUName; val != nil {
		resp.Header.Set("x-ms-sku-name", string(*val))
	}
	if val := server.GetResponse(respr).AccountKind; val != nil {
		resp.Header.Set("x-ms-account-kind", string(*val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetProperties(req *http.Request) (*http.Response, error) {
	if s.srv.GetProperties == nil {
		return nil, &nonRetriableError{errors.New("method GetProperties not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	snapshotParam := getOptional(qp.Get("snapshot"))
	versionIDParam := getOptional(qp.Get("versionid"))
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	encryptionKeyParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key"))
	encryptionKeySHA256Param := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key-sha256"))
	encryptionAlgorithmParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-algorithm"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientGetPropertiesOptions
	if snapshotParam != nil || versionIDParam != nil || timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientGetPropertiesOptions{
			Snapshot:  snapshotParam,
			VersionID: versionIDParam,
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var cpkInfo *azblob.CpkInfo
	if encryptionKeyParam != nil || encryptionKeySHA256Param != nil || encryptionAlgorithmParam != nil {
		cpkInfo = &azblob.CpkInfo{
			EncryptionKey:       encryptionKeyParam,
			EncryptionKeySHA256: encryptionKeySHA256Param,
			EncryptionAlgorithm: encryptionAlgorithmParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.GetProperties(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], options, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CreationTime; val != nil {
		resp.Header.Set("x-ms-creation-time", val.Format(time.RFC1123))
	}
	for k, v := range server.GetResponse(respr).Metadata {
		if v != nil {
			resp.Header.Set("x-ms-meta-"+k, *v)
		}
	}
	if val := server.GetResponse(respr).ObjectReplicationPolicyID; val != nil {
		resp.Header.Set("x-ms-or-policy-id", *val)
	}
	for k, v := range server.GetResponse(respr).ObjectReplicationRules {
		if v != nil {
			resp.Header.Set("x-ms-or-"+k, *v)
		}
	}
	if val := server.GetResponse(respr).BlobType; val != nil {
		resp.Header.Set("x-ms-blob-type", string(*val))
	}
	if val := server.GetResponse(respr).CopyCompletionTime; val != nil {
		resp.Header.Set("x-ms-copy-completion-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CopyStatusDescription; val != nil {
		resp.Header.Set("x-ms-copy-status-description", *val)
	}
	if val := server.GetResponse(respr).CopyID; val != nil {
		resp.Header.Set("x-ms-copy-id", *val)
	}
	if val := server.GetResponse(respr).CopyProgress; val != nil {
		resp.Header.Set("x-ms-copy-progress", *val)
	}
	if val := server.GetResponse(respr).CopySource; val != nil {
		resp.Header.Set("x-ms-copy-source", *val)
	}
	if val := server.GetResponse(respr).CopyStatus; val != nil {
		resp.Header.Set("x-ms-copy-status", string(*val))
	}
	if val := server.GetResponse(respr).IsIncrementalCopy; val != nil {
		resp.Header.Set("x-ms-incremental-copy", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).DestinationSnapshot; val != nil {
		resp.Header.Set("x-ms-copy-destination-snapshot", *val)
	}
	if val := server.GetResponse(respr).LeaseDuration; val != nil {
		resp.Header.Set("x-ms-lease-duration", string(*val))
	}
	if val := server.GetResponse(respr).LeaseState; val != nil {
		resp.Header.Set("x-ms-lease-state", string(*val))
	}
	if val := server.GetResponse(respr).LeaseStatus; val != nil {
		resp.Header.Set("x-ms-lease-status", string(*val))
	}
	if val := server.GetResponse(respr).ContentLength; val != nil {
		resp.Header.Set("Content-Length", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).ContentType; val != nil {
		resp.Header.Set("Content-Type", *val)
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).ContentMD5; val != nil {
		resp.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).ContentEncoding; val != nil {
		resp.Header.Set("Content-Encoding", *val)
	}
	if val := server.GetResponse(respr).ContentDisposition; val != nil {
		resp.Header.Set("Content-Disposition", *val)
	}
	if val := server.GetResponse(respr).ContentLanguage; val != nil {
		resp.Header.Set("Content-Language", *val)
	}
	if val := server.GetResponse(respr).CacheControl; val != nil {
		resp.Header.Set("Cache-Control", *val)
	}
	if val := server.GetResponse(respr).BlobSequenceNumber; val != nil {
		resp.Header.Set("x-ms-blob-sequence-number", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).AcceptRanges; val != nil {
		resp.Header.Set("Accept-Ranges", *val)
	}
	if val := server.GetResponse(respr).BlobCommittedBlockCount; val != nil {
		resp.Header.Set("x-ms-blob-committed-block-count", strconv.FormatInt(int64(*val), 10))
	}
	if val := server.GetResponse(respr).IsServerEncrypted; val != nil {
		resp.Header.Set("x-ms-server-encrypted", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).EncryptionKeySHA256; val != nil {
		resp.Header.Set("x-ms-encryption-key-sha256", *val)
	}
	if val := server.GetResponse(respr).EncryptionScope; val != nil {
		resp.Header.Set("x-ms-encryption-scope", *val)
	}
	if val := server.GetResponse(respr).AccessTier; val != nil {
		resp.Header.Set("x-ms-access-tier", *val)
	}
	if val := server.GetResponse(respr).AccessTierInferred; val != nil {
		resp.Header.Set("x-ms-access-tier-inferred", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).ArchiveStatus; val != nil {
		resp.Header.Set("x-ms-archive-status", *val)
	}
	if val := server.GetResponse(respr).AccessTierChangeTime; val != nil {
		resp.Header.Set("x-ms-access-tier-change-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).VersionID; val != nil {
		resp.Header.Set("x-ms-version-id", *val)
	}
	if val := server.GetResponse(respr).IsCurrentVersion; val != nil {
		resp.Header.Set("x-ms-is-current-version", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).TagCount; val != nil {
		resp.Header.Set("x-ms-tag-count", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).ExpiresOn; val != nil {
		resp.Header.Set("x-ms-expiry-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).IsSealed; val != nil {
		resp.Header.Set("x-ms-blob-sealed", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).RehydratePriority; val != nil {
		resp.Header.Set("x-ms-rehydrate-priority", *val)
	}
	if val := server.GetResponse(respr).LastAccessed; val != nil {
		resp.Header.Set("x-ms-last-access-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ImmutabilityPolicyExpiresOn; val != nil {
		resp.Header.Set("x-ms-immutability-policy-until-date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ImmutabilityPolicyMode; val != nil {
		resp.Header.Set("x-ms-immutability-policy-mode", string(*val))
	}
	if val := server.GetResponse(respr).LegalHold; val != nil {
		resp.Header.Set("x-ms-legal-hold", strconv.FormatBool(*val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchGetTags(req *http.Request) (*http.Response, error) {
	if s.srv.GetTags == nil {
		return nil, &nonRetriableError{errors.New("method GetTags not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	snapshotParam := getOptional(qp.Get("snapshot"))
	versionIDParam := getOptional(qp.Get("versionid"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	var options *azblob.ClientGetTagsOptions
	if timeoutParam != nil || requestIDParam != nil || snapshotParam != nil || versionIDParam != nil {
		options = &azblob.ClientGetTagsOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
			Snapshot:  snapshotParam,
			VersionID: versionIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfTags: ifTagsParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := s.srv.GetTags(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum39(qp.Get("comp")), options, modifiedAccessConditions, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.MarshalResponseAsXML(respContent, server.GetResponse(respr).Tags, req)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchQuery(req *http.Request) (*http.Response, error) {
	if s.srv.Query == nil {
		return nil, &nonRetriableError{errors.New("method Query not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsXML[azblob.QueryRequest](req)
	if err != nil {
		return nil, err
	}
	snapshotParam := getOptional(qp.Get("snapshot"))
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	encryptionKeyParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key"))
	encryptionKeySHA256Param := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key-sha256"))
	encryptionAlgorithmParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-algorithm"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientQueryOptions
	if snapshotParam != nil || timeoutParam != nil || requestIDParam != nil || !reflect.ValueOf(body).IsZero() {
		options = &azblob.ClientQueryOptions{
			Snapshot:     snapshotParam,
			Timeout:      timeoutParam,
			RequestID:    requestIDParam,
			QueryRequest: &body,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var cpkInfo *azblob.CpkInfo
	if encryptionKeyParam != nil || encryptionKeySHA256Param != nil || encryptionAlgorithmParam != nil {
		cpkInfo = &azblob.CpkInfo{
			EncryptionKey:       encryptionKeyParam,
			EncryptionKeySHA256: encryptionKeySHA256Param,
			EncryptionAlgorithm: encryptionAlgorithmParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.Query(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum37(qp.Get("comp")), options, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK, http.StatusPartialContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusPartialContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, &server.ResponseOptions{
		Body:        server.GetResponse(respr).Body,
		ContentType: "application/octet-stream",
	})
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	for k, v := range server.GetResponse(respr).Metadata {
		if v != nil {
			resp.Header.Set("x-ms-meta-"+k, *v)
		}
	}
	if val := server.GetResponse(respr).ContentLength; val != nil {
		resp.Header.Set("Content-Length", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).ContentType; val != nil {
		resp.Header.Set("Content-Type", *val)
	}
	if val := server.GetResponse(respr).ContentRange; val != nil {
		resp.Header.Set("Content-Range", *val)
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).ContentMD5; val != nil {
		resp.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).ContentEncoding; val != nil {
		resp.Header.Set("Content-Encoding", *val)
	}
	if val := server.GetResponse(respr).CacheControl; val != nil {
		resp.Header.Set("Cache-Control", *val)
	}
	if val := server.GetResponse(respr).ContentDisposition; val != nil {
		resp.Header.Set("Content-Disposition", *val)
	}
	if val := server.GetResponse(respr).ContentLanguage; val != nil {
		resp.Header.Set("Content-Language", *val)
	}
	if val := server.GetResponse(respr).BlobSequenceNumber; val != nil {
		resp.Header.Set("x-ms-blob-sequence-number", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).BlobType; val != nil {
		resp.Header.Set("x-ms-blob-type", string(*val))
	}
	if val := server.GetResponse(respr).CopyCompletionTime; val != nil {
		resp.Header.Set("x-ms-copy-completion-time", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CopyStatusDescription; val != nil {
		resp.Header.Set("x-ms-copy-status-description", *val)
	}
	if val := server.GetResponse(respr).CopyID; val != nil {
		resp.Header.Set("x-ms-copy-id", *val)
	}
	if val := server.GetResponse(respr).CopyProgress; val != nil {
		resp.Header.Set("x-ms-copy-progress", *val)
	}
	if val := server.GetResponse(respr).CopySource; val != nil {
		resp.Header.Set("x-ms-copy-source", *val)
	}
	if val := server.GetResponse(respr).CopyStatus; val != nil {
		resp.Header.Set("x-ms-copy-status", string(*val))
	}
	if val := server.GetResponse(respr).LeaseDuration; val != nil {
		resp.Header.Set("x-ms-lease-duration", string(*val))
	}
	if val := server.GetResponse(respr).LeaseState; val != nil {
		resp.Header.Set("x-ms-lease-state", string(*val))
	}
	if val := server.GetResponse(respr).LeaseStatus; val != nil {
		resp.Header.Set("x-ms-lease-status", string(*val))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).AcceptRanges; val != nil {
		resp.Header.Set("Accept-Ranges", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).BlobCommittedBlockCount; val != nil {
		resp.Header.Set("x-ms-blob-committed-block-count", strconv.FormatInt(int64(*val), 10))
	}
	if val := server.GetResponse(respr).IsServerEncrypted; val != nil {
		resp.Header.Set("x-ms-server-encrypted", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).EncryptionKeySHA256; val != nil {
		resp.Header.Set("x-ms-encryption-key-sha256", *val)
	}
	if val := server.GetResponse(respr).EncryptionScope; val != nil {
		resp.Header.Set("x-ms-encryption-scope", *val)
	}
	if val := server.GetResponse(respr).BlobContentMD5; val != nil {
		resp.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(val))
	}
	if val := server.GetResponse(respr).ContentCRC64; val != nil {
		resp.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchReleaseLease(req *http.Request) (*http.Response, error) {
	if s.srv.ReleaseLease == nil {
		return nil, &nonRetriableError{errors.New("method ReleaseLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientReleaseLeaseOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientReleaseLeaseOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.ReleaseLease(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum16(qp.Get("comp")), getHeaderValue(req.Header, "x-ms-lease-id"), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchRenewLease(req *http.Request) (*http.Response, error) {
	if s.srv.RenewLease == nil {
		return nil, &nonRetriableError{errors.New("method RenewLease not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientRenewLeaseOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientRenewLeaseOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.RenewLease(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum16(qp.Get("comp")), getHeaderValue(req.Header, "x-ms-lease-id"), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LeaseID; val != nil {
		resp.Header.Set("x-ms-lease-id", *val)
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetExpiry(req *http.Request) (*http.Response, error) {
	if s.srv.SetExpiry == nil {
		return nil, &nonRetriableError{errors.New("method SetExpiry not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	expiresOnParam := getOptional(getHeaderValue(req.Header, "x-ms-expiry-time"))
	var options *azblob.ClientSetExpiryOptions
	if timeoutParam != nil || requestIDParam != nil || expiresOnParam != nil {
		options = &azblob.ClientSetExpiryOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
			ExpiresOn: expiresOnParam,
		}
	}
	respr, errRespr := s.srv.SetExpiry(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum21(qp.Get("comp")), azblob.BlobExpiryOptions(getHeaderValue(req.Header, "x-ms-expiry-option")), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetHTTPHeaders(req *http.Request) (*http.Response, error) {
	if s.srv.SetHTTPHeaders == nil {
		return nil, &nonRetriableError{errors.New("method SetHTTPHeaders not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	blobCacheControlParam := getOptional(getHeaderValue(req.Header, "x-ms-blob-cache-control"))
	blobContentTypeParam := getOptional(getHeaderValue(req.Header, "x-ms-blob-content-type"))
	blobContentMD5Param, err := base64.StdEncoding.DecodeString(getHeaderValue(req.Header, "x-ms-blob-content-md5"))
	if err != nil {
		return nil, err
	}
	blobContentEncodingParam := getOptional(getHeaderValue(req.Header, "x-ms-blob-content-encoding"))
	blobContentLanguageParam := getOptional(getHeaderValue(req.Header, "x-ms-blob-content-language"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	blobContentDispositionParam := getOptional(getHeaderValue(req.Header, "x-ms-blob-content-disposition"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientSetHTTPHeadersOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientSetHTTPHeadersOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	var blobHTTPHeaders *azblob.BlobHTTPHeaders
	if blobCacheControlParam != nil || blobContentTypeParam != nil || blobContentMD5Param != nil || blobContentEncodingParam != nil || blobContentLanguageParam != nil || blobContentDispositionParam != nil {
		blobHTTPHeaders = &azblob.BlobHTTPHeaders{
			BlobCacheControl:       blobCacheControlParam,
			BlobContentType:        blobContentTypeParam,
			BlobContentMD5:         blobContentMD5Param,
			BlobContentEncoding:    blobContentEncodingParam,
			BlobContentLanguage:    blobContentLanguageParam,
			BlobContentDisposition: blobContentDispositionParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.SetHTTPHeaders(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum1(qp.Get("comp")), options, blobHTTPHeaders, leaseAccessConditions, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).BlobSequenceNumber; val != nil {
		resp.Header.Set("x-ms-blob-sequence-number", strconv.FormatInt(*val, 10))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetImmutabilityPolicy(req *http.Request) (*http.Response, error) {
	if s.srv.SetImmutabilityPolicy == nil {
		return nil, &nonRetriableError{errors.New("method SetImmutabilityPolicy not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	immutabilityPolicyExpiryParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-immutability-policy-until-date"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	immutabilityPolicyModeParam := getOptional(azblob.BlobImmutabilityPolicyMode(getHeaderValue(req.Header, "x-ms-immutability-policy-mode")))
	var options *azblob.ClientSetImmutabilityPolicyOptions
	if timeoutParam != nil || requestIDParam != nil || immutabilityPolicyExpiryParam != nil || immutabilityPolicyModeParam != nil {
		options = &azblob.ClientSetImmutabilityPolicyOptions{
			Timeout:                  timeoutParam,
			RequestID:                requestIDParam,
			ImmutabilityPolicyExpiry: immutabilityPolicyExpiryParam,
			ImmutabilityPolicyMode:   immutabilityPolicyModeParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifUnmodifiedSinceParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
		}
	}
	respr, errRespr := s.srv.SetImmutabilityPolicy(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum23(qp.Get("comp")), options, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ImmutabilityPolicyExpiry; val != nil {
		resp.Header.Set("x-ms-immutability-policy-until-date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ImmutabilityPolicyMode; val != nil {
		resp.Header.Set("x-ms-immutability-policy-mode", string(*val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetLegalHold(req *http.Request) (*http.Response, error) {
	if s.srv.SetLegalHold == nil {
		return nil, &nonRetriableError{errors.New("method SetLegalHold not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	legalHoldParam, err := strconv.ParseBool(getHeaderValue(req.Header, "x-ms-legal-hold"))
	if err != nil {
		return nil, err
	}
	var options *azblob.ClientSetLegalHoldOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientSetLegalHoldOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	respr, errRespr := s.srv.SetLegalHold(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum24(qp.Get("comp")), legalHoldParam, options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).LegalHold; val != nil {
		resp.Header.Set("x-ms-legal-hold", strconv.FormatBool(*val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetMetadata(req *http.Request) (*http.Response, error) {
	if s.srv.SetMetadata == nil {
		return nil, &nonRetriableError{errors.New("method SetMetadata not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var metadataParam map[string]*string
	for hh := range req.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if metadataParam == nil {
				metadataParam = map[string]*string{}
			}
			metadataParam[hh[len("x-ms-meta-"):]] = to.Ptr(getHeaderValue(req.Header, hh))
		}
	}
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	encryptionKeyParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key"))
	encryptionKeySHA256Param := getOptional(getHeaderValue(req.Header, "x-ms-encryption-key-sha256"))
	encryptionAlgorithmParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-algorithm"))
	encryptionScopeParam := getOptional(getHeaderValue(req.Header, "x-ms-encryption-scope"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientSetMetadataOptions
	if timeoutParam != nil || metadataParam != nil || requestIDParam != nil {
		options = &azblob.ClientSetMetadataOptions{
			Timeout:   timeoutParam,
			Metadata:  metadataParam,
			RequestID: requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var cpkInfo *azblob.CpkInfo
	if encryptionKeyParam != nil || encryptionKeySHA256Param != nil || encryptionAlgorithmParam != nil {
		cpkInfo = &azblob.CpkInfo{
			EncryptionKey:       encryptionKeyParam,
			EncryptionKeySHA256: encryptionKeySHA256Param,
			EncryptionAlgorithm: encryptionAlgorithmParam,
		}
	}
	var cpkScopeInfo *azblob.CpkScopeInfo
	if encryptionScopeParam != nil {
		cpkScopeInfo = &azblob.CpkScopeInfo{
			EncryptionScope: encryptionScopeParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	respr, errRespr := s.srv.SetMetadata(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum12(qp.Get("comp")), options, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).VersionID; val != nil {
		resp.Header.Set("x-ms-version-id", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).IsServerEncrypted; val != nil {
		resp.Header.Set("x-ms-request-server-encrypted", strconv.FormatBool(*val))
	}
	if val := server.GetResponse(respr).EncryptionKeySHA256; val != nil {
		resp.Header.Set("x-ms-encryption-key-sha256", *val)
	}
	if val := server.GetResponse(respr).EncryptionScope; val != nil {
		resp.Header.Set("x-ms-encryption-scope", *val)
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetTags(req *http.Request) (*http.Response, error) {
	if s.srv.SetTags == nil {
		return nil, &nonRetriableError{errors.New("method SetTags not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	body, err := server.UnmarshalRequestAsXML[azblob.Tags](req)
	if err != nil {
		return nil, err
	}
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	versionIDParam := getOptional(qp.Get("versionid"))
	transactionalContentMD5Param, err := base64.StdEncoding.DecodeString(getHeaderValue(req.Header, "Content-MD5"))
	if err != nil {
		return nil, err
	}
	transactionalContentCRC64Param, err := base64.StdEncoding.DecodeString(getHeaderValue(req.Header, "x-ms-content-crc64"))
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	var options *azblob.ClientSetTagsOptions
	if timeoutParam != nil || versionIDParam != nil || transactionalContentMD5Param != nil || transactionalContentCRC64Param != nil || requestIDParam != nil || !reflect.ValueOf(body).IsZero() {
		options = &azblob.ClientSetTagsOptions{
			Timeout:                   timeoutParam,
			VersionID:                 versionIDParam,
			TransactionalContentMD5:   transactionalContentMD5Param,
			TransactionalContentCRC64: transactionalContentCRC64Param,
			RequestID:                 requestIDParam,
			Tags:                      &body,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfTags: ifTagsParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := s.srv.SetTags(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum39(qp.Get("comp")), options, modifiedAccessConditions, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusNoContent}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusNoContent", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchSetTier(req *http.Request) (*http.Response, error) {
	if s.srv.SetTier == nil {
		return nil, &nonRetriableError{errors.New("method SetTier not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	snapshotParam := getOptional(qp.Get("snapshot"))
	versionIDParam := getOptional(qp.Get("versionid"))
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	rehydratePriorityParam := getOptional(azblob.RehydratePriority(getHeaderValue(req.Header, "x-ms-rehydrate-priority")))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	var options *azblob.ClientSetTierOptions
	if snapshotParam != nil || versionIDParam != nil || timeoutParam != nil || rehydratePriorityParam != nil || requestIDParam != nil {
		options = &azblob.ClientSetTierOptions{
			Snapshot:          snapshotParam,
			VersionID:         versionIDParam,
			Timeout:           timeoutParam,
			RehydratePriority: rehydratePriorityParam,
			RequestID:         requestIDParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfTags: ifTagsParam,
		}
	}
	respr, errRespr := s.srv.SetTier(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum29(qp.Get("comp")), azblob.AccessTier(getHeaderValue(req.Header, "x-ms-access-tier")), options, leaseAccessConditions, modifiedAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK, http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK, http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	return resp, nil
}

func (s *ServerTransport) dispatchStartCopyFromURL(req *http.Request) (*http.Response, error) {
	if s.srv.StartCopyFromURL == nil {
		return nil, &nonRetriableError{errors.New("method StartCopyFromURL not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	var metadataParam map[string]*string
	for hh := range req.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if metadataParam == nil {
				metadataParam = map[string]*string{}
			}
			metadataParam[hh[len("x-ms-meta-"):]] = to.Ptr(getHeaderValue(req.Header, hh))
		}
	}
	tierParam := getOptional(azblob.AccessTier(getHeaderValue(req.Header, "x-ms-access-tier")))
	rehydratePriorityParam := getOptional(azblob.RehydratePriority(getHeaderValue(req.Header, "x-ms-rehydrate-priority")))
	sourceIfModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-source-if-modified-since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	sourceIfUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-source-if-unmodified-since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	sourceIfMatchParam := getOptional(getHeaderValue(req.Header, "x-ms-source-if-match"))
	sourceIfNoneMatchParam := getOptional(getHeaderValue(req.Header, "x-ms-source-if-none-match"))
	sourceIfTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-source-if-tags"))
	ifModifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Modified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifUnmodifiedSinceParam, err := parseOptional(getHeaderValue(req.Header, "If-Unmodified-Since"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	ifMatchParam := getOptional(getHeaderValue(req.Header, "If-Match"))
	ifNoneMatchParam := getOptional(getHeaderValue(req.Header, "If-None-Match"))
	ifTagsParam := getOptional(getHeaderValue(req.Header, "x-ms-if-tags"))
	leaseIDParam := getOptional(getHeaderValue(req.Header, "x-ms-lease-id"))
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	blobTagsStringParam := getOptional(getHeaderValue(req.Header, "x-ms-tags"))
	sealBlobParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-seal-blob"), strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	immutabilityPolicyExpiryParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-immutability-policy-until-date"), func(v string) (time.Time, error) { return time.Parse(time.RFC1123, v) })
	if err != nil {
		return nil, err
	}
	immutabilityPolicyModeParam := getOptional(azblob.BlobImmutabilityPolicyMode(getHeaderValue(req.Header, "x-ms-immutability-policy-mode")))
	legalHoldParam, err := parseOptional(getHeaderValue(req.Header, "x-ms-legal-hold"), strconv.ParseBool)
	if err != nil {
		return nil, err
	}
	var options *azblob.ClientStartCopyFromURLOptions
	if timeoutParam != nil || metadataParam != nil || tierParam != nil || rehydratePriorityParam != nil || requestIDParam != nil || blobTagsStringParam != nil || sealBlobParam != nil || immutabilityPolicyExpiryParam != nil || immutabilityPolicyModeParam != nil || legalHoldParam != nil {
		options = &azblob.ClientStartCopyFromURLOptions{
			Timeout:                  timeoutParam,
			Metadata:                 metadataParam,
			Tier:                     tierParam,
			RehydratePriority:        rehydratePriorityParam,
			RequestID:                requestIDParam,
			BlobTagsString:           blobTagsStringParam,
			SealBlob:                 sealBlobParam,
			ImmutabilityPolicyExpiry: immutabilityPolicyExpiryParam,
			ImmutabilityPolicyMode:   immutabilityPolicyModeParam,
			LegalHold:                legalHoldParam,
		}
	}
	var sourceModifiedAccessConditions *azblob.SourceModifiedAccessConditions
	if sourceIfModifiedSinceParam != nil || sourceIfUnmodifiedSinceParam != nil || sourceIfMatchParam != nil || sourceIfNoneMatchParam != nil || sourceIfTagsParam != nil {
		sourceModifiedAccessConditions = &azblob.SourceModifiedAccessConditions{
			SourceIfModifiedSince:   sourceIfModifiedSinceParam,
			SourceIfUnmodifiedSince: sourceIfUnmodifiedSinceParam,
			SourceIfMatch:           sourceIfMatchParam,
			SourceIfNoneMatch:       sourceIfNoneMatchParam,
			SourceIfTags:            sourceIfTagsParam,
		}
	}
	var modifiedAccessConditions *azblob.ModifiedAccessConditions
	if ifModifiedSinceParam != nil || ifUnmodifiedSinceParam != nil || ifMatchParam != nil || ifNoneMatchParam != nil || ifTagsParam != nil {
		modifiedAccessConditions = &azblob.ModifiedAccessConditions{
			IfModifiedSince:   ifModifiedSinceParam,
			IfUnmodifiedSince: ifUnmodifiedSinceParam,
			IfMatch:           ifMatchParam,
			IfNoneMatch:       ifNoneMatchParam,
			IfTags:            ifTagsParam,
		}
	}
	var leaseAccessConditions *azblob.LeaseAccessConditions
	if leaseIDParam != nil {
		leaseAccessConditions = &azblob.LeaseAccessConditions{
			LeaseID: leaseIDParam,
		}
	}
	respr, errRespr := s.srv.StartCopyFromURL(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], getHeaderValue(req.Header, "x-ms-copy-source"), options, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusAccepted}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusAccepted", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ETag; val != nil {
		resp.Header.Set("ETag", *val)
	}
	if val := server.GetResponse(respr).LastModified; val != nil {
		resp.Header.Set("Last-Modified", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).VersionID; val != nil {
		resp.Header.Set("x-ms-version-id", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	if val := server.GetResponse(respr).CopyID; val != nil {
		resp.Header.Set("x-ms-copy-id", *val)
	}
	if val := server.GetResponse(respr).CopyStatus; val != nil {
		resp.Header.Set("x-ms-copy-status", string(*val))
	}
	return resp, nil
}

func (s *ServerTransport) dispatchUndelete(req *http.Request) (*http.Response, error) {
	if s.srv.Undelete == nil {
		return nil, &nonRetriableError{errors.New("method Undelete not implemented")}
	}
	const regexStr = "/(?P<containerName>[a-zA-Z0-9-_]+)/(?P<blob>[a-zA-Z0-9-_]+)"
	regex := regexp.MustCompile(regexStr)
	matches := regex.FindStringSubmatch(req.URL.Path)
	if matches == nil || len(matches) < 2 {
		return nil, fmt.Errorf("failed to parse path %s", req.URL.Path)
	}
	qp := req.URL.Query()
	timeoutParam, err := parseOptional(qp.Get("timeout"), func(v string) (int32, error) {
		p, parseErr := strconv.ParseInt(v, 10, 32)
		if parseErr != nil {
			return 0, parseErr
		}
		return int32(p), nil
	})
	if err != nil {
		return nil, err
	}
	requestIDParam := getOptional(getHeaderValue(req.Header, "x-ms-client-request-id"))
	var options *azblob.ClientUndeleteOptions
	if timeoutParam != nil || requestIDParam != nil {
		options = &azblob.ClientUndeleteOptions{
			Timeout:   timeoutParam,
			RequestID: requestIDParam,
		}
	}
	respr, errRespr := s.srv.Undelete(req.Context(), matches[regex.SubexpIndex("containerName")], matches[regex.SubexpIndex("blob")], azblob.Enum14(qp.Get("comp")), options)
	if respErr := server.GetError(errRespr, req); respErr != nil {
		return nil, respErr
	}
	respContent := server.GetResponseContent(respr)
	if !contains([]int{http.StatusOK}, respContent.HTTPStatus) {
		return nil, &nonRetriableError{fmt.Errorf("unexpected status code %d. acceptable values are http.StatusOK", respContent.HTTPStatus)}
	}
	resp, err := server.NewResponse(respContent, req, nil)
	if err != nil {
		return nil, err
	}
	if val := server.GetResponse(respr).ClientRequestID; val != nil {
		resp.Header.Set("x-ms-client-request-id", *val)
	}
	if val := server.GetResponse(respr).RequestID; val != nil {
		resp.Header.Set("x-ms-request-id", *val)
	}
	if val := server.GetResponse(respr).Version; val != nil {
		resp.Header.Set("x-ms-version", *val)
	}
	if val := server.GetResponse(respr).Date; val != nil {
		resp.Header.Set("Date", val.Format(time.RFC1123))
	}
	return resp, nil
}
