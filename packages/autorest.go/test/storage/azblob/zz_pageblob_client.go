// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PageBlobClient contains the methods for the PageBlob group.
// Don't use this type directly, use a constructor function instead.
type PageBlobClient struct {
	internal *azcore.Client
	endpoint string
	version  Enum2
}

// ClearPages - The Clear Pages operation clears a set of pages from a page blob
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - contentLength - The length of the request.
//   - options - PageBlobClientClearPagesOptions contains the optional parameters for the PageBlobClient.ClearPages method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - CpkInfo - CpkInfo contains a group of parameters for the Client.Download method.
//   - CpkScopeInfo - CpkScopeInfo contains a group of parameters for the Client.SetMetadata method.
//   - SequenceNumberAccessConditions - SequenceNumberAccessConditions contains a group of parameters for the PageBlobClient.UploadPages
//     method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) ClearPages(ctx context.Context, containerName string, blob string, comp Enum32, contentLength int64, options *PageBlobClientClearPagesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, sequenceNumberAccessConditions *SequenceNumberAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (PageBlobClientClearPagesResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.ClearPages", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.clearPagesCreateRequest(ctx, containerName, blob, comp, contentLength, options, leaseAccessConditions, cpkInfo, cpkScopeInfo, sequenceNumberAccessConditions, modifiedAccessConditions)
	if err != nil {
		return PageBlobClientClearPagesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientClearPagesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientClearPagesResponse{}, err
	}
	resp, err := client.clearPagesHandleResponse(httpResp)
	return resp, err
}

// clearPagesCreateRequest creates the ClearPages request.
func (client *PageBlobClient) clearPagesCreateRequest(ctx context.Context, containerName string, blob string, comp Enum32, contentLength int64, options *PageBlobClientClearPagesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, sequenceNumberAccessConditions *SequenceNumberAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	req.Raw().Header["Content-Length"] = []string{strconv.FormatInt(contentLength, 10)}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header["x-ms-encryption-algorithm"] = []string{"AES256"}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header["x-ms-encryption-key"] = []string{*cpkInfo.EncryptionKey}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header["x-ms-encryption-key-sha256"] = []string{*cpkInfo.EncryptionKeySHA256}
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header["x-ms-encryption-scope"] = []string{*cpkScopeInfo.EncryptionScope}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberEqualTo != nil {
		req.Raw().Header["x-ms-if-sequence-number-eq"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberEqualTo, 10)}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo != nil {
		req.Raw().Header["x-ms-if-sequence-number-le"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo, 10)}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberLessThan != nil {
		req.Raw().Header["x-ms-if-sequence-number-lt"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberLessThan, 10)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-page-write"] = []string{"clear"}
	if options != nil && options.Range != nil {
		req.Raw().Header["x-ms-range"] = []string{*options.Range}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// clearPagesHandleResponse handles the ClearPages response.
func (client *PageBlobClient) clearPagesHandleResponse(resp *http.Response) (PageBlobClientClearPagesResponse, error) {
	result := PageBlobClientClearPagesResponse{}
	if vals, ok := resp.Header["x-ms-blob-sequence-number"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientClearPagesResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Content-MD5"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientClearPagesResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientClearPagesResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientClearPagesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	if vals, ok := resp.Header["x-ms-content-crc64"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientClearPagesResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	return result, nil
}

// CopyIncremental - The Copy Incremental operation copies a snapshot of the source page blob to a destination page blob.
// The snapshot is copied such that only the differential changes between the previously copied
// snapshot are transferred to the destination. The copied snapshots are complete copies of the original snapshot and can
// be read or copied from as usual. This API is supported since REST version
// 2016-05-31.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - copySource - Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies
//     a page blob snapshot. The value should be URL-encoded as it would appear in a request
//     URI. The source blob must either be public or must be authenticated via a shared access signature.
//   - options - PageBlobClientCopyIncrementalOptions contains the optional parameters for the PageBlobClient.CopyIncremental
//     method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) CopyIncremental(ctx context.Context, containerName string, blob string, comp Enum34, copySource string, options *PageBlobClientCopyIncrementalOptions, modifiedAccessConditions *ModifiedAccessConditions) (PageBlobClientCopyIncrementalResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.CopyIncremental", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.copyIncrementalCreateRequest(ctx, containerName, blob, comp, copySource, options, modifiedAccessConditions)
	if err != nil {
		return PageBlobClientCopyIncrementalResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientCopyIncrementalResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientCopyIncrementalResponse{}, err
	}
	resp, err := client.copyIncrementalHandleResponse(httpResp)
	return resp, err
}

// copyIncrementalCreateRequest creates the CopyIncremental request.
func (client *PageBlobClient) copyIncrementalCreateRequest(ctx context.Context, containerName string, blob string, comp Enum34, copySource string, options *PageBlobClientCopyIncrementalOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["x-ms-copy-source"] = []string{copySource}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// copyIncrementalHandleResponse handles the CopyIncremental response.
func (client *PageBlobClient) copyIncrementalHandleResponse(resp *http.Response) (PageBlobClientCopyIncrementalResponse, error) {
	result := PageBlobClientCopyIncrementalResponse{}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["x-ms-copy-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.CopyID = &val
	}
	if vals, ok := resp.Header["x-ms-copy-status"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientCopyIncrementalResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientCopyIncrementalResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	return result, nil
}

// Create - The Create operation creates a new page blob.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - contentLength - The length of the request.
//   - blobContentLength - This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned
//     to a 512-byte boundary.
//   - options - PageBlobClientCreateOptions contains the optional parameters for the PageBlobClient.Create method.
//   - BlobHTTPHeaders - BlobHTTPHeaders contains a group of parameters for the Client.SetHTTPHeaders method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - CpkInfo - CpkInfo contains a group of parameters for the Client.Download method.
//   - CpkScopeInfo - CpkScopeInfo contains a group of parameters for the Client.SetMetadata method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) Create(ctx context.Context, containerName string, blob string, contentLength int64, blobContentLength int64, options *PageBlobClientCreateOptions, blobHTTPHeaders *BlobHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (PageBlobClientCreateResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.Create", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.createCreateRequest(ctx, containerName, blob, contentLength, blobContentLength, options, blobHTTPHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if err != nil {
		return PageBlobClientCreateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientCreateResponse{}, err
	}
	resp, err := client.createHandleResponse(httpResp)
	return resp, err
}

// createCreateRequest creates the Create request.
func (client *PageBlobClient) createCreateRequest(ctx context.Context, containerName string, blob string, contentLength int64, blobContentLength int64, options *PageBlobClientCreateOptions, blobHTTPHeaders *BlobHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	req.Raw().Header["Content-Length"] = []string{strconv.FormatInt(contentLength, 10)}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.Tier != nil {
		req.Raw().Header["x-ms-access-tier"] = []string{string(*options.Tier)}
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobCacheControl != nil {
		req.Raw().Header["x-ms-blob-cache-control"] = []string{*blobHTTPHeaders.BlobCacheControl}
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentDisposition != nil {
		req.Raw().Header["x-ms-blob-content-disposition"] = []string{*blobHTTPHeaders.BlobContentDisposition}
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentEncoding != nil {
		req.Raw().Header["x-ms-blob-content-encoding"] = []string{*blobHTTPHeaders.BlobContentEncoding}
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentLanguage != nil {
		req.Raw().Header["x-ms-blob-content-language"] = []string{*blobHTTPHeaders.BlobContentLanguage}
	}
	req.Raw().Header["x-ms-blob-content-length"] = []string{strconv.FormatInt(blobContentLength, 10)}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentMD5 != nil {
		req.Raw().Header["x-ms-blob-content-md5"] = []string{base64.StdEncoding.EncodeToString(blobHTTPHeaders.BlobContentMD5)}
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentType != nil {
		req.Raw().Header["x-ms-blob-content-type"] = []string{*blobHTTPHeaders.BlobContentType}
	}
	if options != nil && options.BlobSequenceNumber != nil {
		req.Raw().Header["x-ms-blob-sequence-number"] = []string{strconv.FormatInt(*options.BlobSequenceNumber, 10)}
	}
	req.Raw().Header["x-ms-blob-type"] = []string{"PageBlob"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header["x-ms-encryption-algorithm"] = []string{"AES256"}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header["x-ms-encryption-key"] = []string{*cpkInfo.EncryptionKey}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header["x-ms-encryption-key-sha256"] = []string{*cpkInfo.EncryptionKeySHA256}
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header["x-ms-encryption-scope"] = []string{*cpkScopeInfo.EncryptionScope}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if options != nil && options.ImmutabilityPolicyMode != nil {
		req.Raw().Header["x-ms-immutability-policy-mode"] = []string{string(*options.ImmutabilityPolicyMode)}
	}
	if options != nil && options.ImmutabilityPolicyExpiry != nil {
		req.Raw().Header["x-ms-immutability-policy-until-date"] = []string{options.ImmutabilityPolicyExpiry.Format(time.RFC1123)}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	if options != nil && options.LegalHold != nil {
		req.Raw().Header["x-ms-legal-hold"] = []string{strconv.FormatBool(*options.LegalHold)}
	}
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			if v != nil {
				req.Raw().Header["x-ms-meta-"+k] = []string{*v}
			}
		}
	}
	if options != nil && options.BlobTagsString != nil {
		req.Raw().Header["x-ms-tags"] = []string{*options.BlobTagsString}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *PageBlobClient) createHandleResponse(resp *http.Response) (PageBlobClientCreateResponse, error) {
	result := PageBlobClientCreateResponse{}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Content-MD5"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientCreateResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientCreateResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["x-ms-encryption-key-sha256"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.EncryptionKeySHA256 = &val
	}
	if vals, ok := resp.Header["x-ms-encryption-scope"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.EncryptionScope = &val
	}
	if vals, ok := resp.Header["x-ms-request-server-encrypted"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return PageBlobClientCreateResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	if vals, ok := resp.Header["x-ms-version-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.VersionID = &val
	}
	return result, nil
}

// NewGetPageRangesPager - The Get Page Ranges operation returns the list of valid page ranges for a page blob or snapshot
// of a page blob
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - options - PageBlobClientGetPageRangesOptions contains the optional parameters for the PageBlobClient.NewGetPageRangesPager
//     method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) NewGetPageRangesPager(containerName string, blob string, comp Enum33, options *PageBlobClientGetPageRangesOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) *runtime.Pager[PageBlobClientGetPageRangesResponse] {
	return runtime.NewPager(runtime.PagingHandler[PageBlobClientGetPageRangesResponse]{
		More: func(page PageBlobClientGetPageRangesResponse) bool {
			return page.NextMarker != nil && len(*page.NextMarker) > 0
		},
		Fetcher: func(ctx context.Context, page *PageBlobClientGetPageRangesResponse) (PageBlobClientGetPageRangesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextMarker
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getPageRangesCreateRequest(ctx, containerName, blob, comp, options, leaseAccessConditions, modifiedAccessConditions)
			}, nil)
			if err != nil {
				return PageBlobClientGetPageRangesResponse{}, err
			}
			return client.getPageRangesHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getPageRangesCreateRequest creates the GetPageRanges request.
func (client *PageBlobClient) getPageRangesCreateRequest(ctx context.Context, containerName string, blob string, comp Enum33, options *PageBlobClientGetPageRangesOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Snapshot != nil {
		reqQP.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	if options != nil && options.Range != nil {
		req.Raw().Header["x-ms-range"] = []string{*options.Range}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// getPageRangesHandleResponse handles the GetPageRanges response.
func (client *PageBlobClient) getPageRangesHandleResponse(resp *http.Response) (PageBlobClientGetPageRangesResponse, error) {
	result := PageBlobClientGetPageRangesResponse{}
	if vals, ok := resp.Header["x-ms-blob-content-length"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobContentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientGetPageRangesResponse{}, err
		}
		result.BlobContentLength = &blobContentLength
	}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientGetPageRangesResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientGetPageRangesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	if err := runtime.UnmarshalAsXML(resp, &result.PageList); err != nil {
		return PageBlobClientGetPageRangesResponse{}, err
	}
	return result, nil
}

// NewGetPageRangesDiffPager - The Get Page Ranges Diff operation returns the list of valid page ranges for a page blob that
// were changed between target blob and previous snapshot.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - options - PageBlobClientGetPageRangesDiffOptions contains the optional parameters for the PageBlobClient.NewGetPageRangesDiffPager
//     method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) NewGetPageRangesDiffPager(containerName string, blob string, comp Enum33, options *PageBlobClientGetPageRangesDiffOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) *runtime.Pager[PageBlobClientGetPageRangesDiffResponse] {
	return runtime.NewPager(runtime.PagingHandler[PageBlobClientGetPageRangesDiffResponse]{
		More: func(page PageBlobClientGetPageRangesDiffResponse) bool {
			return page.NextMarker != nil && len(*page.NextMarker) > 0
		},
		Fetcher: func(ctx context.Context, page *PageBlobClientGetPageRangesDiffResponse) (PageBlobClientGetPageRangesDiffResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextMarker
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.getPageRangesDiffCreateRequest(ctx, containerName, blob, comp, options, leaseAccessConditions, modifiedAccessConditions)
			}, nil)
			if err != nil {
				return PageBlobClientGetPageRangesDiffResponse{}, err
			}
			return client.getPageRangesDiffHandleResponse(resp)
		},
		Tracer: client.internal.Tracer(),
	})
}

// getPageRangesDiffCreateRequest creates the GetPageRangesDiff request.
func (client *PageBlobClient) getPageRangesDiffCreateRequest(ctx context.Context, containerName string, blob string, comp Enum33, options *PageBlobClientGetPageRangesDiffOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Prevsnapshot != nil {
		reqQP.Set("prevsnapshot", *options.Prevsnapshot)
	}
	if options != nil && options.Snapshot != nil {
		reqQP.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	if options != nil && options.PrevSnapshotURL != nil {
		req.Raw().Header["x-ms-previous-snapshot-url"] = []string{*options.PrevSnapshotURL}
	}
	if options != nil && options.Range != nil {
		req.Raw().Header["x-ms-range"] = []string{*options.Range}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// getPageRangesDiffHandleResponse handles the GetPageRangesDiff response.
func (client *PageBlobClient) getPageRangesDiffHandleResponse(resp *http.Response) (PageBlobClientGetPageRangesDiffResponse, error) {
	result := PageBlobClientGetPageRangesDiffResponse{}
	if vals, ok := resp.Header["x-ms-blob-content-length"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobContentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientGetPageRangesDiffResponse{}, err
		}
		result.BlobContentLength = &blobContentLength
	}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientGetPageRangesDiffResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientGetPageRangesDiffResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	if err := runtime.UnmarshalAsXML(resp, &result.PageList); err != nil {
		return PageBlobClientGetPageRangesDiffResponse{}, err
	}
	return result, nil
}

// Resize - Resize the Blob
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - blobContentLength - This header specifies the maximum size for the page blob, up to 1 TB. The page blob size must be aligned
//     to a 512-byte boundary.
//   - options - PageBlobClientResizeOptions contains the optional parameters for the PageBlobClient.Resize method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - CpkInfo - CpkInfo contains a group of parameters for the Client.Download method.
//   - CpkScopeInfo - CpkScopeInfo contains a group of parameters for the Client.SetMetadata method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) Resize(ctx context.Context, containerName string, blob string, comp Enum1, blobContentLength int64, options *PageBlobClientResizeOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (PageBlobClientResizeResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.Resize", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.resizeCreateRequest(ctx, containerName, blob, comp, blobContentLength, options, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if err != nil {
		return PageBlobClientResizeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientResizeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientResizeResponse{}, err
	}
	resp, err := client.resizeHandleResponse(httpResp)
	return resp, err
}

// resizeCreateRequest creates the Resize request.
func (client *PageBlobClient) resizeCreateRequest(ctx context.Context, containerName string, blob string, comp Enum1, blobContentLength int64, options *PageBlobClientResizeOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	req.Raw().Header["x-ms-blob-content-length"] = []string{strconv.FormatInt(blobContentLength, 10)}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header["x-ms-encryption-algorithm"] = []string{"AES256"}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header["x-ms-encryption-key"] = []string{*cpkInfo.EncryptionKey}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header["x-ms-encryption-key-sha256"] = []string{*cpkInfo.EncryptionKeySHA256}
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header["x-ms-encryption-scope"] = []string{*cpkScopeInfo.EncryptionScope}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// resizeHandleResponse handles the Resize response.
func (client *PageBlobClient) resizeHandleResponse(resp *http.Response) (PageBlobClientResizeResponse, error) {
	result := PageBlobClientResizeResponse{}
	if vals, ok := resp.Header["x-ms-blob-sequence-number"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientResizeResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientResizeResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientResizeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	return result, nil
}

// UpdateSequenceNumber - Update the sequence number of the blob
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - sequenceNumberAction - Required if the x-ms-blob-sequence-number header is set for the request. This property applies to
//     page blobs only. This property indicates how the service should modify the blob's sequence number
//   - options - PageBlobClientUpdateSequenceNumberOptions contains the optional parameters for the PageBlobClient.UpdateSequenceNumber
//     method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) UpdateSequenceNumber(ctx context.Context, containerName string, blob string, comp Enum1, sequenceNumberAction SequenceNumberActionType, options *PageBlobClientUpdateSequenceNumberOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (PageBlobClientUpdateSequenceNumberResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.UpdateSequenceNumber", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.updateSequenceNumberCreateRequest(ctx, containerName, blob, comp, sequenceNumberAction, options, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return PageBlobClientUpdateSequenceNumberResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientUpdateSequenceNumberResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientUpdateSequenceNumberResponse{}, err
	}
	resp, err := client.updateSequenceNumberHandleResponse(httpResp)
	return resp, err
}

// updateSequenceNumberCreateRequest creates the UpdateSequenceNumber request.
func (client *PageBlobClient) updateSequenceNumberCreateRequest(ctx context.Context, containerName string, blob string, comp Enum1, sequenceNumberAction SequenceNumberActionType, options *PageBlobClientUpdateSequenceNumberOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.BlobSequenceNumber != nil {
		req.Raw().Header["x-ms-blob-sequence-number"] = []string{strconv.FormatInt(*options.BlobSequenceNumber, 10)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-sequence-number-action"] = []string{string(sequenceNumberAction)}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// updateSequenceNumberHandleResponse handles the UpdateSequenceNumber response.
func (client *PageBlobClient) updateSequenceNumberHandleResponse(resp *http.Response) (PageBlobClientUpdateSequenceNumberResponse, error) {
	result := PageBlobClientUpdateSequenceNumberResponse{}
	if vals, ok := resp.Header["x-ms-blob-sequence-number"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientUpdateSequenceNumberResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientUpdateSequenceNumberResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientUpdateSequenceNumberResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	return result, nil
}

// UploadPages - The Upload Pages operation writes a range of pages to a page blob
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - contentLength - The length of the request.
//   - body - Initial data
//   - options - PageBlobClientUploadPagesOptions contains the optional parameters for the PageBlobClient.UploadPages method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - CpkInfo - CpkInfo contains a group of parameters for the Client.Download method.
//   - CpkScopeInfo - CpkScopeInfo contains a group of parameters for the Client.SetMetadata method.
//   - SequenceNumberAccessConditions - SequenceNumberAccessConditions contains a group of parameters for the PageBlobClient.UploadPages
//     method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
func (client *PageBlobClient) UploadPages(ctx context.Context, containerName string, blob string, comp Enum32, contentLength int64, body io.ReadSeekCloser, options *PageBlobClientUploadPagesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, sequenceNumberAccessConditions *SequenceNumberAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (PageBlobClientUploadPagesResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.UploadPages", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.uploadPagesCreateRequest(ctx, containerName, blob, comp, contentLength, body, options, leaseAccessConditions, cpkInfo, cpkScopeInfo, sequenceNumberAccessConditions, modifiedAccessConditions)
	if err != nil {
		return PageBlobClientUploadPagesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientUploadPagesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientUploadPagesResponse{}, err
	}
	resp, err := client.uploadPagesHandleResponse(httpResp)
	return resp, err
}

// uploadPagesCreateRequest creates the UploadPages request.
func (client *PageBlobClient) uploadPagesCreateRequest(ctx context.Context, containerName string, blob string, comp Enum32, contentLength int64, body io.ReadSeekCloser, options *PageBlobClientUploadPagesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, sequenceNumberAccessConditions *SequenceNumberAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	req.Raw().Header["Content-Length"] = []string{strconv.FormatInt(contentLength, 10)}
	if options != nil && options.TransactionalContentMD5 != nil {
		req.Raw().Header["Content-MD5"] = []string{base64.StdEncoding.EncodeToString(options.TransactionalContentMD5)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if options != nil && options.TransactionalContentCRC64 != nil {
		req.Raw().Header["x-ms-content-crc64"] = []string{base64.StdEncoding.EncodeToString(options.TransactionalContentCRC64)}
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header["x-ms-encryption-algorithm"] = []string{"AES256"}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header["x-ms-encryption-key"] = []string{*cpkInfo.EncryptionKey}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header["x-ms-encryption-key-sha256"] = []string{*cpkInfo.EncryptionKeySHA256}
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header["x-ms-encryption-scope"] = []string{*cpkScopeInfo.EncryptionScope}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberEqualTo != nil {
		req.Raw().Header["x-ms-if-sequence-number-eq"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberEqualTo, 10)}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo != nil {
		req.Raw().Header["x-ms-if-sequence-number-le"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo, 10)}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberLessThan != nil {
		req.Raw().Header["x-ms-if-sequence-number-lt"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberLessThan, 10)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-page-write"] = []string{"update"}
	if options != nil && options.Range != nil {
		req.Raw().Header["x-ms-range"] = []string{*options.Range}
	}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	if err := req.SetBody(body, "application/octet-stream"); err != nil {
		return nil, err
	}
	return req, nil
}

// uploadPagesHandleResponse handles the UploadPages response.
func (client *PageBlobClient) uploadPagesHandleResponse(resp *http.Response) (PageBlobClientUploadPagesResponse, error) {
	result := PageBlobClientUploadPagesResponse{}
	if vals, ok := resp.Header["x-ms-blob-sequence-number"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientUploadPagesResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if vals, ok := resp.Header["x-ms-client-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ClientRequestID = &val
	}
	if vals, ok := resp.Header["Content-MD5"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientUploadPagesResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientUploadPagesResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["x-ms-encryption-key-sha256"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.EncryptionKeySHA256 = &val
	}
	if vals, ok := resp.Header["x-ms-encryption-scope"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.EncryptionScope = &val
	}
	if vals, ok := resp.Header["x-ms-request-server-encrypted"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return PageBlobClientUploadPagesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientUploadPagesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	if vals, ok := resp.Header["x-ms-content-crc64"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientUploadPagesResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	return result, nil
}

// UploadPagesFromURL - The Upload Pages operation writes a range of pages to a page blob where the contents are read from
// a URL
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-12-02
//   - containerName - The container name.
//   - blob - The blob name.
//   - comp - comp
//   - sourceURL - Specify a URL to the copy source.
//   - sourceRange - Bytes of source data in the specified range. The length of this range should match the ContentLength header
//     and x-ms-range/Range destination range header.
//   - contentLength - The length of the request.
//   - rangeParam - The range of bytes to which the source range would be written. The range should be 512 aligned and range-end
//     is required.
//   - options - PageBlobClientUploadPagesFromURLOptions contains the optional parameters for the PageBlobClient.UploadPagesFromURL
//     method.
//   - CpkInfo - CpkInfo contains a group of parameters for the Client.Download method.
//   - CpkScopeInfo - CpkScopeInfo contains a group of parameters for the Client.SetMetadata method.
//   - LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the ContainerClient.GetProperties method.
//   - SequenceNumberAccessConditions - SequenceNumberAccessConditions contains a group of parameters for the PageBlobClient.UploadPages
//     method.
//   - ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the ContainerClient.Delete method.
//   - SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the Client.StartCopyFromURL
//     method.
func (client *PageBlobClient) UploadPagesFromURL(ctx context.Context, containerName string, blob string, comp Enum32, sourceURL string, sourceRange string, contentLength int64, rangeParam string, options *PageBlobClientUploadPagesFromURLOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, leaseAccessConditions *LeaseAccessConditions, sequenceNumberAccessConditions *SequenceNumberAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (PageBlobClientUploadPagesFromURLResponse, error) {
	var err error
	ctx, endSpan := runtime.StartSpan(ctx, "PageBlobClient.UploadPagesFromURL", client.internal.Tracer(), nil)
	defer func() { endSpan(err) }()
	req, err := client.uploadPagesFromURLCreateRequest(ctx, containerName, blob, comp, sourceURL, sourceRange, contentLength, rangeParam, options, cpkInfo, cpkScopeInfo, leaseAccessConditions, sequenceNumberAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions)
	if err != nil {
		return PageBlobClientUploadPagesFromURLResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return PageBlobClientUploadPagesFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return PageBlobClientUploadPagesFromURLResponse{}, err
	}
	resp, err := client.uploadPagesFromURLHandleResponse(httpResp)
	return resp, err
}

// uploadPagesFromURLCreateRequest creates the UploadPagesFromURL request.
func (client *PageBlobClient) uploadPagesFromURLCreateRequest(ctx context.Context, containerName string, blob string, comp Enum32, sourceURL string, sourceRange string, contentLength int64, rangeParam string, options *PageBlobClientUploadPagesFromURLOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, leaseAccessConditions *LeaseAccessConditions, sequenceNumberAccessConditions *SequenceNumberAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (*policy.Request, error) {
	urlPath := "/{containerName}/{blob}"
	if containerName == "" {
		return nil, errors.New("parameter containerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	if blob == "" {
		return nil, errors.New("parameter blob cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blob}", url.PathEscape(blob))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	req.Raw().Header["Content-Length"] = []string{strconv.FormatInt(contentLength, 10)}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*modifiedAccessConditions.IfMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*modifiedAccessConditions.IfNoneMatch}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["x-ms-copy-source"] = []string{sourceURL}
	if options != nil && options.CopySourceAuthorization != nil {
		req.Raw().Header["x-ms-copy-source-authorization"] = []string{*options.CopySourceAuthorization}
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header["x-ms-encryption-algorithm"] = []string{"AES256"}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header["x-ms-encryption-key"] = []string{*cpkInfo.EncryptionKey}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header["x-ms-encryption-key-sha256"] = []string{*cpkInfo.EncryptionKeySHA256}
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header["x-ms-encryption-scope"] = []string{*cpkScopeInfo.EncryptionScope}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberEqualTo != nil {
		req.Raw().Header["x-ms-if-sequence-number-eq"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberEqualTo, 10)}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo != nil {
		req.Raw().Header["x-ms-if-sequence-number-le"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberLessThanOrEqualTo, 10)}
	}
	if sequenceNumberAccessConditions != nil && sequenceNumberAccessConditions.IfSequenceNumberLessThan != nil {
		req.Raw().Header["x-ms-if-sequence-number-lt"] = []string{strconv.FormatInt(*sequenceNumberAccessConditions.IfSequenceNumberLessThan, 10)}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header["x-ms-if-tags"] = []string{*modifiedAccessConditions.IfTags}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-page-write"] = []string{"update"}
	req.Raw().Header["x-ms-range"] = []string{rangeParam}
	if options != nil && options.SourceContentcrc64 != nil {
		req.Raw().Header["x-ms-source-content-crc64"] = []string{base64.StdEncoding.EncodeToString(options.SourceContentcrc64)}
	}
	if options != nil && options.SourceContentMD5 != nil {
		req.Raw().Header["x-ms-source-content-md5"] = []string{base64.StdEncoding.EncodeToString(options.SourceContentMD5)}
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Raw().Header["x-ms-source-if-match"] = []string{*sourceModifiedAccessConditions.SourceIfMatch}
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Raw().Header["x-ms-source-if-modified-since"] = []string{sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123)}
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Raw().Header["x-ms-source-if-none-match"] = []string{*sourceModifiedAccessConditions.SourceIfNoneMatch}
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Raw().Header["x-ms-source-if-unmodified-since"] = []string{sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123)}
	}
	req.Raw().Header["x-ms-source-range"] = []string{sourceRange}
	req.Raw().Header["x-ms-version"] = []string{string(client.version)}
	return req, nil
}

// uploadPagesFromURLHandleResponse handles the UploadPagesFromURL response.
func (client *PageBlobClient) uploadPagesFromURLHandleResponse(resp *http.Response) (PageBlobClientUploadPagesFromURLResponse, error) {
	result := PageBlobClientUploadPagesFromURLResponse{}
	if vals, ok := resp.Header["x-ms-blob-sequence-number"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return PageBlobClientUploadPagesFromURLResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if vals, ok := resp.Header["Content-MD5"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientUploadPagesFromURLResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if vals, ok := resp.Header["Date"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientUploadPagesFromURLResponse{}, err
		}
		result.Date = &date
	}
	if vals, ok := resp.Header["ETag"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.ETag = &val
	}
	if vals, ok := resp.Header["x-ms-encryption-key-sha256"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.EncryptionKeySHA256 = &val
	}
	if vals, ok := resp.Header["x-ms-encryption-scope"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.EncryptionScope = &val
	}
	if vals, ok := resp.Header["x-ms-request-server-encrypted"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return PageBlobClientUploadPagesFromURLResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if vals, ok := resp.Header["Last-Modified"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return PageBlobClientUploadPagesFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if vals, ok := resp.Header["x-ms-request-id"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.RequestID = &val
	}
	if vals, ok := resp.Header["x-ms-version"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		result.Version = &val
	}
	if vals, ok := resp.Header["x-ms-content-crc64"]; ok && len(vals) > 0 && vals[0] != "" {
		val := vals[0]
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return PageBlobClientUploadPagesFromURLResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	return result, nil
}
