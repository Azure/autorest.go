//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ContainerServicesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ContainerServicesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ContainerServicesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ContainerServicesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ContainerServicesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ContainerServicesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ContainerServicesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ContainerServicesClientCreateOrUpdateResponse, error) {
	result := ContainerServicesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ContainerService)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ContainerServicesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ContainerServicesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ContainerServicesClientCreateOrUpdatePoller) Resume(token string, client *ContainerServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ContainerServicesClient.CreateOrUpdate", token, client.pl)
	return
}

// ContainerServicesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ContainerServicesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ContainerServicesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ContainerServicesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ContainerServicesClientDeletePoller) Result(ctx context.Context) (resp ContainerServicesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ContainerServicesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ContainerServicesClientDeleteResponse, error) {
	result := ContainerServicesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ContainerServicesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ContainerServicesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ContainerServicesClientDeletePoller) Resume(token string, client *ContainerServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ContainerServicesClient.Delete", token, client.pl)
	return
}

// DedicatedHostsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DedicatedHostsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DedicatedHostsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DedicatedHostsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DedicatedHostsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp DedicatedHostsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DedicatedHostsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostsClientCreateOrUpdateResponse, error) {
	result := DedicatedHostsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DedicatedHost)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DedicatedHostsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DedicatedHostsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DedicatedHostsClientCreateOrUpdatePoller) Resume(token string, client *DedicatedHostsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DedicatedHostsClient.CreateOrUpdate", token, client.pl)
	return
}

// DedicatedHostsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DedicatedHostsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DedicatedHostsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DedicatedHostsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DedicatedHostsClientDeletePoller) Result(ctx context.Context) (resp DedicatedHostsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DedicatedHostsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostsClientDeleteResponse, error) {
	result := DedicatedHostsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DedicatedHostsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DedicatedHostsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DedicatedHostsClientDeletePoller) Resume(token string, client *DedicatedHostsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DedicatedHostsClient.Delete", token, client.pl)
	return
}

// DedicatedHostsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DedicatedHostsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DedicatedHostsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DedicatedHostsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DedicatedHostsClientUpdatePoller) Result(ctx context.Context) (resp DedicatedHostsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DedicatedHostsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostsClientUpdateResponse, error) {
	result := DedicatedHostsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DedicatedHost)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DedicatedHostsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DedicatedHostsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DedicatedHostsClientUpdatePoller) Resume(token string, client *DedicatedHostsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DedicatedHostsClient.Update", token, client.pl)
	return
}

// DiskEncryptionSetsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DiskEncryptionSetsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DiskEncryptionSetsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DiskEncryptionSetsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DiskEncryptionSetsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp DiskEncryptionSetsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DiskEncryptionSetsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientCreateOrUpdateResponse, error) {
	result := DiskEncryptionSetsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DiskEncryptionSet)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DiskEncryptionSetsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DiskEncryptionSetsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DiskEncryptionSetsClientCreateOrUpdatePoller) Resume(token string, client *DiskEncryptionSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.CreateOrUpdate", token, client.pl)
	return
}

// DiskEncryptionSetsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DiskEncryptionSetsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DiskEncryptionSetsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DiskEncryptionSetsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DiskEncryptionSetsClientDeletePoller) Result(ctx context.Context) (resp DiskEncryptionSetsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DiskEncryptionSetsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientDeleteResponse, error) {
	result := DiskEncryptionSetsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DiskEncryptionSetsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DiskEncryptionSetsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DiskEncryptionSetsClientDeletePoller) Resume(token string, client *DiskEncryptionSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.Delete", token, client.pl)
	return
}

// DiskEncryptionSetsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DiskEncryptionSetsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DiskEncryptionSetsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DiskEncryptionSetsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DiskEncryptionSetsClientUpdatePoller) Result(ctx context.Context) (resp DiskEncryptionSetsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DiskEncryptionSetsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientUpdateResponse, error) {
	result := DiskEncryptionSetsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DiskEncryptionSet)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DiskEncryptionSetsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DiskEncryptionSetsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DiskEncryptionSetsClientUpdatePoller) Resume(token string, client *DiskEncryptionSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.Update", token, client.pl)
	return
}

// DisksClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DisksClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DisksClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DisksClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DisksClientCreateOrUpdatePoller) Result(ctx context.Context) (resp DisksClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DisksClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientCreateOrUpdateResponse, error) {
	result := DisksClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Disk)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DisksClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DisksClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DisksClientCreateOrUpdatePoller) Resume(token string, client *DisksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DisksClient.CreateOrUpdate", token, client.pl)
	return
}

// DisksClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DisksClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DisksClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DisksClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DisksClientDeletePoller) Result(ctx context.Context) (resp DisksClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DisksClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientDeleteResponse, error) {
	result := DisksClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DisksClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DisksClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DisksClientDeletePoller) Resume(token string, client *DisksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DisksClient.Delete", token, client.pl)
	return
}

// DisksClientGrantAccessPoller provides polling facilities until the operation reaches a terminal state.
type DisksClientGrantAccessPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DisksClientGrantAccessPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DisksClientGrantAccessPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DisksClientGrantAccessPoller) Result(ctx context.Context) (resp DisksClientGrantAccessResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DisksClientGrantAccessPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientGrantAccessResponse, error) {
	result := DisksClientGrantAccessResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.AccessURI)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DisksClientGrantAccessPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DisksClientGrantAccessPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DisksClientGrantAccessPoller) Resume(token string, client *DisksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DisksClient.GrantAccess", token, client.pl)
	return
}

// DisksClientRevokeAccessPoller provides polling facilities until the operation reaches a terminal state.
type DisksClientRevokeAccessPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DisksClientRevokeAccessPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DisksClientRevokeAccessPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DisksClientRevokeAccessPoller) Result(ctx context.Context) (resp DisksClientRevokeAccessResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DisksClientRevokeAccessPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientRevokeAccessResponse, error) {
	result := DisksClientRevokeAccessResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DisksClientRevokeAccessPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DisksClientRevokeAccessPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DisksClientRevokeAccessPoller) Resume(token string, client *DisksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DisksClient.RevokeAccess", token, client.pl)
	return
}

// DisksClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DisksClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DisksClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DisksClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DisksClientUpdatePoller) Result(ctx context.Context) (resp DisksClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DisksClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientUpdateResponse, error) {
	result := DisksClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Disk)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DisksClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DisksClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DisksClientUpdatePoller) Resume(token string, client *DisksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DisksClient.Update", token, client.pl)
	return
}

// GalleriesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleriesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleriesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleriesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleriesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp GalleriesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleriesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleriesClientCreateOrUpdateResponse, error) {
	result := GalleriesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Gallery)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleriesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleriesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleriesClientCreateOrUpdatePoller) Resume(token string, client *GalleriesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleriesClient.CreateOrUpdate", token, client.pl)
	return
}

// GalleriesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type GalleriesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleriesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleriesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleriesClientDeletePoller) Result(ctx context.Context) (resp GalleriesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleriesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleriesClientDeleteResponse, error) {
	result := GalleriesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleriesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleriesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleriesClientDeletePoller) Resume(token string, client *GalleriesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleriesClient.Delete", token, client.pl)
	return
}

// GalleriesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleriesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleriesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleriesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleriesClientUpdatePoller) Result(ctx context.Context) (resp GalleriesClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleriesClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleriesClientUpdateResponse, error) {
	result := GalleriesClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Gallery)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleriesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleriesClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleriesClientUpdatePoller) Resume(token string, client *GalleriesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleriesClient.Update", token, client.pl)
	return
}

// GalleryApplicationVersionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationVersionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryApplicationVersionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryApplicationVersionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryApplicationVersionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp GalleryApplicationVersionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryApplicationVersionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionsClientCreateOrUpdateResponse, error) {
	result := GalleryApplicationVersionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryApplicationVersion)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryApplicationVersionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryApplicationVersionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryApplicationVersionsClientCreateOrUpdatePoller) Resume(token string, client *GalleryApplicationVersionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryApplicationVersionsClient.CreateOrUpdate", token, client.pl)
	return
}

// GalleryApplicationVersionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationVersionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryApplicationVersionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryApplicationVersionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryApplicationVersionsClientDeletePoller) Result(ctx context.Context) (resp GalleryApplicationVersionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryApplicationVersionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionsClientDeleteResponse, error) {
	result := GalleryApplicationVersionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryApplicationVersionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryApplicationVersionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryApplicationVersionsClientDeletePoller) Resume(token string, client *GalleryApplicationVersionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryApplicationVersionsClient.Delete", token, client.pl)
	return
}

// GalleryApplicationVersionsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationVersionsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryApplicationVersionsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryApplicationVersionsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryApplicationVersionsClientUpdatePoller) Result(ctx context.Context) (resp GalleryApplicationVersionsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryApplicationVersionsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionsClientUpdateResponse, error) {
	result := GalleryApplicationVersionsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryApplicationVersion)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryApplicationVersionsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryApplicationVersionsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryApplicationVersionsClientUpdatePoller) Resume(token string, client *GalleryApplicationVersionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryApplicationVersionsClient.Update", token, client.pl)
	return
}

// GalleryApplicationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryApplicationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryApplicationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryApplicationsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp GalleryApplicationsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryApplicationsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationsClientCreateOrUpdateResponse, error) {
	result := GalleryApplicationsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryApplication)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryApplicationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryApplicationsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryApplicationsClientCreateOrUpdatePoller) Resume(token string, client *GalleryApplicationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryApplicationsClient.CreateOrUpdate", token, client.pl)
	return
}

// GalleryApplicationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryApplicationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryApplicationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryApplicationsClientDeletePoller) Result(ctx context.Context) (resp GalleryApplicationsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryApplicationsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationsClientDeleteResponse, error) {
	result := GalleryApplicationsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryApplicationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryApplicationsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryApplicationsClientDeletePoller) Resume(token string, client *GalleryApplicationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryApplicationsClient.Delete", token, client.pl)
	return
}

// GalleryApplicationsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryApplicationsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryApplicationsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryApplicationsClientUpdatePoller) Result(ctx context.Context) (resp GalleryApplicationsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryApplicationsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationsClientUpdateResponse, error) {
	result := GalleryApplicationsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryApplication)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryApplicationsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryApplicationsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryApplicationsClientUpdatePoller) Resume(token string, client *GalleryApplicationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryApplicationsClient.Update", token, client.pl)
	return
}

// GalleryImageVersionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImageVersionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryImageVersionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryImageVersionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryImageVersionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp GalleryImageVersionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryImageVersionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionsClientCreateOrUpdateResponse, error) {
	result := GalleryImageVersionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryImageVersion)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryImageVersionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryImageVersionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryImageVersionsClientCreateOrUpdatePoller) Resume(token string, client *GalleryImageVersionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryImageVersionsClient.CreateOrUpdate", token, client.pl)
	return
}

// GalleryImageVersionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImageVersionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryImageVersionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryImageVersionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryImageVersionsClientDeletePoller) Result(ctx context.Context) (resp GalleryImageVersionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryImageVersionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionsClientDeleteResponse, error) {
	result := GalleryImageVersionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryImageVersionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryImageVersionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryImageVersionsClientDeletePoller) Resume(token string, client *GalleryImageVersionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryImageVersionsClient.Delete", token, client.pl)
	return
}

// GalleryImageVersionsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImageVersionsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryImageVersionsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryImageVersionsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryImageVersionsClientUpdatePoller) Result(ctx context.Context) (resp GalleryImageVersionsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryImageVersionsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionsClientUpdateResponse, error) {
	result := GalleryImageVersionsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryImageVersion)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryImageVersionsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryImageVersionsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryImageVersionsClientUpdatePoller) Resume(token string, client *GalleryImageVersionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryImageVersionsClient.Update", token, client.pl)
	return
}

// GalleryImagesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImagesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryImagesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryImagesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryImagesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp GalleryImagesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryImagesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImagesClientCreateOrUpdateResponse, error) {
	result := GalleryImagesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryImage)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryImagesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryImagesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryImagesClientCreateOrUpdatePoller) Resume(token string, client *GalleryImagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryImagesClient.CreateOrUpdate", token, client.pl)
	return
}

// GalleryImagesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImagesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryImagesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryImagesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryImagesClientDeletePoller) Result(ctx context.Context) (resp GalleryImagesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryImagesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImagesClientDeleteResponse, error) {
	result := GalleryImagesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryImagesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryImagesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryImagesClientDeletePoller) Resume(token string, client *GalleryImagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryImagesClient.Delete", token, client.pl)
	return
}

// GalleryImagesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImagesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *GalleryImagesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *GalleryImagesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *GalleryImagesClientUpdatePoller) Result(ctx context.Context) (resp GalleryImagesClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *GalleryImagesClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImagesClientUpdateResponse, error) {
	result := GalleryImagesClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GalleryImage)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *GalleryImagesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a GalleryImagesClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *GalleryImagesClientUpdatePoller) Resume(token string, client *GalleryImagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("GalleryImagesClient.Update", token, client.pl)
	return
}

// ImagesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ImagesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ImagesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ImagesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ImagesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ImagesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ImagesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ImagesClientCreateOrUpdateResponse, error) {
	result := ImagesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Image)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ImagesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ImagesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ImagesClientCreateOrUpdatePoller) Resume(token string, client *ImagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ImagesClient.CreateOrUpdate", token, client.pl)
	return
}

// ImagesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ImagesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ImagesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ImagesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ImagesClientDeletePoller) Result(ctx context.Context) (resp ImagesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ImagesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ImagesClientDeleteResponse, error) {
	result := ImagesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ImagesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ImagesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ImagesClientDeletePoller) Resume(token string, client *ImagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ImagesClient.Delete", token, client.pl)
	return
}

// ImagesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ImagesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ImagesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ImagesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ImagesClientUpdatePoller) Result(ctx context.Context) (resp ImagesClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ImagesClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ImagesClientUpdateResponse, error) {
	result := ImagesClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Image)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ImagesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ImagesClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ImagesClientUpdatePoller) Resume(token string, client *ImagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ImagesClient.Update", token, client.pl)
	return
}

// LogAnalyticsClientExportRequestRateByIntervalPoller provides polling facilities until the operation reaches a terminal state.
type LogAnalyticsClientExportRequestRateByIntervalPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LogAnalyticsClientExportRequestRateByIntervalPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LogAnalyticsClientExportRequestRateByIntervalPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LogAnalyticsClientExportRequestRateByIntervalPoller) Result(ctx context.Context) (resp LogAnalyticsClientExportRequestRateByIntervalResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *LogAnalyticsClientExportRequestRateByIntervalPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LogAnalyticsClientExportRequestRateByIntervalResponse, error) {
	result := LogAnalyticsClientExportRequestRateByIntervalResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LogAnalyticsOperationResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LogAnalyticsClientExportRequestRateByIntervalPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LogAnalyticsClientExportRequestRateByIntervalPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LogAnalyticsClientExportRequestRateByIntervalPoller) Resume(token string, client *LogAnalyticsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LogAnalyticsClient.ExportRequestRateByInterval", token, client.pl)
	return
}

// LogAnalyticsClientExportThrottledRequestsPoller provides polling facilities until the operation reaches a terminal state.
type LogAnalyticsClientExportThrottledRequestsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LogAnalyticsClientExportThrottledRequestsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LogAnalyticsClientExportThrottledRequestsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LogAnalyticsClientExportThrottledRequestsPoller) Result(ctx context.Context) (resp LogAnalyticsClientExportThrottledRequestsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *LogAnalyticsClientExportThrottledRequestsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (LogAnalyticsClientExportThrottledRequestsResponse, error) {
	result := LogAnalyticsClientExportThrottledRequestsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LogAnalyticsOperationResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LogAnalyticsClientExportThrottledRequestsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LogAnalyticsClientExportThrottledRequestsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LogAnalyticsClientExportThrottledRequestsPoller) Resume(token string, client *LogAnalyticsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LogAnalyticsClient.ExportThrottledRequests", token, client.pl)
	return
}

// SnapshotsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SnapshotsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SnapshotsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SnapshotsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SnapshotsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp SnapshotsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SnapshotsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientCreateOrUpdateResponse, error) {
	result := SnapshotsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Snapshot)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SnapshotsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SnapshotsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SnapshotsClientCreateOrUpdatePoller) Resume(token string, client *SnapshotsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SnapshotsClient.CreateOrUpdate", token, client.pl)
	return
}

// SnapshotsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SnapshotsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SnapshotsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SnapshotsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SnapshotsClientDeletePoller) Result(ctx context.Context) (resp SnapshotsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SnapshotsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientDeleteResponse, error) {
	result := SnapshotsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SnapshotsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SnapshotsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SnapshotsClientDeletePoller) Resume(token string, client *SnapshotsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SnapshotsClient.Delete", token, client.pl)
	return
}

// SnapshotsClientGrantAccessPoller provides polling facilities until the operation reaches a terminal state.
type SnapshotsClientGrantAccessPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SnapshotsClientGrantAccessPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SnapshotsClientGrantAccessPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SnapshotsClientGrantAccessPoller) Result(ctx context.Context) (resp SnapshotsClientGrantAccessResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SnapshotsClientGrantAccessPoller) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientGrantAccessResponse, error) {
	result := SnapshotsClientGrantAccessResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.AccessURI)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SnapshotsClientGrantAccessPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SnapshotsClientGrantAccessPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SnapshotsClientGrantAccessPoller) Resume(token string, client *SnapshotsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SnapshotsClient.GrantAccess", token, client.pl)
	return
}

// SnapshotsClientRevokeAccessPoller provides polling facilities until the operation reaches a terminal state.
type SnapshotsClientRevokeAccessPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SnapshotsClientRevokeAccessPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SnapshotsClientRevokeAccessPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SnapshotsClientRevokeAccessPoller) Result(ctx context.Context) (resp SnapshotsClientRevokeAccessResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SnapshotsClientRevokeAccessPoller) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientRevokeAccessResponse, error) {
	result := SnapshotsClientRevokeAccessResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SnapshotsClientRevokeAccessPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SnapshotsClientRevokeAccessPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SnapshotsClientRevokeAccessPoller) Resume(token string, client *SnapshotsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SnapshotsClient.RevokeAccess", token, client.pl)
	return
}

// SnapshotsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SnapshotsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SnapshotsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SnapshotsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SnapshotsClientUpdatePoller) Result(ctx context.Context) (resp SnapshotsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SnapshotsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientUpdateResponse, error) {
	result := SnapshotsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Snapshot)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SnapshotsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SnapshotsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SnapshotsClientUpdatePoller) Resume(token string, client *SnapshotsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SnapshotsClient.Update", token, client.pl)
	return
}

// VirtualMachineExtensionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineExtensionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineExtensionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineExtensionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineExtensionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualMachineExtensionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineExtensionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientCreateOrUpdateResponse, error) {
	result := VirtualMachineExtensionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineExtension)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineExtensionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineExtensionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineExtensionsClientCreateOrUpdatePoller) Resume(token string, client *VirtualMachineExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualMachineExtensionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineExtensionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineExtensionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineExtensionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineExtensionsClientDeletePoller) Result(ctx context.Context) (resp VirtualMachineExtensionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineExtensionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientDeleteResponse, error) {
	result := VirtualMachineExtensionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineExtensionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineExtensionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineExtensionsClientDeletePoller) Resume(token string, client *VirtualMachineExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.Delete", token, client.pl)
	return
}

// VirtualMachineExtensionsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineExtensionsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineExtensionsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineExtensionsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineExtensionsClientUpdatePoller) Result(ctx context.Context) (resp VirtualMachineExtensionsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineExtensionsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientUpdateResponse, error) {
	result := VirtualMachineExtensionsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineExtension)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineExtensionsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineExtensionsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineExtensionsClientUpdatePoller) Resume(token string, client *VirtualMachineExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.Update", token, client.pl)
	return
}

// VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse, error) {
	result := VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineScaleSetExtension)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller) Resume(token string, client *VirtualMachineScaleSetExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetExtensionsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualMachineScaleSetExtensionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetExtensionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetExtensionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetExtensionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetExtensionsClientDeletePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetExtensionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetExtensionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionsClientDeleteResponse, error) {
	result := VirtualMachineScaleSetExtensionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetExtensionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetExtensionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetExtensionsClientDeletePoller) Resume(token string, client *VirtualMachineScaleSetExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetExtensionsClient.Delete", token, client.pl)
	return
}

// VirtualMachineScaleSetExtensionsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetExtensionsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetExtensionsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetExtensionsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetExtensionsClientUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetExtensionsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetExtensionsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionsClientUpdateResponse, error) {
	result := VirtualMachineScaleSetExtensionsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineScaleSetExtension)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetExtensionsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetExtensionsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetExtensionsClientUpdatePoller) Resume(token string, client *VirtualMachineScaleSetExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetExtensionsClient.Update", token, client.pl)
	return
}

// VirtualMachineScaleSetRollingUpgradesClientCancelPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetRollingUpgradesClientCancelPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetRollingUpgradesClientCancelPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetRollingUpgradesClientCancelPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetRollingUpgradesClientCancelPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetRollingUpgradesClientCancelResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetRollingUpgradesClientCancelPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetRollingUpgradesClientCancelResponse, error) {
	result := VirtualMachineScaleSetRollingUpgradesClientCancelResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetRollingUpgradesClientCancelPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetRollingUpgradesClientCancelPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetRollingUpgradesClientCancelPoller) Resume(token string, client *VirtualMachineScaleSetRollingUpgradesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetRollingUpgradesClient.Cancel", token, client.pl)
	return
}

// VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse, error) {
	result := VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller) Resume(token string, client *VirtualMachineScaleSetRollingUpgradesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetRollingUpgradesClient.StartExtensionUpgrade", token, client.pl)
	return
}

// VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse, error) {
	result := VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller) Resume(token string, client *VirtualMachineScaleSetRollingUpgradesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetRollingUpgradesClient.StartOSUpgrade", token, client.pl)
	return
}

// VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse, error) {
	result := VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineExtension)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller) Resume(token string, client *VirtualMachineScaleSetVMExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMExtensionsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualMachineScaleSetVMExtensionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMExtensionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMExtensionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMExtensionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMExtensionsClientDeletePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMExtensionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMExtensionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionsClientDeleteResponse, error) {
	result := VirtualMachineScaleSetVMExtensionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMExtensionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMExtensionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMExtensionsClientDeletePoller) Resume(token string, client *VirtualMachineScaleSetVMExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMExtensionsClient.Delete", token, client.pl)
	return
}

// VirtualMachineScaleSetVMExtensionsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMExtensionsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMExtensionsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMExtensionsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMExtensionsClientUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMExtensionsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMExtensionsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionsClientUpdateResponse, error) {
	result := VirtualMachineScaleSetVMExtensionsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineExtension)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMExtensionsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMExtensionsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMExtensionsClientUpdatePoller) Resume(token string, client *VirtualMachineScaleSetVMExtensionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMExtensionsClient.Update", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientDeallocatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientDeallocatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientDeallocatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientDeallocatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientDeallocatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientDeallocateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientDeallocatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientDeallocateResponse, error) {
	result := VirtualMachineScaleSetVMsClientDeallocateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientDeallocatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientDeallocatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientDeallocatePoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Deallocate", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientDeletePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientDeleteResponse, error) {
	result := VirtualMachineScaleSetVMsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientDeletePoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Delete", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientPerformMaintenancePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientPerformMaintenancePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientPerformMaintenancePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientPerformMaintenancePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientPerformMaintenancePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientPerformMaintenanceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientPerformMaintenancePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientPerformMaintenanceResponse, error) {
	result := VirtualMachineScaleSetVMsClientPerformMaintenanceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientPerformMaintenancePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientPerformMaintenancePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientPerformMaintenancePoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.PerformMaintenance", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientPowerOffPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientPowerOffPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientPowerOffPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientPowerOffPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientPowerOffPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientPowerOffResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientPowerOffPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientPowerOffResponse, error) {
	result := VirtualMachineScaleSetVMsClientPowerOffResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientPowerOffPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientPowerOffPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientPowerOffPoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.PowerOff", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientRedeployPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientRedeployPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientRedeployPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientRedeployPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientRedeployPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientRedeployResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientRedeployPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRedeployResponse, error) {
	result := VirtualMachineScaleSetVMsClientRedeployResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientRedeployPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRedeployPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientRedeployPoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Redeploy", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientReimageAllPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientReimageAllPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientReimageAllPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientReimageAllPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientReimageAllPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientReimageAllResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientReimageAllPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientReimageAllResponse, error) {
	result := VirtualMachineScaleSetVMsClientReimageAllResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientReimageAllPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientReimageAllPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientReimageAllPoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.ReimageAll", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientReimagePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientReimagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientReimagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientReimagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientReimagePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientReimageResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientReimagePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientReimageResponse, error) {
	result := VirtualMachineScaleSetVMsClientReimageResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientReimagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientReimagePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientReimagePoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Reimage", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientRestartPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientRestartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientRestartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientRestartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientRestartPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientRestartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientRestartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRestartResponse, error) {
	result := VirtualMachineScaleSetVMsClientRestartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientRestartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRestartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientRestartPoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Restart", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientRunCommandPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientRunCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientRunCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientRunCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientRunCommandPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientRunCommandResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientRunCommandPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRunCommandResponse, error) {
	result := VirtualMachineScaleSetVMsClientRunCommandResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.RunCommandResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientRunCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRunCommandPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientRunCommandPoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.RunCommand", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientStartPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientStartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientStartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientStartResponse, error) {
	result := VirtualMachineScaleSetVMsClientStartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientStartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientStartPoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Start", token, client.pl)
	return
}

// VirtualMachineScaleSetVMsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetVMsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetVMsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetVMsClientUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetVMsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetVMsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientUpdateResponse, error) {
	result := VirtualMachineScaleSetVMsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineScaleSetVM)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetVMsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetVMsClientUpdatePoller) Resume(token string, client *VirtualMachineScaleSetVMsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Update", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientCreateOrUpdateResponse, error) {
	result := VirtualMachineScaleSetsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineScaleSet)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientCreateOrUpdatePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientDeallocatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientDeallocatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientDeallocatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientDeallocatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientDeallocatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientDeallocateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientDeallocatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientDeallocateResponse, error) {
	result := VirtualMachineScaleSetsClientDeallocateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientDeallocatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientDeallocatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientDeallocatePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Deallocate", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientDeleteInstancesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientDeleteInstancesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientDeleteInstancesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientDeleteInstancesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientDeleteInstancesPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientDeleteInstancesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientDeleteInstancesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientDeleteInstancesResponse, error) {
	result := VirtualMachineScaleSetsClientDeleteInstancesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientDeleteInstancesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientDeleteInstancesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientDeleteInstancesPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.DeleteInstances", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientDeletePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientDeleteResponse, error) {
	result := VirtualMachineScaleSetsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientDeletePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Delete", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientPerformMaintenancePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientPerformMaintenancePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientPerformMaintenancePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientPerformMaintenancePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientPerformMaintenancePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientPerformMaintenanceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientPerformMaintenancePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientPerformMaintenanceResponse, error) {
	result := VirtualMachineScaleSetsClientPerformMaintenanceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientPerformMaintenancePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientPerformMaintenancePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientPerformMaintenancePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.PerformMaintenance", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientPowerOffPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientPowerOffPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientPowerOffPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientPowerOffPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientPowerOffPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientPowerOffResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientPowerOffPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientPowerOffResponse, error) {
	result := VirtualMachineScaleSetsClientPowerOffResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientPowerOffPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientPowerOffPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientPowerOffPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.PowerOff", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientRedeployPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientRedeployPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientRedeployPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientRedeployPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientRedeployPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientRedeployResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientRedeployPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientRedeployResponse, error) {
	result := VirtualMachineScaleSetsClientRedeployResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientRedeployPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientRedeployPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientRedeployPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Redeploy", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientReimageAllPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientReimageAllPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientReimageAllPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientReimageAllPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientReimageAllPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientReimageAllResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientReimageAllPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientReimageAllResponse, error) {
	result := VirtualMachineScaleSetsClientReimageAllResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientReimageAllPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientReimageAllPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientReimageAllPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.ReimageAll", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientReimagePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientReimagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientReimagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientReimagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientReimagePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientReimageResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientReimagePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientReimageResponse, error) {
	result := VirtualMachineScaleSetsClientReimageResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientReimagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientReimagePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientReimagePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Reimage", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientRestartPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientRestartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientRestartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientRestartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientRestartPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientRestartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientRestartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientRestartResponse, error) {
	result := VirtualMachineScaleSetsClientRestartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientRestartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientRestartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientRestartPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Restart", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse, error) {
	result := VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.SetOrchestrationServiceState", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientStartPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientStartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientStartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientStartResponse, error) {
	result := VirtualMachineScaleSetsClientStartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientStartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientStartPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Start", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientUpdateInstancesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientUpdateInstancesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientUpdateInstancesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientUpdateInstancesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientUpdateInstancesPoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientUpdateInstancesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientUpdateInstancesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientUpdateInstancesResponse, error) {
	result := VirtualMachineScaleSetsClientUpdateInstancesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientUpdateInstancesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientUpdateInstancesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientUpdateInstancesPoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.UpdateInstances", token, client.pl)
	return
}

// VirtualMachineScaleSetsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachineScaleSetsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachineScaleSetsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachineScaleSetsClientUpdatePoller) Result(ctx context.Context) (resp VirtualMachineScaleSetsClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachineScaleSetsClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientUpdateResponse, error) {
	result := VirtualMachineScaleSetsClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineScaleSet)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachineScaleSetsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachineScaleSetsClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachineScaleSetsClientUpdatePoller) Resume(token string, client *VirtualMachineScaleSetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Update", token, client.pl)
	return
}

// VirtualMachinesClientCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientCapturePoller) Result(ctx context.Context) (resp VirtualMachinesClientCaptureResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientCapturePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCaptureResponse, error) {
	result := VirtualMachinesClientCaptureResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachineCaptureResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientCapturePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientCapturePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Capture", token, client.pl)
	return
}

// VirtualMachinesClientConvertToManagedDisksPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientConvertToManagedDisksPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientConvertToManagedDisksPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientConvertToManagedDisksPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientConvertToManagedDisksPoller) Result(ctx context.Context) (resp VirtualMachinesClientConvertToManagedDisksResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientConvertToManagedDisksPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientConvertToManagedDisksResponse, error) {
	result := VirtualMachinesClientConvertToManagedDisksResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientConvertToManagedDisksPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientConvertToManagedDisksPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientConvertToManagedDisksPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.ConvertToManagedDisks", token, client.pl)
	return
}

// VirtualMachinesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualMachinesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCreateOrUpdateResponse, error) {
	result := VirtualMachinesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachine)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientCreateOrUpdatePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualMachinesClientDeallocatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientDeallocatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientDeallocatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientDeallocatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientDeallocatePoller) Result(ctx context.Context) (resp VirtualMachinesClientDeallocateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientDeallocatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeallocateResponse, error) {
	result := VirtualMachinesClientDeallocateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientDeallocatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientDeallocatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientDeallocatePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Deallocate", token, client.pl)
	return
}

// VirtualMachinesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientDeletePoller) Result(ctx context.Context) (resp VirtualMachinesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeleteResponse, error) {
	result := VirtualMachinesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientDeletePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Delete", token, client.pl)
	return
}

// VirtualMachinesClientPerformMaintenancePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientPerformMaintenancePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientPerformMaintenancePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientPerformMaintenancePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientPerformMaintenancePoller) Result(ctx context.Context) (resp VirtualMachinesClientPerformMaintenanceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientPerformMaintenancePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientPerformMaintenanceResponse, error) {
	result := VirtualMachinesClientPerformMaintenanceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientPerformMaintenancePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientPerformMaintenancePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientPerformMaintenancePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.PerformMaintenance", token, client.pl)
	return
}

// VirtualMachinesClientPowerOffPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientPowerOffPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientPowerOffPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientPowerOffPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientPowerOffPoller) Result(ctx context.Context) (resp VirtualMachinesClientPowerOffResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientPowerOffPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientPowerOffResponse, error) {
	result := VirtualMachinesClientPowerOffResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientPowerOffPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientPowerOffPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientPowerOffPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.PowerOff", token, client.pl)
	return
}

// VirtualMachinesClientReapplyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientReapplyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientReapplyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientReapplyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientReapplyPoller) Result(ctx context.Context) (resp VirtualMachinesClientReapplyResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientReapplyPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientReapplyResponse, error) {
	result := VirtualMachinesClientReapplyResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientReapplyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientReapplyPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientReapplyPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reapply", token, client.pl)
	return
}

// VirtualMachinesClientRedeployPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientRedeployPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientRedeployPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientRedeployPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientRedeployPoller) Result(ctx context.Context) (resp VirtualMachinesClientRedeployResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientRedeployPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRedeployResponse, error) {
	result := VirtualMachinesClientRedeployResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientRedeployPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientRedeployPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientRedeployPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Redeploy", token, client.pl)
	return
}

// VirtualMachinesClientReimagePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientReimagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientReimagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientReimagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientReimagePoller) Result(ctx context.Context) (resp VirtualMachinesClientReimageResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientReimagePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientReimageResponse, error) {
	result := VirtualMachinesClientReimageResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientReimagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientReimagePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientReimagePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reimage", token, client.pl)
	return
}

// VirtualMachinesClientRestartPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientRestartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientRestartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientRestartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientRestartPoller) Result(ctx context.Context) (resp VirtualMachinesClientRestartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientRestartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRestartResponse, error) {
	result := VirtualMachinesClientRestartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientRestartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientRestartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientRestartPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Restart", token, client.pl)
	return
}

// VirtualMachinesClientRunCommandPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientRunCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientRunCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientRunCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientRunCommandPoller) Result(ctx context.Context) (resp VirtualMachinesClientRunCommandResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientRunCommandPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRunCommandResponse, error) {
	result := VirtualMachinesClientRunCommandResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.RunCommandResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientRunCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientRunCommandPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientRunCommandPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.RunCommand", token, client.pl)
	return
}

// VirtualMachinesClientStartPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientStartPoller) Result(ctx context.Context) (resp VirtualMachinesClientStartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientStartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientStartResponse, error) {
	result := VirtualMachinesClientStartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientStartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientStartPoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Start", token, client.pl)
	return
}

// VirtualMachinesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualMachinesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualMachinesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualMachinesClientUpdatePoller) Result(ctx context.Context) (resp VirtualMachinesClientUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualMachinesClientUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientUpdateResponse, error) {
	result := VirtualMachinesClientUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualMachine)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualMachinesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualMachinesClientUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualMachinesClientUpdatePoller) Resume(token string, client *VirtualMachinesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Update", token, client.pl)
	return
}
