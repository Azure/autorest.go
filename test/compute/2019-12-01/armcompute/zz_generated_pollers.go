// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// AccessURIPoller provides polling facilities until the operation reaches a terminal state.
type AccessURIPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AccessURIResponse will be returned.
	FinalResponse(ctx context.Context) (AccessURIResponse, error)
}

type accessURIPoller struct {
	pt *armcore.LROPoller
}

func (p *accessURIPoller) Done() bool {
	return p.pt.Done()
}

func (p *accessURIPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *accessURIPoller) FinalResponse(ctx context.Context) (AccessURIResponse, error) {
	respType := AccessURIResponse{AccessURI: &AccessURI{}}
	resp, err := p.pt.FinalResponse(ctx, respType.AccessURI)
	if err != nil {
		return AccessURIResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *accessURIPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *accessURIPoller) pollUntilDone(ctx context.Context, freq time.Duration) (AccessURIResponse, error) {
	respType := AccessURIResponse{AccessURI: &AccessURI{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.AccessURI)
	if err != nil {
		return AccessURIResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ContainerServicePoller provides polling facilities until the operation reaches a terminal state.
type ContainerServicePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ContainerServiceResponse will be returned.
	FinalResponse(ctx context.Context) (ContainerServiceResponse, error)
}

type containerServicePoller struct {
	pt *armcore.LROPoller
}

func (p *containerServicePoller) Done() bool {
	return p.pt.Done()
}

func (p *containerServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *containerServicePoller) FinalResponse(ctx context.Context) (ContainerServiceResponse, error) {
	respType := ContainerServiceResponse{ContainerService: &ContainerService{}}
	resp, err := p.pt.FinalResponse(ctx, respType.ContainerService)
	if err != nil {
		return ContainerServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *containerServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *containerServicePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ContainerServiceResponse, error) {
	respType := ContainerServiceResponse{ContainerService: &ContainerService{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.ContainerService)
	if err != nil {
		return ContainerServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DedicatedHostPoller provides polling facilities until the operation reaches a terminal state.
type DedicatedHostPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DedicatedHostResponse will be returned.
	FinalResponse(ctx context.Context) (DedicatedHostResponse, error)
}

type dedicatedHostPoller struct {
	pt *armcore.LROPoller
}

func (p *dedicatedHostPoller) Done() bool {
	return p.pt.Done()
}

func (p *dedicatedHostPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *dedicatedHostPoller) FinalResponse(ctx context.Context) (DedicatedHostResponse, error) {
	respType := DedicatedHostResponse{DedicatedHost: &DedicatedHost{}}
	resp, err := p.pt.FinalResponse(ctx, respType.DedicatedHost)
	if err != nil {
		return DedicatedHostResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *dedicatedHostPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *dedicatedHostPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostResponse, error) {
	respType := DedicatedHostResponse{DedicatedHost: &DedicatedHost{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.DedicatedHost)
	if err != nil {
		return DedicatedHostResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DiskEncryptionSetPoller provides polling facilities until the operation reaches a terminal state.
type DiskEncryptionSetPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DiskEncryptionSetResponse will be returned.
	FinalResponse(ctx context.Context) (DiskEncryptionSetResponse, error)
}

type diskEncryptionSetPoller struct {
	pt *armcore.LROPoller
}

func (p *diskEncryptionSetPoller) Done() bool {
	return p.pt.Done()
}

func (p *diskEncryptionSetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *diskEncryptionSetPoller) FinalResponse(ctx context.Context) (DiskEncryptionSetResponse, error) {
	respType := DiskEncryptionSetResponse{DiskEncryptionSet: &DiskEncryptionSet{}}
	resp, err := p.pt.FinalResponse(ctx, respType.DiskEncryptionSet)
	if err != nil {
		return DiskEncryptionSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *diskEncryptionSetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *diskEncryptionSetPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetResponse, error) {
	respType := DiskEncryptionSetResponse{DiskEncryptionSet: &DiskEncryptionSet{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.DiskEncryptionSet)
	if err != nil {
		return DiskEncryptionSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DiskPoller provides polling facilities until the operation reaches a terminal state.
type DiskPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DiskResponse will be returned.
	FinalResponse(ctx context.Context) (DiskResponse, error)
}

type diskPoller struct {
	pt *armcore.LROPoller
}

func (p *diskPoller) Done() bool {
	return p.pt.Done()
}

func (p *diskPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *diskPoller) FinalResponse(ctx context.Context) (DiskResponse, error) {
	respType := DiskResponse{Disk: &Disk{}}
	resp, err := p.pt.FinalResponse(ctx, respType.Disk)
	if err != nil {
		return DiskResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *diskPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *diskPoller) pollUntilDone(ctx context.Context, freq time.Duration) (DiskResponse, error) {
	respType := DiskResponse{Disk: &Disk{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.Disk)
	if err != nil {
		return DiskResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryApplicationPoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryApplicationResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryApplicationResponse, error)
}

type galleryApplicationPoller struct {
	pt *armcore.LROPoller
}

func (p *galleryApplicationPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryApplicationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *galleryApplicationPoller) FinalResponse(ctx context.Context) (GalleryApplicationResponse, error) {
	respType := GalleryApplicationResponse{GalleryApplication: &GalleryApplication{}}
	resp, err := p.pt.FinalResponse(ctx, respType.GalleryApplication)
	if err != nil {
		return GalleryApplicationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryApplicationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryApplicationPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationResponse, error) {
	respType := GalleryApplicationResponse{GalleryApplication: &GalleryApplication{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.GalleryApplication)
	if err != nil {
		return GalleryApplicationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryApplicationVersionPoller provides polling facilities until the operation reaches a terminal state.
type GalleryApplicationVersionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryApplicationVersionResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryApplicationVersionResponse, error)
}

type galleryApplicationVersionPoller struct {
	pt *armcore.LROPoller
}

func (p *galleryApplicationVersionPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryApplicationVersionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *galleryApplicationVersionPoller) FinalResponse(ctx context.Context) (GalleryApplicationVersionResponse, error) {
	respType := GalleryApplicationVersionResponse{GalleryApplicationVersion: &GalleryApplicationVersion{}}
	resp, err := p.pt.FinalResponse(ctx, respType.GalleryApplicationVersion)
	if err != nil {
		return GalleryApplicationVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryApplicationVersionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryApplicationVersionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionResponse, error) {
	respType := GalleryApplicationVersionResponse{GalleryApplicationVersion: &GalleryApplicationVersion{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.GalleryApplicationVersion)
	if err != nil {
		return GalleryApplicationVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryImagePoller provides polling facilities until the operation reaches a terminal state.
type GalleryImagePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryImageResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryImageResponse, error)
}

type galleryImagePoller struct {
	pt *armcore.LROPoller
}

func (p *galleryImagePoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryImagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *galleryImagePoller) FinalResponse(ctx context.Context) (GalleryImageResponse, error) {
	respType := GalleryImageResponse{GalleryImage: &GalleryImage{}}
	resp, err := p.pt.FinalResponse(ctx, respType.GalleryImage)
	if err != nil {
		return GalleryImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryImagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryImagePoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageResponse, error) {
	respType := GalleryImageResponse{GalleryImage: &GalleryImage{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.GalleryImage)
	if err != nil {
		return GalleryImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryImageVersionPoller provides polling facilities until the operation reaches a terminal state.
type GalleryImageVersionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryImageVersionResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryImageVersionResponse, error)
}

type galleryImageVersionPoller struct {
	pt *armcore.LROPoller
}

func (p *galleryImageVersionPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryImageVersionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *galleryImageVersionPoller) FinalResponse(ctx context.Context) (GalleryImageVersionResponse, error) {
	respType := GalleryImageVersionResponse{GalleryImageVersion: &GalleryImageVersion{}}
	resp, err := p.pt.FinalResponse(ctx, respType.GalleryImageVersion)
	if err != nil {
		return GalleryImageVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryImageVersionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryImageVersionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionResponse, error) {
	respType := GalleryImageVersionResponse{GalleryImageVersion: &GalleryImageVersion{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.GalleryImageVersion)
	if err != nil {
		return GalleryImageVersionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// GalleryPoller provides polling facilities until the operation reaches a terminal state.
type GalleryPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final GalleryResponse will be returned.
	FinalResponse(ctx context.Context) (GalleryResponse, error)
}

type galleryPoller struct {
	pt *armcore.LROPoller
}

func (p *galleryPoller) Done() bool {
	return p.pt.Done()
}

func (p *galleryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *galleryPoller) FinalResponse(ctx context.Context) (GalleryResponse, error) {
	respType := GalleryResponse{Gallery: &Gallery{}}
	resp, err := p.pt.FinalResponse(ctx, respType.Gallery)
	if err != nil {
		return GalleryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *galleryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *galleryPoller) pollUntilDone(ctx context.Context, freq time.Duration) (GalleryResponse, error) {
	respType := GalleryResponse{Gallery: &Gallery{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.Gallery)
	if err != nil {
		return GalleryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// HTTPPoller provides polling facilities until the operation reaches a terminal state.
type HTTPPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final *http.Response will be returned.
	FinalResponse(ctx context.Context) (*http.Response, error)
}

type httpPoller struct {
	pt *armcore.LROPoller
}

func (p *httpPoller) Done() bool {
	return p.pt.Done()
}

func (p *httpPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *httpPoller) FinalResponse(ctx context.Context) (*http.Response, error) {
	return p.pt.FinalResponse(ctx, nil)
}

func (p *httpPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *httpPoller) pollUntilDone(ctx context.Context, freq time.Duration) (*http.Response, error) {
	return p.pt.PollUntilDone(ctx, freq, nil)
}

// ImagePoller provides polling facilities until the operation reaches a terminal state.
type ImagePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ImageResponse will be returned.
	FinalResponse(ctx context.Context) (ImageResponse, error)
}

type imagePoller struct {
	pt *armcore.LROPoller
}

func (p *imagePoller) Done() bool {
	return p.pt.Done()
}

func (p *imagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *imagePoller) FinalResponse(ctx context.Context) (ImageResponse, error) {
	respType := ImageResponse{Image: &Image{}}
	resp, err := p.pt.FinalResponse(ctx, respType.Image)
	if err != nil {
		return ImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *imagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *imagePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ImageResponse, error) {
	respType := ImageResponse{Image: &Image{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.Image)
	if err != nil {
		return ImageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LogAnalyticsOperationResultPoller provides polling facilities until the operation reaches a terminal state.
type LogAnalyticsOperationResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LogAnalyticsOperationResultResponse will be returned.
	FinalResponse(ctx context.Context) (LogAnalyticsOperationResultResponse, error)
}

type logAnalyticsOperationResultPoller struct {
	pt *armcore.LROPoller
}

func (p *logAnalyticsOperationResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *logAnalyticsOperationResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *logAnalyticsOperationResultPoller) FinalResponse(ctx context.Context) (LogAnalyticsOperationResultResponse, error) {
	respType := LogAnalyticsOperationResultResponse{LogAnalyticsOperationResult: &LogAnalyticsOperationResult{}}
	resp, err := p.pt.FinalResponse(ctx, respType.LogAnalyticsOperationResult)
	if err != nil {
		return LogAnalyticsOperationResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *logAnalyticsOperationResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *logAnalyticsOperationResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (LogAnalyticsOperationResultResponse, error) {
	respType := LogAnalyticsOperationResultResponse{LogAnalyticsOperationResult: &LogAnalyticsOperationResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.LogAnalyticsOperationResult)
	if err != nil {
		return LogAnalyticsOperationResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RunCommandResultPoller provides polling facilities until the operation reaches a terminal state.
type RunCommandResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RunCommandResultResponse will be returned.
	FinalResponse(ctx context.Context) (RunCommandResultResponse, error)
}

type runCommandResultPoller struct {
	pt *armcore.LROPoller
}

func (p *runCommandResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *runCommandResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *runCommandResultPoller) FinalResponse(ctx context.Context) (RunCommandResultResponse, error) {
	respType := RunCommandResultResponse{RunCommandResult: &RunCommandResult{}}
	resp, err := p.pt.FinalResponse(ctx, respType.RunCommandResult)
	if err != nil {
		return RunCommandResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *runCommandResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *runCommandResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (RunCommandResultResponse, error) {
	respType := RunCommandResultResponse{RunCommandResult: &RunCommandResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.RunCommandResult)
	if err != nil {
		return RunCommandResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SnapshotPoller provides polling facilities until the operation reaches a terminal state.
type SnapshotPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SnapshotResponse will be returned.
	FinalResponse(ctx context.Context) (SnapshotResponse, error)
}

type snapshotPoller struct {
	pt *armcore.LROPoller
}

func (p *snapshotPoller) Done() bool {
	return p.pt.Done()
}

func (p *snapshotPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *snapshotPoller) FinalResponse(ctx context.Context) (SnapshotResponse, error) {
	respType := SnapshotResponse{Snapshot: &Snapshot{}}
	resp, err := p.pt.FinalResponse(ctx, respType.Snapshot)
	if err != nil {
		return SnapshotResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *snapshotPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *snapshotPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SnapshotResponse, error) {
	respType := SnapshotResponse{Snapshot: &Snapshot{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.Snapshot)
	if err != nil {
		return SnapshotResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineCaptureResultPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineCaptureResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineCaptureResultResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineCaptureResultResponse, error)
}

type virtualMachineCaptureResultPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualMachineCaptureResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineCaptureResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualMachineCaptureResultPoller) FinalResponse(ctx context.Context) (VirtualMachineCaptureResultResponse, error) {
	respType := VirtualMachineCaptureResultResponse{VirtualMachineCaptureResult: &VirtualMachineCaptureResult{}}
	resp, err := p.pt.FinalResponse(ctx, respType.VirtualMachineCaptureResult)
	if err != nil {
		return VirtualMachineCaptureResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineCaptureResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineCaptureResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineCaptureResultResponse, error) {
	respType := VirtualMachineCaptureResultResponse{VirtualMachineCaptureResult: &VirtualMachineCaptureResult{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.VirtualMachineCaptureResult)
	if err != nil {
		return VirtualMachineCaptureResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineExtensionPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineExtensionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineExtensionResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineExtensionResponse, error)
}

type virtualMachineExtensionPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualMachineExtensionPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualMachineExtensionPoller) FinalResponse(ctx context.Context) (VirtualMachineExtensionResponse, error) {
	respType := VirtualMachineExtensionResponse{VirtualMachineExtension: &VirtualMachineExtension{}}
	resp, err := p.pt.FinalResponse(ctx, respType.VirtualMachineExtension)
	if err != nil {
		return VirtualMachineExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineExtensionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineExtensionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionResponse, error) {
	respType := VirtualMachineExtensionResponse{VirtualMachineExtension: &VirtualMachineExtension{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.VirtualMachineExtension)
	if err != nil {
		return VirtualMachineExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachinePoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachinePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineResponse, error)
}

type virtualMachinePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualMachinePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualMachinePoller) FinalResponse(ctx context.Context) (VirtualMachineResponse, error) {
	respType := VirtualMachineResponse{VirtualMachine: &VirtualMachine{}}
	resp, err := p.pt.FinalResponse(ctx, respType.VirtualMachine)
	if err != nil {
		return VirtualMachineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachinePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineResponse, error) {
	respType := VirtualMachineResponse{VirtualMachine: &VirtualMachine{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.VirtualMachine)
	if err != nil {
		return VirtualMachineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetExtensionPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetExtensionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetExtensionResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetExtensionResponse, error)
}

type virtualMachineScaleSetExtensionPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualMachineScaleSetExtensionPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetExtensionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualMachineScaleSetExtensionPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetExtensionResponse, error) {
	respType := VirtualMachineScaleSetExtensionResponse{VirtualMachineScaleSetExtension: &VirtualMachineScaleSetExtension{}}
	resp, err := p.pt.FinalResponse(ctx, respType.VirtualMachineScaleSetExtension)
	if err != nil {
		return VirtualMachineScaleSetExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetExtensionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetExtensionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionResponse, error) {
	respType := VirtualMachineScaleSetExtensionResponse{VirtualMachineScaleSetExtension: &VirtualMachineScaleSetExtension{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.VirtualMachineScaleSetExtension)
	if err != nil {
		return VirtualMachineScaleSetExtensionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetResponse, error)
}

type virtualMachineScaleSetPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualMachineScaleSetPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualMachineScaleSetPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetResponse, error) {
	respType := VirtualMachineScaleSetResponse{VirtualMachineScaleSet: &VirtualMachineScaleSet{}}
	resp, err := p.pt.FinalResponse(ctx, respType.VirtualMachineScaleSet)
	if err != nil {
		return VirtualMachineScaleSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetResponse, error) {
	respType := VirtualMachineScaleSetResponse{VirtualMachineScaleSet: &VirtualMachineScaleSet{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.VirtualMachineScaleSet)
	if err != nil {
		return VirtualMachineScaleSetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualMachineScaleSetVMPoller provides polling facilities until the operation reaches a terminal state.
type VirtualMachineScaleSetVMPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualMachineScaleSetVMResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualMachineScaleSetVMResponse, error)
}

type virtualMachineScaleSetVMPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualMachineScaleSetVMPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualMachineScaleSetVMPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualMachineScaleSetVMPoller) FinalResponse(ctx context.Context) (VirtualMachineScaleSetVMResponse, error) {
	respType := VirtualMachineScaleSetVMResponse{VirtualMachineScaleSetVM: &VirtualMachineScaleSetVM{}}
	resp, err := p.pt.FinalResponse(ctx, respType.VirtualMachineScaleSetVM)
	if err != nil {
		return VirtualMachineScaleSetVMResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualMachineScaleSetVMPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualMachineScaleSetVMPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMResponse, error) {
	respType := VirtualMachineScaleSetVMResponse{VirtualMachineScaleSetVM: &VirtualMachineScaleSetVM{}}
	resp, err := p.pt.PollUntilDone(ctx, freq, respType.VirtualMachineScaleSetVM)
	if err != nil {
		return VirtualMachineScaleSetVMResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
