//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"time"
)

// AvailabilitySetsClientCreateOrUpdateResponse contains the response from method AvailabilitySetsClient.CreateOrUpdate.
type AvailabilitySetsClientCreateOrUpdateResponse struct {
	AvailabilitySet
}

// AvailabilitySetsClientDeleteResponse contains the response from method AvailabilitySetsClient.Delete.
type AvailabilitySetsClientDeleteResponse struct {
	// placeholder for future response values
}

// AvailabilitySetsClientGetResponse contains the response from method AvailabilitySetsClient.Get.
type AvailabilitySetsClientGetResponse struct {
	AvailabilitySet
}

// AvailabilitySetsClientListAvailableSizesResponse contains the response from method AvailabilitySetsClient.ListAvailableSizes.
type AvailabilitySetsClientListAvailableSizesResponse struct {
	VirtualMachineSizeListResult
}

// AvailabilitySetsClientListBySubscriptionResponse contains the response from method AvailabilitySetsClient.ListBySubscription.
type AvailabilitySetsClientListBySubscriptionResponse struct {
	AvailabilitySetListResult
}

// AvailabilitySetsClientListResponse contains the response from method AvailabilitySetsClient.List.
type AvailabilitySetsClientListResponse struct {
	AvailabilitySetListResult
}

// AvailabilitySetsClientUpdateResponse contains the response from method AvailabilitySetsClient.Update.
type AvailabilitySetsClientUpdateResponse struct {
	AvailabilitySet
}

// ContainerServicesClientCreateOrUpdatePollerResponse contains the response from method ContainerServicesClient.CreateOrUpdate.
type ContainerServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainerServicesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainerServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainerServicesClientCreateOrUpdateResponse, error) {
	respType := ContainerServicesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ContainerService)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ContainerServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ContainerServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ContainerServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainerServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ContainerServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ContainerServicesClientCreateOrUpdateResponse contains the response from method ContainerServicesClient.CreateOrUpdate.
type ContainerServicesClientCreateOrUpdateResponse struct {
	ContainerService
}

// ContainerServicesClientDeletePollerResponse contains the response from method ContainerServicesClient.Delete.
type ContainerServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ContainerServicesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ContainerServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ContainerServicesClientDeleteResponse, error) {
	respType := ContainerServicesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ContainerServicesClientDeletePollerResponse from the provided client and resume token.
func (l *ContainerServicesClientDeletePollerResponse) Resume(ctx context.Context, client *ContainerServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ContainerServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ContainerServicesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ContainerServicesClientDeleteResponse contains the response from method ContainerServicesClient.Delete.
type ContainerServicesClientDeleteResponse struct {
	// placeholder for future response values
}

// ContainerServicesClientGetResponse contains the response from method ContainerServicesClient.Get.
type ContainerServicesClientGetResponse struct {
	ContainerService
}

// ContainerServicesClientListByResourceGroupResponse contains the response from method ContainerServicesClient.ListByResourceGroup.
type ContainerServicesClientListByResourceGroupResponse struct {
	ContainerServiceListResult
}

// ContainerServicesClientListResponse contains the response from method ContainerServicesClient.List.
type ContainerServicesClientListResponse struct {
	ContainerServiceListResult
}

// DedicatedHostGroupsClientCreateOrUpdateResponse contains the response from method DedicatedHostGroupsClient.CreateOrUpdate.
type DedicatedHostGroupsClientCreateOrUpdateResponse struct {
	DedicatedHostGroup
}

// DedicatedHostGroupsClientDeleteResponse contains the response from method DedicatedHostGroupsClient.Delete.
type DedicatedHostGroupsClientDeleteResponse struct {
	// placeholder for future response values
}

// DedicatedHostGroupsClientGetResponse contains the response from method DedicatedHostGroupsClient.Get.
type DedicatedHostGroupsClientGetResponse struct {
	DedicatedHostGroup
}

// DedicatedHostGroupsClientListByResourceGroupResponse contains the response from method DedicatedHostGroupsClient.ListByResourceGroup.
type DedicatedHostGroupsClientListByResourceGroupResponse struct {
	DedicatedHostGroupListResult
}

// DedicatedHostGroupsClientListBySubscriptionResponse contains the response from method DedicatedHostGroupsClient.ListBySubscription.
type DedicatedHostGroupsClientListBySubscriptionResponse struct {
	DedicatedHostGroupListResult
}

// DedicatedHostGroupsClientUpdateResponse contains the response from method DedicatedHostGroupsClient.Update.
type DedicatedHostGroupsClientUpdateResponse struct {
	DedicatedHostGroup
}

// DedicatedHostsClientCreateOrUpdatePollerResponse contains the response from method DedicatedHostsClient.CreateOrUpdate.
type DedicatedHostsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DedicatedHostsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DedicatedHostsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostsClientCreateOrUpdateResponse, error) {
	respType := DedicatedHostsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DedicatedHost)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DedicatedHostsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DedicatedHostsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DedicatedHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DedicatedHostsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DedicatedHostsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DedicatedHostsClientCreateOrUpdateResponse contains the response from method DedicatedHostsClient.CreateOrUpdate.
type DedicatedHostsClientCreateOrUpdateResponse struct {
	DedicatedHost
}

// DedicatedHostsClientDeletePollerResponse contains the response from method DedicatedHostsClient.Delete.
type DedicatedHostsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DedicatedHostsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DedicatedHostsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostsClientDeleteResponse, error) {
	respType := DedicatedHostsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DedicatedHostsClientDeletePollerResponse from the provided client and resume token.
func (l *DedicatedHostsClientDeletePollerResponse) Resume(ctx context.Context, client *DedicatedHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DedicatedHostsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DedicatedHostsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DedicatedHostsClientDeleteResponse contains the response from method DedicatedHostsClient.Delete.
type DedicatedHostsClientDeleteResponse struct {
	// placeholder for future response values
}

// DedicatedHostsClientGetResponse contains the response from method DedicatedHostsClient.Get.
type DedicatedHostsClientGetResponse struct {
	DedicatedHost
}

// DedicatedHostsClientListByHostGroupResponse contains the response from method DedicatedHostsClient.ListByHostGroup.
type DedicatedHostsClientListByHostGroupResponse struct {
	DedicatedHostListResult
}

// DedicatedHostsClientUpdatePollerResponse contains the response from method DedicatedHostsClient.Update.
type DedicatedHostsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DedicatedHostsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DedicatedHostsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DedicatedHostsClientUpdateResponse, error) {
	respType := DedicatedHostsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DedicatedHost)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DedicatedHostsClientUpdatePollerResponse from the provided client and resume token.
func (l *DedicatedHostsClientUpdatePollerResponse) Resume(ctx context.Context, client *DedicatedHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DedicatedHostsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DedicatedHostsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DedicatedHostsClientUpdateResponse contains the response from method DedicatedHostsClient.Update.
type DedicatedHostsClientUpdateResponse struct {
	DedicatedHost
}

// DiskEncryptionSetsClientCreateOrUpdatePollerResponse contains the response from method DiskEncryptionSetsClient.CreateOrUpdate.
type DiskEncryptionSetsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskEncryptionSetsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskEncryptionSetsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientCreateOrUpdateResponse, error) {
	respType := DiskEncryptionSetsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskEncryptionSet)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DiskEncryptionSetsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DiskEncryptionSetsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DiskEncryptionSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskEncryptionSetsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DiskEncryptionSetsClientCreateOrUpdateResponse contains the response from method DiskEncryptionSetsClient.CreateOrUpdate.
type DiskEncryptionSetsClientCreateOrUpdateResponse struct {
	DiskEncryptionSet
}

// DiskEncryptionSetsClientDeletePollerResponse contains the response from method DiskEncryptionSetsClient.Delete.
type DiskEncryptionSetsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskEncryptionSetsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskEncryptionSetsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientDeleteResponse, error) {
	respType := DiskEncryptionSetsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DiskEncryptionSetsClientDeletePollerResponse from the provided client and resume token.
func (l *DiskEncryptionSetsClientDeletePollerResponse) Resume(ctx context.Context, client *DiskEncryptionSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskEncryptionSetsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DiskEncryptionSetsClientDeleteResponse contains the response from method DiskEncryptionSetsClient.Delete.
type DiskEncryptionSetsClientDeleteResponse struct {
	// placeholder for future response values
}

// DiskEncryptionSetsClientGetResponse contains the response from method DiskEncryptionSetsClient.Get.
type DiskEncryptionSetsClientGetResponse struct {
	DiskEncryptionSet
}

// DiskEncryptionSetsClientListByResourceGroupResponse contains the response from method DiskEncryptionSetsClient.ListByResourceGroup.
type DiskEncryptionSetsClientListByResourceGroupResponse struct {
	DiskEncryptionSetList
}

// DiskEncryptionSetsClientListResponse contains the response from method DiskEncryptionSetsClient.List.
type DiskEncryptionSetsClientListResponse struct {
	DiskEncryptionSetList
}

// DiskEncryptionSetsClientUpdatePollerResponse contains the response from method DiskEncryptionSetsClient.Update.
type DiskEncryptionSetsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskEncryptionSetsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskEncryptionSetsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientUpdateResponse, error) {
	respType := DiskEncryptionSetsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskEncryptionSet)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DiskEncryptionSetsClientUpdatePollerResponse from the provided client and resume token.
func (l *DiskEncryptionSetsClientUpdatePollerResponse) Resume(ctx context.Context, client *DiskEncryptionSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskEncryptionSetsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DiskEncryptionSetsClientUpdateResponse contains the response from method DiskEncryptionSetsClient.Update.
type DiskEncryptionSetsClientUpdateResponse struct {
	DiskEncryptionSet
}

// DisksClientCreateOrUpdatePollerResponse contains the response from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientCreateOrUpdateResponse, error) {
	respType := DisksClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Disk)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DisksClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientCreateOrUpdateResponse contains the response from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdateResponse struct {
	Disk
}

// DisksClientDeletePollerResponse contains the response from method DisksClient.Delete.
type DisksClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientDeleteResponse, error) {
	respType := DisksClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientDeletePollerResponse from the provided client and resume token.
func (l *DisksClientDeletePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientDeleteResponse contains the response from method DisksClient.Delete.
type DisksClientDeleteResponse struct {
	// placeholder for future response values
}

// DisksClientGetResponse contains the response from method DisksClient.Get.
type DisksClientGetResponse struct {
	Disk
}

// DisksClientGrantAccessPollerResponse contains the response from method DisksClient.GrantAccess.
type DisksClientGrantAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientGrantAccessPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientGrantAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientGrantAccessResponse, error) {
	respType := DisksClientGrantAccessResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccessURI)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientGrantAccessPollerResponse from the provided client and resume token.
func (l *DisksClientGrantAccessPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.GrantAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientGrantAccessPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientGrantAccessResponse contains the response from method DisksClient.GrantAccess.
type DisksClientGrantAccessResponse struct {
	AccessURI
}

// DisksClientListByResourceGroupResponse contains the response from method DisksClient.ListByResourceGroup.
type DisksClientListByResourceGroupResponse struct {
	DiskList
}

// DisksClientListResponse contains the response from method DisksClient.List.
type DisksClientListResponse struct {
	DiskList
}

// DisksClientRevokeAccessPollerResponse contains the response from method DisksClient.RevokeAccess.
type DisksClientRevokeAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientRevokeAccessPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientRevokeAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientRevokeAccessResponse, error) {
	respType := DisksClientRevokeAccessResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientRevokeAccessPollerResponse from the provided client and resume token.
func (l *DisksClientRevokeAccessPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.RevokeAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientRevokeAccessPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientRevokeAccessResponse contains the response from method DisksClient.RevokeAccess.
type DisksClientRevokeAccessResponse struct {
	// placeholder for future response values
}

// DisksClientUpdatePollerResponse contains the response from method DisksClient.Update.
type DisksClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientUpdateResponse, error) {
	respType := DisksClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Disk)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientUpdatePollerResponse from the provided client and resume token.
func (l *DisksClientUpdatePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientUpdateResponse contains the response from method DisksClient.Update.
type DisksClientUpdateResponse struct {
	Disk
}

// GalleriesClientCreateOrUpdatePollerResponse contains the response from method GalleriesClient.CreateOrUpdate.
type GalleriesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleriesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleriesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleriesClientCreateOrUpdateResponse, error) {
	respType := GalleriesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Gallery)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleriesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GalleriesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GalleriesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleriesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleriesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleriesClientCreateOrUpdateResponse contains the response from method GalleriesClient.CreateOrUpdate.
type GalleriesClientCreateOrUpdateResponse struct {
	Gallery
}

// GalleriesClientDeletePollerResponse contains the response from method GalleriesClient.Delete.
type GalleriesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleriesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleriesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleriesClientDeleteResponse, error) {
	respType := GalleriesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleriesClientDeletePollerResponse from the provided client and resume token.
func (l *GalleriesClientDeletePollerResponse) Resume(ctx context.Context, client *GalleriesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleriesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleriesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleriesClientDeleteResponse contains the response from method GalleriesClient.Delete.
type GalleriesClientDeleteResponse struct {
	// placeholder for future response values
}

// GalleriesClientGetResponse contains the response from method GalleriesClient.Get.
type GalleriesClientGetResponse struct {
	Gallery
}

// GalleriesClientListByResourceGroupResponse contains the response from method GalleriesClient.ListByResourceGroup.
type GalleriesClientListByResourceGroupResponse struct {
	GalleryList
}

// GalleriesClientListResponse contains the response from method GalleriesClient.List.
type GalleriesClientListResponse struct {
	GalleryList
}

// GalleriesClientUpdatePollerResponse contains the response from method GalleriesClient.Update.
type GalleriesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleriesClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleriesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleriesClientUpdateResponse, error) {
	respType := GalleriesClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Gallery)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleriesClientUpdatePollerResponse from the provided client and resume token.
func (l *GalleriesClientUpdatePollerResponse) Resume(ctx context.Context, client *GalleriesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleriesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleriesClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleriesClientUpdateResponse contains the response from method GalleriesClient.Update.
type GalleriesClientUpdateResponse struct {
	Gallery
}

// GalleryApplicationVersionsClientCreateOrUpdatePollerResponse contains the response from method GalleryApplicationVersionsClient.CreateOrUpdate.
type GalleryApplicationVersionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryApplicationVersionsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryApplicationVersionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionsClientCreateOrUpdateResponse, error) {
	respType := GalleryApplicationVersionsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryApplicationVersion)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryApplicationVersionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GalleryApplicationVersionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GalleryApplicationVersionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryApplicationVersionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryApplicationVersionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryApplicationVersionsClientCreateOrUpdateResponse contains the response from method GalleryApplicationVersionsClient.CreateOrUpdate.
type GalleryApplicationVersionsClientCreateOrUpdateResponse struct {
	GalleryApplicationVersion
}

// GalleryApplicationVersionsClientDeletePollerResponse contains the response from method GalleryApplicationVersionsClient.Delete.
type GalleryApplicationVersionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryApplicationVersionsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryApplicationVersionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionsClientDeleteResponse, error) {
	respType := GalleryApplicationVersionsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryApplicationVersionsClientDeletePollerResponse from the provided client and resume token.
func (l *GalleryApplicationVersionsClientDeletePollerResponse) Resume(ctx context.Context, client *GalleryApplicationVersionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryApplicationVersionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryApplicationVersionsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryApplicationVersionsClientDeleteResponse contains the response from method GalleryApplicationVersionsClient.Delete.
type GalleryApplicationVersionsClientDeleteResponse struct {
	// placeholder for future response values
}

// GalleryApplicationVersionsClientGetResponse contains the response from method GalleryApplicationVersionsClient.Get.
type GalleryApplicationVersionsClientGetResponse struct {
	GalleryApplicationVersion
}

// GalleryApplicationVersionsClientListByGalleryApplicationResponse contains the response from method GalleryApplicationVersionsClient.ListByGalleryApplication.
type GalleryApplicationVersionsClientListByGalleryApplicationResponse struct {
	GalleryApplicationVersionList
}

// GalleryApplicationVersionsClientUpdatePollerResponse contains the response from method GalleryApplicationVersionsClient.Update.
type GalleryApplicationVersionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryApplicationVersionsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryApplicationVersionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationVersionsClientUpdateResponse, error) {
	respType := GalleryApplicationVersionsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryApplicationVersion)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryApplicationVersionsClientUpdatePollerResponse from the provided client and resume token.
func (l *GalleryApplicationVersionsClientUpdatePollerResponse) Resume(ctx context.Context, client *GalleryApplicationVersionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryApplicationVersionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryApplicationVersionsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryApplicationVersionsClientUpdateResponse contains the response from method GalleryApplicationVersionsClient.Update.
type GalleryApplicationVersionsClientUpdateResponse struct {
	GalleryApplicationVersion
}

// GalleryApplicationsClientCreateOrUpdatePollerResponse contains the response from method GalleryApplicationsClient.CreateOrUpdate.
type GalleryApplicationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryApplicationsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryApplicationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationsClientCreateOrUpdateResponse, error) {
	respType := GalleryApplicationsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryApplication)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryApplicationsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GalleryApplicationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GalleryApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryApplicationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryApplicationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryApplicationsClientCreateOrUpdateResponse contains the response from method GalleryApplicationsClient.CreateOrUpdate.
type GalleryApplicationsClientCreateOrUpdateResponse struct {
	GalleryApplication
}

// GalleryApplicationsClientDeletePollerResponse contains the response from method GalleryApplicationsClient.Delete.
type GalleryApplicationsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryApplicationsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryApplicationsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationsClientDeleteResponse, error) {
	respType := GalleryApplicationsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryApplicationsClientDeletePollerResponse from the provided client and resume token.
func (l *GalleryApplicationsClientDeletePollerResponse) Resume(ctx context.Context, client *GalleryApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryApplicationsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryApplicationsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryApplicationsClientDeleteResponse contains the response from method GalleryApplicationsClient.Delete.
type GalleryApplicationsClientDeleteResponse struct {
	// placeholder for future response values
}

// GalleryApplicationsClientGetResponse contains the response from method GalleryApplicationsClient.Get.
type GalleryApplicationsClientGetResponse struct {
	GalleryApplication
}

// GalleryApplicationsClientListByGalleryResponse contains the response from method GalleryApplicationsClient.ListByGallery.
type GalleryApplicationsClientListByGalleryResponse struct {
	GalleryApplicationList
}

// GalleryApplicationsClientUpdatePollerResponse contains the response from method GalleryApplicationsClient.Update.
type GalleryApplicationsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryApplicationsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryApplicationsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryApplicationsClientUpdateResponse, error) {
	respType := GalleryApplicationsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryApplication)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryApplicationsClientUpdatePollerResponse from the provided client and resume token.
func (l *GalleryApplicationsClientUpdatePollerResponse) Resume(ctx context.Context, client *GalleryApplicationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryApplicationsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryApplicationsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryApplicationsClientUpdateResponse contains the response from method GalleryApplicationsClient.Update.
type GalleryApplicationsClientUpdateResponse struct {
	GalleryApplication
}

// GalleryImageVersionsClientCreateOrUpdatePollerResponse contains the response from method GalleryImageVersionsClient.CreateOrUpdate.
type GalleryImageVersionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryImageVersionsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryImageVersionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionsClientCreateOrUpdateResponse, error) {
	respType := GalleryImageVersionsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryImageVersion)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryImageVersionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GalleryImageVersionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GalleryImageVersionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryImageVersionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryImageVersionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryImageVersionsClientCreateOrUpdateResponse contains the response from method GalleryImageVersionsClient.CreateOrUpdate.
type GalleryImageVersionsClientCreateOrUpdateResponse struct {
	GalleryImageVersion
}

// GalleryImageVersionsClientDeletePollerResponse contains the response from method GalleryImageVersionsClient.Delete.
type GalleryImageVersionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryImageVersionsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryImageVersionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionsClientDeleteResponse, error) {
	respType := GalleryImageVersionsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryImageVersionsClientDeletePollerResponse from the provided client and resume token.
func (l *GalleryImageVersionsClientDeletePollerResponse) Resume(ctx context.Context, client *GalleryImageVersionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryImageVersionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryImageVersionsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryImageVersionsClientDeleteResponse contains the response from method GalleryImageVersionsClient.Delete.
type GalleryImageVersionsClientDeleteResponse struct {
	// placeholder for future response values
}

// GalleryImageVersionsClientGetResponse contains the response from method GalleryImageVersionsClient.Get.
type GalleryImageVersionsClientGetResponse struct {
	GalleryImageVersion
}

// GalleryImageVersionsClientListByGalleryImageResponse contains the response from method GalleryImageVersionsClient.ListByGalleryImage.
type GalleryImageVersionsClientListByGalleryImageResponse struct {
	GalleryImageVersionList
}

// GalleryImageVersionsClientUpdatePollerResponse contains the response from method GalleryImageVersionsClient.Update.
type GalleryImageVersionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryImageVersionsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryImageVersionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImageVersionsClientUpdateResponse, error) {
	respType := GalleryImageVersionsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryImageVersion)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryImageVersionsClientUpdatePollerResponse from the provided client and resume token.
func (l *GalleryImageVersionsClientUpdatePollerResponse) Resume(ctx context.Context, client *GalleryImageVersionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryImageVersionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryImageVersionsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryImageVersionsClientUpdateResponse contains the response from method GalleryImageVersionsClient.Update.
type GalleryImageVersionsClientUpdateResponse struct {
	GalleryImageVersion
}

// GalleryImagesClientCreateOrUpdatePollerResponse contains the response from method GalleryImagesClient.CreateOrUpdate.
type GalleryImagesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryImagesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryImagesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImagesClientCreateOrUpdateResponse, error) {
	respType := GalleryImagesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryImage)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryImagesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GalleryImagesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GalleryImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryImagesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryImagesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryImagesClientCreateOrUpdateResponse contains the response from method GalleryImagesClient.CreateOrUpdate.
type GalleryImagesClientCreateOrUpdateResponse struct {
	GalleryImage
}

// GalleryImagesClientDeletePollerResponse contains the response from method GalleryImagesClient.Delete.
type GalleryImagesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryImagesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryImagesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImagesClientDeleteResponse, error) {
	respType := GalleryImagesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryImagesClientDeletePollerResponse from the provided client and resume token.
func (l *GalleryImagesClientDeletePollerResponse) Resume(ctx context.Context, client *GalleryImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryImagesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryImagesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryImagesClientDeleteResponse contains the response from method GalleryImagesClient.Delete.
type GalleryImagesClientDeleteResponse struct {
	// placeholder for future response values
}

// GalleryImagesClientGetResponse contains the response from method GalleryImagesClient.Get.
type GalleryImagesClientGetResponse struct {
	GalleryImage
}

// GalleryImagesClientListByGalleryResponse contains the response from method GalleryImagesClient.ListByGallery.
type GalleryImagesClientListByGalleryResponse struct {
	GalleryImageList
}

// GalleryImagesClientUpdatePollerResponse contains the response from method GalleryImagesClient.Update.
type GalleryImagesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GalleryImagesClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GalleryImagesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GalleryImagesClientUpdateResponse, error) {
	respType := GalleryImagesClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GalleryImage)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GalleryImagesClientUpdatePollerResponse from the provided client and resume token.
func (l *GalleryImagesClientUpdatePollerResponse) Resume(ctx context.Context, client *GalleryImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GalleryImagesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GalleryImagesClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GalleryImagesClientUpdateResponse contains the response from method GalleryImagesClient.Update.
type GalleryImagesClientUpdateResponse struct {
	GalleryImage
}

// ImagesClientCreateOrUpdatePollerResponse contains the response from method ImagesClient.CreateOrUpdate.
type ImagesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ImagesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ImagesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ImagesClientCreateOrUpdateResponse, error) {
	respType := ImagesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Image)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ImagesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ImagesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ImagesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ImagesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ImagesClientCreateOrUpdateResponse contains the response from method ImagesClient.CreateOrUpdate.
type ImagesClientCreateOrUpdateResponse struct {
	Image
}

// ImagesClientDeletePollerResponse contains the response from method ImagesClient.Delete.
type ImagesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ImagesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ImagesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ImagesClientDeleteResponse, error) {
	respType := ImagesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ImagesClientDeletePollerResponse from the provided client and resume token.
func (l *ImagesClientDeletePollerResponse) Resume(ctx context.Context, client *ImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ImagesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ImagesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ImagesClientDeleteResponse contains the response from method ImagesClient.Delete.
type ImagesClientDeleteResponse struct {
	// placeholder for future response values
}

// ImagesClientGetResponse contains the response from method ImagesClient.Get.
type ImagesClientGetResponse struct {
	Image
}

// ImagesClientListByResourceGroupResponse contains the response from method ImagesClient.ListByResourceGroup.
type ImagesClientListByResourceGroupResponse struct {
	ImageListResult
}

// ImagesClientListResponse contains the response from method ImagesClient.List.
type ImagesClientListResponse struct {
	ImageListResult
}

// ImagesClientUpdatePollerResponse contains the response from method ImagesClient.Update.
type ImagesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ImagesClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ImagesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ImagesClientUpdateResponse, error) {
	respType := ImagesClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Image)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ImagesClientUpdatePollerResponse from the provided client and resume token.
func (l *ImagesClientUpdatePollerResponse) Resume(ctx context.Context, client *ImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ImagesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ImagesClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ImagesClientUpdateResponse contains the response from method ImagesClient.Update.
type ImagesClientUpdateResponse struct {
	Image
}

// LogAnalyticsClientExportRequestRateByIntervalPollerResponse contains the response from method LogAnalyticsClient.ExportRequestRateByInterval.
type LogAnalyticsClientExportRequestRateByIntervalPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LogAnalyticsClientExportRequestRateByIntervalPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LogAnalyticsClientExportRequestRateByIntervalPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LogAnalyticsClientExportRequestRateByIntervalResponse, error) {
	respType := LogAnalyticsClientExportRequestRateByIntervalResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LogAnalyticsOperationResult)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LogAnalyticsClientExportRequestRateByIntervalPollerResponse from the provided client and resume token.
func (l *LogAnalyticsClientExportRequestRateByIntervalPollerResponse) Resume(ctx context.Context, client *LogAnalyticsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LogAnalyticsClient.ExportRequestRateByInterval", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LogAnalyticsClientExportRequestRateByIntervalPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LogAnalyticsClientExportRequestRateByIntervalResponse contains the response from method LogAnalyticsClient.ExportRequestRateByInterval.
type LogAnalyticsClientExportRequestRateByIntervalResponse struct {
	LogAnalyticsOperationResult
}

// LogAnalyticsClientExportThrottledRequestsPollerResponse contains the response from method LogAnalyticsClient.ExportThrottledRequests.
type LogAnalyticsClientExportThrottledRequestsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LogAnalyticsClientExportThrottledRequestsPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LogAnalyticsClientExportThrottledRequestsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LogAnalyticsClientExportThrottledRequestsResponse, error) {
	respType := LogAnalyticsClientExportThrottledRequestsResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LogAnalyticsOperationResult)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LogAnalyticsClientExportThrottledRequestsPollerResponse from the provided client and resume token.
func (l *LogAnalyticsClientExportThrottledRequestsPollerResponse) Resume(ctx context.Context, client *LogAnalyticsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LogAnalyticsClient.ExportThrottledRequests", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LogAnalyticsClientExportThrottledRequestsPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LogAnalyticsClientExportThrottledRequestsResponse contains the response from method LogAnalyticsClient.ExportThrottledRequests.
type LogAnalyticsClientExportThrottledRequestsResponse struct {
	LogAnalyticsOperationResult
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationListResult
}

// ProximityPlacementGroupsClientCreateOrUpdateResponse contains the response from method ProximityPlacementGroupsClient.CreateOrUpdate.
type ProximityPlacementGroupsClientCreateOrUpdateResponse struct {
	ProximityPlacementGroup
}

// ProximityPlacementGroupsClientDeleteResponse contains the response from method ProximityPlacementGroupsClient.Delete.
type ProximityPlacementGroupsClientDeleteResponse struct {
	// placeholder for future response values
}

// ProximityPlacementGroupsClientGetResponse contains the response from method ProximityPlacementGroupsClient.Get.
type ProximityPlacementGroupsClientGetResponse struct {
	ProximityPlacementGroup
}

// ProximityPlacementGroupsClientListByResourceGroupResponse contains the response from method ProximityPlacementGroupsClient.ListByResourceGroup.
type ProximityPlacementGroupsClientListByResourceGroupResponse struct {
	ProximityPlacementGroupListResult
}

// ProximityPlacementGroupsClientListBySubscriptionResponse contains the response from method ProximityPlacementGroupsClient.ListBySubscription.
type ProximityPlacementGroupsClientListBySubscriptionResponse struct {
	ProximityPlacementGroupListResult
}

// ProximityPlacementGroupsClientUpdateResponse contains the response from method ProximityPlacementGroupsClient.Update.
type ProximityPlacementGroupsClientUpdateResponse struct {
	ProximityPlacementGroup
}

// ResourceSKUsClientListResponse contains the response from method ResourceSKUsClient.List.
type ResourceSKUsClientListResponse struct {
	ResourceSKUsResult
}

// SSHPublicKeysClientCreateResponse contains the response from method SSHPublicKeysClient.Create.
type SSHPublicKeysClientCreateResponse struct {
	SSHPublicKeyResource
}

// SSHPublicKeysClientDeleteResponse contains the response from method SSHPublicKeysClient.Delete.
type SSHPublicKeysClientDeleteResponse struct {
	// placeholder for future response values
}

// SSHPublicKeysClientGenerateKeyPairResponse contains the response from method SSHPublicKeysClient.GenerateKeyPair.
type SSHPublicKeysClientGenerateKeyPairResponse struct {
	SSHPublicKeyGenerateKeyPairResult
}

// SSHPublicKeysClientGetResponse contains the response from method SSHPublicKeysClient.Get.
type SSHPublicKeysClientGetResponse struct {
	SSHPublicKeyResource
}

// SSHPublicKeysClientListByResourceGroupResponse contains the response from method SSHPublicKeysClient.ListByResourceGroup.
type SSHPublicKeysClientListByResourceGroupResponse struct {
	SSHPublicKeysGroupListResult
}

// SSHPublicKeysClientListBySubscriptionResponse contains the response from method SSHPublicKeysClient.ListBySubscription.
type SSHPublicKeysClientListBySubscriptionResponse struct {
	SSHPublicKeysGroupListResult
}

// SSHPublicKeysClientUpdateResponse contains the response from method SSHPublicKeysClient.Update.
type SSHPublicKeysClientUpdateResponse struct {
	SSHPublicKeyResource
}

// SnapshotsClientCreateOrUpdatePollerResponse contains the response from method SnapshotsClient.CreateOrUpdate.
type SnapshotsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientCreateOrUpdateResponse, error) {
	respType := SnapshotsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Snapshot)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SnapshotsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SnapshotsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SnapshotsClientCreateOrUpdateResponse contains the response from method SnapshotsClient.CreateOrUpdate.
type SnapshotsClientCreateOrUpdateResponse struct {
	Snapshot
}

// SnapshotsClientDeletePollerResponse contains the response from method SnapshotsClient.Delete.
type SnapshotsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientDeleteResponse, error) {
	respType := SnapshotsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SnapshotsClientDeletePollerResponse from the provided client and resume token.
func (l *SnapshotsClientDeletePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SnapshotsClientDeleteResponse contains the response from method SnapshotsClient.Delete.
type SnapshotsClientDeleteResponse struct {
	// placeholder for future response values
}

// SnapshotsClientGetResponse contains the response from method SnapshotsClient.Get.
type SnapshotsClientGetResponse struct {
	Snapshot
}

// SnapshotsClientGrantAccessPollerResponse contains the response from method SnapshotsClient.GrantAccess.
type SnapshotsClientGrantAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientGrantAccessPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientGrantAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientGrantAccessResponse, error) {
	respType := SnapshotsClientGrantAccessResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccessURI)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SnapshotsClientGrantAccessPollerResponse from the provided client and resume token.
func (l *SnapshotsClientGrantAccessPollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.GrantAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientGrantAccessPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SnapshotsClientGrantAccessResponse contains the response from method SnapshotsClient.GrantAccess.
type SnapshotsClientGrantAccessResponse struct {
	AccessURI
}

// SnapshotsClientListByResourceGroupResponse contains the response from method SnapshotsClient.ListByResourceGroup.
type SnapshotsClientListByResourceGroupResponse struct {
	SnapshotList
}

// SnapshotsClientListResponse contains the response from method SnapshotsClient.List.
type SnapshotsClientListResponse struct {
	SnapshotList
}

// SnapshotsClientRevokeAccessPollerResponse contains the response from method SnapshotsClient.RevokeAccess.
type SnapshotsClientRevokeAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientRevokeAccessPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientRevokeAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientRevokeAccessResponse, error) {
	respType := SnapshotsClientRevokeAccessResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SnapshotsClientRevokeAccessPollerResponse from the provided client and resume token.
func (l *SnapshotsClientRevokeAccessPollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.RevokeAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientRevokeAccessPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SnapshotsClientRevokeAccessResponse contains the response from method SnapshotsClient.RevokeAccess.
type SnapshotsClientRevokeAccessResponse struct {
	// placeholder for future response values
}

// SnapshotsClientUpdatePollerResponse contains the response from method SnapshotsClient.Update.
type SnapshotsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientUpdateResponse, error) {
	respType := SnapshotsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Snapshot)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SnapshotsClientUpdatePollerResponse from the provided client and resume token.
func (l *SnapshotsClientUpdatePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SnapshotsClientUpdateResponse contains the response from method SnapshotsClient.Update.
type SnapshotsClientUpdateResponse struct {
	Snapshot
}

// UsageClientListResponse contains the response from method UsageClient.List.
type UsageClientListResponse struct {
	ListUsagesResult
}

// VirtualMachineExtensionImagesClientGetResponse contains the response from method VirtualMachineExtensionImagesClient.Get.
type VirtualMachineExtensionImagesClientGetResponse struct {
	VirtualMachineExtensionImage
}

// VirtualMachineExtensionImagesClientListTypesResponse contains the response from method VirtualMachineExtensionImagesClient.ListTypes.
type VirtualMachineExtensionImagesClientListTypesResponse struct {
	// Array of VirtualMachineExtensionImage
	VirtualMachineExtensionImageArray []*VirtualMachineExtensionImage
}

// VirtualMachineExtensionImagesClientListVersionsResponse contains the response from method VirtualMachineExtensionImagesClient.ListVersions.
type VirtualMachineExtensionImagesClientListVersionsResponse struct {
	// Array of VirtualMachineExtensionImage
	VirtualMachineExtensionImageArray []*VirtualMachineExtensionImage
}

// VirtualMachineExtensionsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineExtensionsClient.CreateOrUpdate.
type VirtualMachineExtensionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineExtensionsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineExtensionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineExtensionsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineExtension)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineExtensionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineExtensionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineExtensionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineExtensionsClientCreateOrUpdateResponse contains the response from method VirtualMachineExtensionsClient.CreateOrUpdate.
type VirtualMachineExtensionsClientCreateOrUpdateResponse struct {
	VirtualMachineExtension
}

// VirtualMachineExtensionsClientDeletePollerResponse contains the response from method VirtualMachineExtensionsClient.Delete.
type VirtualMachineExtensionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineExtensionsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineExtensionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientDeleteResponse, error) {
	respType := VirtualMachineExtensionsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineExtensionsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineExtensionsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineExtensionsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineExtensionsClientDeleteResponse contains the response from method VirtualMachineExtensionsClient.Delete.
type VirtualMachineExtensionsClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachineExtensionsClientGetResponse contains the response from method VirtualMachineExtensionsClient.Get.
type VirtualMachineExtensionsClientGetResponse struct {
	VirtualMachineExtension
}

// VirtualMachineExtensionsClientListResponse contains the response from method VirtualMachineExtensionsClient.List.
type VirtualMachineExtensionsClientListResponse struct {
	VirtualMachineExtensionsListResult
}

// VirtualMachineExtensionsClientUpdatePollerResponse contains the response from method VirtualMachineExtensionsClient.Update.
type VirtualMachineExtensionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineExtensionsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineExtensionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientUpdateResponse, error) {
	respType := VirtualMachineExtensionsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineExtension)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineExtensionsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineExtensionsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineExtensionsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineExtensionsClientUpdateResponse contains the response from method VirtualMachineExtensionsClient.Update.
type VirtualMachineExtensionsClientUpdateResponse struct {
	VirtualMachineExtension
}

// VirtualMachineImagesClientGetResponse contains the response from method VirtualMachineImagesClient.Get.
type VirtualMachineImagesClientGetResponse struct {
	VirtualMachineImage
}

// VirtualMachineImagesClientListOffersResponse contains the response from method VirtualMachineImagesClient.ListOffers.
type VirtualMachineImagesClientListOffersResponse struct {
	// Array of VirtualMachineImageResource
	VirtualMachineImageResourceArray []*VirtualMachineImageResource
}

// VirtualMachineImagesClientListPublishersResponse contains the response from method VirtualMachineImagesClient.ListPublishers.
type VirtualMachineImagesClientListPublishersResponse struct {
	// Array of VirtualMachineImageResource
	VirtualMachineImageResourceArray []*VirtualMachineImageResource
}

// VirtualMachineImagesClientListResponse contains the response from method VirtualMachineImagesClient.List.
type VirtualMachineImagesClientListResponse struct {
	// Array of VirtualMachineImageResource
	VirtualMachineImageResourceArray []*VirtualMachineImageResource
}

// VirtualMachineImagesClientListSKUsResponse contains the response from method VirtualMachineImagesClient.ListSKUs.
type VirtualMachineImagesClientListSKUsResponse struct {
	// Array of VirtualMachineImageResource
	VirtualMachineImageResourceArray []*VirtualMachineImageResource
}

// VirtualMachineRunCommandsClientGetResponse contains the response from method VirtualMachineRunCommandsClient.Get.
type VirtualMachineRunCommandsClientGetResponse struct {
	RunCommandDocument
}

// VirtualMachineRunCommandsClientListResponse contains the response from method VirtualMachineRunCommandsClient.List.
type VirtualMachineRunCommandsClientListResponse struct {
	RunCommandListResult
}

// VirtualMachineScaleSetExtensionsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineScaleSetExtensionsClient.CreateOrUpdate.
type VirtualMachineScaleSetExtensionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetExtensionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineScaleSetExtension)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetExtensionsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *VirtualMachineScaleSetExtensionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetExtensionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetExtensionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse contains the response from method VirtualMachineScaleSetExtensionsClient.CreateOrUpdate.
type VirtualMachineScaleSetExtensionsClientCreateOrUpdateResponse struct {
	VirtualMachineScaleSetExtension
}

// VirtualMachineScaleSetExtensionsClientDeletePollerResponse contains the response from method VirtualMachineScaleSetExtensionsClient.Delete.
type VirtualMachineScaleSetExtensionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetExtensionsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetExtensionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionsClientDeleteResponse, error) {
	respType := VirtualMachineScaleSetExtensionsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetExtensionsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetExtensionsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetExtensionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetExtensionsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetExtensionsClientDeleteResponse contains the response from method VirtualMachineScaleSetExtensionsClient.Delete.
type VirtualMachineScaleSetExtensionsClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetExtensionsClientGetResponse contains the response from method VirtualMachineScaleSetExtensionsClient.Get.
type VirtualMachineScaleSetExtensionsClientGetResponse struct {
	VirtualMachineScaleSetExtension
}

// VirtualMachineScaleSetExtensionsClientListResponse contains the response from method VirtualMachineScaleSetExtensionsClient.List.
type VirtualMachineScaleSetExtensionsClientListResponse struct {
	VirtualMachineScaleSetExtensionListResult
}

// VirtualMachineScaleSetExtensionsClientUpdatePollerResponse contains the response from method VirtualMachineScaleSetExtensionsClient.Update.
type VirtualMachineScaleSetExtensionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetExtensionsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetExtensionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetExtensionsClientUpdateResponse, error) {
	respType := VirtualMachineScaleSetExtensionsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineScaleSetExtension)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetExtensionsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetExtensionsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetExtensionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetExtensionsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetExtensionsClientUpdateResponse contains the response from method VirtualMachineScaleSetExtensionsClient.Update.
type VirtualMachineScaleSetExtensionsClientUpdateResponse struct {
	VirtualMachineScaleSetExtension
}

// VirtualMachineScaleSetRollingUpgradesClientCancelPollerResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.Cancel.
type VirtualMachineScaleSetRollingUpgradesClientCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetRollingUpgradesClientCancelPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetRollingUpgradesClientCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetRollingUpgradesClientCancelResponse, error) {
	respType := VirtualMachineScaleSetRollingUpgradesClientCancelResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetRollingUpgradesClientCancelPollerResponse from the provided client and resume
// token.
func (l *VirtualMachineScaleSetRollingUpgradesClientCancelPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetRollingUpgradesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetRollingUpgradesClient.Cancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetRollingUpgradesClientCancelPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetRollingUpgradesClientCancelResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.Cancel.
type VirtualMachineScaleSetRollingUpgradesClientCancelResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetRollingUpgradesClientGetLatestResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.GetLatest.
type VirtualMachineScaleSetRollingUpgradesClientGetLatestResponse struct {
	RollingUpgradeStatusInfo
}

// VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePollerResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.StartExtensionUpgrade.
type VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse, error) {
	respType := VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePollerResponse from the provided client
// and resume token.
func (l *VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetRollingUpgradesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetRollingUpgradesClient.StartExtensionUpgrade", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.StartExtensionUpgrade.
type VirtualMachineScaleSetRollingUpgradesClientStartExtensionUpgradeResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePollerResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.StartOSUpgrade.
type VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse, error) {
	respType := VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePollerResponse from the provided client and
// resume token.
func (l *VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetRollingUpgradesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetRollingUpgradesClient.StartOSUpgrade", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse contains the response from method VirtualMachineScaleSetRollingUpgradesClient.StartOSUpgrade.
type VirtualMachineScaleSetRollingUpgradesClientStartOSUpgradeResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.CreateOrUpdate.
type VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineExtension)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMExtensionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMExtensionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.CreateOrUpdate.
type VirtualMachineScaleSetVMExtensionsClientCreateOrUpdateResponse struct {
	VirtualMachineExtension
}

// VirtualMachineScaleSetVMExtensionsClientDeletePollerResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.Delete.
type VirtualMachineScaleSetVMExtensionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMExtensionsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMExtensionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionsClientDeleteResponse, error) {
	respType := VirtualMachineScaleSetVMExtensionsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMExtensionsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMExtensionsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMExtensionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMExtensionsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMExtensionsClientDeleteResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.Delete.
type VirtualMachineScaleSetVMExtensionsClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMExtensionsClientGetResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.Get.
type VirtualMachineScaleSetVMExtensionsClientGetResponse struct {
	VirtualMachineExtension
}

// VirtualMachineScaleSetVMExtensionsClientListResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.List.
type VirtualMachineScaleSetVMExtensionsClientListResponse struct {
	VirtualMachineExtensionsListResult
}

// VirtualMachineScaleSetVMExtensionsClientUpdatePollerResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.Update.
type VirtualMachineScaleSetVMExtensionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMExtensionsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMExtensionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMExtensionsClientUpdateResponse, error) {
	respType := VirtualMachineScaleSetVMExtensionsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineExtension)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMExtensionsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMExtensionsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMExtensionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMExtensionsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMExtensionsClientUpdateResponse contains the response from method VirtualMachineScaleSetVMExtensionsClient.Update.
type VirtualMachineScaleSetVMExtensionsClientUpdateResponse struct {
	VirtualMachineExtension
}

// VirtualMachineScaleSetVMsClientDeallocatePollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Deallocate.
type VirtualMachineScaleSetVMsClientDeallocatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientDeallocatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientDeallocatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientDeallocateResponse, error) {
	respType := VirtualMachineScaleSetVMsClientDeallocateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientDeallocatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientDeallocatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Deallocate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientDeallocatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientDeallocateResponse contains the response from method VirtualMachineScaleSetVMsClient.Deallocate.
type VirtualMachineScaleSetVMsClientDeallocateResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientDeletePollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Delete.
type VirtualMachineScaleSetVMsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientDeleteResponse, error) {
	respType := VirtualMachineScaleSetVMsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientDeleteResponse contains the response from method VirtualMachineScaleSetVMsClient.Delete.
type VirtualMachineScaleSetVMsClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientGetInstanceViewResponse contains the response from method VirtualMachineScaleSetVMsClient.GetInstanceView.
type VirtualMachineScaleSetVMsClientGetInstanceViewResponse struct {
	VirtualMachineScaleSetVMInstanceView
}

// VirtualMachineScaleSetVMsClientGetResponse contains the response from method VirtualMachineScaleSetVMsClient.Get.
type VirtualMachineScaleSetVMsClientGetResponse struct {
	VirtualMachineScaleSetVM
}

// VirtualMachineScaleSetVMsClientListResponse contains the response from method VirtualMachineScaleSetVMsClient.List.
type VirtualMachineScaleSetVMsClientListResponse struct {
	VirtualMachineScaleSetVMListResult
}

// VirtualMachineScaleSetVMsClientPerformMaintenancePollerResponse contains the response from method VirtualMachineScaleSetVMsClient.PerformMaintenance.
type VirtualMachineScaleSetVMsClientPerformMaintenancePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientPerformMaintenancePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientPerformMaintenancePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientPerformMaintenanceResponse, error) {
	respType := VirtualMachineScaleSetVMsClientPerformMaintenanceResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientPerformMaintenancePollerResponse from the provided client and resume
// token.
func (l *VirtualMachineScaleSetVMsClientPerformMaintenancePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.PerformMaintenance", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientPerformMaintenancePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientPerformMaintenanceResponse contains the response from method VirtualMachineScaleSetVMsClient.PerformMaintenance.
type VirtualMachineScaleSetVMsClientPerformMaintenanceResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientPowerOffPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.PowerOff.
type VirtualMachineScaleSetVMsClientPowerOffPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientPowerOffPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientPowerOffPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientPowerOffResponse, error) {
	respType := VirtualMachineScaleSetVMsClientPowerOffResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientPowerOffPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientPowerOffPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.PowerOff", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientPowerOffPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientPowerOffResponse contains the response from method VirtualMachineScaleSetVMsClient.PowerOff.
type VirtualMachineScaleSetVMsClientPowerOffResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientRedeployPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Redeploy.
type VirtualMachineScaleSetVMsClientRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientRedeployPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRedeployResponse, error) {
	respType := VirtualMachineScaleSetVMsClientRedeployResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Redeploy", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientRedeployPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientRedeployResponse contains the response from method VirtualMachineScaleSetVMsClient.Redeploy.
type VirtualMachineScaleSetVMsClientRedeployResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientReimageAllPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.ReimageAll.
type VirtualMachineScaleSetVMsClientReimageAllPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientReimageAllPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientReimageAllPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientReimageAllResponse, error) {
	respType := VirtualMachineScaleSetVMsClientReimageAllResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientReimageAllPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientReimageAllPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.ReimageAll", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientReimageAllPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientReimageAllResponse contains the response from method VirtualMachineScaleSetVMsClient.ReimageAll.
type VirtualMachineScaleSetVMsClientReimageAllResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientReimagePollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Reimage.
type VirtualMachineScaleSetVMsClientReimagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientReimagePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientReimagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientReimageResponse, error) {
	respType := VirtualMachineScaleSetVMsClientReimageResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientReimagePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientReimagePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Reimage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientReimagePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientReimageResponse contains the response from method VirtualMachineScaleSetVMsClient.Reimage.
type VirtualMachineScaleSetVMsClientReimageResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientRestartPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Restart.
type VirtualMachineScaleSetVMsClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientRestartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRestartResponse, error) {
	respType := VirtualMachineScaleSetVMsClientRestartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRestartPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientRestartPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientRestartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientRestartResponse contains the response from method VirtualMachineScaleSetVMsClient.Restart.
type VirtualMachineScaleSetVMsClientRestartResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientRunCommandPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.RunCommand.
type VirtualMachineScaleSetVMsClientRunCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientRunCommandPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientRunCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRunCommandResponse, error) {
	respType := VirtualMachineScaleSetVMsClientRunCommandResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RunCommandResult)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRunCommandPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientRunCommandPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.RunCommand", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientRunCommandPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientRunCommandResponse contains the response from method VirtualMachineScaleSetVMsClient.RunCommand.
type VirtualMachineScaleSetVMsClientRunCommandResponse struct {
	RunCommandResult
}

// VirtualMachineScaleSetVMsClientSimulateEvictionResponse contains the response from method VirtualMachineScaleSetVMsClient.SimulateEviction.
type VirtualMachineScaleSetVMsClientSimulateEvictionResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientStartPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Start.
type VirtualMachineScaleSetVMsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientStartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientStartResponse, error) {
	respType := VirtualMachineScaleSetVMsClientStartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientStartPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientStartPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientStartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientStartResponse contains the response from method VirtualMachineScaleSetVMsClient.Start.
type VirtualMachineScaleSetVMsClientStartResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetVMsClientUpdatePollerResponse contains the response from method VirtualMachineScaleSetVMsClient.Update.
type VirtualMachineScaleSetVMsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientUpdateResponse, error) {
	respType := VirtualMachineScaleSetVMsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineScaleSetVM)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetVMsClientUpdateResponse contains the response from method VirtualMachineScaleSetVMsClient.Update.
type VirtualMachineScaleSetVMsClientUpdateResponse struct {
	VirtualMachineScaleSetVM
}

// VirtualMachineScaleSetsClientConvertToSinglePlacementGroupResponse contains the response from method VirtualMachineScaleSetsClient.ConvertToSinglePlacementGroup.
type VirtualMachineScaleSetsClientConvertToSinglePlacementGroupResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineScaleSetsClient.CreateOrUpdate.
type VirtualMachineScaleSetsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineScaleSetsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineScaleSet)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientCreateOrUpdateResponse contains the response from method VirtualMachineScaleSetsClient.CreateOrUpdate.
type VirtualMachineScaleSetsClientCreateOrUpdateResponse struct {
	VirtualMachineScaleSet
}

// VirtualMachineScaleSetsClientDeallocatePollerResponse contains the response from method VirtualMachineScaleSetsClient.Deallocate.
type VirtualMachineScaleSetsClientDeallocatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientDeallocatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientDeallocatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientDeallocateResponse, error) {
	respType := VirtualMachineScaleSetsClientDeallocateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientDeallocatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientDeallocatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Deallocate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientDeallocatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientDeallocateResponse contains the response from method VirtualMachineScaleSetsClient.Deallocate.
type VirtualMachineScaleSetsClientDeallocateResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientDeleteInstancesPollerResponse contains the response from method VirtualMachineScaleSetsClient.DeleteInstances.
type VirtualMachineScaleSetsClientDeleteInstancesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientDeleteInstancesPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientDeleteInstancesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientDeleteInstancesResponse, error) {
	respType := VirtualMachineScaleSetsClientDeleteInstancesResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientDeleteInstancesPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientDeleteInstancesPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.DeleteInstances", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientDeleteInstancesPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientDeleteInstancesResponse contains the response from method VirtualMachineScaleSetsClient.DeleteInstances.
type VirtualMachineScaleSetsClientDeleteInstancesResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientDeletePollerResponse contains the response from method VirtualMachineScaleSetsClient.Delete.
type VirtualMachineScaleSetsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientDeleteResponse, error) {
	respType := VirtualMachineScaleSetsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientDeleteResponse contains the response from method VirtualMachineScaleSetsClient.Delete.
type VirtualMachineScaleSetsClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientForceRecoveryServiceFabricPlatformUpdateDomainWalkResponse contains the response from method
// VirtualMachineScaleSetsClient.ForceRecoveryServiceFabricPlatformUpdateDomainWalk.
type VirtualMachineScaleSetsClientForceRecoveryServiceFabricPlatformUpdateDomainWalkResponse struct {
	RecoveryWalkResponse
}

// VirtualMachineScaleSetsClientGetInstanceViewResponse contains the response from method VirtualMachineScaleSetsClient.GetInstanceView.
type VirtualMachineScaleSetsClientGetInstanceViewResponse struct {
	VirtualMachineScaleSetInstanceView
}

// VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse contains the response from method VirtualMachineScaleSetsClient.GetOSUpgradeHistory.
type VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse struct {
	VirtualMachineScaleSetListOSUpgradeHistory
}

// VirtualMachineScaleSetsClientGetResponse contains the response from method VirtualMachineScaleSetsClient.Get.
type VirtualMachineScaleSetsClientGetResponse struct {
	VirtualMachineScaleSet
}

// VirtualMachineScaleSetsClientListAllResponse contains the response from method VirtualMachineScaleSetsClient.ListAll.
type VirtualMachineScaleSetsClientListAllResponse struct {
	VirtualMachineScaleSetListWithLinkResult
}

// VirtualMachineScaleSetsClientListResponse contains the response from method VirtualMachineScaleSetsClient.List.
type VirtualMachineScaleSetsClientListResponse struct {
	VirtualMachineScaleSetListResult
}

// VirtualMachineScaleSetsClientListSKUsResponse contains the response from method VirtualMachineScaleSetsClient.ListSKUs.
type VirtualMachineScaleSetsClientListSKUsResponse struct {
	VirtualMachineScaleSetListSKUsResult
}

// VirtualMachineScaleSetsClientPerformMaintenancePollerResponse contains the response from method VirtualMachineScaleSetsClient.PerformMaintenance.
type VirtualMachineScaleSetsClientPerformMaintenancePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientPerformMaintenancePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientPerformMaintenancePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientPerformMaintenanceResponse, error) {
	respType := VirtualMachineScaleSetsClientPerformMaintenanceResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientPerformMaintenancePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientPerformMaintenancePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.PerformMaintenance", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientPerformMaintenancePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientPerformMaintenanceResponse contains the response from method VirtualMachineScaleSetsClient.PerformMaintenance.
type VirtualMachineScaleSetsClientPerformMaintenanceResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientPowerOffPollerResponse contains the response from method VirtualMachineScaleSetsClient.PowerOff.
type VirtualMachineScaleSetsClientPowerOffPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientPowerOffPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientPowerOffPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientPowerOffResponse, error) {
	respType := VirtualMachineScaleSetsClientPowerOffResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientPowerOffPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientPowerOffPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.PowerOff", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientPowerOffPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientPowerOffResponse contains the response from method VirtualMachineScaleSetsClient.PowerOff.
type VirtualMachineScaleSetsClientPowerOffResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientRedeployPollerResponse contains the response from method VirtualMachineScaleSetsClient.Redeploy.
type VirtualMachineScaleSetsClientRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientRedeployPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientRedeployResponse, error) {
	respType := VirtualMachineScaleSetsClientRedeployResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Redeploy", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientRedeployPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientRedeployResponse contains the response from method VirtualMachineScaleSetsClient.Redeploy.
type VirtualMachineScaleSetsClientRedeployResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientReimageAllPollerResponse contains the response from method VirtualMachineScaleSetsClient.ReimageAll.
type VirtualMachineScaleSetsClientReimageAllPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientReimageAllPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientReimageAllPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientReimageAllResponse, error) {
	respType := VirtualMachineScaleSetsClientReimageAllResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientReimageAllPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientReimageAllPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.ReimageAll", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientReimageAllPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientReimageAllResponse contains the response from method VirtualMachineScaleSetsClient.ReimageAll.
type VirtualMachineScaleSetsClientReimageAllResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientReimagePollerResponse contains the response from method VirtualMachineScaleSetsClient.Reimage.
type VirtualMachineScaleSetsClientReimagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientReimagePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientReimagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientReimageResponse, error) {
	respType := VirtualMachineScaleSetsClientReimageResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientReimagePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientReimagePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Reimage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientReimagePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientReimageResponse contains the response from method VirtualMachineScaleSetsClient.Reimage.
type VirtualMachineScaleSetsClientReimageResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientRestartPollerResponse contains the response from method VirtualMachineScaleSetsClient.Restart.
type VirtualMachineScaleSetsClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientRestartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientRestartResponse, error) {
	respType := VirtualMachineScaleSetsClientRestartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientRestartPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientRestartPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientRestartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientRestartResponse contains the response from method VirtualMachineScaleSetsClient.Restart.
type VirtualMachineScaleSetsClientRestartResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientSetOrchestrationServiceStatePollerResponse contains the response from method VirtualMachineScaleSetsClient.SetOrchestrationServiceState.
type VirtualMachineScaleSetsClientSetOrchestrationServiceStatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientSetOrchestrationServiceStatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse, error) {
	respType := VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientSetOrchestrationServiceStatePollerResponse from the provided client and
// resume token.
func (l *VirtualMachineScaleSetsClientSetOrchestrationServiceStatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.SetOrchestrationServiceState", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientSetOrchestrationServiceStatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse contains the response from method VirtualMachineScaleSetsClient.SetOrchestrationServiceState.
type VirtualMachineScaleSetsClientSetOrchestrationServiceStateResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientStartPollerResponse contains the response from method VirtualMachineScaleSetsClient.Start.
type VirtualMachineScaleSetsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientStartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientStartResponse, error) {
	respType := VirtualMachineScaleSetsClientStartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientStartPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientStartPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientStartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientStartResponse contains the response from method VirtualMachineScaleSetsClient.Start.
type VirtualMachineScaleSetsClientStartResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientUpdateInstancesPollerResponse contains the response from method VirtualMachineScaleSetsClient.UpdateInstances.
type VirtualMachineScaleSetsClientUpdateInstancesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientUpdateInstancesPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientUpdateInstancesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientUpdateInstancesResponse, error) {
	respType := VirtualMachineScaleSetsClientUpdateInstancesResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientUpdateInstancesPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientUpdateInstancesPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.UpdateInstances", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientUpdateInstancesPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientUpdateInstancesResponse contains the response from method VirtualMachineScaleSetsClient.UpdateInstances.
type VirtualMachineScaleSetsClientUpdateInstancesResponse struct {
	// placeholder for future response values
}

// VirtualMachineScaleSetsClientUpdatePollerResponse contains the response from method VirtualMachineScaleSetsClient.Update.
type VirtualMachineScaleSetsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetsClientUpdateResponse, error) {
	respType := VirtualMachineScaleSetsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineScaleSet)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineScaleSetsClientUpdateResponse contains the response from method VirtualMachineScaleSetsClient.Update.
type VirtualMachineScaleSetsClientUpdateResponse struct {
	VirtualMachineScaleSet
}

// VirtualMachineSizesClientListResponse contains the response from method VirtualMachineSizesClient.List.
type VirtualMachineSizesClientListResponse struct {
	VirtualMachineSizeListResult
}

// VirtualMachinesClientCapturePollerResponse contains the response from method VirtualMachinesClient.Capture.
type VirtualMachinesClientCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientCapturePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCaptureResponse, error) {
	respType := VirtualMachinesClientCaptureResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineCaptureResult)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientCapturePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientCapturePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Capture", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientCapturePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientCaptureResponse contains the response from method VirtualMachinesClient.Capture.
type VirtualMachinesClientCaptureResponse struct {
	VirtualMachineCaptureResult
}

// VirtualMachinesClientConvertToManagedDisksPollerResponse contains the response from method VirtualMachinesClient.ConvertToManagedDisks.
type VirtualMachinesClientConvertToManagedDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientConvertToManagedDisksPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientConvertToManagedDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientConvertToManagedDisksResponse, error) {
	respType := VirtualMachinesClientConvertToManagedDisksResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientConvertToManagedDisksPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientConvertToManagedDisksPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.ConvertToManagedDisks", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientConvertToManagedDisksPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientConvertToManagedDisksResponse contains the response from method VirtualMachinesClient.ConvertToManagedDisks.
type VirtualMachinesClientConvertToManagedDisksResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientCreateOrUpdatePollerResponse contains the response from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCreateOrUpdateResponse, error) {
	respType := VirtualMachinesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachine)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientCreateOrUpdateResponse contains the response from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdateResponse struct {
	VirtualMachine
}

// VirtualMachinesClientDeallocatePollerResponse contains the response from method VirtualMachinesClient.Deallocate.
type VirtualMachinesClientDeallocatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientDeallocatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientDeallocatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeallocateResponse, error) {
	respType := VirtualMachinesClientDeallocateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientDeallocatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientDeallocatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Deallocate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientDeallocatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientDeallocateResponse contains the response from method VirtualMachinesClient.Deallocate.
type VirtualMachinesClientDeallocateResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientDeletePollerResponse contains the response from method VirtualMachinesClient.Delete.
type VirtualMachinesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeleteResponse, error) {
	respType := VirtualMachinesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientDeleteResponse contains the response from method VirtualMachinesClient.Delete.
type VirtualMachinesClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientGeneralizeResponse contains the response from method VirtualMachinesClient.Generalize.
type VirtualMachinesClientGeneralizeResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientGetResponse contains the response from method VirtualMachinesClient.Get.
type VirtualMachinesClientGetResponse struct {
	VirtualMachine
}

// VirtualMachinesClientInstanceViewResponse contains the response from method VirtualMachinesClient.InstanceView.
type VirtualMachinesClientInstanceViewResponse struct {
	VirtualMachineInstanceView
}

// VirtualMachinesClientListAllResponse contains the response from method VirtualMachinesClient.ListAll.
type VirtualMachinesClientListAllResponse struct {
	VirtualMachineListResult
}

// VirtualMachinesClientListAvailableSizesResponse contains the response from method VirtualMachinesClient.ListAvailableSizes.
type VirtualMachinesClientListAvailableSizesResponse struct {
	VirtualMachineSizeListResult
}

// VirtualMachinesClientListByLocationResponse contains the response from method VirtualMachinesClient.ListByLocation.
type VirtualMachinesClientListByLocationResponse struct {
	VirtualMachineListResult
}

// VirtualMachinesClientListResponse contains the response from method VirtualMachinesClient.List.
type VirtualMachinesClientListResponse struct {
	VirtualMachineListResult
}

// VirtualMachinesClientPerformMaintenancePollerResponse contains the response from method VirtualMachinesClient.PerformMaintenance.
type VirtualMachinesClientPerformMaintenancePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientPerformMaintenancePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientPerformMaintenancePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientPerformMaintenanceResponse, error) {
	respType := VirtualMachinesClientPerformMaintenanceResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientPerformMaintenancePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientPerformMaintenancePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.PerformMaintenance", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientPerformMaintenancePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientPerformMaintenanceResponse contains the response from method VirtualMachinesClient.PerformMaintenance.
type VirtualMachinesClientPerformMaintenanceResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientPowerOffPollerResponse contains the response from method VirtualMachinesClient.PowerOff.
type VirtualMachinesClientPowerOffPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientPowerOffPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientPowerOffPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientPowerOffResponse, error) {
	respType := VirtualMachinesClientPowerOffResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientPowerOffPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientPowerOffPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.PowerOff", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientPowerOffPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientPowerOffResponse contains the response from method VirtualMachinesClient.PowerOff.
type VirtualMachinesClientPowerOffResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientReapplyPollerResponse contains the response from method VirtualMachinesClient.Reapply.
type VirtualMachinesClientReapplyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientReapplyPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientReapplyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientReapplyResponse, error) {
	respType := VirtualMachinesClientReapplyResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientReapplyPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientReapplyPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reapply", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientReapplyPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientReapplyResponse contains the response from method VirtualMachinesClient.Reapply.
type VirtualMachinesClientReapplyResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientRedeployPollerResponse contains the response from method VirtualMachinesClient.Redeploy.
type VirtualMachinesClientRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRedeployPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRedeployResponse, error) {
	respType := VirtualMachinesClientRedeployResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Redeploy", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRedeployPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientRedeployResponse contains the response from method VirtualMachinesClient.Redeploy.
type VirtualMachinesClientRedeployResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientReimagePollerResponse contains the response from method VirtualMachinesClient.Reimage.
type VirtualMachinesClientReimagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientReimagePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientReimagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientReimageResponse, error) {
	respType := VirtualMachinesClientReimageResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientReimagePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientReimagePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reimage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientReimagePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientReimageResponse contains the response from method VirtualMachinesClient.Reimage.
type VirtualMachinesClientReimageResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientRestartPollerResponse contains the response from method VirtualMachinesClient.Restart.
type VirtualMachinesClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRestartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRestartResponse, error) {
	respType := VirtualMachinesClientRestartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRestartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRestartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRestartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientRestartResponse contains the response from method VirtualMachinesClient.Restart.
type VirtualMachinesClientRestartResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientRunCommandPollerResponse contains the response from method VirtualMachinesClient.RunCommand.
type VirtualMachinesClientRunCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRunCommandPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRunCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRunCommandResponse, error) {
	respType := VirtualMachinesClientRunCommandResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RunCommandResult)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRunCommandPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRunCommandPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.RunCommand", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRunCommandPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientRunCommandResponse contains the response from method VirtualMachinesClient.RunCommand.
type VirtualMachinesClientRunCommandResponse struct {
	RunCommandResult
}

// VirtualMachinesClientSimulateEvictionResponse contains the response from method VirtualMachinesClient.SimulateEviction.
type VirtualMachinesClientSimulateEvictionResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientStartPollerResponse contains the response from method VirtualMachinesClient.Start.
type VirtualMachinesClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientStartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientStartResponse, error) {
	respType := VirtualMachinesClientStartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientStartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientStartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientStartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientStartResponse contains the response from method VirtualMachinesClient.Start.
type VirtualMachinesClientStartResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientUpdatePollerResponse contains the response from method VirtualMachinesClient.Update.
type VirtualMachinesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientUpdateResponse, error) {
	respType := VirtualMachinesClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachine)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientUpdateResponse contains the response from method VirtualMachinesClient.Update.
type VirtualMachinesClientUpdateResponse struct {
	VirtualMachine
}
