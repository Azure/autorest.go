//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AvailabilitySetsClientListBySubscriptionPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListBySubscriptionPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailabilitySetsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailabilitySetsClientListBySubscriptionPager) NextPage(ctx context.Context) (AvailabilitySetsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailabilitySetsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailabilitySetsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailabilitySetsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailabilitySetsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return AvailabilitySetsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailabilitySetsClientListPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailabilitySetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailabilitySetsClientListPager) NextPage(ctx context.Context) (AvailabilitySetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailabilitySetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailabilitySetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailabilitySetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailabilitySetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailabilitySetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ContainerServicesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ContainerServicesClientListByResourceGroupPager struct {
	client    *ContainerServicesClient
	current   ContainerServicesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerServicesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ContainerServicesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerServiceListResult.NextLink == nil || len(*p.current.ContainerServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ContainerServicesClientListByResourceGroupPager) NextPage(ctx context.Context) (ContainerServicesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ContainerServicesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ContainerServicesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ContainerServicesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ContainerServicesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ContainerServicesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ContainerServicesClientListPager provides operations for iterating over paged responses.
type ContainerServicesClientListPager struct {
	client    *ContainerServicesClient
	current   ContainerServicesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerServicesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ContainerServicesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerServiceListResult.NextLink == nil || len(*p.current.ContainerServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ContainerServicesClientListPager) NextPage(ctx context.Context) (ContainerServicesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ContainerServicesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ContainerServicesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ContainerServicesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ContainerServicesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ContainerServicesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DedicatedHostGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DedicatedHostGroupsClientListByResourceGroupPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) (DedicatedHostGroupsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DedicatedHostGroupsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DedicatedHostGroupsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DedicatedHostGroupsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DedicatedHostGroupsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DedicatedHostGroupsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DedicatedHostGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type DedicatedHostGroupsClientListBySubscriptionPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) (DedicatedHostGroupsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DedicatedHostGroupsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DedicatedHostGroupsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DedicatedHostGroupsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DedicatedHostGroupsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return DedicatedHostGroupsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DedicatedHostsClientListByHostGroupPager provides operations for iterating over paged responses.
type DedicatedHostsClientListByHostGroupPager struct {
	client    *DedicatedHostsClient
	current   DedicatedHostsClientListByHostGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostsClientListByHostGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DedicatedHostsClientListByHostGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostListResult.NextLink == nil || len(*p.current.DedicatedHostListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DedicatedHostsClientListByHostGroupPager) NextPage(ctx context.Context) (DedicatedHostsClientListByHostGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DedicatedHostsClientListByHostGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DedicatedHostsClientListByHostGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DedicatedHostsClientListByHostGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DedicatedHostsClientListByHostGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHostGroupHandleResponse(resp)
	if err != nil {
		return DedicatedHostsClientListByHostGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskEncryptionSetsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListByResourceGroupPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) NextPage(ctx context.Context) (DiskEncryptionSetsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskEncryptionSetsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskEncryptionSetsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskEncryptionSetsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskEncryptionSetsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DiskEncryptionSetsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskEncryptionSetsClientListPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskEncryptionSetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskEncryptionSetsClientListPager) NextPage(ctx context.Context) (DiskEncryptionSetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskEncryptionSetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskEncryptionSetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskEncryptionSetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskEncryptionSetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DiskEncryptionSetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DisksClientListByResourceGroupPager provides operations for iterating over paged responses.
type DisksClientListByResourceGroupPager struct {
	client    *DisksClient
	current   DisksClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DisksClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DisksClientListByResourceGroupPager) NextPage(ctx context.Context) (DisksClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DisksClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DisksClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DisksClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DisksClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DisksClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DisksClientListPager provides operations for iterating over paged responses.
type DisksClientListPager struct {
	client    *DisksClient
	current   DisksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DisksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DisksClientListPager) NextPage(ctx context.Context) (DisksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DisksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DisksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DisksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DisksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DisksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleriesClientListByResourceGroupPager provides operations for iterating over paged responses.
type GalleriesClientListByResourceGroupPager struct {
	client    *GalleriesClient
	current   GalleriesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleriesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleriesClientListByResourceGroupPager) NextPage(ctx context.Context) (GalleriesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleriesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleriesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleriesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleriesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return GalleriesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleriesClientListPager provides operations for iterating over paged responses.
type GalleriesClientListPager struct {
	client    *GalleriesClient
	current   GalleriesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleriesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleriesClientListPager) NextPage(ctx context.Context) (GalleriesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleriesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleriesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleriesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleriesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return GalleriesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryApplicationVersionsClientListByGalleryApplicationPager provides operations for iterating over paged responses.
type GalleryApplicationVersionsClientListByGalleryApplicationPager struct {
	client    *GalleryApplicationVersionsClient
	current   GalleryApplicationVersionsClientListByGalleryApplicationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationVersionsClientListByGalleryApplicationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationVersionList.NextLink == nil || len(*p.current.GalleryApplicationVersionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) NextPage(ctx context.Context) (GalleryApplicationVersionsClientListByGalleryApplicationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryApplicationHandleResponse(resp)
	if err != nil {
		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryApplicationsClientListByGalleryPager provides operations for iterating over paged responses.
type GalleryApplicationsClientListByGalleryPager struct {
	client    *GalleryApplicationsClient
	current   GalleryApplicationsClientListByGalleryResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationsClientListByGalleryResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryApplicationsClientListByGalleryPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationList.NextLink == nil || len(*p.current.GalleryApplicationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryApplicationsClientListByGalleryPager) NextPage(ctx context.Context) (GalleryApplicationsClientListByGalleryResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryApplicationsClientListByGalleryResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryApplicationsClientListByGalleryResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryApplicationsClientListByGalleryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryApplicationsClientListByGalleryResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		return GalleryApplicationsClientListByGalleryResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryImageVersionsClientListByGalleryImagePager provides operations for iterating over paged responses.
type GalleryImageVersionsClientListByGalleryImagePager struct {
	client    *GalleryImageVersionsClient
	current   GalleryImageVersionsClientListByGalleryImageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImageVersionsClientListByGalleryImageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryImageVersionsClientListByGalleryImagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageVersionList.NextLink == nil || len(*p.current.GalleryImageVersionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryImageVersionsClientListByGalleryImagePager) NextPage(ctx context.Context) (GalleryImageVersionsClientListByGalleryImageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryImageVersionsClientListByGalleryImageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryImageVersionsClientListByGalleryImageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryImageVersionsClientListByGalleryImageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryImageVersionsClientListByGalleryImageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryImageHandleResponse(resp)
	if err != nil {
		return GalleryImageVersionsClientListByGalleryImageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryImagesClientListByGalleryPager provides operations for iterating over paged responses.
type GalleryImagesClientListByGalleryPager struct {
	client    *GalleryImagesClient
	current   GalleryImagesClientListByGalleryResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImagesClientListByGalleryResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryImagesClientListByGalleryPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryImagesClientListByGalleryPager) NextPage(ctx context.Context) (GalleryImagesClientListByGalleryResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryImagesClientListByGalleryResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryImagesClientListByGalleryResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryImagesClientListByGalleryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryImagesClientListByGalleryResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		return GalleryImagesClientListByGalleryResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ImagesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ImagesClientListByResourceGroupPager struct {
	client    *ImagesClient
	current   ImagesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ImagesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ImagesClientListByResourceGroupPager) NextPage(ctx context.Context) (ImagesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ImagesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ImagesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ImagesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ImagesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ImagesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ImagesClientListPager provides operations for iterating over paged responses.
type ImagesClientListPager struct {
	client    *ImagesClient
	current   ImagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ImagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ImagesClientListPager) NextPage(ctx context.Context) (ImagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ImagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ImagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ImagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ImagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ImagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProximityPlacementGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsClientListByResourceGroupPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) (ProximityPlacementGroupsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProximityPlacementGroupsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProximityPlacementGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsClientListBySubscriptionPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) (ProximityPlacementGroupsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProximityPlacementGroupsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ResourceSKUsClientListPager provides operations for iterating over paged responses.
type ResourceSKUsClientListPager struct {
	client    *ResourceSKUsClient
	current   ResourceSKUsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceSKUsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ResourceSKUsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUsResult.NextLink == nil || len(*p.current.ResourceSKUsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ResourceSKUsClientListPager) NextPage(ctx context.Context) (ResourceSKUsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ResourceSKUsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ResourceSKUsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ResourceSKUsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ResourceSKUsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ResourceSKUsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SSHPublicKeysClientListByResourceGroupPager provides operations for iterating over paged responses.
type SSHPublicKeysClientListByResourceGroupPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SSHPublicKeysClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SSHPublicKeysClientListByResourceGroupPager) NextPage(ctx context.Context) (SSHPublicKeysClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SSHPublicKeysClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SSHPublicKeysClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SSHPublicKeysClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SSHPublicKeysClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return SSHPublicKeysClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SSHPublicKeysClientListBySubscriptionPager provides operations for iterating over paged responses.
type SSHPublicKeysClientListBySubscriptionPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SSHPublicKeysClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SSHPublicKeysClientListBySubscriptionPager) NextPage(ctx context.Context) (SSHPublicKeysClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SSHPublicKeysClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SSHPublicKeysClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SSHPublicKeysClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SSHPublicKeysClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return SSHPublicKeysClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SnapshotsClientListByResourceGroupPager provides operations for iterating over paged responses.
type SnapshotsClientListByResourceGroupPager struct {
	client    *SnapshotsClient
	current   SnapshotsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SnapshotsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SnapshotsClientListByResourceGroupPager) NextPage(ctx context.Context) (SnapshotsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SnapshotsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SnapshotsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SnapshotsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SnapshotsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return SnapshotsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SnapshotsClientListPager provides operations for iterating over paged responses.
type SnapshotsClientListPager struct {
	client    *SnapshotsClient
	current   SnapshotsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SnapshotsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SnapshotsClientListPager) NextPage(ctx context.Context) (SnapshotsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SnapshotsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SnapshotsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SnapshotsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SnapshotsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SnapshotsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UsageClientListPager provides operations for iterating over paged responses.
type UsageClientListPager struct {
	client    *UsageClient
	current   UsageClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsageClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UsageClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListUsagesResult.NextLink == nil || len(*p.current.ListUsagesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UsageClientListPager) NextPage(ctx context.Context) (UsageClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UsageClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UsageClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UsageClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UsageClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UsageClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineRunCommandsClientListPager provides operations for iterating over paged responses.
type VirtualMachineRunCommandsClientListPager struct {
	client    *VirtualMachineRunCommandsClient
	current   VirtualMachineRunCommandsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineRunCommandsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineRunCommandsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunCommandListResult.NextLink == nil || len(*p.current.RunCommandListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineRunCommandsClientListPager) NextPage(ctx context.Context) (VirtualMachineRunCommandsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineRunCommandsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineRunCommandsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineRunCommandsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineRunCommandsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineRunCommandsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetExtensionsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetExtensionsClientListPager struct {
	client    *VirtualMachineScaleSetExtensionsClient
	current   VirtualMachineScaleSetExtensionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetExtensionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetExtensionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetExtensionListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetExtensionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetExtensionsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetExtensionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetExtensionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetExtensionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetExtensionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetExtensionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetExtensionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetVMsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetVMsClientListPager struct {
	client    *VirtualMachineScaleSetVMsClient
	current   VirtualMachineScaleSetVMsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetVMsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetVMsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetVMListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetVMListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetVMsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetVMsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetVMsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetVMsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetVMsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetVMsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetVMsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink == nil || len(*p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getOSUpgradeHistoryHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListAllPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListAllPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListWithLinkResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListWithLinkResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListAllPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListSKUsPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListSKUsPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListSKUsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListSKUsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListSKUsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListSKUsResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListSKUsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListSKUsPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListSKUsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListSKUsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListSKUsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListSKUsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSKUsHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListSKUsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListAllPager provides operations for iterating over paged responses.
type VirtualMachinesClientListAllPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListAllPager) NextPage(ctx context.Context) (VirtualMachinesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListByLocationPager provides operations for iterating over paged responses.
type VirtualMachinesClientListByLocationPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListByLocationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListByLocationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListByLocationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListByLocationPager) NextPage(ctx context.Context) (VirtualMachinesClientListByLocationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListByLocationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListByLocationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListByLocationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListByLocationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListByLocationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListPager provides operations for iterating over paged responses.
type VirtualMachinesClientListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListPager) NextPage(ctx context.Context) (VirtualMachinesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
