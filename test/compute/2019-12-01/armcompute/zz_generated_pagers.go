//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AvailabilitySetsClientListBySubscriptionPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListBySubscriptionPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailabilitySetsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailabilitySetsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailabilitySetsClientListBySubscriptionResponse page.
func (p *AvailabilitySetsClientListBySubscriptionPager) PageResponse() AvailabilitySetsClientListBySubscriptionResponse {
	return p.current
}

// AvailabilitySetsClientListPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *AvailabilitySetsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *AvailabilitySetsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current AvailabilitySetsClientListResponse page.
func (p *AvailabilitySetsClientListPager) PageResponse() AvailabilitySetsClientListResponse {
	return p.current
}

// ContainerServicesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ContainerServicesClientListByResourceGroupPager struct {
	client    *ContainerServicesClient
	current   ContainerServicesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerServicesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContainerServicesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContainerServicesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerServiceListResult.NextLink == nil || len(*p.current.ContainerServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContainerServicesClientListByResourceGroupResponse page.
func (p *ContainerServicesClientListByResourceGroupPager) PageResponse() ContainerServicesClientListByResourceGroupResponse {
	return p.current
}

// ContainerServicesClientListPager provides operations for iterating over paged responses.
type ContainerServicesClientListPager struct {
	client    *ContainerServicesClient
	current   ContainerServicesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContainerServicesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ContainerServicesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ContainerServicesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContainerServiceListResult.NextLink == nil || len(*p.current.ContainerServiceListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ContainerServicesClientListResponse page.
func (p *ContainerServicesClientListPager) PageResponse() ContainerServicesClientListResponse {
	return p.current
}

// DedicatedHostGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DedicatedHostGroupsClientListByResourceGroupPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DedicatedHostGroupsClientListByResourceGroupResponse page.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) PageResponse() DedicatedHostGroupsClientListByResourceGroupResponse {
	return p.current
}

// DedicatedHostGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type DedicatedHostGroupsClientListBySubscriptionPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DedicatedHostGroupsClientListBySubscriptionResponse page.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) PageResponse() DedicatedHostGroupsClientListBySubscriptionResponse {
	return p.current
}

// DedicatedHostsClientListByHostGroupPager provides operations for iterating over paged responses.
type DedicatedHostsClientListByHostGroupPager struct {
	client    *DedicatedHostsClient
	current   DedicatedHostsClientListByHostGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostsClientListByHostGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DedicatedHostsClientListByHostGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DedicatedHostsClientListByHostGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostListResult.NextLink == nil || len(*p.current.DedicatedHostListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByHostGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByHostGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DedicatedHostsClientListByHostGroupResponse page.
func (p *DedicatedHostsClientListByHostGroupPager) PageResponse() DedicatedHostsClientListByHostGroupResponse {
	return p.current
}

// DiskEncryptionSetsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListByResourceGroupPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskEncryptionSetsClientListByResourceGroupResponse page.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) PageResponse() DiskEncryptionSetsClientListByResourceGroupResponse {
	return p.current
}

// DiskEncryptionSetsClientListPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DiskEncryptionSetsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DiskEncryptionSetsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DiskEncryptionSetsClientListResponse page.
func (p *DiskEncryptionSetsClientListPager) PageResponse() DiskEncryptionSetsClientListResponse {
	return p.current
}

// DisksClientListByResourceGroupPager provides operations for iterating over paged responses.
type DisksClientListByResourceGroupPager struct {
	client    *DisksClient
	current   DisksClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DisksClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DisksClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DisksClientListByResourceGroupResponse page.
func (p *DisksClientListByResourceGroupPager) PageResponse() DisksClientListByResourceGroupResponse {
	return p.current
}

// DisksClientListPager provides operations for iterating over paged responses.
type DisksClientListPager struct {
	client    *DisksClient
	current   DisksClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *DisksClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *DisksClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current DisksClientListResponse page.
func (p *DisksClientListPager) PageResponse() DisksClientListResponse {
	return p.current
}

// GalleriesClientListByResourceGroupPager provides operations for iterating over paged responses.
type GalleriesClientListByResourceGroupPager struct {
	client    *GalleriesClient
	current   GalleriesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleriesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleriesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleriesClientListByResourceGroupResponse page.
func (p *GalleriesClientListByResourceGroupPager) PageResponse() GalleriesClientListByResourceGroupResponse {
	return p.current
}

// GalleriesClientListPager provides operations for iterating over paged responses.
type GalleriesClientListPager struct {
	client    *GalleriesClient
	current   GalleriesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleriesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleriesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleriesClientListResponse page.
func (p *GalleriesClientListPager) PageResponse() GalleriesClientListResponse {
	return p.current
}

// GalleryApplicationVersionsClientListByGalleryApplicationPager provides operations for iterating over paged responses.
type GalleryApplicationVersionsClientListByGalleryApplicationPager struct {
	client    *GalleryApplicationVersionsClient
	current   GalleryApplicationVersionsClientListByGalleryApplicationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationVersionsClientListByGalleryApplicationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationVersionList.NextLink == nil || len(*p.current.GalleryApplicationVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryApplicationHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryApplicationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryApplicationVersionsClientListByGalleryApplicationResponse page.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) PageResponse() GalleryApplicationVersionsClientListByGalleryApplicationResponse {
	return p.current
}

// GalleryApplicationsClientListByGalleryPager provides operations for iterating over paged responses.
type GalleryApplicationsClientListByGalleryPager struct {
	client    *GalleryApplicationsClient
	current   GalleryApplicationsClientListByGalleryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationsClientListByGalleryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryApplicationsClientListByGalleryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryApplicationsClientListByGalleryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationList.NextLink == nil || len(*p.current.GalleryApplicationList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryApplicationsClientListByGalleryResponse page.
func (p *GalleryApplicationsClientListByGalleryPager) PageResponse() GalleryApplicationsClientListByGalleryResponse {
	return p.current
}

// GalleryImageVersionsClientListByGalleryImagePager provides operations for iterating over paged responses.
type GalleryImageVersionsClientListByGalleryImagePager struct {
	client    *GalleryImageVersionsClient
	current   GalleryImageVersionsClientListByGalleryImageResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImageVersionsClientListByGalleryImageResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryImageVersionsClientListByGalleryImagePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryImageVersionsClientListByGalleryImagePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageVersionList.NextLink == nil || len(*p.current.GalleryImageVersionList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryImageHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryImageHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryImageVersionsClientListByGalleryImageResponse page.
func (p *GalleryImageVersionsClientListByGalleryImagePager) PageResponse() GalleryImageVersionsClientListByGalleryImageResponse {
	return p.current
}

// GalleryImagesClientListByGalleryPager provides operations for iterating over paged responses.
type GalleryImagesClientListByGalleryPager struct {
	client    *GalleryImagesClient
	current   GalleryImagesClientListByGalleryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImagesClientListByGalleryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *GalleryImagesClientListByGalleryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *GalleryImagesClientListByGalleryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByGalleryHandleError(resp)
		return false
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current GalleryImagesClientListByGalleryResponse page.
func (p *GalleryImagesClientListByGalleryPager) PageResponse() GalleryImagesClientListByGalleryResponse {
	return p.current
}

// ImagesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ImagesClientListByResourceGroupPager struct {
	client    *ImagesClient
	current   ImagesClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ImagesClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ImagesClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ImagesClientListByResourceGroupResponse page.
func (p *ImagesClientListByResourceGroupPager) PageResponse() ImagesClientListByResourceGroupResponse {
	return p.current
}

// ImagesClientListPager provides operations for iterating over paged responses.
type ImagesClientListPager struct {
	client    *ImagesClient
	current   ImagesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ImagesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ImagesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ImagesClientListResponse page.
func (p *ImagesClientListPager) PageResponse() ImagesClientListResponse {
	return p.current
}

// ProximityPlacementGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsClientListByResourceGroupPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProximityPlacementGroupsClientListByResourceGroupResponse page.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) PageResponse() ProximityPlacementGroupsClientListByResourceGroupResponse {
	return p.current
}

// ProximityPlacementGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsClientListBySubscriptionPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ProximityPlacementGroupsClientListBySubscriptionResponse page.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) PageResponse() ProximityPlacementGroupsClientListBySubscriptionResponse {
	return p.current
}

// ResourceSKUsClientListPager provides operations for iterating over paged responses.
type ResourceSKUsClientListPager struct {
	client    *ResourceSKUsClient
	current   ResourceSKUsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceSKUsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *ResourceSKUsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *ResourceSKUsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUsResult.NextLink == nil || len(*p.current.ResourceSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current ResourceSKUsClientListResponse page.
func (p *ResourceSKUsClientListPager) PageResponse() ResourceSKUsClientListResponse {
	return p.current
}

// SSHPublicKeysClientListByResourceGroupPager provides operations for iterating over paged responses.
type SSHPublicKeysClientListByResourceGroupPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SSHPublicKeysClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SSHPublicKeysClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SSHPublicKeysClientListByResourceGroupResponse page.
func (p *SSHPublicKeysClientListByResourceGroupPager) PageResponse() SSHPublicKeysClientListByResourceGroupResponse {
	return p.current
}

// SSHPublicKeysClientListBySubscriptionPager provides operations for iterating over paged responses.
type SSHPublicKeysClientListBySubscriptionPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysClientListBySubscriptionResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysClientListBySubscriptionResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SSHPublicKeysClientListBySubscriptionPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SSHPublicKeysClientListBySubscriptionPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listBySubscriptionHandleError(resp)
		return false
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SSHPublicKeysClientListBySubscriptionResponse page.
func (p *SSHPublicKeysClientListBySubscriptionPager) PageResponse() SSHPublicKeysClientListBySubscriptionResponse {
	return p.current
}

// SnapshotsClientListByResourceGroupPager provides operations for iterating over paged responses.
type SnapshotsClientListByResourceGroupPager struct {
	client    *SnapshotsClient
	current   SnapshotsClientListByResourceGroupResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsClientListByResourceGroupResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SnapshotsClientListByResourceGroupPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SnapshotsClientListByResourceGroupPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByResourceGroupHandleError(resp)
		return false
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SnapshotsClientListByResourceGroupResponse page.
func (p *SnapshotsClientListByResourceGroupPager) PageResponse() SnapshotsClientListByResourceGroupResponse {
	return p.current
}

// SnapshotsClientListPager provides operations for iterating over paged responses.
type SnapshotsClientListPager struct {
	client    *SnapshotsClient
	current   SnapshotsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *SnapshotsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *SnapshotsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current SnapshotsClientListResponse page.
func (p *SnapshotsClientListPager) PageResponse() SnapshotsClientListResponse {
	return p.current
}

// UsageClientListPager provides operations for iterating over paged responses.
type UsageClientListPager struct {
	client    *UsageClient
	current   UsageClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsageClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *UsageClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *UsageClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListUsagesResult.NextLink == nil || len(*p.current.ListUsagesResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current UsageClientListResponse page.
func (p *UsageClientListPager) PageResponse() UsageClientListResponse {
	return p.current
}

// VirtualMachineRunCommandsClientListPager provides operations for iterating over paged responses.
type VirtualMachineRunCommandsClientListPager struct {
	client    *VirtualMachineRunCommandsClient
	current   VirtualMachineRunCommandsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineRunCommandsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineRunCommandsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineRunCommandsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunCommandListResult.NextLink == nil || len(*p.current.RunCommandListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineRunCommandsClientListResponse page.
func (p *VirtualMachineRunCommandsClientListPager) PageResponse() VirtualMachineRunCommandsClientListResponse {
	return p.current
}

// VirtualMachineScaleSetExtensionsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetExtensionsClientListPager struct {
	client    *VirtualMachineScaleSetExtensionsClient
	current   VirtualMachineScaleSetExtensionsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetExtensionsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetExtensionsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetExtensionsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetExtensionListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetExtensionListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetExtensionsClientListResponse page.
func (p *VirtualMachineScaleSetExtensionsClientListPager) PageResponse() VirtualMachineScaleSetExtensionsClientListResponse {
	return p.current
}

// VirtualMachineScaleSetVMsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetVMsClientListPager struct {
	client    *VirtualMachineScaleSetVMsClient
	current   VirtualMachineScaleSetVMsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetVMsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetVMsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetVMsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetVMListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetVMListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetVMsClientListResponse page.
func (p *VirtualMachineScaleSetVMsClientListPager) PageResponse() VirtualMachineScaleSetVMsClientListResponse {
	return p.current
}

// VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink == nil || len(*p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.getOSUpgradeHistoryHandleError(resp)
		return false
	}
	result, err := p.client.getOSUpgradeHistoryHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse page.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) PageResponse() VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse {
	return p.current
}

// VirtualMachineScaleSetsClientListAllPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListAllPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListWithLinkResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListWithLinkResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsClientListAllResponse page.
func (p *VirtualMachineScaleSetsClientListAllPager) PageResponse() VirtualMachineScaleSetsClientListAllResponse {
	return p.current
}

// VirtualMachineScaleSetsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsClientListResponse page.
func (p *VirtualMachineScaleSetsClientListPager) PageResponse() VirtualMachineScaleSetsClientListResponse {
	return p.current
}

// VirtualMachineScaleSetsClientListSKUsPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListSKUsPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListSKUsResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListSKUsResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachineScaleSetsClientListSKUsPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachineScaleSetsClientListSKUsPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListSKUsResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListSKUsResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listSKUsHandleError(resp)
		return false
	}
	result, err := p.client.listSKUsHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachineScaleSetsClientListSKUsResponse page.
func (p *VirtualMachineScaleSetsClientListSKUsPager) PageResponse() VirtualMachineScaleSetsClientListSKUsResponse {
	return p.current
}

// VirtualMachinesClientListAllPager provides operations for iterating over paged responses.
type VirtualMachinesClientListAllPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListAllResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListAllResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesClientListAllPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesClientListAllPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listAllHandleError(resp)
		return false
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesClientListAllResponse page.
func (p *VirtualMachinesClientListAllPager) PageResponse() VirtualMachinesClientListAllResponse {
	return p.current
}

// VirtualMachinesClientListByLocationPager provides operations for iterating over paged responses.
type VirtualMachinesClientListByLocationPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListByLocationResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListByLocationResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesClientListByLocationPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesClientListByLocationPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listByLocationHandleError(resp)
		return false
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesClientListByLocationResponse page.
func (p *VirtualMachinesClientListByLocationPager) PageResponse() VirtualMachinesClientListByLocationResponse {
	return p.current
}

// VirtualMachinesClientListPager provides operations for iterating over paged responses.
type VirtualMachinesClientListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *VirtualMachinesClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *VirtualMachinesClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = p.client.listHandleError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current VirtualMachinesClientListResponse page.
func (p *VirtualMachinesClientListPager) PageResponse() VirtualMachinesClientListResponse {
	return p.current
}
