//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdataboxedge

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AddonsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AddonsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AddonsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *AddonsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *AddonsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp AddonsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *AddonsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsClientCreateOrUpdateResponse, error) {
	result := AddonsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *AddonsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a AddonsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *AddonsClientCreateOrUpdatePoller) Resume(token string, client *AddonsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("AddonsClient.CreateOrUpdate", token, client.pl)
	return
}

// AddonsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AddonsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AddonsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *AddonsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *AddonsClientDeletePoller) Result(ctx context.Context) (resp AddonsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *AddonsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (AddonsClientDeleteResponse, error) {
	result := AddonsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *AddonsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a AddonsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *AddonsClientDeletePoller) Resume(token string, client *AddonsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("AddonsClient.Delete", token, client.pl)
	return
}

// BandwidthSchedulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BandwidthSchedulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BandwidthSchedulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *BandwidthSchedulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *BandwidthSchedulesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp BandwidthSchedulesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *BandwidthSchedulesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (BandwidthSchedulesClientCreateOrUpdateResponse, error) {
	result := BandwidthSchedulesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.BandwidthSchedule)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *BandwidthSchedulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a BandwidthSchedulesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *BandwidthSchedulesClientCreateOrUpdatePoller) Resume(token string, client *BandwidthSchedulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("BandwidthSchedulesClient.CreateOrUpdate", token, client.pl)
	return
}

// BandwidthSchedulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type BandwidthSchedulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BandwidthSchedulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *BandwidthSchedulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *BandwidthSchedulesClientDeletePoller) Result(ctx context.Context) (resp BandwidthSchedulesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *BandwidthSchedulesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (BandwidthSchedulesClientDeleteResponse, error) {
	result := BandwidthSchedulesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *BandwidthSchedulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a BandwidthSchedulesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *BandwidthSchedulesClientDeletePoller) Resume(token string, client *BandwidthSchedulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("BandwidthSchedulesClient.Delete", token, client.pl)
	return
}

// ContainersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ContainersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ContainersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ContainersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ContainersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ContainersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ContainersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersClientCreateOrUpdateResponse, error) {
	result := ContainersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Container)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ContainersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ContainersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ContainersClientCreateOrUpdatePoller) Resume(token string, client *ContainersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ContainersClient.CreateOrUpdate", token, client.pl)
	return
}

// ContainersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ContainersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ContainersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ContainersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ContainersClientDeletePoller) Result(ctx context.Context) (resp ContainersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ContainersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersClientDeleteResponse, error) {
	result := ContainersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ContainersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ContainersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ContainersClientDeletePoller) Resume(token string, client *ContainersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ContainersClient.Delete", token, client.pl)
	return
}

// ContainersClientRefreshPoller provides polling facilities until the operation reaches a terminal state.
type ContainersClientRefreshPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ContainersClientRefreshPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ContainersClientRefreshPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ContainersClientRefreshPoller) Result(ctx context.Context) (resp ContainersClientRefreshResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ContainersClientRefreshPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ContainersClientRefreshResponse, error) {
	result := ContainersClientRefreshResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ContainersClientRefreshPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ContainersClientRefreshPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ContainersClientRefreshPoller) Resume(token string, client *ContainersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ContainersClient.Refresh", token, client.pl)
	return
}

// DevicesClientCreateOrUpdateSecuritySettingsPoller provides polling facilities until the operation reaches a terminal state.
type DevicesClientCreateOrUpdateSecuritySettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesClientCreateOrUpdateSecuritySettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DevicesClientCreateOrUpdateSecuritySettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DevicesClientCreateOrUpdateSecuritySettingsPoller) Result(ctx context.Context) (resp DevicesClientCreateOrUpdateSecuritySettingsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DevicesClientCreateOrUpdateSecuritySettingsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientCreateOrUpdateSecuritySettingsResponse, error) {
	result := DevicesClientCreateOrUpdateSecuritySettingsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DevicesClientCreateOrUpdateSecuritySettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DevicesClientCreateOrUpdateSecuritySettingsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DevicesClientCreateOrUpdateSecuritySettingsPoller) Resume(token string, client *DevicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DevicesClient.CreateOrUpdateSecuritySettings", token, client.pl)
	return
}

// DevicesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DevicesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DevicesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DevicesClientDeletePoller) Result(ctx context.Context) (resp DevicesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DevicesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientDeleteResponse, error) {
	result := DevicesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DevicesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DevicesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DevicesClientDeletePoller) Resume(token string, client *DevicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DevicesClient.Delete", token, client.pl)
	return
}

// DevicesClientDownloadUpdatesPoller provides polling facilities until the operation reaches a terminal state.
type DevicesClientDownloadUpdatesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesClientDownloadUpdatesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DevicesClientDownloadUpdatesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DevicesClientDownloadUpdatesPoller) Result(ctx context.Context) (resp DevicesClientDownloadUpdatesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DevicesClientDownloadUpdatesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientDownloadUpdatesResponse, error) {
	result := DevicesClientDownloadUpdatesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DevicesClientDownloadUpdatesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DevicesClientDownloadUpdatesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DevicesClientDownloadUpdatesPoller) Resume(token string, client *DevicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DevicesClient.DownloadUpdates", token, client.pl)
	return
}

// DevicesClientInstallUpdatesPoller provides polling facilities until the operation reaches a terminal state.
type DevicesClientInstallUpdatesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesClientInstallUpdatesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DevicesClientInstallUpdatesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DevicesClientInstallUpdatesPoller) Result(ctx context.Context) (resp DevicesClientInstallUpdatesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DevicesClientInstallUpdatesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientInstallUpdatesResponse, error) {
	result := DevicesClientInstallUpdatesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DevicesClientInstallUpdatesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DevicesClientInstallUpdatesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DevicesClientInstallUpdatesPoller) Resume(token string, client *DevicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DevicesClient.InstallUpdates", token, client.pl)
	return
}

// DevicesClientScanForUpdatesPoller provides polling facilities until the operation reaches a terminal state.
type DevicesClientScanForUpdatesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesClientScanForUpdatesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DevicesClientScanForUpdatesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DevicesClientScanForUpdatesPoller) Result(ctx context.Context) (resp DevicesClientScanForUpdatesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DevicesClientScanForUpdatesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DevicesClientScanForUpdatesResponse, error) {
	result := DevicesClientScanForUpdatesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DevicesClientScanForUpdatesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DevicesClientScanForUpdatesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DevicesClientScanForUpdatesPoller) Resume(token string, client *DevicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DevicesClient.ScanForUpdates", token, client.pl)
	return
}

// DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller provides polling facilities until the operation reaches a terminal state.
type DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller) Result(ctx context.Context) (resp DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse, error) {
	result := DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DiagnosticSettingsClientUpdateDiagnosticProactiveLogCollectionSettingsPoller) Resume(token string, client *DiagnosticSettingsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DiagnosticSettingsClient.UpdateDiagnosticProactiveLogCollectionSettings", token, client.pl)
	return
}

// DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller provides polling facilities until the operation reaches a terminal state.
type DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller) Result(ctx context.Context) (resp DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse, error) {
	result := DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DiagnosticSettingsClientUpdateDiagnosticRemoteSupportSettingsPoller) Resume(token string, client *DiagnosticSettingsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DiagnosticSettingsClient.UpdateDiagnosticRemoteSupportSettings", token, client.pl)
	return
}

// MonitoringConfigClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type MonitoringConfigClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MonitoringConfigClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *MonitoringConfigClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *MonitoringConfigClientCreateOrUpdatePoller) Result(ctx context.Context) (resp MonitoringConfigClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *MonitoringConfigClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringConfigClientCreateOrUpdateResponse, error) {
	result := MonitoringConfigClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.MonitoringMetricConfiguration)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *MonitoringConfigClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a MonitoringConfigClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *MonitoringConfigClientCreateOrUpdatePoller) Resume(token string, client *MonitoringConfigClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("MonitoringConfigClient.CreateOrUpdate", token, client.pl)
	return
}

// MonitoringConfigClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type MonitoringConfigClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *MonitoringConfigClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *MonitoringConfigClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *MonitoringConfigClientDeletePoller) Result(ctx context.Context) (resp MonitoringConfigClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *MonitoringConfigClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (MonitoringConfigClientDeleteResponse, error) {
	result := MonitoringConfigClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *MonitoringConfigClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a MonitoringConfigClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *MonitoringConfigClientDeletePoller) Resume(token string, client *MonitoringConfigClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("MonitoringConfigClient.Delete", token, client.pl)
	return
}

// OrdersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type OrdersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OrdersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *OrdersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *OrdersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp OrdersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *OrdersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (OrdersClientCreateOrUpdateResponse, error) {
	result := OrdersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Order)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *OrdersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a OrdersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *OrdersClientCreateOrUpdatePoller) Resume(token string, client *OrdersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("OrdersClient.CreateOrUpdate", token, client.pl)
	return
}

// OrdersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type OrdersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *OrdersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *OrdersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *OrdersClientDeletePoller) Result(ctx context.Context) (resp OrdersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *OrdersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (OrdersClientDeleteResponse, error) {
	result := OrdersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *OrdersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a OrdersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *OrdersClientDeletePoller) Resume(token string, client *OrdersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("OrdersClient.Delete", token, client.pl)
	return
}

// RolesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RolesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RolesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RolesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RolesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp RolesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RolesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RolesClientCreateOrUpdateResponse, error) {
	result := RolesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RolesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RolesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RolesClientCreateOrUpdatePoller) Resume(token string, client *RolesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RolesClient.CreateOrUpdate", token, client.pl)
	return
}

// RolesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RolesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RolesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RolesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RolesClientDeletePoller) Result(ctx context.Context) (resp RolesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RolesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RolesClientDeleteResponse, error) {
	result := RolesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RolesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RolesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RolesClientDeletePoller) Resume(token string, client *RolesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RolesClient.Delete", token, client.pl)
	return
}

// SharesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SharesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SharesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SharesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SharesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp SharesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SharesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SharesClientCreateOrUpdateResponse, error) {
	result := SharesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Share)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SharesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SharesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SharesClientCreateOrUpdatePoller) Resume(token string, client *SharesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SharesClient.CreateOrUpdate", token, client.pl)
	return
}

// SharesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SharesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SharesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SharesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SharesClientDeletePoller) Result(ctx context.Context) (resp SharesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SharesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SharesClientDeleteResponse, error) {
	result := SharesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SharesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SharesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SharesClientDeletePoller) Resume(token string, client *SharesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SharesClient.Delete", token, client.pl)
	return
}

// SharesClientRefreshPoller provides polling facilities until the operation reaches a terminal state.
type SharesClientRefreshPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SharesClientRefreshPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SharesClientRefreshPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SharesClientRefreshPoller) Result(ctx context.Context) (resp SharesClientRefreshResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SharesClientRefreshPoller) PollUntilDone(ctx context.Context, freq time.Duration) (SharesClientRefreshResponse, error) {
	result := SharesClientRefreshResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SharesClientRefreshPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SharesClientRefreshPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SharesClientRefreshPoller) Resume(token string, client *SharesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SharesClient.Refresh", token, client.pl)
	return
}

// StorageAccountCredentialsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type StorageAccountCredentialsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StorageAccountCredentialsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *StorageAccountCredentialsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *StorageAccountCredentialsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp StorageAccountCredentialsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *StorageAccountCredentialsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountCredentialsClientCreateOrUpdateResponse, error) {
	result := StorageAccountCredentialsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.StorageAccountCredential)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *StorageAccountCredentialsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a StorageAccountCredentialsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *StorageAccountCredentialsClientCreateOrUpdatePoller) Resume(token string, client *StorageAccountCredentialsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("StorageAccountCredentialsClient.CreateOrUpdate", token, client.pl)
	return
}

// StorageAccountCredentialsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type StorageAccountCredentialsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StorageAccountCredentialsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *StorageAccountCredentialsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *StorageAccountCredentialsClientDeletePoller) Result(ctx context.Context) (resp StorageAccountCredentialsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *StorageAccountCredentialsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountCredentialsClientDeleteResponse, error) {
	result := StorageAccountCredentialsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *StorageAccountCredentialsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a StorageAccountCredentialsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *StorageAccountCredentialsClientDeletePoller) Resume(token string, client *StorageAccountCredentialsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("StorageAccountCredentialsClient.Delete", token, client.pl)
	return
}

// StorageAccountsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type StorageAccountsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StorageAccountsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *StorageAccountsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *StorageAccountsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp StorageAccountsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *StorageAccountsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountsClientCreateOrUpdateResponse, error) {
	result := StorageAccountsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.StorageAccount)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *StorageAccountsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a StorageAccountsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *StorageAccountsClientCreateOrUpdatePoller) Resume(token string, client *StorageAccountsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("StorageAccountsClient.CreateOrUpdate", token, client.pl)
	return
}

// StorageAccountsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type StorageAccountsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StorageAccountsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *StorageAccountsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *StorageAccountsClientDeletePoller) Result(ctx context.Context) (resp StorageAccountsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *StorageAccountsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (StorageAccountsClientDeleteResponse, error) {
	result := StorageAccountsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *StorageAccountsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a StorageAccountsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *StorageAccountsClientDeletePoller) Resume(token string, client *StorageAccountsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("StorageAccountsClient.Delete", token, client.pl)
	return
}

// SupportPackagesClientTriggerSupportPackagePoller provides polling facilities until the operation reaches a terminal state.
type SupportPackagesClientTriggerSupportPackagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SupportPackagesClientTriggerSupportPackagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SupportPackagesClientTriggerSupportPackagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SupportPackagesClientTriggerSupportPackagePoller) Result(ctx context.Context) (resp SupportPackagesClientTriggerSupportPackageResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SupportPackagesClientTriggerSupportPackagePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SupportPackagesClientTriggerSupportPackageResponse, error) {
	result := SupportPackagesClientTriggerSupportPackageResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SupportPackagesClientTriggerSupportPackagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SupportPackagesClientTriggerSupportPackagePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SupportPackagesClientTriggerSupportPackagePoller) Resume(token string, client *SupportPackagesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SupportPackagesClient.TriggerSupportPackage", token, client.pl)
	return
}

// TriggersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type TriggersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *TriggersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *TriggersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp TriggersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *TriggersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (TriggersClientCreateOrUpdateResponse, error) {
	result := TriggersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *TriggersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a TriggersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *TriggersClientCreateOrUpdatePoller) Resume(token string, client *TriggersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("TriggersClient.CreateOrUpdate", token, client.pl)
	return
}

// TriggersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type TriggersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *TriggersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *TriggersClientDeletePoller) Result(ctx context.Context) (resp TriggersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *TriggersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (TriggersClientDeleteResponse, error) {
	result := TriggersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *TriggersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a TriggersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *TriggersClientDeletePoller) Resume(token string, client *TriggersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("TriggersClient.Delete", token, client.pl)
	return
}

// UsersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type UsersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *UsersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *UsersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *UsersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp UsersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *UsersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (UsersClientCreateOrUpdateResponse, error) {
	result := UsersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.User)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *UsersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a UsersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *UsersClientCreateOrUpdatePoller) Resume(token string, client *UsersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("UsersClient.CreateOrUpdate", token, client.pl)
	return
}

// UsersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type UsersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *UsersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *UsersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *UsersClientDeletePoller) Result(ctx context.Context) (resp UsersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *UsersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (UsersClientDeleteResponse, error) {
	result := UsersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *UsersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a UsersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *UsersClientDeletePoller) Resume(token string, client *UsersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("UsersClient.Delete", token, client.pl)
	return
}
