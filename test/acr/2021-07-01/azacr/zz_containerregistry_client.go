//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azacr

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

type containerRegistryClient struct {
	endpoint   string
	apiVersion *string
	pl         runtime.Pipeline
}

// newContainerRegistryClient creates a new instance of containerRegistryClient with the specified values.
//   - endpoint - Registry login URL
//   - apiVersion - Api Version. Specifying any value will set the value to 2021-07-01.
//   - pl - the pipeline used for sending requests and handling responses.
func newContainerRegistryClient(endpoint string, apiVersion *string, pl runtime.Pipeline) *containerRegistryClient {
	client := &containerRegistryClient{
		endpoint:   endpoint,
		apiVersion: apiVersion,
		pl:         pl,
	}
	return client
}

// CheckDockerV2Support - Tells whether this Docker Registry instance supports Docker Registry HTTP API v2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - options - ContainerRegistryClientCheckDockerV2SupportOptions contains the optional parameters for the containerRegistryClient.CheckDockerV2Support
//     method.
func (client *containerRegistryClient) CheckDockerV2Support(ctx context.Context, options *ContainerRegistryClientCheckDockerV2SupportOptions) (ContainerRegistryClientCheckDockerV2SupportResponse, error) {
	req, err := client.checkDockerV2SupportCreateRequest(ctx, options)
	if err != nil {
		return ContainerRegistryClientCheckDockerV2SupportResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientCheckDockerV2SupportResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientCheckDockerV2SupportResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientCheckDockerV2SupportResponse{}, nil
}

// checkDockerV2SupportCreateRequest creates the CheckDockerV2Support request.
func (client *containerRegistryClient) checkDockerV2SupportCreateRequest(ctx context.Context, options *ContainerRegistryClientCheckDockerV2SupportOptions) (*policy.Request, error) {
	urlPath := "/v2/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CreateManifest - Put the manifest identified by name and reference where reference can be a tag or digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - A tag or a digest, pointing to a specific image
//   - payload - Manifest body, can take v1 or v2 values depending on accept header
//   - options - ContainerRegistryClientCreateManifestOptions contains the optional parameters for the containerRegistryClient.CreateManifest
//     method.
func (client *containerRegistryClient) CreateManifest(ctx context.Context, name string, reference string, payload Manifest, options *ContainerRegistryClientCreateManifestOptions) (ContainerRegistryClientCreateManifestResponse, error) {
	req, err := client.createManifestCreateRequest(ctx, name, reference, payload, options)
	if err != nil {
		return ContainerRegistryClientCreateManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientCreateManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ContainerRegistryClientCreateManifestResponse{}, runtime.NewResponseError(resp)
	}
	return client.createManifestHandleResponse(resp)
}

// createManifestCreateRequest creates the CreateManifest request.
func (client *containerRegistryClient) createManifestCreateRequest(ctx context.Context, name string, reference string, payload Manifest, options *ContainerRegistryClientCreateManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, payload)
}

// createManifestHandleResponse handles the CreateManifest response.
func (client *containerRegistryClient) createManifestHandleResponse(resp *http.Response) (ContainerRegistryClientCreateManifestResponse, error) {
	result := ContainerRegistryClientCreateManifestResponse{}
	if val := resp.Header.Get("Docker-Content-Digest"); val != "" {
		result.DockerContentDigest = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return ContainerRegistryClientCreateManifestResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Interface); err != nil {
		return ContainerRegistryClientCreateManifestResponse{}, err
	}
	return result, nil
}

// DeleteManifest - Delete the manifest identified by name and reference. Note that a manifest can only be deleted by digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Digest of a BLOB
//   - options - ContainerRegistryClientDeleteManifestOptions contains the optional parameters for the containerRegistryClient.DeleteManifest
//     method.
func (client *containerRegistryClient) DeleteManifest(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteManifestOptions) (ContainerRegistryClientDeleteManifestResponse, error) {
	req, err := client.deleteManifestCreateRequest(ctx, name, reference, options)
	if err != nil {
		return ContainerRegistryClientDeleteManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientDeleteManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		return ContainerRegistryClientDeleteManifestResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientDeleteManifestResponse{}, nil
}

// deleteManifestCreateRequest creates the DeleteManifest request.
func (client *containerRegistryClient) deleteManifestCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteRepository - Delete the repository identified by name
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientDeleteRepositoryOptions contains the optional parameters for the containerRegistryClient.DeleteRepository
//     method.
func (client *containerRegistryClient) DeleteRepository(ctx context.Context, name string, options *ContainerRegistryClientDeleteRepositoryOptions) (ContainerRegistryClientDeleteRepositoryResponse, error) {
	req, err := client.deleteRepositoryCreateRequest(ctx, name, options)
	if err != nil {
		return ContainerRegistryClientDeleteRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientDeleteRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		return ContainerRegistryClientDeleteRepositoryResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteRepositoryHandleResponse(resp)
}

// deleteRepositoryCreateRequest creates the DeleteRepository request.
func (client *containerRegistryClient) deleteRepositoryCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientDeleteRepositoryOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteRepositoryHandleResponse handles the DeleteRepository response.
func (client *containerRegistryClient) deleteRepositoryHandleResponse(resp *http.Response) (ContainerRegistryClientDeleteRepositoryResponse, error) {
	result := ContainerRegistryClientDeleteRepositoryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeleteRepositoryResult); err != nil {
		return ContainerRegistryClientDeleteRepositoryResponse{}, err
	}
	return result, nil
}

// DeleteTag - Delete tag
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Tag name
//   - options - ContainerRegistryClientDeleteTagOptions contains the optional parameters for the containerRegistryClient.DeleteTag
//     method.
func (client *containerRegistryClient) DeleteTag(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteTagOptions) (ContainerRegistryClientDeleteTagResponse, error) {
	req, err := client.deleteTagCreateRequest(ctx, name, reference, options)
	if err != nil {
		return ContainerRegistryClientDeleteTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientDeleteTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		return ContainerRegistryClientDeleteTagResponse{}, runtime.NewResponseError(resp)
	}
	return ContainerRegistryClientDeleteTagResponse{}, nil
}

// deleteTagCreateRequest creates the DeleteTag request.
func (client *containerRegistryClient) deleteTagCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteTagOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetManifest - Get the manifest identified by name and reference where reference can be a tag or digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - A tag or a digest, pointing to a specific image
//   - options - ContainerRegistryClientGetManifestOptions contains the optional parameters for the containerRegistryClient.GetManifest
//     method.
func (client *containerRegistryClient) GetManifest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetManifestOptions) (ContainerRegistryClientGetManifestResponse, error) {
	req, err := client.getManifestCreateRequest(ctx, name, reference, options)
	if err != nil {
		return ContainerRegistryClientGetManifestResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetManifestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetManifestResponse{}, runtime.NewResponseError(resp)
	}
	return client.getManifestHandleResponse(resp)
}

// getManifestCreateRequest creates the GetManifest request.
func (client *containerRegistryClient) getManifestCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.Accept != nil {
		req.Raw().Header["accept"] = []string{*options.Accept}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestHandleResponse handles the GetManifest response.
func (client *containerRegistryClient) getManifestHandleResponse(resp *http.Response) (ContainerRegistryClientGetManifestResponse, error) {
	result := ContainerRegistryClientGetManifestResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManifestWrapper); err != nil {
		return ContainerRegistryClientGetManifestResponse{}, err
	}
	return result, nil
}

// GetManifestProperties - Get manifest attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - options - ContainerRegistryClientGetManifestPropertiesOptions contains the optional parameters for the containerRegistryClient.GetManifestProperties
//     method.
func (client *containerRegistryClient) GetManifestProperties(ctx context.Context, name string, digest string, options *ContainerRegistryClientGetManifestPropertiesOptions) (ContainerRegistryClientGetManifestPropertiesResponse, error) {
	req, err := client.getManifestPropertiesCreateRequest(ctx, name, digest, options)
	if err != nil {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getManifestPropertiesHandleResponse(resp)
}

// getManifestPropertiesCreateRequest creates the GetManifestProperties request.
func (client *containerRegistryClient) getManifestPropertiesCreateRequest(ctx context.Context, name string, digest string, options *ContainerRegistryClientGetManifestPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests/{digest}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{digest}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestPropertiesHandleResponse handles the GetManifestProperties response.
func (client *containerRegistryClient) getManifestPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientGetManifestPropertiesResponse, error) {
	result := ContainerRegistryClientGetManifestPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactManifestProperties); err != nil {
		return ContainerRegistryClientGetManifestPropertiesResponse{}, err
	}
	return result, nil
}

// NewGetManifestsPager - List manifests of a repository
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetManifestsOptions contains the optional parameters for the containerRegistryClient.GetManifests
//     method.
func (client *containerRegistryClient) NewGetManifestsPager(name string, options *ContainerRegistryClientGetManifestsOptions) *runtime.Pager[ContainerRegistryClientGetManifestsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientGetManifestsResponse]{
		More: func(page ContainerRegistryClientGetManifestsResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientGetManifestsResponse) (ContainerRegistryClientGetManifestsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getManifestsCreateRequest(ctx, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return ContainerRegistryClientGetManifestsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ContainerRegistryClientGetManifestsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ContainerRegistryClientGetManifestsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getManifestsHandleResponse(resp)
		},
	})
}

// getManifestsCreateRequest creates the GetManifests request.
func (client *containerRegistryClient) getManifestsCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetManifestsOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if options != nil && options.Orderby != nil {
		reqQP.Set("orderby", *options.Orderby)
	}
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestsHandleResponse handles the GetManifests response.
func (client *containerRegistryClient) getManifestsHandleResponse(resp *http.Response) (ContainerRegistryClientGetManifestsResponse, error) {
	result := ContainerRegistryClientGetManifestsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Manifests); err != nil {
		return ContainerRegistryClientGetManifestsResponse{}, err
	}
	return result, nil
}

// GetProperties - Get repository attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetPropertiesOptions contains the optional parameters for the containerRegistryClient.GetProperties
//     method.
func (client *containerRegistryClient) GetProperties(ctx context.Context, name string, options *ContainerRegistryClientGetPropertiesOptions) (ContainerRegistryClientGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, name, options)
	if err != nil {
		return ContainerRegistryClientGetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *containerRegistryClient) getPropertiesCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *containerRegistryClient) getPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientGetPropertiesResponse, error) {
	result := ContainerRegistryClientGetPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContainerRepositoryProperties); err != nil {
		return ContainerRegistryClientGetPropertiesResponse{}, err
	}
	return result, nil
}

// NewGetRepositoriesPager - List repositories
//
// Generated from API version 2021-07-01
//   - options - ContainerRegistryClientGetRepositoriesOptions contains the optional parameters for the containerRegistryClient.GetRepositories
//     method.
func (client *containerRegistryClient) NewGetRepositoriesPager(options *ContainerRegistryClientGetRepositoriesOptions) *runtime.Pager[ContainerRegistryClientGetRepositoriesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientGetRepositoriesResponse]{
		More: func(page ContainerRegistryClientGetRepositoriesResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientGetRepositoriesResponse) (ContainerRegistryClientGetRepositoriesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getRepositoriesCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return ContainerRegistryClientGetRepositoriesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ContainerRegistryClientGetRepositoriesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ContainerRegistryClientGetRepositoriesResponse{}, runtime.NewResponseError(resp)
			}
			return client.getRepositoriesHandleResponse(resp)
		},
	})
}

// getRepositoriesCreateRequest creates the GetRepositories request.
func (client *containerRegistryClient) getRepositoriesCreateRequest(ctx context.Context, options *ContainerRegistryClientGetRepositoriesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/_catalog"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRepositoriesHandleResponse handles the GetRepositories response.
func (client *containerRegistryClient) getRepositoriesHandleResponse(resp *http.Response) (ContainerRegistryClientGetRepositoriesResponse, error) {
	result := ContainerRegistryClientGetRepositoriesResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.Repositories); err != nil {
		return ContainerRegistryClientGetRepositoriesResponse{}, err
	}
	return result, nil
}

// GetTagProperties - Get tag attributes by tag
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Tag name
//   - options - ContainerRegistryClientGetTagPropertiesOptions contains the optional parameters for the containerRegistryClient.GetTagProperties
//     method.
func (client *containerRegistryClient) GetTagProperties(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetTagPropertiesOptions) (ContainerRegistryClientGetTagPropertiesResponse, error) {
	req, err := client.getTagPropertiesCreateRequest(ctx, name, reference, options)
	if err != nil {
		return ContainerRegistryClientGetTagPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientGetTagPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientGetTagPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTagPropertiesHandleResponse(resp)
}

// getTagPropertiesCreateRequest creates the GetTagProperties request.
func (client *containerRegistryClient) getTagPropertiesCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetTagPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTagPropertiesHandleResponse handles the GetTagProperties response.
func (client *containerRegistryClient) getTagPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientGetTagPropertiesResponse, error) {
	result := ContainerRegistryClientGetTagPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactTagProperties); err != nil {
		return ContainerRegistryClientGetTagPropertiesResponse{}, err
	}
	return result, nil
}

// NewGetTagsPager - List tags of a repository
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetTagsOptions contains the optional parameters for the containerRegistryClient.GetTags
//     method.
func (client *containerRegistryClient) NewGetTagsPager(name string, options *ContainerRegistryClientGetTagsOptions) *runtime.Pager[ContainerRegistryClientGetTagsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientGetTagsResponse]{
		More: func(page ContainerRegistryClientGetTagsResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientGetTagsResponse) (ContainerRegistryClientGetTagsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getTagsCreateRequest(ctx, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return ContainerRegistryClientGetTagsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ContainerRegistryClientGetTagsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ContainerRegistryClientGetTagsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getTagsHandleResponse(resp)
		},
	})
}

// getTagsCreateRequest creates the GetTags request.
func (client *containerRegistryClient) getTagsCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetTagsOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if options != nil && options.Orderby != nil {
		reqQP.Set("orderby", *options.Orderby)
	}
	if options != nil && options.Digest != nil {
		reqQP.Set("digest", *options.Digest)
	}
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTagsHandleResponse handles the GetTags response.
func (client *containerRegistryClient) getTagsHandleResponse(resp *http.Response) (ContainerRegistryClientGetTagsResponse, error) {
	result := ContainerRegistryClientGetTagsResponse{}
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.TagList); err != nil {
		return ContainerRegistryClientGetTagsResponse{}, err
	}
	return result, nil
}

// UpdateManifestProperties - Update properties of a manifest
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - value - Manifest attribute value
//   - options - ContainerRegistryClientUpdateManifestPropertiesOptions contains the optional parameters for the containerRegistryClient.UpdateManifestProperties
//     method.
func (client *containerRegistryClient) UpdateManifestProperties(ctx context.Context, name string, digest string, value ManifestWriteableProperties, options *ContainerRegistryClientUpdateManifestPropertiesOptions) (ContainerRegistryClientUpdateManifestPropertiesResponse, error) {
	req, err := client.updateManifestPropertiesCreateRequest(ctx, name, digest, value, options)
	if err != nil {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateManifestPropertiesHandleResponse(resp)
}

// updateManifestPropertiesCreateRequest creates the UpdateManifestProperties request.
func (client *containerRegistryClient) updateManifestPropertiesCreateRequest(ctx context.Context, name string, digest string, value ManifestWriteableProperties, options *ContainerRegistryClientUpdateManifestPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests/{digest}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{digest}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, value)
}

// updateManifestPropertiesHandleResponse handles the UpdateManifestProperties response.
func (client *containerRegistryClient) updateManifestPropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientUpdateManifestPropertiesResponse, error) {
	result := ContainerRegistryClientUpdateManifestPropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactManifestProperties); err != nil {
		return ContainerRegistryClientUpdateManifestPropertiesResponse{}, err
	}
	return result, nil
}

// UpdateProperties - Update the attribute identified by name where reference is the name of the repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - value - Repository attribute value
//   - options - ContainerRegistryClientUpdatePropertiesOptions contains the optional parameters for the containerRegistryClient.UpdateProperties
//     method.
func (client *containerRegistryClient) UpdateProperties(ctx context.Context, name string, value RepositoryWriteableProperties, options *ContainerRegistryClientUpdatePropertiesOptions) (ContainerRegistryClientUpdatePropertiesResponse, error) {
	req, err := client.updatePropertiesCreateRequest(ctx, name, value, options)
	if err != nil {
		return ContainerRegistryClientUpdatePropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUpdatePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientUpdatePropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updatePropertiesHandleResponse(resp)
}

// updatePropertiesCreateRequest creates the UpdateProperties request.
func (client *containerRegistryClient) updatePropertiesCreateRequest(ctx context.Context, name string, value RepositoryWriteableProperties, options *ContainerRegistryClientUpdatePropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, value)
}

// updatePropertiesHandleResponse handles the UpdateProperties response.
func (client *containerRegistryClient) updatePropertiesHandleResponse(resp *http.Response) (ContainerRegistryClientUpdatePropertiesResponse, error) {
	result := ContainerRegistryClientUpdatePropertiesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContainerRepositoryProperties); err != nil {
		return ContainerRegistryClientUpdatePropertiesResponse{}, err
	}
	return result, nil
}

// UpdateTagAttributes - Update tag attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Tag name
//   - value - Tag attribute value
//   - options - ContainerRegistryClientUpdateTagAttributesOptions contains the optional parameters for the containerRegistryClient.UpdateTagAttributes
//     method.
func (client *containerRegistryClient) UpdateTagAttributes(ctx context.Context, name string, reference string, value TagWriteableProperties, options *ContainerRegistryClientUpdateTagAttributesOptions) (ContainerRegistryClientUpdateTagAttributesResponse, error) {
	req, err := client.updateTagAttributesCreateRequest(ctx, name, reference, value, options)
	if err != nil {
		return ContainerRegistryClientUpdateTagAttributesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ContainerRegistryClientUpdateTagAttributesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ContainerRegistryClientUpdateTagAttributesResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateTagAttributesHandleResponse(resp)
}

// updateTagAttributesCreateRequest creates the UpdateTagAttributes request.
func (client *containerRegistryClient) updateTagAttributesCreateRequest(ctx context.Context, name string, reference string, value TagWriteableProperties, options *ContainerRegistryClientUpdateTagAttributesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, value)
}

// updateTagAttributesHandleResponse handles the UpdateTagAttributes response.
func (client *containerRegistryClient) updateTagAttributesHandleResponse(resp *http.Response) (ContainerRegistryClientUpdateTagAttributesResponse, error) {
	result := ContainerRegistryClientUpdateTagAttributesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ArtifactTagProperties); err != nil {
		return ContainerRegistryClientUpdateTagAttributesResponse{}, err
	}
	return result, nil
}
