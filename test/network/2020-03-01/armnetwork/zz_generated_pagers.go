//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// ApplicationGatewaysClientListAllPager provides operations for iterating over paged responses.
type ApplicationGatewaysClientListAllPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ApplicationGatewaysClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ApplicationGatewaysClientListAllPager) NextPage(ctx context.Context) (ApplicationGatewaysClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ApplicationGatewaysClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ApplicationGatewaysClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ApplicationGatewaysClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ApplicationGatewaysClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return ApplicationGatewaysClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager provides operations for iterating over paged responses.
type ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayAvailableSSLPredefinedPolicies.NextLink == nil || len(*p.current.ApplicationGatewayAvailableSSLPredefinedPolicies.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesPager) NextPage(ctx context.Context) (ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAvailableSSLPredefinedPoliciesHandleResponse(resp)
	if err != nil {
		return ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ApplicationGatewaysClientListPager provides operations for iterating over paged responses.
type ApplicationGatewaysClientListPager struct {
	client    *ApplicationGatewaysClient
	current   ApplicationGatewaysClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationGatewaysClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ApplicationGatewaysClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationGatewayListResult.NextLink == nil || len(*p.current.ApplicationGatewayListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ApplicationGatewaysClientListPager) NextPage(ctx context.Context) (ApplicationGatewaysClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ApplicationGatewaysClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ApplicationGatewaysClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ApplicationGatewaysClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ApplicationGatewaysClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ApplicationGatewaysClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ApplicationSecurityGroupsClientListAllPager provides operations for iterating over paged responses.
type ApplicationSecurityGroupsClientListAllPager struct {
	client    *ApplicationSecurityGroupsClient
	current   ApplicationSecurityGroupsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationSecurityGroupsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ApplicationSecurityGroupsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ApplicationSecurityGroupsClientListAllPager) NextPage(ctx context.Context) (ApplicationSecurityGroupsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ApplicationSecurityGroupsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ApplicationSecurityGroupsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ApplicationSecurityGroupsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ApplicationSecurityGroupsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return ApplicationSecurityGroupsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ApplicationSecurityGroupsClientListPager provides operations for iterating over paged responses.
type ApplicationSecurityGroupsClientListPager struct {
	client    *ApplicationSecurityGroupsClient
	current   ApplicationSecurityGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ApplicationSecurityGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ApplicationSecurityGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ApplicationSecurityGroupListResult.NextLink == nil || len(*p.current.ApplicationSecurityGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ApplicationSecurityGroupsClientListPager) NextPage(ctx context.Context) (ApplicationSecurityGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ApplicationSecurityGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ApplicationSecurityGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ApplicationSecurityGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ApplicationSecurityGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ApplicationSecurityGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailableDelegationsClientListPager provides operations for iterating over paged responses.
type AvailableDelegationsClientListPager struct {
	client    *AvailableDelegationsClient
	current   AvailableDelegationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableDelegationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailableDelegationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailableDelegationsClientListPager) NextPage(ctx context.Context) (AvailableDelegationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailableDelegationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailableDelegationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailableDelegationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailableDelegationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailableDelegationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailableEndpointServicesClientListPager provides operations for iterating over paged responses.
type AvailableEndpointServicesClientListPager struct {
	client    *AvailableEndpointServicesClient
	current   AvailableEndpointServicesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableEndpointServicesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailableEndpointServicesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EndpointServicesListResult.NextLink == nil || len(*p.current.EndpointServicesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailableEndpointServicesClientListPager) NextPage(ctx context.Context) (AvailableEndpointServicesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailableEndpointServicesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailableEndpointServicesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailableEndpointServicesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailableEndpointServicesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailableEndpointServicesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailablePrivateEndpointTypesClientListByResourceGroupPager provides operations for iterating over paged responses.
type AvailablePrivateEndpointTypesClientListByResourceGroupPager struct {
	client    *AvailablePrivateEndpointTypesClient
	current   AvailablePrivateEndpointTypesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailablePrivateEndpointTypesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailablePrivateEndpointTypesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailablePrivateEndpointTypesClientListByResourceGroupPager) NextPage(ctx context.Context) (AvailablePrivateEndpointTypesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailablePrivateEndpointTypesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailablePrivateEndpointTypesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailablePrivateEndpointTypesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailablePrivateEndpointTypesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return AvailablePrivateEndpointTypesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailablePrivateEndpointTypesClientListPager provides operations for iterating over paged responses.
type AvailablePrivateEndpointTypesClientListPager struct {
	client    *AvailablePrivateEndpointTypesClient
	current   AvailablePrivateEndpointTypesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailablePrivateEndpointTypesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailablePrivateEndpointTypesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailablePrivateEndpointTypesResult.NextLink == nil || len(*p.current.AvailablePrivateEndpointTypesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailablePrivateEndpointTypesClientListPager) NextPage(ctx context.Context) (AvailablePrivateEndpointTypesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailablePrivateEndpointTypesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailablePrivateEndpointTypesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailablePrivateEndpointTypesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailablePrivateEndpointTypesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailablePrivateEndpointTypesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailableResourceGroupDelegationsClientListPager provides operations for iterating over paged responses.
type AvailableResourceGroupDelegationsClientListPager struct {
	client    *AvailableResourceGroupDelegationsClient
	current   AvailableResourceGroupDelegationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableResourceGroupDelegationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailableResourceGroupDelegationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableDelegationsResult.NextLink == nil || len(*p.current.AvailableDelegationsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailableResourceGroupDelegationsClientListPager) NextPage(ctx context.Context) (AvailableResourceGroupDelegationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailableResourceGroupDelegationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailableResourceGroupDelegationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailableResourceGroupDelegationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailableResourceGroupDelegationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailableResourceGroupDelegationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailableServiceAliasesClientListByResourceGroupPager provides operations for iterating over paged responses.
type AvailableServiceAliasesClientListByResourceGroupPager struct {
	client    *AvailableServiceAliasesClient
	current   AvailableServiceAliasesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableServiceAliasesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailableServiceAliasesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailableServiceAliasesClientListByResourceGroupPager) NextPage(ctx context.Context) (AvailableServiceAliasesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailableServiceAliasesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailableServiceAliasesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailableServiceAliasesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailableServiceAliasesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return AvailableServiceAliasesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailableServiceAliasesClientListPager provides operations for iterating over paged responses.
type AvailableServiceAliasesClientListPager struct {
	client    *AvailableServiceAliasesClient
	current   AvailableServiceAliasesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableServiceAliasesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailableServiceAliasesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableServiceAliasesResult.NextLink == nil || len(*p.current.AvailableServiceAliasesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailableServiceAliasesClientListPager) NextPage(ctx context.Context) (AvailableServiceAliasesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailableServiceAliasesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailableServiceAliasesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailableServiceAliasesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailableServiceAliasesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailableServiceAliasesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AzureFirewallFqdnTagsClientListAllPager provides operations for iterating over paged responses.
type AzureFirewallFqdnTagsClientListAllPager struct {
	client    *AzureFirewallFqdnTagsClient
	current   AzureFirewallFqdnTagsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallFqdnTagsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AzureFirewallFqdnTagsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallFqdnTagListResult.NextLink == nil || len(*p.current.AzureFirewallFqdnTagListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AzureFirewallFqdnTagsClientListAllPager) NextPage(ctx context.Context) (AzureFirewallFqdnTagsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AzureFirewallFqdnTagsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AzureFirewallFqdnTagsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AzureFirewallFqdnTagsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AzureFirewallFqdnTagsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return AzureFirewallFqdnTagsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AzureFirewallsClientListAllPager provides operations for iterating over paged responses.
type AzureFirewallsClientListAllPager struct {
	client    *AzureFirewallsClient
	current   AzureFirewallsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AzureFirewallsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AzureFirewallsClientListAllPager) NextPage(ctx context.Context) (AzureFirewallsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AzureFirewallsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AzureFirewallsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AzureFirewallsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AzureFirewallsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return AzureFirewallsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AzureFirewallsClientListPager provides operations for iterating over paged responses.
type AzureFirewallsClientListPager struct {
	client    *AzureFirewallsClient
	current   AzureFirewallsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AzureFirewallsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AzureFirewallsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AzureFirewallListResult.NextLink == nil || len(*p.current.AzureFirewallListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AzureFirewallsClientListPager) NextPage(ctx context.Context) (AzureFirewallsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AzureFirewallsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AzureFirewallsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AzureFirewallsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AzureFirewallsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AzureFirewallsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BastionHostsClientListByResourceGroupPager provides operations for iterating over paged responses.
type BastionHostsClientListByResourceGroupPager struct {
	client    *BastionHostsClient
	current   BastionHostsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BastionHostsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BastionHostsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BastionHostsClientListByResourceGroupPager) NextPage(ctx context.Context) (BastionHostsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BastionHostsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BastionHostsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BastionHostsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BastionHostsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return BastionHostsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BastionHostsClientListPager provides operations for iterating over paged responses.
type BastionHostsClientListPager struct {
	client    *BastionHostsClient
	current   BastionHostsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BastionHostsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BastionHostsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionHostListResult.NextLink == nil || len(*p.current.BastionHostListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BastionHostsClientListPager) NextPage(ctx context.Context) (BastionHostsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BastionHostsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BastionHostsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BastionHostsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BastionHostsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BastionHostsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BgpServiceCommunitiesClientListPager provides operations for iterating over paged responses.
type BgpServiceCommunitiesClientListPager struct {
	client    *BgpServiceCommunitiesClient
	current   BgpServiceCommunitiesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BgpServiceCommunitiesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BgpServiceCommunitiesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BgpServiceCommunityListResult.NextLink == nil || len(*p.current.BgpServiceCommunityListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BgpServiceCommunitiesClientListPager) NextPage(ctx context.Context) (BgpServiceCommunitiesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BgpServiceCommunitiesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BgpServiceCommunitiesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BgpServiceCommunitiesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BgpServiceCommunitiesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BgpServiceCommunitiesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DdosProtectionPlansClientListByResourceGroupPager provides operations for iterating over paged responses.
type DdosProtectionPlansClientListByResourceGroupPager struct {
	client    *DdosProtectionPlansClient
	current   DdosProtectionPlansClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DdosProtectionPlansClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DdosProtectionPlansClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DdosProtectionPlansClientListByResourceGroupPager) NextPage(ctx context.Context) (DdosProtectionPlansClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DdosProtectionPlansClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DdosProtectionPlansClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DdosProtectionPlansClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DdosProtectionPlansClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DdosProtectionPlansClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DdosProtectionPlansClientListPager provides operations for iterating over paged responses.
type DdosProtectionPlansClientListPager struct {
	client    *DdosProtectionPlansClient
	current   DdosProtectionPlansClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DdosProtectionPlansClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DdosProtectionPlansClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DdosProtectionPlanListResult.NextLink == nil || len(*p.current.DdosProtectionPlanListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DdosProtectionPlansClientListPager) NextPage(ctx context.Context) (DdosProtectionPlansClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DdosProtectionPlansClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DdosProtectionPlansClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DdosProtectionPlansClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DdosProtectionPlansClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DdosProtectionPlansClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DefaultSecurityRulesClientListPager provides operations for iterating over paged responses.
type DefaultSecurityRulesClientListPager struct {
	client    *DefaultSecurityRulesClient
	current   DefaultSecurityRulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DefaultSecurityRulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DefaultSecurityRulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DefaultSecurityRulesClientListPager) NextPage(ctx context.Context) (DefaultSecurityRulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DefaultSecurityRulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DefaultSecurityRulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DefaultSecurityRulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DefaultSecurityRulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DefaultSecurityRulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCircuitAuthorizationsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitAuthorizationsClientListPager struct {
	client    *ExpressRouteCircuitAuthorizationsClient
	current   ExpressRouteCircuitAuthorizationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitAuthorizationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCircuitAuthorizationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationListResult.NextLink == nil || len(*p.current.AuthorizationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCircuitAuthorizationsClientListPager) NextPage(ctx context.Context) (ExpressRouteCircuitAuthorizationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCircuitAuthorizationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCircuitAuthorizationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCircuitAuthorizationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCircuitConnectionsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitConnectionsClientListPager struct {
	client    *ExpressRouteCircuitConnectionsClient
	current   ExpressRouteCircuitConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCircuitConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCircuitConnectionsClientListPager) NextPage(ctx context.Context) (ExpressRouteCircuitConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCircuitConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCircuitConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCircuitConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCircuitConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteCircuitConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCircuitPeeringsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitPeeringsClientListPager struct {
	client    *ExpressRouteCircuitPeeringsClient
	current   ExpressRouteCircuitPeeringsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitPeeringsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCircuitPeeringsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitPeeringListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitPeeringListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCircuitPeeringsClientListPager) NextPage(ctx context.Context) (ExpressRouteCircuitPeeringsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCircuitPeeringsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCircuitPeeringsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCircuitPeeringsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCircuitPeeringsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteCircuitPeeringsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCircuitsClientListAllPager provides operations for iterating over paged responses.
type ExpressRouteCircuitsClientListAllPager struct {
	client    *ExpressRouteCircuitsClient
	current   ExpressRouteCircuitsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCircuitsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCircuitsClientListAllPager) NextPage(ctx context.Context) (ExpressRouteCircuitsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCircuitsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCircuitsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCircuitsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCircuitsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return ExpressRouteCircuitsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCircuitsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCircuitsClientListPager struct {
	client    *ExpressRouteCircuitsClient
	current   ExpressRouteCircuitsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCircuitsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCircuitsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCircuitListResult.NextLink == nil || len(*p.current.ExpressRouteCircuitListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCircuitsClientListPager) NextPage(ctx context.Context) (ExpressRouteCircuitsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCircuitsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCircuitsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCircuitsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCircuitsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteCircuitsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCrossConnectionPeeringsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionPeeringsClientListPager struct {
	client    *ExpressRouteCrossConnectionPeeringsClient
	current   ExpressRouteCrossConnectionPeeringsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionPeeringsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCrossConnectionPeeringsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionPeeringList.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionPeeringList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCrossConnectionPeeringsClientListPager) NextPage(ctx context.Context) (ExpressRouteCrossConnectionPeeringsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCrossConnectionPeeringsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCrossConnectionPeeringsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCrossConnectionsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionsClientListByResourceGroupPager struct {
	client    *ExpressRouteCrossConnectionsClient
	current   ExpressRouteCrossConnectionsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCrossConnectionsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCrossConnectionsClientListByResourceGroupPager) NextPage(ctx context.Context) (ExpressRouteCrossConnectionsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCrossConnectionsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCrossConnectionsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCrossConnectionsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCrossConnectionsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ExpressRouteCrossConnectionsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteCrossConnectionsClientListPager provides operations for iterating over paged responses.
type ExpressRouteCrossConnectionsClientListPager struct {
	client    *ExpressRouteCrossConnectionsClient
	current   ExpressRouteCrossConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteCrossConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteCrossConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteCrossConnectionListResult.NextLink == nil || len(*p.current.ExpressRouteCrossConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteCrossConnectionsClientListPager) NextPage(ctx context.Context) (ExpressRouteCrossConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteCrossConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteCrossConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteCrossConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteCrossConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteCrossConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteLinksClientListPager provides operations for iterating over paged responses.
type ExpressRouteLinksClientListPager struct {
	client    *ExpressRouteLinksClient
	current   ExpressRouteLinksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteLinksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteLinksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteLinkListResult.NextLink == nil || len(*p.current.ExpressRouteLinkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteLinksClientListPager) NextPage(ctx context.Context) (ExpressRouteLinksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteLinksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteLinksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteLinksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteLinksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteLinksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRoutePortsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ExpressRoutePortsClientListByResourceGroupPager struct {
	client    *ExpressRoutePortsClient
	current   ExpressRoutePortsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRoutePortsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRoutePortsClientListByResourceGroupPager) NextPage(ctx context.Context) (ExpressRoutePortsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRoutePortsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRoutePortsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRoutePortsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRoutePortsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ExpressRoutePortsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRoutePortsClientListPager provides operations for iterating over paged responses.
type ExpressRoutePortsClientListPager struct {
	client    *ExpressRoutePortsClient
	current   ExpressRoutePortsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRoutePortsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortListResult.NextLink == nil || len(*p.current.ExpressRoutePortListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRoutePortsClientListPager) NextPage(ctx context.Context) (ExpressRoutePortsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRoutePortsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRoutePortsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRoutePortsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRoutePortsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRoutePortsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRoutePortsLocationsClientListPager provides operations for iterating over paged responses.
type ExpressRoutePortsLocationsClientListPager struct {
	client    *ExpressRoutePortsLocationsClient
	current   ExpressRoutePortsLocationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRoutePortsLocationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRoutePortsLocationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRoutePortsLocationListResult.NextLink == nil || len(*p.current.ExpressRoutePortsLocationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRoutePortsLocationsClientListPager) NextPage(ctx context.Context) (ExpressRoutePortsLocationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRoutePortsLocationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRoutePortsLocationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRoutePortsLocationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRoutePortsLocationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRoutePortsLocationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExpressRouteServiceProvidersClientListPager provides operations for iterating over paged responses.
type ExpressRouteServiceProvidersClientListPager struct {
	client    *ExpressRouteServiceProvidersClient
	current   ExpressRouteServiceProvidersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExpressRouteServiceProvidersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExpressRouteServiceProvidersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteServiceProviderListResult.NextLink == nil || len(*p.current.ExpressRouteServiceProviderListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExpressRouteServiceProvidersClientListPager) NextPage(ctx context.Context) (ExpressRouteServiceProvidersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExpressRouteServiceProvidersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExpressRouteServiceProvidersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExpressRouteServiceProvidersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExpressRouteServiceProvidersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExpressRouteServiceProvidersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FirewallPoliciesClientListAllPager provides operations for iterating over paged responses.
type FirewallPoliciesClientListAllPager struct {
	client    *FirewallPoliciesClient
	current   FirewallPoliciesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPoliciesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FirewallPoliciesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *FirewallPoliciesClientListAllPager) NextPage(ctx context.Context) (FirewallPoliciesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return FirewallPoliciesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FirewallPoliciesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FirewallPoliciesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FirewallPoliciesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return FirewallPoliciesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FirewallPoliciesClientListPager provides operations for iterating over paged responses.
type FirewallPoliciesClientListPager struct {
	client    *FirewallPoliciesClient
	current   FirewallPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FirewallPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyListResult.NextLink == nil || len(*p.current.FirewallPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *FirewallPoliciesClientListPager) NextPage(ctx context.Context) (FirewallPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return FirewallPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FirewallPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FirewallPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FirewallPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return FirewallPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FirewallPolicyRuleGroupsClientListPager provides operations for iterating over paged responses.
type FirewallPolicyRuleGroupsClientListPager struct {
	client    *FirewallPolicyRuleGroupsClient
	current   FirewallPolicyRuleGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FirewallPolicyRuleGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FirewallPolicyRuleGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FirewallPolicyRuleGroupListResult.NextLink == nil || len(*p.current.FirewallPolicyRuleGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *FirewallPolicyRuleGroupsClientListPager) NextPage(ctx context.Context) (FirewallPolicyRuleGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return FirewallPolicyRuleGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FirewallPolicyRuleGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FirewallPolicyRuleGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FirewallPolicyRuleGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return FirewallPolicyRuleGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FlowLogsClientListPager provides operations for iterating over paged responses.
type FlowLogsClientListPager struct {
	client    *FlowLogsClient
	current   FlowLogsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FlowLogsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FlowLogsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FlowLogListResult.NextLink == nil || len(*p.current.FlowLogListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *FlowLogsClientListPager) NextPage(ctx context.Context) (FlowLogsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return FlowLogsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FlowLogsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FlowLogsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FlowLogsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return FlowLogsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// HubVirtualNetworkConnectionsClientListPager provides operations for iterating over paged responses.
type HubVirtualNetworkConnectionsClientListPager struct {
	client    *HubVirtualNetworkConnectionsClient
	current   HubVirtualNetworkConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubVirtualNetworkConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *HubVirtualNetworkConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListHubVirtualNetworkConnectionsResult.NextLink == nil || len(*p.current.ListHubVirtualNetworkConnectionsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *HubVirtualNetworkConnectionsClientListPager) NextPage(ctx context.Context) (HubVirtualNetworkConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return HubVirtualNetworkConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return HubVirtualNetworkConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return HubVirtualNetworkConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return HubVirtualNetworkConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return HubVirtualNetworkConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IPAllocationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IPAllocationsClientListByResourceGroupPager struct {
	client    *IPAllocationsClient
	current   IPAllocationsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPAllocationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IPAllocationsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IPAllocationsClientListByResourceGroupPager) NextPage(ctx context.Context) (IPAllocationsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IPAllocationsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IPAllocationsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IPAllocationsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IPAllocationsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return IPAllocationsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IPAllocationsClientListPager provides operations for iterating over paged responses.
type IPAllocationsClientListPager struct {
	client    *IPAllocationsClient
	current   IPAllocationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPAllocationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IPAllocationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPAllocationListResult.NextLink == nil || len(*p.current.IPAllocationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IPAllocationsClientListPager) NextPage(ctx context.Context) (IPAllocationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IPAllocationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IPAllocationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IPAllocationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IPAllocationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IPAllocationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IPGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IPGroupsClientListByResourceGroupPager struct {
	client    *IPGroupsClient
	current   IPGroupsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IPGroupsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IPGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) (IPGroupsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IPGroupsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IPGroupsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IPGroupsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IPGroupsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return IPGroupsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IPGroupsClientListPager provides operations for iterating over paged responses.
type IPGroupsClientListPager struct {
	client    *IPGroupsClient
	current   IPGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IPGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IPGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IPGroupListResult.NextLink == nil || len(*p.current.IPGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IPGroupsClientListPager) NextPage(ctx context.Context) (IPGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IPGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IPGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IPGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IPGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IPGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InboundNatRulesClientListPager provides operations for iterating over paged responses.
type InboundNatRulesClientListPager struct {
	client    *InboundNatRulesClient
	current   InboundNatRulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InboundNatRulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InboundNatRulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InboundNatRuleListResult.NextLink == nil || len(*p.current.InboundNatRuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InboundNatRulesClientListPager) NextPage(ctx context.Context) (InboundNatRulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InboundNatRulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InboundNatRulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InboundNatRulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InboundNatRulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return InboundNatRulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfaceIPConfigurationsClientListPager provides operations for iterating over paged responses.
type InterfaceIPConfigurationsClientListPager struct {
	client    *InterfaceIPConfigurationsClient
	current   InterfaceIPConfigurationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfaceIPConfigurationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfaceIPConfigurationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.InterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfaceIPConfigurationsClientListPager) NextPage(ctx context.Context) (InterfaceIPConfigurationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfaceIPConfigurationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfaceIPConfigurationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfaceIPConfigurationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfaceIPConfigurationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return InterfaceIPConfigurationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfaceLoadBalancersClientListPager provides operations for iterating over paged responses.
type InterfaceLoadBalancersClientListPager struct {
	client    *InterfaceLoadBalancersClient
	current   InterfaceLoadBalancersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfaceLoadBalancersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfaceLoadBalancersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceLoadBalancerListResult.NextLink == nil || len(*p.current.InterfaceLoadBalancerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfaceLoadBalancersClientListPager) NextPage(ctx context.Context) (InterfaceLoadBalancersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfaceLoadBalancersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfaceLoadBalancersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfaceLoadBalancersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfaceLoadBalancersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return InterfaceLoadBalancersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfaceTapConfigurationsClientListPager provides operations for iterating over paged responses.
type InterfaceTapConfigurationsClientListPager struct {
	client    *InterfaceTapConfigurationsClient
	current   InterfaceTapConfigurationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfaceTapConfigurationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfaceTapConfigurationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceTapConfigurationListResult.NextLink == nil || len(*p.current.InterfaceTapConfigurationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfaceTapConfigurationsClientListPager) NextPage(ctx context.Context) (InterfaceTapConfigurationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfaceTapConfigurationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfaceTapConfigurationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfaceTapConfigurationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfaceTapConfigurationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return InterfaceTapConfigurationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfacesClientListAllPager provides operations for iterating over paged responses.
type InterfacesClientListAllPager struct {
	client    *InterfacesClient
	current   InterfacesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfacesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfacesClientListAllPager) NextPage(ctx context.Context) (InterfacesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfacesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfacesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfacesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfacesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return InterfacesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfacesClientListPager provides operations for iterating over paged responses.
type InterfacesClientListPager struct {
	client    *InterfacesClient
	current   InterfacesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfacesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfacesClientListPager) NextPage(ctx context.Context) (InterfacesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfacesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfacesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfacesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfacesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return InterfacesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager provides operations for iterating over paged responses.
type InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager struct {
	client    *InterfacesClient
	current   InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceIPConfigurationListResult.NextLink == nil || len(*p.current.InterfaceIPConfigurationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfacesClientListVirtualMachineScaleSetIPConfigurationsPager) NextPage(ctx context.Context) (InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVirtualMachineScaleSetIPConfigurationsHandleResponse(resp)
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager provides operations for iterating over paged responses.
type InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager struct {
	client    *InterfacesClient
	current   InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfacesClientListVirtualMachineScaleSetNetworkInterfacesPager) NextPage(ctx context.Context) (InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVirtualMachineScaleSetNetworkInterfacesHandleResponse(resp)
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager provides operations for iterating over paged responses.
type InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager struct {
	client    *InterfacesClient
	current   InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesPager) NextPage(ctx context.Context) (InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVirtualMachineScaleSetVMNetworkInterfacesHandleResponse(resp)
	if err != nil {
		return InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancerBackendAddressPoolsClientListPager provides operations for iterating over paged responses.
type LoadBalancerBackendAddressPoolsClientListPager struct {
	client    *LoadBalancerBackendAddressPoolsClient
	current   LoadBalancerBackendAddressPoolsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerBackendAddressPoolsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancerBackendAddressPoolsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerBackendAddressPoolListResult.NextLink == nil || len(*p.current.LoadBalancerBackendAddressPoolListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancerBackendAddressPoolsClientListPager) NextPage(ctx context.Context) (LoadBalancerBackendAddressPoolsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancerBackendAddressPoolsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancerBackendAddressPoolsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancerBackendAddressPoolsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancerBackendAddressPoolsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancerBackendAddressPoolsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancerFrontendIPConfigurationsClientListPager provides operations for iterating over paged responses.
type LoadBalancerFrontendIPConfigurationsClientListPager struct {
	client    *LoadBalancerFrontendIPConfigurationsClient
	current   LoadBalancerFrontendIPConfigurationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerFrontendIPConfigurationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancerFrontendIPConfigurationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink == nil || len(*p.current.LoadBalancerFrontendIPConfigurationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancerFrontendIPConfigurationsClientListPager) NextPage(ctx context.Context) (LoadBalancerFrontendIPConfigurationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancerFrontendIPConfigurationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancerFrontendIPConfigurationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancerFrontendIPConfigurationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancerFrontendIPConfigurationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancerFrontendIPConfigurationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancerLoadBalancingRulesClientListPager provides operations for iterating over paged responses.
type LoadBalancerLoadBalancingRulesClientListPager struct {
	client    *LoadBalancerLoadBalancingRulesClient
	current   LoadBalancerLoadBalancingRulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerLoadBalancingRulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancerLoadBalancingRulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerLoadBalancingRuleListResult.NextLink == nil || len(*p.current.LoadBalancerLoadBalancingRuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancerLoadBalancingRulesClientListPager) NextPage(ctx context.Context) (LoadBalancerLoadBalancingRulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancerLoadBalancingRulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancerLoadBalancingRulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancerLoadBalancingRulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancerLoadBalancingRulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancerLoadBalancingRulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancerNetworkInterfacesClientListPager provides operations for iterating over paged responses.
type LoadBalancerNetworkInterfacesClientListPager struct {
	client    *LoadBalancerNetworkInterfacesClient
	current   LoadBalancerNetworkInterfacesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerNetworkInterfacesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancerNetworkInterfacesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InterfaceListResult.NextLink == nil || len(*p.current.InterfaceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancerNetworkInterfacesClientListPager) NextPage(ctx context.Context) (LoadBalancerNetworkInterfacesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancerNetworkInterfacesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancerNetworkInterfacesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancerNetworkInterfacesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancerNetworkInterfacesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancerNetworkInterfacesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancerOutboundRulesClientListPager provides operations for iterating over paged responses.
type LoadBalancerOutboundRulesClientListPager struct {
	client    *LoadBalancerOutboundRulesClient
	current   LoadBalancerOutboundRulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerOutboundRulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancerOutboundRulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerOutboundRuleListResult.NextLink == nil || len(*p.current.LoadBalancerOutboundRuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancerOutboundRulesClientListPager) NextPage(ctx context.Context) (LoadBalancerOutboundRulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancerOutboundRulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancerOutboundRulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancerOutboundRulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancerOutboundRulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancerOutboundRulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancerProbesClientListPager provides operations for iterating over paged responses.
type LoadBalancerProbesClientListPager struct {
	client    *LoadBalancerProbesClient
	current   LoadBalancerProbesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancerProbesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancerProbesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerProbeListResult.NextLink == nil || len(*p.current.LoadBalancerProbeListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancerProbesClientListPager) NextPage(ctx context.Context) (LoadBalancerProbesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancerProbesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancerProbesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancerProbesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancerProbesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancerProbesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancersClientListAllPager provides operations for iterating over paged responses.
type LoadBalancersClientListAllPager struct {
	client    *LoadBalancersClient
	current   LoadBalancersClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancersClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancersClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancersClientListAllPager) NextPage(ctx context.Context) (LoadBalancersClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancersClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancersClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancersClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancersClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return LoadBalancersClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoadBalancersClientListPager provides operations for iterating over paged responses.
type LoadBalancersClientListPager struct {
	client    *LoadBalancersClient
	current   LoadBalancersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoadBalancersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoadBalancersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoadBalancerListResult.NextLink == nil || len(*p.current.LoadBalancerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoadBalancersClientListPager) NextPage(ctx context.Context) (LoadBalancersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoadBalancersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoadBalancersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoadBalancersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoadBalancersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LoadBalancersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LocalNetworkGatewaysClientListPager provides operations for iterating over paged responses.
type LocalNetworkGatewaysClientListPager struct {
	client    *LocalNetworkGatewaysClient
	current   LocalNetworkGatewaysClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LocalNetworkGatewaysClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LocalNetworkGatewaysClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LocalNetworkGatewayListResult.NextLink == nil || len(*p.current.LocalNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LocalNetworkGatewaysClientListPager) NextPage(ctx context.Context) (LocalNetworkGatewaysClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LocalNetworkGatewaysClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LocalNetworkGatewaysClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LocalNetworkGatewaysClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LocalNetworkGatewaysClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LocalNetworkGatewaysClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagementClientDisconnectActiveSessionsPager provides operations for iterating over paged responses.
type ManagementClientDisconnectActiveSessionsPager struct {
	client    *ManagementClient
	current   ManagementClientDisconnectActiveSessionsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagementClientDisconnectActiveSessionsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagementClientDisconnectActiveSessionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionSessionDeleteResult.NextLink == nil || len(*p.current.BastionSessionDeleteResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ManagementClientDisconnectActiveSessionsPager) NextPage(ctx context.Context) (ManagementClientDisconnectActiveSessionsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ManagementClientDisconnectActiveSessionsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagementClientDisconnectActiveSessionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagementClientDisconnectActiveSessionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagementClientDisconnectActiveSessionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.disconnectActiveSessionsHandleResponse(resp)
	if err != nil {
		return ManagementClientDisconnectActiveSessionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagementClientGetActiveSessionsPager provides operations for iterating over paged responses.
type ManagementClientGetActiveSessionsPager struct {
	client  *ManagementClient
	current ManagementClientGetActiveSessionsResponse
	second  bool
}

// More returns true if there are more pages to retrieve.
func (p *ManagementClientGetActiveSessionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionActiveSessionListResult.NextLink == nil || len(*p.current.BastionActiveSessionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ManagementClientGetActiveSessionsPager) NextPage(ctx context.Context) (ManagementClientGetActiveSessionsResponse, error) {
	if !p.second {
		p.second = true
		return p.current, nil
	} else if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ManagementClientGetActiveSessionsResponse{}, errors.New("no more pages")
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.BastionActiveSessionListResult.NextLink)
	if err != nil {
		return ManagementClientGetActiveSessionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagementClientGetActiveSessionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {

		return ManagementClientGetActiveSessionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getActiveSessionsHandleResponse(resp)
	if err != nil {
		return ManagementClientGetActiveSessionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagementClientGetBastionShareableLinkPager provides operations for iterating over paged responses.
type ManagementClientGetBastionShareableLinkPager struct {
	client    *ManagementClient
	current   ManagementClientGetBastionShareableLinkResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagementClientGetBastionShareableLinkResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagementClientGetBastionShareableLinkPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ManagementClientGetBastionShareableLinkPager) NextPage(ctx context.Context) (ManagementClientGetBastionShareableLinkResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ManagementClientGetBastionShareableLinkResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagementClientGetBastionShareableLinkResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagementClientGetBastionShareableLinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagementClientGetBastionShareableLinkResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getBastionShareableLinkHandleResponse(resp)
	if err != nil {
		return ManagementClientGetBastionShareableLinkResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagementClientPutBastionShareableLinkPager provides operations for iterating over paged responses.
type ManagementClientPutBastionShareableLinkPager struct {
	client  *ManagementClient
	current ManagementClientPutBastionShareableLinkResponse
	second  bool
}

// More returns true if there are more pages to retrieve.
func (p *ManagementClientPutBastionShareableLinkPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BastionShareableLinkListResult.NextLink == nil || len(*p.current.BastionShareableLinkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ManagementClientPutBastionShareableLinkPager) NextPage(ctx context.Context) (ManagementClientPutBastionShareableLinkResponse, error) {
	if !p.second {
		p.second = true
		return p.current, nil
	} else if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ManagementClientPutBastionShareableLinkResponse{}, errors.New("no more pages")
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.BastionShareableLinkListResult.NextLink)
	if err != nil {
		return ManagementClientPutBastionShareableLinkResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagementClientPutBastionShareableLinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {

		return ManagementClientPutBastionShareableLinkResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.putBastionShareableLinkHandleResponse(resp)
	if err != nil {
		return ManagementClientPutBastionShareableLinkResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// NatGatewaysClientListAllPager provides operations for iterating over paged responses.
type NatGatewaysClientListAllPager struct {
	client    *NatGatewaysClient
	current   NatGatewaysClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatGatewaysClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *NatGatewaysClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *NatGatewaysClientListAllPager) NextPage(ctx context.Context) (NatGatewaysClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return NatGatewaysClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return NatGatewaysClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return NatGatewaysClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return NatGatewaysClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return NatGatewaysClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// NatGatewaysClientListPager provides operations for iterating over paged responses.
type NatGatewaysClientListPager struct {
	client    *NatGatewaysClient
	current   NatGatewaysClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NatGatewaysClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *NatGatewaysClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NatGatewayListResult.NextLink == nil || len(*p.current.NatGatewayListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *NatGatewaysClientListPager) NextPage(ctx context.Context) (NatGatewaysClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return NatGatewaysClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return NatGatewaysClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return NatGatewaysClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return NatGatewaysClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return NatGatewaysClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// P2SVPNGatewaysClientListByResourceGroupPager provides operations for iterating over paged responses.
type P2SVPNGatewaysClientListByResourceGroupPager struct {
	client    *P2SVPNGatewaysClient
	current   P2SVPNGatewaysClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, P2SVPNGatewaysClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *P2SVPNGatewaysClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListP2SVPNGatewaysResult.NextLink == nil || len(*p.current.ListP2SVPNGatewaysResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *P2SVPNGatewaysClientListByResourceGroupPager) NextPage(ctx context.Context) (P2SVPNGatewaysClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return P2SVPNGatewaysClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return P2SVPNGatewaysClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return P2SVPNGatewaysClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return P2SVPNGatewaysClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return P2SVPNGatewaysClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// P2SVPNGatewaysClientListPager provides operations for iterating over paged responses.
type P2SVPNGatewaysClientListPager struct {
	client    *P2SVPNGatewaysClient
	current   P2SVPNGatewaysClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, P2SVPNGatewaysClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *P2SVPNGatewaysClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListP2SVPNGatewaysResult.NextLink == nil || len(*p.current.ListP2SVPNGatewaysResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *P2SVPNGatewaysClientListPager) NextPage(ctx context.Context) (P2SVPNGatewaysClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return P2SVPNGatewaysClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return P2SVPNGatewaysClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return P2SVPNGatewaysClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return P2SVPNGatewaysClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return P2SVPNGatewaysClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PeerExpressRouteCircuitConnectionsClientListPager provides operations for iterating over paged responses.
type PeerExpressRouteCircuitConnectionsClientListPager struct {
	client    *PeerExpressRouteCircuitConnectionsClient
	current   PeerExpressRouteCircuitConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PeerExpressRouteCircuitConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PeerExpressRouteCircuitConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PeerExpressRouteCircuitConnectionListResult.NextLink == nil || len(*p.current.PeerExpressRouteCircuitConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PeerExpressRouteCircuitConnectionsClientListPager) NextPage(ctx context.Context) (PeerExpressRouteCircuitConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PeerExpressRouteCircuitConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PeerExpressRouteCircuitConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PeerExpressRouteCircuitConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PeerExpressRouteCircuitConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PeerExpressRouteCircuitConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateDNSZoneGroupsClientListPager provides operations for iterating over paged responses.
type PrivateDNSZoneGroupsClientListPager struct {
	client    *PrivateDNSZoneGroupsClient
	current   PrivateDNSZoneGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateDNSZoneGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateDNSZoneGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateDNSZoneGroupListResult.NextLink == nil || len(*p.current.PrivateDNSZoneGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateDNSZoneGroupsClientListPager) NextPage(ctx context.Context) (PrivateDNSZoneGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateDNSZoneGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateDNSZoneGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateDNSZoneGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateDNSZoneGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PrivateDNSZoneGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateEndpointsClientListBySubscriptionPager provides operations for iterating over paged responses.
type PrivateEndpointsClientListBySubscriptionPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateEndpointsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateEndpointsClientListBySubscriptionPager) NextPage(ctx context.Context) (PrivateEndpointsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateEndpointsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateEndpointsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateEndpointsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateEndpointsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return PrivateEndpointsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateEndpointsClientListPager provides operations for iterating over paged responses.
type PrivateEndpointsClientListPager struct {
	client    *PrivateEndpointsClient
	current   PrivateEndpointsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateEndpointsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointListResult.NextLink == nil || len(*p.current.PrivateEndpointListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateEndpointsClientListPager) NextPage(ctx context.Context) (PrivateEndpointsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateEndpointsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateEndpointsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateEndpointsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateEndpointsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PrivateEndpointsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupPager) NextPage(ctx context.Context) (PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAutoApprovedPrivateLinkServicesByResourceGroupHandleResponse(resp)
	if err != nil {
		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoApprovedPrivateLinkServicesResult.NextLink == nil || len(*p.current.AutoApprovedPrivateLinkServicesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesPager) NextPage(ctx context.Context) (PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAutoApprovedPrivateLinkServicesHandleResponse(resp)
	if err != nil {
		return PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkServicesClientListBySubscriptionPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListBySubscriptionPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkServicesClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkServicesClientListBySubscriptionPager) NextPage(ctx context.Context) (PrivateLinkServicesClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateLinkServicesClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkServicesClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkServicesClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkServicesClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return PrivateLinkServicesClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkServicesClientListPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkServicesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkServiceListResult.NextLink == nil || len(*p.current.PrivateLinkServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkServicesClientListPager) NextPage(ctx context.Context) (PrivateLinkServicesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateLinkServicesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkServicesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkServicesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkServicesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PrivateLinkServicesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkServicesClientListPrivateEndpointConnectionsPager provides operations for iterating over paged responses.
type PrivateLinkServicesClientListPrivateEndpointConnectionsPager struct {
	client    *PrivateLinkServicesClient
	current   PrivateLinkServicesClientListPrivateEndpointConnectionsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkServicesClientListPrivateEndpointConnectionsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkServicesClientListPrivateEndpointConnectionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkServicesClientListPrivateEndpointConnectionsPager) NextPage(ctx context.Context) (PrivateLinkServicesClientListPrivateEndpointConnectionsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateLinkServicesClientListPrivateEndpointConnectionsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkServicesClientListPrivateEndpointConnectionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkServicesClientListPrivateEndpointConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkServicesClientListPrivateEndpointConnectionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listPrivateEndpointConnectionsHandleResponse(resp)
	if err != nil {
		return PrivateLinkServicesClientListPrivateEndpointConnectionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListAllPager provides operations for iterating over paged responses.
type ProfilesClientListAllPager struct {
	client    *ProfilesClient
	current   ProfilesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListAllPager) NextPage(ctx context.Context) (ProfilesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return ProfilesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListPager provides operations for iterating over paged responses.
type ProfilesClientListPager struct {
	client    *ProfilesClient
	current   ProfilesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListPager) NextPage(ctx context.Context) (ProfilesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ProfilesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PublicIPAddressesClientListAllPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListAllPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PublicIPAddressesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PublicIPAddressesClientListAllPager) NextPage(ctx context.Context) (PublicIPAddressesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PublicIPAddressesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PublicIPAddressesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PublicIPAddressesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PublicIPAddressesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return PublicIPAddressesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PublicIPAddressesClientListPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PublicIPAddressesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PublicIPAddressesClientListPager) NextPage(ctx context.Context) (PublicIPAddressesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PublicIPAddressesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PublicIPAddressesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PublicIPAddressesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PublicIPAddressesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PublicIPAddressesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesPager) NextPage(ctx context.Context) (PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVirtualMachineScaleSetPublicIPAddressesHandleResponse(resp)
	if err != nil {
		return PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager provides operations for iterating over paged responses.
type PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager struct {
	client    *PublicIPAddressesClient
	current   PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPAddressListResult.NextLink == nil || len(*p.current.PublicIPAddressListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesPager) NextPage(ctx context.Context) (PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVirtualMachineScaleSetVMPublicIPAddressesHandleResponse(resp)
	if err != nil {
		return PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PublicIPPrefixesClientListAllPager provides operations for iterating over paged responses.
type PublicIPPrefixesClientListAllPager struct {
	client    *PublicIPPrefixesClient
	current   PublicIPPrefixesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPPrefixesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PublicIPPrefixesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PublicIPPrefixesClientListAllPager) NextPage(ctx context.Context) (PublicIPPrefixesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PublicIPPrefixesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PublicIPPrefixesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PublicIPPrefixesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PublicIPPrefixesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return PublicIPPrefixesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PublicIPPrefixesClientListPager provides operations for iterating over paged responses.
type PublicIPPrefixesClientListPager struct {
	client    *PublicIPPrefixesClient
	current   PublicIPPrefixesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PublicIPPrefixesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PublicIPPrefixesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PublicIPPrefixListResult.NextLink == nil || len(*p.current.PublicIPPrefixListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PublicIPPrefixesClientListPager) NextPage(ctx context.Context) (PublicIPPrefixesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PublicIPPrefixesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PublicIPPrefixesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PublicIPPrefixesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PublicIPPrefixesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PublicIPPrefixesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RouteFilterRulesClientListByRouteFilterPager provides operations for iterating over paged responses.
type RouteFilterRulesClientListByRouteFilterPager struct {
	client    *RouteFilterRulesClient
	current   RouteFilterRulesClientListByRouteFilterResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFilterRulesClientListByRouteFilterResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RouteFilterRulesClientListByRouteFilterPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterRuleListResult.NextLink == nil || len(*p.current.RouteFilterRuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RouteFilterRulesClientListByRouteFilterPager) NextPage(ctx context.Context) (RouteFilterRulesClientListByRouteFilterResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RouteFilterRulesClientListByRouteFilterResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RouteFilterRulesClientListByRouteFilterResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RouteFilterRulesClientListByRouteFilterResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RouteFilterRulesClientListByRouteFilterResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByRouteFilterHandleResponse(resp)
	if err != nil {
		return RouteFilterRulesClientListByRouteFilterResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RouteFiltersClientListByResourceGroupPager provides operations for iterating over paged responses.
type RouteFiltersClientListByResourceGroupPager struct {
	client    *RouteFiltersClient
	current   RouteFiltersClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFiltersClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RouteFiltersClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RouteFiltersClientListByResourceGroupPager) NextPage(ctx context.Context) (RouteFiltersClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RouteFiltersClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RouteFiltersClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RouteFiltersClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RouteFiltersClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return RouteFiltersClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RouteFiltersClientListPager provides operations for iterating over paged responses.
type RouteFiltersClientListPager struct {
	client    *RouteFiltersClient
	current   RouteFiltersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteFiltersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RouteFiltersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteFilterListResult.NextLink == nil || len(*p.current.RouteFilterListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RouteFiltersClientListPager) NextPage(ctx context.Context) (RouteFiltersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RouteFiltersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RouteFiltersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RouteFiltersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RouteFiltersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RouteFiltersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RouteTablesClientListAllPager provides operations for iterating over paged responses.
type RouteTablesClientListAllPager struct {
	client    *RouteTablesClient
	current   RouteTablesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteTablesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RouteTablesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RouteTablesClientListAllPager) NextPage(ctx context.Context) (RouteTablesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RouteTablesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RouteTablesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RouteTablesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RouteTablesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return RouteTablesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RouteTablesClientListPager provides operations for iterating over paged responses.
type RouteTablesClientListPager struct {
	client    *RouteTablesClient
	current   RouteTablesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RouteTablesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RouteTablesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteTableListResult.NextLink == nil || len(*p.current.RouteTableListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RouteTablesClientListPager) NextPage(ctx context.Context) (RouteTablesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RouteTablesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RouteTablesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RouteTablesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RouteTablesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RouteTablesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoutesClientListPager provides operations for iterating over paged responses.
type RoutesClientListPager struct {
	client    *RoutesClient
	current   RoutesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoutesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoutesClientListPager) NextPage(ctx context.Context) (RoutesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoutesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoutesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoutesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoutesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RoutesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecurityGroupsClientListAllPager provides operations for iterating over paged responses.
type SecurityGroupsClientListAllPager struct {
	client    *SecurityGroupsClient
	current   SecurityGroupsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityGroupsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecurityGroupsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityGroupListResult.NextLink == nil || len(*p.current.SecurityGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecurityGroupsClientListAllPager) NextPage(ctx context.Context) (SecurityGroupsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecurityGroupsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecurityGroupsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecurityGroupsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecurityGroupsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return SecurityGroupsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecurityGroupsClientListPager provides operations for iterating over paged responses.
type SecurityGroupsClientListPager struct {
	client    *SecurityGroupsClient
	current   SecurityGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecurityGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityGroupListResult.NextLink == nil || len(*p.current.SecurityGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecurityGroupsClientListPager) NextPage(ctx context.Context) (SecurityGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecurityGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecurityGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecurityGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecurityGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecurityGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecurityPartnerProvidersClientListByResourceGroupPager provides operations for iterating over paged responses.
type SecurityPartnerProvidersClientListByResourceGroupPager struct {
	client    *SecurityPartnerProvidersClient
	current   SecurityPartnerProvidersClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPartnerProvidersClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecurityPartnerProvidersClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecurityPartnerProvidersClientListByResourceGroupPager) NextPage(ctx context.Context) (SecurityPartnerProvidersClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecurityPartnerProvidersClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecurityPartnerProvidersClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecurityPartnerProvidersClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecurityPartnerProvidersClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return SecurityPartnerProvidersClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecurityPartnerProvidersClientListPager provides operations for iterating over paged responses.
type SecurityPartnerProvidersClientListPager struct {
	client    *SecurityPartnerProvidersClient
	current   SecurityPartnerProvidersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPartnerProvidersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecurityPartnerProvidersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPartnerProviderListResult.NextLink == nil || len(*p.current.SecurityPartnerProviderListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecurityPartnerProvidersClientListPager) NextPage(ctx context.Context) (SecurityPartnerProvidersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecurityPartnerProvidersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecurityPartnerProvidersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecurityPartnerProvidersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecurityPartnerProvidersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecurityPartnerProvidersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecurityRulesClientListPager provides operations for iterating over paged responses.
type SecurityRulesClientListPager struct {
	client    *SecurityRulesClient
	current   SecurityRulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityRulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecurityRulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityRuleListResult.NextLink == nil || len(*p.current.SecurityRuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecurityRulesClientListPager) NextPage(ctx context.Context) (SecurityRulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecurityRulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecurityRulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecurityRulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecurityRulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecurityRulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceEndpointPoliciesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceEndpointPoliciesClientListByResourceGroupPager struct {
	client    *ServiceEndpointPoliciesClient
	current   ServiceEndpointPoliciesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPoliciesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceEndpointPoliciesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceEndpointPoliciesClientListByResourceGroupPager) NextPage(ctx context.Context) (ServiceEndpointPoliciesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceEndpointPoliciesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceEndpointPoliciesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceEndpointPoliciesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceEndpointPoliciesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ServiceEndpointPoliciesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceEndpointPoliciesClientListPager provides operations for iterating over paged responses.
type ServiceEndpointPoliciesClientListPager struct {
	client    *ServiceEndpointPoliciesClient
	current   ServiceEndpointPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceEndpointPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceEndpointPoliciesClientListPager) NextPage(ctx context.Context) (ServiceEndpointPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceEndpointPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceEndpointPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceEndpointPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceEndpointPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ServiceEndpointPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager struct {
	client    *ServiceEndpointPolicyDefinitionsClient
	current   ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceEndpointPolicyDefinitionListResult.NextLink == nil || len(*p.current.ServiceEndpointPolicyDefinitionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceEndpointPolicyDefinitionsClientListByResourceGroupPager) NextPage(ctx context.Context) (ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubnetsClientListPager provides operations for iterating over paged responses.
type SubnetsClientListPager struct {
	client    *SubnetsClient
	current   SubnetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubnetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubnetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubnetListResult.NextLink == nil || len(*p.current.SubnetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubnetsClientListPager) NextPage(ctx context.Context) (SubnetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubnetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubnetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubnetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubnetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SubnetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UsagesClientListPager provides operations for iterating over paged responses.
type UsagesClientListPager struct {
	client    *UsagesClient
	current   UsagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UsagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UsagesClientListPager) NextPage(ctx context.Context) (UsagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UsagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UsagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UsagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UsagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UsagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNConnectionsClientListByVPNGatewayPager provides operations for iterating over paged responses.
type VPNConnectionsClientListByVPNGatewayPager struct {
	client    *VPNConnectionsClient
	current   VPNConnectionsClientListByVPNGatewayResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNConnectionsClientListByVPNGatewayResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNConnectionsClientListByVPNGatewayPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNConnectionsResult.NextLink == nil || len(*p.current.ListVPNConnectionsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNConnectionsClientListByVPNGatewayPager) NextPage(ctx context.Context) (VPNConnectionsClientListByVPNGatewayResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNConnectionsClientListByVPNGatewayResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNConnectionsClientListByVPNGatewayResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNConnectionsClientListByVPNGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNConnectionsClientListByVPNGatewayResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByVPNGatewayHandleResponse(resp)
	if err != nil {
		return VPNConnectionsClientListByVPNGatewayResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNGatewaysClientListByResourceGroupPager provides operations for iterating over paged responses.
type VPNGatewaysClientListByResourceGroupPager struct {
	client    *VPNGatewaysClient
	current   VPNGatewaysClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNGatewaysClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNGatewaysClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewaysResult.NextLink == nil || len(*p.current.ListVPNGatewaysResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNGatewaysClientListByResourceGroupPager) NextPage(ctx context.Context) (VPNGatewaysClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNGatewaysClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNGatewaysClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNGatewaysClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNGatewaysClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VPNGatewaysClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNGatewaysClientListPager provides operations for iterating over paged responses.
type VPNGatewaysClientListPager struct {
	client    *VPNGatewaysClient
	current   VPNGatewaysClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNGatewaysClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNGatewaysClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNGatewaysResult.NextLink == nil || len(*p.current.ListVPNGatewaysResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNGatewaysClientListPager) NextPage(ctx context.Context) (VPNGatewaysClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNGatewaysClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNGatewaysClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNGatewaysClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNGatewaysClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VPNGatewaysClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNLinkConnectionsClientListByVPNConnectionPager provides operations for iterating over paged responses.
type VPNLinkConnectionsClientListByVPNConnectionPager struct {
	client    *VPNLinkConnectionsClient
	current   VPNLinkConnectionsClientListByVPNConnectionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNLinkConnectionsClientListByVPNConnectionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNLinkConnectionsClientListByVPNConnectionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSiteLinkConnectionsResult.NextLink == nil || len(*p.current.ListVPNSiteLinkConnectionsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNLinkConnectionsClientListByVPNConnectionPager) NextPage(ctx context.Context) (VPNLinkConnectionsClientListByVPNConnectionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNLinkConnectionsClientListByVPNConnectionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNLinkConnectionsClientListByVPNConnectionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNLinkConnectionsClientListByVPNConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNLinkConnectionsClientListByVPNConnectionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByVPNConnectionHandleResponse(resp)
	if err != nil {
		return VPNLinkConnectionsClientListByVPNConnectionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNServerConfigurationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type VPNServerConfigurationsClientListByResourceGroupPager struct {
	client    *VPNServerConfigurationsClient
	current   VPNServerConfigurationsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNServerConfigurationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNServerConfigurationsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNServerConfigurationsResult.NextLink == nil || len(*p.current.ListVPNServerConfigurationsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNServerConfigurationsClientListByResourceGroupPager) NextPage(ctx context.Context) (VPNServerConfigurationsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNServerConfigurationsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNServerConfigurationsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNServerConfigurationsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNServerConfigurationsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VPNServerConfigurationsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNServerConfigurationsClientListPager provides operations for iterating over paged responses.
type VPNServerConfigurationsClientListPager struct {
	client    *VPNServerConfigurationsClient
	current   VPNServerConfigurationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNServerConfigurationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNServerConfigurationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNServerConfigurationsResult.NextLink == nil || len(*p.current.ListVPNServerConfigurationsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNServerConfigurationsClientListPager) NextPage(ctx context.Context) (VPNServerConfigurationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNServerConfigurationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNServerConfigurationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNServerConfigurationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNServerConfigurationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VPNServerConfigurationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNSiteLinksClientListByVPNSitePager provides operations for iterating over paged responses.
type VPNSiteLinksClientListByVPNSitePager struct {
	client    *VPNSiteLinksClient
	current   VPNSiteLinksClientListByVPNSiteResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSiteLinksClientListByVPNSiteResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNSiteLinksClientListByVPNSitePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSiteLinksResult.NextLink == nil || len(*p.current.ListVPNSiteLinksResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNSiteLinksClientListByVPNSitePager) NextPage(ctx context.Context) (VPNSiteLinksClientListByVPNSiteResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNSiteLinksClientListByVPNSiteResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNSiteLinksClientListByVPNSiteResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNSiteLinksClientListByVPNSiteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNSiteLinksClientListByVPNSiteResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByVPNSiteHandleResponse(resp)
	if err != nil {
		return VPNSiteLinksClientListByVPNSiteResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNSitesClientListByResourceGroupPager provides operations for iterating over paged responses.
type VPNSitesClientListByResourceGroupPager struct {
	client    *VPNSitesClient
	current   VPNSitesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSitesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNSitesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSitesResult.NextLink == nil || len(*p.current.ListVPNSitesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNSitesClientListByResourceGroupPager) NextPage(ctx context.Context) (VPNSitesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNSitesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNSitesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNSitesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNSitesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VPNSitesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VPNSitesClientListPager provides operations for iterating over paged responses.
type VPNSitesClientListPager struct {
	client    *VPNSitesClient
	current   VPNSitesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VPNSitesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VPNSitesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVPNSitesResult.NextLink == nil || len(*p.current.ListVPNSitesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VPNSitesClientListPager) NextPage(ctx context.Context) (VPNSitesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VPNSitesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VPNSitesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VPNSitesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VPNSitesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VPNSitesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualAppliancesClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualAppliancesClientListByResourceGroupPager struct {
	client    *VirtualAppliancesClient
	current   VirtualAppliancesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualAppliancesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualAppliancesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualApplianceListResult.NextLink == nil || len(*p.current.VirtualApplianceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualAppliancesClientListByResourceGroupPager) NextPage(ctx context.Context) (VirtualAppliancesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualAppliancesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualAppliancesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualAppliancesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualAppliancesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VirtualAppliancesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualAppliancesClientListPager provides operations for iterating over paged responses.
type VirtualAppliancesClientListPager struct {
	client    *VirtualAppliancesClient
	current   VirtualAppliancesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualAppliancesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualAppliancesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualApplianceListResult.NextLink == nil || len(*p.current.VirtualApplianceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualAppliancesClientListPager) NextPage(ctx context.Context) (VirtualAppliancesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualAppliancesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualAppliancesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualAppliancesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualAppliancesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualAppliancesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualHubRouteTableV2SClientListPager provides operations for iterating over paged responses.
type VirtualHubRouteTableV2SClientListPager struct {
	client    *VirtualHubRouteTableV2SClient
	current   VirtualHubRouteTableV2SClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubRouteTableV2SClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualHubRouteTableV2SClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubRouteTableV2SResult.NextLink == nil || len(*p.current.ListVirtualHubRouteTableV2SResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualHubRouteTableV2SClientListPager) NextPage(ctx context.Context) (VirtualHubRouteTableV2SClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualHubRouteTableV2SClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualHubRouteTableV2SClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualHubRouteTableV2SClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualHubRouteTableV2SClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualHubRouteTableV2SClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualHubsClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualHubsClientListByResourceGroupPager struct {
	client    *VirtualHubsClient
	current   VirtualHubsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualHubsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualHubsClientListByResourceGroupPager) NextPage(ctx context.Context) (VirtualHubsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualHubsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualHubsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualHubsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualHubsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VirtualHubsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualHubsClientListPager provides operations for iterating over paged responses.
type VirtualHubsClientListPager struct {
	client    *VirtualHubsClient
	current   VirtualHubsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualHubsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualHubsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualHubsResult.NextLink == nil || len(*p.current.ListVirtualHubsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualHubsClientListPager) NextPage(ctx context.Context) (VirtualHubsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualHubsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualHubsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualHubsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualHubsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualHubsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworkGatewayConnectionsClientListPager provides operations for iterating over paged responses.
type VirtualNetworkGatewayConnectionsClientListPager struct {
	client    *VirtualNetworkGatewayConnectionsClient
	current   VirtualNetworkGatewayConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewayConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworkGatewayConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayConnectionListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworkGatewayConnectionsClientListPager) NextPage(ctx context.Context) (VirtualNetworkGatewayConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworkGatewayConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworkGatewayConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworkGatewayConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworkGatewayConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualNetworkGatewayConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworkGatewaysClientListConnectionsPager provides operations for iterating over paged responses.
type VirtualNetworkGatewaysClientListConnectionsPager struct {
	client    *VirtualNetworkGatewaysClient
	current   VirtualNetworkGatewaysClientListConnectionsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewaysClientListConnectionsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworkGatewaysClientListConnectionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayListConnectionsResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListConnectionsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworkGatewaysClientListConnectionsPager) NextPage(ctx context.Context) (VirtualNetworkGatewaysClientListConnectionsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworkGatewaysClientListConnectionsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworkGatewaysClientListConnectionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworkGatewaysClientListConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworkGatewaysClientListConnectionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listConnectionsHandleResponse(resp)
	if err != nil {
		return VirtualNetworkGatewaysClientListConnectionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworkGatewaysClientListPager provides operations for iterating over paged responses.
type VirtualNetworkGatewaysClientListPager struct {
	client    *VirtualNetworkGatewaysClient
	current   VirtualNetworkGatewaysClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkGatewaysClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworkGatewaysClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkGatewayListResult.NextLink == nil || len(*p.current.VirtualNetworkGatewayListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworkGatewaysClientListPager) NextPage(ctx context.Context) (VirtualNetworkGatewaysClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworkGatewaysClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworkGatewaysClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworkGatewaysClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworkGatewaysClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualNetworkGatewaysClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworkPeeringsClientListPager provides operations for iterating over paged responses.
type VirtualNetworkPeeringsClientListPager struct {
	client    *VirtualNetworkPeeringsClient
	current   VirtualNetworkPeeringsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkPeeringsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworkPeeringsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkPeeringListResult.NextLink == nil || len(*p.current.VirtualNetworkPeeringListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworkPeeringsClientListPager) NextPage(ctx context.Context) (VirtualNetworkPeeringsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworkPeeringsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworkPeeringsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworkPeeringsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworkPeeringsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualNetworkPeeringsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworkTapsClientListAllPager provides operations for iterating over paged responses.
type VirtualNetworkTapsClientListAllPager struct {
	client    *VirtualNetworkTapsClient
	current   VirtualNetworkTapsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkTapsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworkTapsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworkTapsClientListAllPager) NextPage(ctx context.Context) (VirtualNetworkTapsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworkTapsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworkTapsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworkTapsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworkTapsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return VirtualNetworkTapsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworkTapsClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualNetworkTapsClientListByResourceGroupPager struct {
	client    *VirtualNetworkTapsClient
	current   VirtualNetworkTapsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworkTapsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworkTapsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkTapListResult.NextLink == nil || len(*p.current.VirtualNetworkTapListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworkTapsClientListByResourceGroupPager) NextPage(ctx context.Context) (VirtualNetworkTapsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworkTapsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworkTapsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworkTapsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworkTapsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VirtualNetworkTapsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworksClientListAllPager provides operations for iterating over paged responses.
type VirtualNetworksClientListAllPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworksClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworksClientListAllPager) NextPage(ctx context.Context) (VirtualNetworksClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworksClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworksClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworksClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworksClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return VirtualNetworksClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworksClientListPager provides operations for iterating over paged responses.
type VirtualNetworksClientListPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListResult.NextLink == nil || len(*p.current.VirtualNetworkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworksClientListPager) NextPage(ctx context.Context) (VirtualNetworksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualNetworksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworksClientListUsagePager provides operations for iterating over paged responses.
type VirtualNetworksClientListUsagePager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworksClientListUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkListUsageResult.NextLink == nil || len(*p.current.VirtualNetworkListUsageResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworksClientListUsagePager) NextPage(ctx context.Context) (VirtualNetworksClientListUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworksClientListUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworksClientListUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworksClientListUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworksClientListUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listUsageHandleResponse(resp)
	if err != nil {
		return VirtualNetworksClientListUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualRouterPeeringsClientListPager provides operations for iterating over paged responses.
type VirtualRouterPeeringsClientListPager struct {
	client    *VirtualRouterPeeringsClient
	current   VirtualRouterPeeringsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRouterPeeringsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualRouterPeeringsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterPeeringListResult.NextLink == nil || len(*p.current.VirtualRouterPeeringListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualRouterPeeringsClientListPager) NextPage(ctx context.Context) (VirtualRouterPeeringsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualRouterPeeringsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualRouterPeeringsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualRouterPeeringsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualRouterPeeringsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualRouterPeeringsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualRoutersClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualRoutersClientListByResourceGroupPager struct {
	client    *VirtualRoutersClient
	current   VirtualRoutersClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRoutersClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualRoutersClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualRoutersClientListByResourceGroupPager) NextPage(ctx context.Context) (VirtualRoutersClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualRoutersClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualRoutersClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualRoutersClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualRoutersClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VirtualRoutersClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualRoutersClientListPager provides operations for iterating over paged responses.
type VirtualRoutersClientListPager struct {
	client    *VirtualRoutersClient
	current   VirtualRoutersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualRoutersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualRoutersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualRouterListResult.NextLink == nil || len(*p.current.VirtualRouterListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualRoutersClientListPager) NextPage(ctx context.Context) (VirtualRoutersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualRoutersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualRoutersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualRoutersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualRoutersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualRoutersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualWansClientListByResourceGroupPager provides operations for iterating over paged responses.
type VirtualWansClientListByResourceGroupPager struct {
	client    *VirtualWansClient
	current   VirtualWansClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualWansClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualWansClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualWANsResult.NextLink == nil || len(*p.current.ListVirtualWANsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualWansClientListByResourceGroupPager) NextPage(ctx context.Context) (VirtualWansClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualWansClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualWansClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualWansClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualWansClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return VirtualWansClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualWansClientListPager provides operations for iterating over paged responses.
type VirtualWansClientListPager struct {
	client    *VirtualWansClient
	current   VirtualWansClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualWansClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualWansClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListVirtualWANsResult.NextLink == nil || len(*p.current.ListVirtualWANsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualWansClientListPager) NextPage(ctx context.Context) (VirtualWansClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualWansClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualWansClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualWansClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualWansClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualWansClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WebApplicationFirewallPoliciesClientListAllPager provides operations for iterating over paged responses.
type WebApplicationFirewallPoliciesClientListAllPager struct {
	client    *WebApplicationFirewallPoliciesClient
	current   WebApplicationFirewallPoliciesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebApplicationFirewallPoliciesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WebApplicationFirewallPoliciesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WebApplicationFirewallPoliciesClientListAllPager) NextPage(ctx context.Context) (WebApplicationFirewallPoliciesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WebApplicationFirewallPoliciesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WebApplicationFirewallPoliciesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WebApplicationFirewallPoliciesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WebApplicationFirewallPoliciesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return WebApplicationFirewallPoliciesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WebApplicationFirewallPoliciesClientListPager provides operations for iterating over paged responses.
type WebApplicationFirewallPoliciesClientListPager struct {
	client    *WebApplicationFirewallPoliciesClient
	current   WebApplicationFirewallPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WebApplicationFirewallPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WebApplicationFirewallPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyListResult.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WebApplicationFirewallPoliciesClientListPager) NextPage(ctx context.Context) (WebApplicationFirewallPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WebApplicationFirewallPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WebApplicationFirewallPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WebApplicationFirewallPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WebApplicationFirewallPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WebApplicationFirewallPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
