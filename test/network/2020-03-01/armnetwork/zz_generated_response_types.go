//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ApplicationGatewaysClientBackendHealthOnDemandPollerResponse contains the response from method ApplicationGatewaysClient.BackendHealthOnDemand.
type ApplicationGatewaysClientBackendHealthOnDemandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysClientBackendHealthOnDemandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysClientBackendHealthOnDemandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewaysClientBackendHealthOnDemandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysClientBackendHealthOnDemandPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysClientBackendHealthOnDemandPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.BackendHealthOnDemand", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysClientBackendHealthOnDemandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysClientBackendHealthOnDemandResponse contains the response from method ApplicationGatewaysClient.BackendHealthOnDemand.
type ApplicationGatewaysClientBackendHealthOnDemandResponse struct {
	ApplicationGatewayBackendHealthOnDemand
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientBackendHealthPollerResponse contains the response from method ApplicationGatewaysClient.BackendHealth.
type ApplicationGatewaysClientBackendHealthPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysClientBackendHealthPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysClientBackendHealthPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientBackendHealthResponse, error) {
	respType := ApplicationGatewaysClientBackendHealthResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysClientBackendHealthPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysClientBackendHealthPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.BackendHealth", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysClientBackendHealthPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysClientBackendHealthResponse contains the response from method ApplicationGatewaysClient.BackendHealth.
type ApplicationGatewaysClientBackendHealthResponse struct {
	ApplicationGatewayBackendHealth
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientCreateOrUpdatePollerResponse contains the response from method ApplicationGatewaysClient.CreateOrUpdate.
type ApplicationGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientCreateOrUpdateResponse, error) {
	respType := ApplicationGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysClientCreateOrUpdateResponse contains the response from method ApplicationGatewaysClient.CreateOrUpdate.
type ApplicationGatewaysClientCreateOrUpdateResponse struct {
	ApplicationGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientDeletePollerResponse contains the response from method ApplicationGatewaysClient.Delete.
type ApplicationGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientDeleteResponse, error) {
	respType := ApplicationGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysClientDeleteResponse contains the response from method ApplicationGatewaysClient.Delete.
type ApplicationGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientGetResponse contains the response from method ApplicationGatewaysClient.Get.
type ApplicationGatewaysClientGetResponse struct {
	ApplicationGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientGetSSLPredefinedPolicyResponse contains the response from method ApplicationGatewaysClient.GetSSLPredefinedPolicy.
type ApplicationGatewaysClientGetSSLPredefinedPolicyResponse struct {
	ApplicationGatewaySSLPredefinedPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientListAllResponse contains the response from method ApplicationGatewaysClient.ListAll.
type ApplicationGatewaysClientListAllResponse struct {
	ApplicationGatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientListAvailableRequestHeadersResponse contains the response from method ApplicationGatewaysClient.ListAvailableRequestHeaders.
type ApplicationGatewaysClientListAvailableRequestHeadersResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Response for ApplicationGatewayAvailableRequestHeaders API service call.
	StringArray []*string
}

// ApplicationGatewaysClientListAvailableResponseHeadersResponse contains the response from method ApplicationGatewaysClient.ListAvailableResponseHeaders.
type ApplicationGatewaysClientListAvailableResponseHeadersResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Response for ApplicationGatewayAvailableResponseHeaders API service call.
	StringArray []*string
}

// ApplicationGatewaysClientListAvailableSSLOptionsResponse contains the response from method ApplicationGatewaysClient.ListAvailableSSLOptions.
type ApplicationGatewaysClientListAvailableSSLOptionsResponse struct {
	ApplicationGatewayAvailableSSLOptions
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse contains the response from method ApplicationGatewaysClient.ListAvailableSSLPredefinedPolicies.
type ApplicationGatewaysClientListAvailableSSLPredefinedPoliciesResponse struct {
	ApplicationGatewayAvailableSSLPredefinedPolicies
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientListAvailableServerVariablesResponse contains the response from method ApplicationGatewaysClient.ListAvailableServerVariables.
type ApplicationGatewaysClientListAvailableServerVariablesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Response for ApplicationGatewayAvailableServerVariables API service call.
	StringArray []*string
}

// ApplicationGatewaysClientListAvailableWafRuleSetsResponse contains the response from method ApplicationGatewaysClient.ListAvailableWafRuleSets.
type ApplicationGatewaysClientListAvailableWafRuleSetsResponse struct {
	ApplicationGatewayAvailableWafRuleSetsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientListResponse contains the response from method ApplicationGatewaysClient.List.
type ApplicationGatewaysClientListResponse struct {
	ApplicationGatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientStartPollerResponse contains the response from method ApplicationGatewaysClient.Start.
type ApplicationGatewaysClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientStartResponse, error) {
	respType := ApplicationGatewaysClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysClientStartPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysClientStartPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysClientStartResponse contains the response from method ApplicationGatewaysClient.Start.
type ApplicationGatewaysClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientStopPollerResponse contains the response from method ApplicationGatewaysClient.Stop.
type ApplicationGatewaysClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationGatewaysClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationGatewaysClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientStopResponse, error) {
	respType := ApplicationGatewaysClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationGatewaysClientStopPollerResponse from the provided client and resume token.
func (l *ApplicationGatewaysClientStopPollerResponse) Resume(ctx context.Context, client *ApplicationGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationGatewaysClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationGatewaysClientStopResponse contains the response from method ApplicationGatewaysClient.Stop.
type ApplicationGatewaysClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationGatewaysClientUpdateTagsResponse contains the response from method ApplicationGatewaysClient.UpdateTags.
type ApplicationGatewaysClientUpdateTagsResponse struct {
	ApplicationGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsClientCreateOrUpdatePollerResponse contains the response from method ApplicationSecurityGroupsClient.CreateOrUpdate.
type ApplicationSecurityGroupsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationSecurityGroupsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationSecurityGroupsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsClientCreateOrUpdateResponse, error) {
	respType := ApplicationSecurityGroupsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ApplicationSecurityGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationSecurityGroupsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ApplicationSecurityGroupsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ApplicationSecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationSecurityGroupsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationSecurityGroupsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationSecurityGroupsClientCreateOrUpdateResponse contains the response from method ApplicationSecurityGroupsClient.CreateOrUpdate.
type ApplicationSecurityGroupsClientCreateOrUpdateResponse struct {
	ApplicationSecurityGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsClientDeletePollerResponse contains the response from method ApplicationSecurityGroupsClient.Delete.
type ApplicationSecurityGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ApplicationSecurityGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ApplicationSecurityGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsClientDeleteResponse, error) {
	respType := ApplicationSecurityGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ApplicationSecurityGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *ApplicationSecurityGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *ApplicationSecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ApplicationSecurityGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ApplicationSecurityGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ApplicationSecurityGroupsClientDeleteResponse contains the response from method ApplicationSecurityGroupsClient.Delete.
type ApplicationSecurityGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsClientGetResponse contains the response from method ApplicationSecurityGroupsClient.Get.
type ApplicationSecurityGroupsClientGetResponse struct {
	ApplicationSecurityGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsClientListAllResponse contains the response from method ApplicationSecurityGroupsClient.ListAll.
type ApplicationSecurityGroupsClientListAllResponse struct {
	ApplicationSecurityGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsClientListResponse contains the response from method ApplicationSecurityGroupsClient.List.
type ApplicationSecurityGroupsClientListResponse struct {
	ApplicationSecurityGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ApplicationSecurityGroupsClientUpdateTagsResponse contains the response from method ApplicationSecurityGroupsClient.UpdateTags.
type ApplicationSecurityGroupsClientUpdateTagsResponse struct {
	ApplicationSecurityGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableDelegationsClientListResponse contains the response from method AvailableDelegationsClient.List.
type AvailableDelegationsClientListResponse struct {
	AvailableDelegationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableEndpointServicesClientListResponse contains the response from method AvailableEndpointServicesClient.List.
type AvailableEndpointServicesClientListResponse struct {
	EndpointServicesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailablePrivateEndpointTypesClientListByResourceGroupResponse contains the response from method AvailablePrivateEndpointTypesClient.ListByResourceGroup.
type AvailablePrivateEndpointTypesClientListByResourceGroupResponse struct {
	AvailablePrivateEndpointTypesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailablePrivateEndpointTypesClientListResponse contains the response from method AvailablePrivateEndpointTypesClient.List.
type AvailablePrivateEndpointTypesClientListResponse struct {
	AvailablePrivateEndpointTypesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableResourceGroupDelegationsClientListResponse contains the response from method AvailableResourceGroupDelegationsClient.List.
type AvailableResourceGroupDelegationsClientListResponse struct {
	AvailableDelegationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableServiceAliasesClientListByResourceGroupResponse contains the response from method AvailableServiceAliasesClient.ListByResourceGroup.
type AvailableServiceAliasesClientListByResourceGroupResponse struct {
	AvailableServiceAliasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AvailableServiceAliasesClientListResponse contains the response from method AvailableServiceAliasesClient.List.
type AvailableServiceAliasesClientListResponse struct {
	AvailableServiceAliasesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallFqdnTagsClientListAllResponse contains the response from method AzureFirewallFqdnTagsClient.ListAll.
type AzureFirewallFqdnTagsClientListAllResponse struct {
	AzureFirewallFqdnTagListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsClientCreateOrUpdatePollerResponse contains the response from method AzureFirewallsClient.CreateOrUpdate.
type AzureFirewallsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureFirewallsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AzureFirewallsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsClientCreateOrUpdateResponse, error) {
	respType := AzureFirewallsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureFirewall)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureFirewallsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AzureFirewallsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AzureFirewallsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AzureFirewallsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AzureFirewallsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureFirewallsClientCreateOrUpdateResponse contains the response from method AzureFirewallsClient.CreateOrUpdate.
type AzureFirewallsClientCreateOrUpdateResponse struct {
	AzureFirewall
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsClientDeletePollerResponse contains the response from method AzureFirewallsClient.Delete.
type AzureFirewallsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureFirewallsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AzureFirewallsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsClientDeleteResponse, error) {
	respType := AzureFirewallsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureFirewallsClientDeletePollerResponse from the provided client and resume token.
func (l *AzureFirewallsClientDeletePollerResponse) Resume(ctx context.Context, client *AzureFirewallsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AzureFirewallsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AzureFirewallsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureFirewallsClientDeleteResponse contains the response from method AzureFirewallsClient.Delete.
type AzureFirewallsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsClientGetResponse contains the response from method AzureFirewallsClient.Get.
type AzureFirewallsClientGetResponse struct {
	AzureFirewall
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsClientListAllResponse contains the response from method AzureFirewallsClient.ListAll.
type AzureFirewallsClientListAllResponse struct {
	AzureFirewallListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsClientListResponse contains the response from method AzureFirewallsClient.List.
type AzureFirewallsClientListResponse struct {
	AzureFirewallListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AzureFirewallsClientUpdateTagsPollerResponse contains the response from method AzureFirewallsClient.UpdateTags.
type AzureFirewallsClientUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AzureFirewallsClientUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AzureFirewallsClientUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsClientUpdateTagsResponse, error) {
	respType := AzureFirewallsClientUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureFirewall)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AzureFirewallsClientUpdateTagsPollerResponse from the provided client and resume token.
func (l *AzureFirewallsClientUpdateTagsPollerResponse) Resume(ctx context.Context, client *AzureFirewallsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AzureFirewallsClient.UpdateTags", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AzureFirewallsClientUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AzureFirewallsClientUpdateTagsResponse contains the response from method AzureFirewallsClient.UpdateTags.
type AzureFirewallsClientUpdateTagsResponse struct {
	AzureFirewall
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsClientCreateOrUpdatePollerResponse contains the response from method BastionHostsClient.CreateOrUpdate.
type BastionHostsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BastionHostsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BastionHostsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsClientCreateOrUpdateResponse, error) {
	respType := BastionHostsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BastionHost)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BastionHostsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *BastionHostsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *BastionHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BastionHostsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BastionHostsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BastionHostsClientCreateOrUpdateResponse contains the response from method BastionHostsClient.CreateOrUpdate.
type BastionHostsClientCreateOrUpdateResponse struct {
	BastionHost
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsClientDeletePollerResponse contains the response from method BastionHostsClient.Delete.
type BastionHostsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *BastionHostsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l BastionHostsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsClientDeleteResponse, error) {
	respType := BastionHostsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a BastionHostsClientDeletePollerResponse from the provided client and resume token.
func (l *BastionHostsClientDeletePollerResponse) Resume(ctx context.Context, client *BastionHostsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("BastionHostsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &BastionHostsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// BastionHostsClientDeleteResponse contains the response from method BastionHostsClient.Delete.
type BastionHostsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsClientGetResponse contains the response from method BastionHostsClient.Get.
type BastionHostsClientGetResponse struct {
	BastionHost
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsClientListByResourceGroupResponse contains the response from method BastionHostsClient.ListByResourceGroup.
type BastionHostsClientListByResourceGroupResponse struct {
	BastionHostListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BastionHostsClientListResponse contains the response from method BastionHostsClient.List.
type BastionHostsClientListResponse struct {
	BastionHostListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BgpServiceCommunitiesClientListResponse contains the response from method BgpServiceCommunitiesClient.List.
type BgpServiceCommunitiesClientListResponse struct {
	BgpServiceCommunityListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientCreateOrUpdatePollerResponse contains the response from method ConnectionMonitorsClient.CreateOrUpdate.
type ConnectionMonitorsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientCreateOrUpdateResponse, error) {
	respType := ConnectionMonitorsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionMonitorResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsClientCreateOrUpdateResponse contains the response from method ConnectionMonitorsClient.CreateOrUpdate.
type ConnectionMonitorsClientCreateOrUpdateResponse struct {
	ConnectionMonitorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientDeletePollerResponse contains the response from method ConnectionMonitorsClient.Delete.
type ConnectionMonitorsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientDeleteResponse, error) {
	respType := ConnectionMonitorsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsClientDeletePollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsClientDeletePollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsClientDeleteResponse contains the response from method ConnectionMonitorsClient.Delete.
type ConnectionMonitorsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientGetResponse contains the response from method ConnectionMonitorsClient.Get.
type ConnectionMonitorsClientGetResponse struct {
	ConnectionMonitorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientListResponse contains the response from method ConnectionMonitorsClient.List.
type ConnectionMonitorsClientListResponse struct {
	ConnectionMonitorListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientQueryPollerResponse contains the response from method ConnectionMonitorsClient.Query.
type ConnectionMonitorsClientQueryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsClientQueryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsClientQueryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientQueryResponse, error) {
	respType := ConnectionMonitorsClientQueryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionMonitorQueryResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsClientQueryPollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsClientQueryPollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Query", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsClientQueryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsClientQueryResponse contains the response from method ConnectionMonitorsClient.Query.
type ConnectionMonitorsClientQueryResponse struct {
	ConnectionMonitorQueryResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientStartPollerResponse contains the response from method ConnectionMonitorsClient.Start.
type ConnectionMonitorsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientStartResponse, error) {
	respType := ConnectionMonitorsClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsClientStartPollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsClientStartPollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsClientStartResponse contains the response from method ConnectionMonitorsClient.Start.
type ConnectionMonitorsClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientStopPollerResponse contains the response from method ConnectionMonitorsClient.Stop.
type ConnectionMonitorsClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ConnectionMonitorsClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ConnectionMonitorsClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientStopResponse, error) {
	respType := ConnectionMonitorsClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ConnectionMonitorsClientStopPollerResponse from the provided client and resume token.
func (l *ConnectionMonitorsClientStopPollerResponse) Resume(ctx context.Context, client *ConnectionMonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ConnectionMonitorsClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ConnectionMonitorsClientStopResponse contains the response from method ConnectionMonitorsClient.Stop.
type ConnectionMonitorsClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ConnectionMonitorsClientUpdateTagsResponse contains the response from method ConnectionMonitorsClient.UpdateTags.
type ConnectionMonitorsClientUpdateTagsResponse struct {
	ConnectionMonitorResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesClientCreateOrUpdatePollerResponse contains the response from method DdosCustomPoliciesClient.CreateOrUpdate.
type DdosCustomPoliciesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosCustomPoliciesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosCustomPoliciesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesClientCreateOrUpdateResponse, error) {
	respType := DdosCustomPoliciesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DdosCustomPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosCustomPoliciesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DdosCustomPoliciesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DdosCustomPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosCustomPoliciesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DdosCustomPoliciesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosCustomPoliciesClientCreateOrUpdateResponse contains the response from method DdosCustomPoliciesClient.CreateOrUpdate.
type DdosCustomPoliciesClientCreateOrUpdateResponse struct {
	DdosCustomPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesClientDeletePollerResponse contains the response from method DdosCustomPoliciesClient.Delete.
type DdosCustomPoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosCustomPoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosCustomPoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesClientDeleteResponse, error) {
	respType := DdosCustomPoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosCustomPoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *DdosCustomPoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *DdosCustomPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosCustomPoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DdosCustomPoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosCustomPoliciesClientDeleteResponse contains the response from method DdosCustomPoliciesClient.Delete.
type DdosCustomPoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesClientGetResponse contains the response from method DdosCustomPoliciesClient.Get.
type DdosCustomPoliciesClientGetResponse struct {
	DdosCustomPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosCustomPoliciesClientUpdateTagsResponse contains the response from method DdosCustomPoliciesClient.UpdateTags.
type DdosCustomPoliciesClientUpdateTagsResponse struct {
	DdosCustomPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansClientCreateOrUpdatePollerResponse contains the response from method DdosProtectionPlansClient.CreateOrUpdate.
type DdosProtectionPlansClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosProtectionPlansClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosProtectionPlansClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansClientCreateOrUpdateResponse, error) {
	respType := DdosProtectionPlansClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DdosProtectionPlan)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosProtectionPlansClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DdosProtectionPlansClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DdosProtectionPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosProtectionPlansClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DdosProtectionPlansClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosProtectionPlansClientCreateOrUpdateResponse contains the response from method DdosProtectionPlansClient.CreateOrUpdate.
type DdosProtectionPlansClientCreateOrUpdateResponse struct {
	DdosProtectionPlan
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansClientDeletePollerResponse contains the response from method DdosProtectionPlansClient.Delete.
type DdosProtectionPlansClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DdosProtectionPlansClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DdosProtectionPlansClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansClientDeleteResponse, error) {
	respType := DdosProtectionPlansClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DdosProtectionPlansClientDeletePollerResponse from the provided client and resume token.
func (l *DdosProtectionPlansClientDeletePollerResponse) Resume(ctx context.Context, client *DdosProtectionPlansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DdosProtectionPlansClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DdosProtectionPlansClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DdosProtectionPlansClientDeleteResponse contains the response from method DdosProtectionPlansClient.Delete.
type DdosProtectionPlansClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansClientGetResponse contains the response from method DdosProtectionPlansClient.Get.
type DdosProtectionPlansClientGetResponse struct {
	DdosProtectionPlan
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansClientListByResourceGroupResponse contains the response from method DdosProtectionPlansClient.ListByResourceGroup.
type DdosProtectionPlansClientListByResourceGroupResponse struct {
	DdosProtectionPlanListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansClientListResponse contains the response from method DdosProtectionPlansClient.List.
type DdosProtectionPlansClientListResponse struct {
	DdosProtectionPlanListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DdosProtectionPlansClientUpdateTagsResponse contains the response from method DdosProtectionPlansClient.UpdateTags.
type DdosProtectionPlansClientUpdateTagsResponse struct {
	DdosProtectionPlan
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DefaultSecurityRulesClientGetResponse contains the response from method DefaultSecurityRulesClient.Get.
type DefaultSecurityRulesClientGetResponse struct {
	SecurityRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DefaultSecurityRulesClientListResponse contains the response from method DefaultSecurityRulesClient.List.
type DefaultSecurityRulesClientListResponse struct {
	SecurityRuleListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitAuthorizationsClient.CreateOrUpdate.
type ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitAuthorizationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitAuthorizationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse contains the response from method ExpressRouteCircuitAuthorizationsClient.CreateOrUpdate.
type ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse struct {
	ExpressRouteCircuitAuthorization
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsClientDeletePollerResponse contains the response from method ExpressRouteCircuitAuthorizationsClient.Delete.
type ExpressRouteCircuitAuthorizationsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitAuthorizationsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitAuthorizationsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsClientDeleteResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitAuthorizationsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitAuthorizationsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitAuthorizationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitAuthorizationsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitAuthorizationsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitAuthorizationsClientDeleteResponse contains the response from method ExpressRouteCircuitAuthorizationsClient.Delete.
type ExpressRouteCircuitAuthorizationsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsClientGetResponse contains the response from method ExpressRouteCircuitAuthorizationsClient.Get.
type ExpressRouteCircuitAuthorizationsClientGetResponse struct {
	ExpressRouteCircuitAuthorization
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitAuthorizationsClientListResponse contains the response from method ExpressRouteCircuitAuthorizationsClient.List.
type ExpressRouteCircuitAuthorizationsClientListResponse struct {
	AuthorizationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitConnectionsClient.CreateOrUpdate.
type ExpressRouteCircuitConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *ExpressRouteCircuitConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse contains the response from method ExpressRouteCircuitConnectionsClient.CreateOrUpdate.
type ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse struct {
	ExpressRouteCircuitConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsClientDeletePollerResponse contains the response from method ExpressRouteCircuitConnectionsClient.Delete.
type ExpressRouteCircuitConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsClientDeleteResponse, error) {
	respType := ExpressRouteCircuitConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitConnectionsClientDeleteResponse contains the response from method ExpressRouteCircuitConnectionsClient.Delete.
type ExpressRouteCircuitConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsClientGetResponse contains the response from method ExpressRouteCircuitConnectionsClient.Get.
type ExpressRouteCircuitConnectionsClientGetResponse struct {
	ExpressRouteCircuitConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitConnectionsClientListResponse contains the response from method ExpressRouteCircuitConnectionsClient.List.
type ExpressRouteCircuitConnectionsClientListResponse struct {
	ExpressRouteCircuitConnectionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitPeeringsClient.CreateOrUpdate.
type ExpressRouteCircuitPeeringsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitPeeringsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitPeeringsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitPeeringsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitPeeringsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse contains the response from method ExpressRouteCircuitPeeringsClient.CreateOrUpdate.
type ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse struct {
	ExpressRouteCircuitPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsClientDeletePollerResponse contains the response from method ExpressRouteCircuitPeeringsClient.Delete.
type ExpressRouteCircuitPeeringsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitPeeringsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitPeeringsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsClientDeleteResponse, error) {
	respType := ExpressRouteCircuitPeeringsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitPeeringsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitPeeringsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitPeeringsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitPeeringsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitPeeringsClientDeleteResponse contains the response from method ExpressRouteCircuitPeeringsClient.Delete.
type ExpressRouteCircuitPeeringsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsClientGetResponse contains the response from method ExpressRouteCircuitPeeringsClient.Get.
type ExpressRouteCircuitPeeringsClientGetResponse struct {
	ExpressRouteCircuitPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitPeeringsClientListResponse contains the response from method ExpressRouteCircuitPeeringsClient.List.
type ExpressRouteCircuitPeeringsClientListResponse struct {
	ExpressRouteCircuitPeeringListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteCircuitsClient.CreateOrUpdate.
type ExpressRouteCircuitsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuit)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsClientCreateOrUpdateResponse contains the response from method ExpressRouteCircuitsClient.CreateOrUpdate.
type ExpressRouteCircuitsClientCreateOrUpdateResponse struct {
	ExpressRouteCircuit
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientDeletePollerResponse contains the response from method ExpressRouteCircuitsClient.Delete.
type ExpressRouteCircuitsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientDeleteResponse, error) {
	respType := ExpressRouteCircuitsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsClientDeleteResponse contains the response from method ExpressRouteCircuitsClient.Delete.
type ExpressRouteCircuitsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientGetPeeringStatsResponse contains the response from method ExpressRouteCircuitsClient.GetPeeringStats.
type ExpressRouteCircuitsClientGetPeeringStatsResponse struct {
	ExpressRouteCircuitStats
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientGetResponse contains the response from method ExpressRouteCircuitsClient.Get.
type ExpressRouteCircuitsClientGetResponse struct {
	ExpressRouteCircuit
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientGetStatsResponse contains the response from method ExpressRouteCircuitsClient.GetStats.
type ExpressRouteCircuitsClientGetStatsResponse struct {
	ExpressRouteCircuitStats
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientListAllResponse contains the response from method ExpressRouteCircuitsClient.ListAll.
type ExpressRouteCircuitsClientListAllResponse struct {
	ExpressRouteCircuitListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientListArpTablePollerResponse contains the response from method ExpressRouteCircuitsClient.ListArpTable.
type ExpressRouteCircuitsClientListArpTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsClientListArpTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsClientListArpTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientListArpTableResponse, error) {
	respType := ExpressRouteCircuitsClientListArpTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsClientListArpTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsClientListArpTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListArpTable", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsClientListArpTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsClientListArpTableResponse contains the response from method ExpressRouteCircuitsClient.ListArpTable.
type ExpressRouteCircuitsClientListArpTableResponse struct {
	ExpressRouteCircuitsArpTableListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientListResponse contains the response from method ExpressRouteCircuitsClient.List.
type ExpressRouteCircuitsClientListResponse struct {
	ExpressRouteCircuitListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientListRoutesTablePollerResponse contains the response from method ExpressRouteCircuitsClient.ListRoutesTable.
type ExpressRouteCircuitsClientListRoutesTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsClientListRoutesTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsClientListRoutesTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientListRoutesTableResponse, error) {
	respType := ExpressRouteCircuitsClientListRoutesTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsClientListRoutesTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCircuitsClientListRoutesTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListRoutesTable", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsClientListRoutesTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsClientListRoutesTableResponse contains the response from method ExpressRouteCircuitsClient.ListRoutesTable.
type ExpressRouteCircuitsClientListRoutesTableResponse struct {
	ExpressRouteCircuitsRoutesTableListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientListRoutesTableSummaryPollerResponse contains the response from method ExpressRouteCircuitsClient.ListRoutesTableSummary.
type ExpressRouteCircuitsClientListRoutesTableSummaryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCircuitsClientListRoutesTableSummaryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCircuitsClientListRoutesTableSummaryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCircuitsClientListRoutesTableSummaryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCircuitsClientListRoutesTableSummaryPollerResponse from the provided client and resume
// token.
func (l *ExpressRouteCircuitsClientListRoutesTableSummaryPollerResponse) Resume(ctx context.Context, client *ExpressRouteCircuitsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListRoutesTableSummary", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCircuitsClientListRoutesTableSummaryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCircuitsClientListRoutesTableSummaryResponse contains the response from method ExpressRouteCircuitsClient.ListRoutesTableSummary.
type ExpressRouteCircuitsClientListRoutesTableSummaryResponse struct {
	ExpressRouteCircuitsRoutesTableSummaryListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCircuitsClientUpdateTagsResponse contains the response from method ExpressRouteCircuitsClient.UpdateTags.
type ExpressRouteCircuitsClientUpdateTagsResponse struct {
	ExpressRouteCircuit
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteConnectionsClient.CreateOrUpdate.
type ExpressRouteConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteConnectionsClientCreateOrUpdateResponse contains the response from method ExpressRouteConnectionsClient.CreateOrUpdate.
type ExpressRouteConnectionsClientCreateOrUpdateResponse struct {
	ExpressRouteConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsClientDeletePollerResponse contains the response from method ExpressRouteConnectionsClient.Delete.
type ExpressRouteConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsClientDeleteResponse, error) {
	respType := ExpressRouteConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteConnectionsClientDeleteResponse contains the response from method ExpressRouteConnectionsClient.Delete.
type ExpressRouteConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsClientGetResponse contains the response from method ExpressRouteConnectionsClient.Get.
type ExpressRouteConnectionsClientGetResponse struct {
	ExpressRouteConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteConnectionsClientListResponse contains the response from method ExpressRouteConnectionsClient.List.
type ExpressRouteConnectionsClientListResponse struct {
	ExpressRouteConnectionList
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteCrossConnectionPeeringsClient.CreateOrUpdate.
type ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePollerResponse from the provided client and
// resume token.
func (l *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionPeeringsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse contains the response from method ExpressRouteCrossConnectionPeeringsClient.CreateOrUpdate.
type ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse struct {
	ExpressRouteCrossConnectionPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsClientDeletePollerResponse contains the response from method ExpressRouteCrossConnectionPeeringsClient.Delete.
type ExpressRouteCrossConnectionPeeringsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionPeeringsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionPeeringsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsClientDeleteResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionPeeringsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionPeeringsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionPeeringsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionPeeringsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionPeeringsClientDeleteResponse contains the response from method ExpressRouteCrossConnectionPeeringsClient.Delete.
type ExpressRouteCrossConnectionPeeringsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsClientGetResponse contains the response from method ExpressRouteCrossConnectionPeeringsClient.Get.
type ExpressRouteCrossConnectionPeeringsClientGetResponse struct {
	ExpressRouteCrossConnectionPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionPeeringsClientListResponse contains the response from method ExpressRouteCrossConnectionPeeringsClient.List.
type ExpressRouteCrossConnectionPeeringsClientListResponse struct {
	ExpressRouteCrossConnectionPeeringList
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteCrossConnectionsClient.CreateOrUpdate.
type ExpressRouteCrossConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *ExpressRouteCrossConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsClientCreateOrUpdateResponse contains the response from method ExpressRouteCrossConnectionsClient.CreateOrUpdate.
type ExpressRouteCrossConnectionsClientCreateOrUpdateResponse struct {
	ExpressRouteCrossConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientGetResponse contains the response from method ExpressRouteCrossConnectionsClient.Get.
type ExpressRouteCrossConnectionsClientGetResponse struct {
	ExpressRouteCrossConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientListArpTablePollerResponse contains the response from method ExpressRouteCrossConnectionsClient.ListArpTable.
type ExpressRouteCrossConnectionsClientListArpTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsClientListArpTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsClientListArpTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientListArpTableResponse, error) {
	respType := ExpressRouteCrossConnectionsClientListArpTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientListArpTablePollerResponse from the provided client and resume token.
func (l *ExpressRouteCrossConnectionsClientListArpTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListArpTable", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsClientListArpTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsClientListArpTableResponse contains the response from method ExpressRouteCrossConnectionsClient.ListArpTable.
type ExpressRouteCrossConnectionsClientListArpTableResponse struct {
	ExpressRouteCircuitsArpTableListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientListByResourceGroupResponse contains the response from method ExpressRouteCrossConnectionsClient.ListByResourceGroup.
type ExpressRouteCrossConnectionsClientListByResourceGroupResponse struct {
	ExpressRouteCrossConnectionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientListResponse contains the response from method ExpressRouteCrossConnectionsClient.List.
type ExpressRouteCrossConnectionsClientListResponse struct {
	ExpressRouteCrossConnectionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientListRoutesTablePollerResponse contains the response from method ExpressRouteCrossConnectionsClient.ListRoutesTable.
type ExpressRouteCrossConnectionsClientListRoutesTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsClientListRoutesTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsClientListRoutesTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientListRoutesTableResponse, error) {
	respType := ExpressRouteCrossConnectionsClientListRoutesTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientListRoutesTablePollerResponse from the provided client and resume
// token.
func (l *ExpressRouteCrossConnectionsClientListRoutesTablePollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListRoutesTable", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsClientListRoutesTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsClientListRoutesTableResponse contains the response from method ExpressRouteCrossConnectionsClient.ListRoutesTable.
type ExpressRouteCrossConnectionsClientListRoutesTableResponse struct {
	ExpressRouteCircuitsRoutesTableListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientListRoutesTableSummaryPollerResponse contains the response from method ExpressRouteCrossConnectionsClient.ListRoutesTableSummary.
type ExpressRouteCrossConnectionsClientListRoutesTableSummaryPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteCrossConnectionsClientListRoutesTableSummaryPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientListRoutesTableSummaryPollerResponse from the provided client and
// resume token.
func (l *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPollerResponse) Resume(ctx context.Context, client *ExpressRouteCrossConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListRoutesTableSummary", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse contains the response from method ExpressRouteCrossConnectionsClient.ListRoutesTableSummary.
type ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse struct {
	ExpressRouteCrossConnectionsRoutesTableSummaryListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteCrossConnectionsClientUpdateTagsResponse contains the response from method ExpressRouteCrossConnectionsClient.UpdateTags.
type ExpressRouteCrossConnectionsClientUpdateTagsResponse struct {
	ExpressRouteCrossConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysClientCreateOrUpdatePollerResponse contains the response from method ExpressRouteGatewaysClient.CreateOrUpdate.
type ExpressRouteGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysClientCreateOrUpdateResponse, error) {
	respType := ExpressRouteGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRouteGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRouteGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteGatewaysClientCreateOrUpdateResponse contains the response from method ExpressRouteGatewaysClient.CreateOrUpdate.
type ExpressRouteGatewaysClientCreateOrUpdateResponse struct {
	ExpressRouteGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysClientDeletePollerResponse contains the response from method ExpressRouteGatewaysClient.Delete.
type ExpressRouteGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRouteGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRouteGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysClientDeleteResponse, error) {
	respType := ExpressRouteGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRouteGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRouteGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRouteGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRouteGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRouteGatewaysClientDeleteResponse contains the response from method ExpressRouteGatewaysClient.Delete.
type ExpressRouteGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysClientGetResponse contains the response from method ExpressRouteGatewaysClient.Get.
type ExpressRouteGatewaysClientGetResponse struct {
	ExpressRouteGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysClientListByResourceGroupResponse contains the response from method ExpressRouteGatewaysClient.ListByResourceGroup.
type ExpressRouteGatewaysClientListByResourceGroupResponse struct {
	ExpressRouteGatewayList
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteGatewaysClientListBySubscriptionResponse contains the response from method ExpressRouteGatewaysClient.ListBySubscription.
type ExpressRouteGatewaysClientListBySubscriptionResponse struct {
	ExpressRouteGatewayList
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteLinksClientGetResponse contains the response from method ExpressRouteLinksClient.Get.
type ExpressRouteLinksClientGetResponse struct {
	ExpressRouteLink
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteLinksClientListResponse contains the response from method ExpressRouteLinksClient.List.
type ExpressRouteLinksClientListResponse struct {
	ExpressRouteLinkListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsClientCreateOrUpdatePollerResponse contains the response from method ExpressRoutePortsClient.CreateOrUpdate.
type ExpressRoutePortsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRoutePortsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRoutePortsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsClientCreateOrUpdateResponse, error) {
	respType := ExpressRoutePortsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ExpressRoutePort)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRoutePortsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ExpressRoutePortsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ExpressRoutePortsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRoutePortsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRoutePortsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRoutePortsClientCreateOrUpdateResponse contains the response from method ExpressRoutePortsClient.CreateOrUpdate.
type ExpressRoutePortsClientCreateOrUpdateResponse struct {
	ExpressRoutePort
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsClientDeletePollerResponse contains the response from method ExpressRoutePortsClient.Delete.
type ExpressRoutePortsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ExpressRoutePortsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ExpressRoutePortsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsClientDeleteResponse, error) {
	respType := ExpressRoutePortsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ExpressRoutePortsClientDeletePollerResponse from the provided client and resume token.
func (l *ExpressRoutePortsClientDeletePollerResponse) Resume(ctx context.Context, client *ExpressRoutePortsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ExpressRoutePortsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ExpressRoutePortsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ExpressRoutePortsClientDeleteResponse contains the response from method ExpressRoutePortsClient.Delete.
type ExpressRoutePortsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsClientGetResponse contains the response from method ExpressRoutePortsClient.Get.
type ExpressRoutePortsClientGetResponse struct {
	ExpressRoutePort
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsClientListByResourceGroupResponse contains the response from method ExpressRoutePortsClient.ListByResourceGroup.
type ExpressRoutePortsClientListByResourceGroupResponse struct {
	ExpressRoutePortListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsClientListResponse contains the response from method ExpressRoutePortsClient.List.
type ExpressRoutePortsClientListResponse struct {
	ExpressRoutePortListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsClientUpdateTagsResponse contains the response from method ExpressRoutePortsClient.UpdateTags.
type ExpressRoutePortsClientUpdateTagsResponse struct {
	ExpressRoutePort
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsLocationsClientGetResponse contains the response from method ExpressRoutePortsLocationsClient.Get.
type ExpressRoutePortsLocationsClientGetResponse struct {
	ExpressRoutePortsLocation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRoutePortsLocationsClientListResponse contains the response from method ExpressRoutePortsLocationsClient.List.
type ExpressRoutePortsLocationsClientListResponse struct {
	ExpressRoutePortsLocationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ExpressRouteServiceProvidersClientListResponse contains the response from method ExpressRouteServiceProvidersClient.List.
type ExpressRouteServiceProvidersClientListResponse struct {
	ExpressRouteServiceProviderListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesClientCreateOrUpdatePollerResponse contains the response from method FirewallPoliciesClient.CreateOrUpdate.
type FirewallPoliciesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPoliciesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPoliciesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesClientCreateOrUpdateResponse, error) {
	respType := FirewallPoliciesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FirewallPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPoliciesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FirewallPoliciesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FirewallPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPoliciesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FirewallPoliciesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPoliciesClientCreateOrUpdateResponse contains the response from method FirewallPoliciesClient.CreateOrUpdate.
type FirewallPoliciesClientCreateOrUpdateResponse struct {
	FirewallPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesClientDeletePollerResponse contains the response from method FirewallPoliciesClient.Delete.
type FirewallPoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesClientDeleteResponse, error) {
	respType := FirewallPoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *FirewallPoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *FirewallPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FirewallPoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPoliciesClientDeleteResponse contains the response from method FirewallPoliciesClient.Delete.
type FirewallPoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesClientGetResponse contains the response from method FirewallPoliciesClient.Get.
type FirewallPoliciesClientGetResponse struct {
	FirewallPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesClientListAllResponse contains the response from method FirewallPoliciesClient.ListAll.
type FirewallPoliciesClientListAllResponse struct {
	FirewallPolicyListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPoliciesClientListResponse contains the response from method FirewallPoliciesClient.List.
type FirewallPoliciesClientListResponse struct {
	FirewallPolicyListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleGroupsClientCreateOrUpdatePollerResponse contains the response from method FirewallPolicyRuleGroupsClient.CreateOrUpdate.
type FirewallPolicyRuleGroupsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPolicyRuleGroupsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleGroupsClientCreateOrUpdateResponse, error) {
	respType := FirewallPolicyRuleGroupsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FirewallPolicyRuleGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPolicyRuleGroupsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FirewallPolicyRuleGroupsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FirewallPolicyRuleGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPolicyRuleGroupsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FirewallPolicyRuleGroupsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPolicyRuleGroupsClientCreateOrUpdateResponse contains the response from method FirewallPolicyRuleGroupsClient.CreateOrUpdate.
type FirewallPolicyRuleGroupsClientCreateOrUpdateResponse struct {
	FirewallPolicyRuleGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleGroupsClientDeletePollerResponse contains the response from method FirewallPolicyRuleGroupsClient.Delete.
type FirewallPolicyRuleGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FirewallPolicyRuleGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FirewallPolicyRuleGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleGroupsClientDeleteResponse, error) {
	respType := FirewallPolicyRuleGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FirewallPolicyRuleGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *FirewallPolicyRuleGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *FirewallPolicyRuleGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FirewallPolicyRuleGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FirewallPolicyRuleGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FirewallPolicyRuleGroupsClientDeleteResponse contains the response from method FirewallPolicyRuleGroupsClient.Delete.
type FirewallPolicyRuleGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleGroupsClientGetResponse contains the response from method FirewallPolicyRuleGroupsClient.Get.
type FirewallPolicyRuleGroupsClientGetResponse struct {
	FirewallPolicyRuleGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FirewallPolicyRuleGroupsClientListResponse contains the response from method FirewallPolicyRuleGroupsClient.List.
type FirewallPolicyRuleGroupsClientListResponse struct {
	FirewallPolicyRuleGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsClientCreateOrUpdatePollerResponse contains the response from method FlowLogsClient.CreateOrUpdate.
type FlowLogsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FlowLogsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FlowLogsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsClientCreateOrUpdateResponse, error) {
	respType := FlowLogsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FlowLog)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FlowLogsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FlowLogsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FlowLogsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FlowLogsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FlowLogsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FlowLogsClientCreateOrUpdateResponse contains the response from method FlowLogsClient.CreateOrUpdate.
type FlowLogsClientCreateOrUpdateResponse struct {
	FlowLog
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsClientDeletePollerResponse contains the response from method FlowLogsClient.Delete.
type FlowLogsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FlowLogsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FlowLogsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsClientDeleteResponse, error) {
	respType := FlowLogsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a FlowLogsClientDeletePollerResponse from the provided client and resume token.
func (l *FlowLogsClientDeletePollerResponse) Resume(ctx context.Context, client *FlowLogsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FlowLogsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FlowLogsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// FlowLogsClientDeleteResponse contains the response from method FlowLogsClient.Delete.
type FlowLogsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsClientGetResponse contains the response from method FlowLogsClient.Get.
type FlowLogsClientGetResponse struct {
	FlowLog
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FlowLogsClientListResponse contains the response from method FlowLogsClient.List.
type FlowLogsClientListResponse struct {
	FlowLogListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubVirtualNetworkConnectionsClientGetResponse contains the response from method HubVirtualNetworkConnectionsClient.Get.
type HubVirtualNetworkConnectionsClientGetResponse struct {
	HubVirtualNetworkConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HubVirtualNetworkConnectionsClientListResponse contains the response from method HubVirtualNetworkConnectionsClient.List.
type HubVirtualNetworkConnectionsClientListResponse struct {
	ListHubVirtualNetworkConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsClientCreateOrUpdatePollerResponse contains the response from method IPAllocationsClient.CreateOrUpdate.
type IPAllocationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPAllocationsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPAllocationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsClientCreateOrUpdateResponse, error) {
	respType := IPAllocationsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IPAllocation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPAllocationsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IPAllocationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IPAllocationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPAllocationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IPAllocationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPAllocationsClientCreateOrUpdateResponse contains the response from method IPAllocationsClient.CreateOrUpdate.
type IPAllocationsClientCreateOrUpdateResponse struct {
	IPAllocation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsClientDeletePollerResponse contains the response from method IPAllocationsClient.Delete.
type IPAllocationsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPAllocationsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPAllocationsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsClientDeleteResponse, error) {
	respType := IPAllocationsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPAllocationsClientDeletePollerResponse from the provided client and resume token.
func (l *IPAllocationsClientDeletePollerResponse) Resume(ctx context.Context, client *IPAllocationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPAllocationsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IPAllocationsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPAllocationsClientDeleteResponse contains the response from method IPAllocationsClient.Delete.
type IPAllocationsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsClientGetResponse contains the response from method IPAllocationsClient.Get.
type IPAllocationsClientGetResponse struct {
	IPAllocation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsClientListByResourceGroupResponse contains the response from method IPAllocationsClient.ListByResourceGroup.
type IPAllocationsClientListByResourceGroupResponse struct {
	IPAllocationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsClientListResponse contains the response from method IPAllocationsClient.List.
type IPAllocationsClientListResponse struct {
	IPAllocationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPAllocationsClientUpdateTagsResponse contains the response from method IPAllocationsClient.UpdateTags.
type IPAllocationsClientUpdateTagsResponse struct {
	IPAllocation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsClientCreateOrUpdatePollerResponse contains the response from method IPGroupsClient.CreateOrUpdate.
type IPGroupsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPGroupsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPGroupsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsClientCreateOrUpdateResponse, error) {
	respType := IPGroupsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.IPGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPGroupsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *IPGroupsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *IPGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPGroupsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IPGroupsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPGroupsClientCreateOrUpdateResponse contains the response from method IPGroupsClient.CreateOrUpdate.
type IPGroupsClientCreateOrUpdateResponse struct {
	IPGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsClientDeletePollerResponse contains the response from method IPGroupsClient.Delete.
type IPGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *IPGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l IPGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsClientDeleteResponse, error) {
	respType := IPGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a IPGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *IPGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *IPGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("IPGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &IPGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// IPGroupsClientDeleteResponse contains the response from method IPGroupsClient.Delete.
type IPGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsClientGetResponse contains the response from method IPGroupsClient.Get.
type IPGroupsClientGetResponse struct {
	IPGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsClientListByResourceGroupResponse contains the response from method IPGroupsClient.ListByResourceGroup.
type IPGroupsClientListByResourceGroupResponse struct {
	IPGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsClientListResponse contains the response from method IPGroupsClient.List.
type IPGroupsClientListResponse struct {
	IPGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IPGroupsClientUpdateGroupsResponse contains the response from method IPGroupsClient.UpdateGroups.
type IPGroupsClientUpdateGroupsResponse struct {
	IPGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesClientCreateOrUpdatePollerResponse contains the response from method InboundNatRulesClient.CreateOrUpdate.
type InboundNatRulesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InboundNatRulesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InboundNatRulesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesClientCreateOrUpdateResponse, error) {
	respType := InboundNatRulesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InboundNatRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InboundNatRulesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InboundNatRulesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InboundNatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InboundNatRulesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InboundNatRulesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InboundNatRulesClientCreateOrUpdateResponse contains the response from method InboundNatRulesClient.CreateOrUpdate.
type InboundNatRulesClientCreateOrUpdateResponse struct {
	InboundNatRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesClientDeletePollerResponse contains the response from method InboundNatRulesClient.Delete.
type InboundNatRulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InboundNatRulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InboundNatRulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesClientDeleteResponse, error) {
	respType := InboundNatRulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InboundNatRulesClientDeletePollerResponse from the provided client and resume token.
func (l *InboundNatRulesClientDeletePollerResponse) Resume(ctx context.Context, client *InboundNatRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InboundNatRulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InboundNatRulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InboundNatRulesClientDeleteResponse contains the response from method InboundNatRulesClient.Delete.
type InboundNatRulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesClientGetResponse contains the response from method InboundNatRulesClient.Get.
type InboundNatRulesClientGetResponse struct {
	InboundNatRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InboundNatRulesClientListResponse contains the response from method InboundNatRulesClient.List.
type InboundNatRulesClientListResponse struct {
	InboundNatRuleListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceIPConfigurationsClientGetResponse contains the response from method InterfaceIPConfigurationsClient.Get.
type InterfaceIPConfigurationsClientGetResponse struct {
	InterfaceIPConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceIPConfigurationsClientListResponse contains the response from method InterfaceIPConfigurationsClient.List.
type InterfaceIPConfigurationsClientListResponse struct {
	InterfaceIPConfigurationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceLoadBalancersClientListResponse contains the response from method InterfaceLoadBalancersClient.List.
type InterfaceLoadBalancersClientListResponse struct {
	InterfaceLoadBalancerListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceTapConfigurationsClientCreateOrUpdatePollerResponse contains the response from method InterfaceTapConfigurationsClient.CreateOrUpdate.
type InterfaceTapConfigurationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InterfaceTapConfigurationsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InterfaceTapConfigurationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InterfaceTapConfigurationsClientCreateOrUpdateResponse, error) {
	respType := InterfaceTapConfigurationsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.InterfaceTapConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InterfaceTapConfigurationsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InterfaceTapConfigurationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InterfaceTapConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InterfaceTapConfigurationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InterfaceTapConfigurationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InterfaceTapConfigurationsClientCreateOrUpdateResponse contains the response from method InterfaceTapConfigurationsClient.CreateOrUpdate.
type InterfaceTapConfigurationsClientCreateOrUpdateResponse struct {
	InterfaceTapConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceTapConfigurationsClientDeletePollerResponse contains the response from method InterfaceTapConfigurationsClient.Delete.
type InterfaceTapConfigurationsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InterfaceTapConfigurationsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InterfaceTapConfigurationsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InterfaceTapConfigurationsClientDeleteResponse, error) {
	respType := InterfaceTapConfigurationsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InterfaceTapConfigurationsClientDeletePollerResponse from the provided client and resume token.
func (l *InterfaceTapConfigurationsClientDeletePollerResponse) Resume(ctx context.Context, client *InterfaceTapConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InterfaceTapConfigurationsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InterfaceTapConfigurationsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InterfaceTapConfigurationsClientDeleteResponse contains the response from method InterfaceTapConfigurationsClient.Delete.
type InterfaceTapConfigurationsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceTapConfigurationsClientGetResponse contains the response from method InterfaceTapConfigurationsClient.Get.
type InterfaceTapConfigurationsClientGetResponse struct {
	InterfaceTapConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfaceTapConfigurationsClientListResponse contains the response from method InterfaceTapConfigurationsClient.List.
type InterfaceTapConfigurationsClientListResponse struct {
	InterfaceTapConfigurationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientCreateOrUpdatePollerResponse contains the response from method InterfacesClient.CreateOrUpdate.
type InterfacesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InterfacesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InterfacesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientCreateOrUpdateResponse, error) {
	respType := InterfacesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Interface)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InterfacesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *InterfacesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *InterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InterfacesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InterfacesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InterfacesClientCreateOrUpdateResponse contains the response from method InterfacesClient.CreateOrUpdate.
type InterfacesClientCreateOrUpdateResponse struct {
	Interface
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientDeletePollerResponse contains the response from method InterfacesClient.Delete.
type InterfacesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InterfacesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InterfacesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientDeleteResponse, error) {
	respType := InterfacesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InterfacesClientDeletePollerResponse from the provided client and resume token.
func (l *InterfacesClientDeletePollerResponse) Resume(ctx context.Context, client *InterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InterfacesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InterfacesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InterfacesClientDeleteResponse contains the response from method InterfacesClient.Delete.
type InterfacesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientGetEffectiveRouteTablePollerResponse contains the response from method InterfacesClient.GetEffectiveRouteTable.
type InterfacesClientGetEffectiveRouteTablePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InterfacesClientGetEffectiveRouteTablePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InterfacesClientGetEffectiveRouteTablePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientGetEffectiveRouteTableResponse, error) {
	respType := InterfacesClientGetEffectiveRouteTableResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.EffectiveRouteListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InterfacesClientGetEffectiveRouteTablePollerResponse from the provided client and resume token.
func (l *InterfacesClientGetEffectiveRouteTablePollerResponse) Resume(ctx context.Context, client *InterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InterfacesClient.GetEffectiveRouteTable", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InterfacesClientGetEffectiveRouteTablePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InterfacesClientGetEffectiveRouteTableResponse contains the response from method InterfacesClient.GetEffectiveRouteTable.
type InterfacesClientGetEffectiveRouteTableResponse struct {
	EffectiveRouteListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientGetResponse contains the response from method InterfacesClient.Get.
type InterfacesClientGetResponse struct {
	Interface
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientGetVirtualMachineScaleSetIPConfigurationResponse contains the response from method InterfacesClient.GetVirtualMachineScaleSetIPConfiguration.
type InterfacesClientGetVirtualMachineScaleSetIPConfigurationResponse struct {
	InterfaceIPConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientGetVirtualMachineScaleSetNetworkInterfaceResponse contains the response from method InterfacesClient.GetVirtualMachineScaleSetNetworkInterface.
type InterfacesClientGetVirtualMachineScaleSetNetworkInterfaceResponse struct {
	Interface
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientListAllResponse contains the response from method InterfacesClient.ListAll.
type InterfacesClientListAllResponse struct {
	InterfaceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientListEffectiveNetworkSecurityGroupsPollerResponse contains the response from method InterfacesClient.ListEffectiveNetworkSecurityGroups.
type InterfacesClientListEffectiveNetworkSecurityGroupsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *InterfacesClientListEffectiveNetworkSecurityGroupsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l InterfacesClientListEffectiveNetworkSecurityGroupsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientListEffectiveNetworkSecurityGroupsResponse, error) {
	respType := InterfacesClientListEffectiveNetworkSecurityGroupsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a InterfacesClientListEffectiveNetworkSecurityGroupsPollerResponse from the provided client and resume
// token.
func (l *InterfacesClientListEffectiveNetworkSecurityGroupsPollerResponse) Resume(ctx context.Context, client *InterfacesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("InterfacesClient.ListEffectiveNetworkSecurityGroups", token, client.pl)
	if err != nil {
		return err
	}
	poller := &InterfacesClientListEffectiveNetworkSecurityGroupsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// InterfacesClientListEffectiveNetworkSecurityGroupsResponse contains the response from method InterfacesClient.ListEffectiveNetworkSecurityGroups.
type InterfacesClientListEffectiveNetworkSecurityGroupsResponse struct {
	EffectiveNetworkSecurityGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientListResponse contains the response from method InterfacesClient.List.
type InterfacesClientListResponse struct {
	InterfaceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse contains the response from method InterfacesClient.ListVirtualMachineScaleSetIPConfigurations.
type InterfacesClientListVirtualMachineScaleSetIPConfigurationsResponse struct {
	InterfaceIPConfigurationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse contains the response from method InterfacesClient.ListVirtualMachineScaleSetNetworkInterfaces.
type InterfacesClientListVirtualMachineScaleSetNetworkInterfacesResponse struct {
	InterfaceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse contains the response from method InterfacesClient.ListVirtualMachineScaleSetVMNetworkInterfaces.
type InterfacesClientListVirtualMachineScaleSetVMNetworkInterfacesResponse struct {
	InterfaceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InterfacesClientUpdateTagsResponse contains the response from method InterfacesClient.UpdateTags.
type InterfacesClientUpdateTagsResponse struct {
	Interface
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerBackendAddressPoolsClientGetResponse contains the response from method LoadBalancerBackendAddressPoolsClient.Get.
type LoadBalancerBackendAddressPoolsClientGetResponse struct {
	BackendAddressPool
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerBackendAddressPoolsClientListResponse contains the response from method LoadBalancerBackendAddressPoolsClient.List.
type LoadBalancerBackendAddressPoolsClientListResponse struct {
	LoadBalancerBackendAddressPoolListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerFrontendIPConfigurationsClientGetResponse contains the response from method LoadBalancerFrontendIPConfigurationsClient.Get.
type LoadBalancerFrontendIPConfigurationsClientGetResponse struct {
	FrontendIPConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerFrontendIPConfigurationsClientListResponse contains the response from method LoadBalancerFrontendIPConfigurationsClient.List.
type LoadBalancerFrontendIPConfigurationsClientListResponse struct {
	LoadBalancerFrontendIPConfigurationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerLoadBalancingRulesClientGetResponse contains the response from method LoadBalancerLoadBalancingRulesClient.Get.
type LoadBalancerLoadBalancingRulesClientGetResponse struct {
	LoadBalancingRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerLoadBalancingRulesClientListResponse contains the response from method LoadBalancerLoadBalancingRulesClient.List.
type LoadBalancerLoadBalancingRulesClientListResponse struct {
	LoadBalancerLoadBalancingRuleListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerNetworkInterfacesClientListResponse contains the response from method LoadBalancerNetworkInterfacesClient.List.
type LoadBalancerNetworkInterfacesClientListResponse struct {
	InterfaceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerOutboundRulesClientGetResponse contains the response from method LoadBalancerOutboundRulesClient.Get.
type LoadBalancerOutboundRulesClientGetResponse struct {
	OutboundRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerOutboundRulesClientListResponse contains the response from method LoadBalancerOutboundRulesClient.List.
type LoadBalancerOutboundRulesClientListResponse struct {
	LoadBalancerOutboundRuleListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerProbesClientGetResponse contains the response from method LoadBalancerProbesClient.Get.
type LoadBalancerProbesClientGetResponse struct {
	Probe
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancerProbesClientListResponse contains the response from method LoadBalancerProbesClient.List.
type LoadBalancerProbesClientListResponse struct {
	LoadBalancerProbeListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersClientCreateOrUpdatePollerResponse contains the response from method LoadBalancersClient.CreateOrUpdate.
type LoadBalancersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersClientCreateOrUpdateResponse, error) {
	respType := LoadBalancersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LoadBalancer)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LoadBalancersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LoadBalancersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LoadBalancersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancersClientCreateOrUpdateResponse contains the response from method LoadBalancersClient.CreateOrUpdate.
type LoadBalancersClientCreateOrUpdateResponse struct {
	LoadBalancer
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersClientDeletePollerResponse contains the response from method LoadBalancersClient.Delete.
type LoadBalancersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LoadBalancersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LoadBalancersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersClientDeleteResponse, error) {
	respType := LoadBalancersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LoadBalancersClientDeletePollerResponse from the provided client and resume token.
func (l *LoadBalancersClientDeletePollerResponse) Resume(ctx context.Context, client *LoadBalancersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LoadBalancersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LoadBalancersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LoadBalancersClientDeleteResponse contains the response from method LoadBalancersClient.Delete.
type LoadBalancersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersClientGetResponse contains the response from method LoadBalancersClient.Get.
type LoadBalancersClientGetResponse struct {
	LoadBalancer
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersClientListAllResponse contains the response from method LoadBalancersClient.ListAll.
type LoadBalancersClientListAllResponse struct {
	LoadBalancerListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersClientListResponse contains the response from method LoadBalancersClient.List.
type LoadBalancersClientListResponse struct {
	LoadBalancerListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LoadBalancersClientUpdateTagsResponse contains the response from method LoadBalancersClient.UpdateTags.
type LoadBalancersClientUpdateTagsResponse struct {
	LoadBalancer
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysClientCreateOrUpdatePollerResponse contains the response from method LocalNetworkGatewaysClient.CreateOrUpdate.
type LocalNetworkGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LocalNetworkGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LocalNetworkGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysClientCreateOrUpdateResponse, error) {
	respType := LocalNetworkGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LocalNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LocalNetworkGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LocalNetworkGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LocalNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LocalNetworkGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LocalNetworkGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LocalNetworkGatewaysClientCreateOrUpdateResponse contains the response from method LocalNetworkGatewaysClient.CreateOrUpdate.
type LocalNetworkGatewaysClientCreateOrUpdateResponse struct {
	LocalNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysClientDeletePollerResponse contains the response from method LocalNetworkGatewaysClient.Delete.
type LocalNetworkGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LocalNetworkGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LocalNetworkGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysClientDeleteResponse, error) {
	respType := LocalNetworkGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LocalNetworkGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *LocalNetworkGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *LocalNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LocalNetworkGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LocalNetworkGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LocalNetworkGatewaysClientDeleteResponse contains the response from method LocalNetworkGatewaysClient.Delete.
type LocalNetworkGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysClientGetResponse contains the response from method LocalNetworkGatewaysClient.Get.
type LocalNetworkGatewaysClientGetResponse struct {
	LocalNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysClientListResponse contains the response from method LocalNetworkGatewaysClient.List.
type LocalNetworkGatewaysClientListResponse struct {
	LocalNetworkGatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LocalNetworkGatewaysClientUpdateTagsResponse contains the response from method LocalNetworkGatewaysClient.UpdateTags.
type LocalNetworkGatewaysClientUpdateTagsResponse struct {
	LocalNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientCheckDNSNameAvailabilityResponse contains the response from method ManagementClient.CheckDNSNameAvailability.
type ManagementClientCheckDNSNameAvailabilityResponse struct {
	DNSNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientDeleteBastionShareableLinkPollerResponse contains the response from method ManagementClient.DeleteBastionShareableLink.
type ManagementClientDeleteBastionShareableLinkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagementClientDeleteBastionShareableLinkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagementClientDeleteBastionShareableLinkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagementClientDeleteBastionShareableLinkResponse, error) {
	respType := ManagementClientDeleteBastionShareableLinkResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagementClientDeleteBastionShareableLinkPollerResponse from the provided client and resume token.
func (l *ManagementClientDeleteBastionShareableLinkPollerResponse) Resume(ctx context.Context, client *ManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagementClient.DeleteBastionShareableLink", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagementClientDeleteBastionShareableLinkPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagementClientDeleteBastionShareableLinkResponse contains the response from method ManagementClient.DeleteBastionShareableLink.
type ManagementClientDeleteBastionShareableLinkResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientDisconnectActiveSessionsResponse contains the response from method ManagementClient.DisconnectActiveSessions.
type ManagementClientDisconnectActiveSessionsResponse struct {
	BastionSessionDeleteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse contains the response from method ManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile.
type ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error) {
	respType := ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNProfileResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse from the provided
// client and resume token.
func (l *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePollerResponse) Resume(ctx context.Context, client *ManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse contains the response from method ManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile.
type ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse struct {
	VPNProfileResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientGetActiveSessionsPollerResponse contains the response from method ManagementClient.GetActiveSessions.
type ManagementClientGetActiveSessionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagementClientGetActiveSessionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagementClientGetActiveSessionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (*ManagementClientGetActiveSessionsPager, error) {
	respType := &ManagementClientGetActiveSessionsPager{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.current.BastionActiveSessionListResult)
	if err != nil {
		return respType, err
	}
	respType.current.RawResponse = resp
	respType.client = l.Poller.client
	return respType, nil
}

// Resume rehydrates a ManagementClientGetActiveSessionsPollerResponse from the provided client and resume token.
func (l *ManagementClientGetActiveSessionsPollerResponse) Resume(ctx context.Context, client *ManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagementClient.GetActiveSessions", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagementClientGetActiveSessionsPoller{
		pt:     pt,
		client: client,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagementClientGetActiveSessionsResponse contains the response from method ManagementClient.GetActiveSessions.
type ManagementClientGetActiveSessionsResponse struct {
	BastionActiveSessionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientGetBastionShareableLinkResponse contains the response from method ManagementClient.GetBastionShareableLink.
type ManagementClientGetBastionShareableLinkResponse struct {
	BastionShareableLinkListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientPutBastionShareableLinkPollerResponse contains the response from method ManagementClient.PutBastionShareableLink.
type ManagementClientPutBastionShareableLinkPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ManagementClientPutBastionShareableLinkPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ManagementClientPutBastionShareableLinkPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (*ManagementClientPutBastionShareableLinkPager, error) {
	respType := &ManagementClientPutBastionShareableLinkPager{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.current.BastionShareableLinkListResult)
	if err != nil {
		return respType, err
	}
	respType.current.RawResponse = resp
	respType.client = l.Poller.client
	return respType, nil
}

// Resume rehydrates a ManagementClientPutBastionShareableLinkPollerResponse from the provided client and resume token.
func (l *ManagementClientPutBastionShareableLinkPollerResponse) Resume(ctx context.Context, client *ManagementClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ManagementClient.PutBastionShareableLink", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ManagementClientPutBastionShareableLinkPoller{
		pt:     pt,
		client: client,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ManagementClientPutBastionShareableLinkResponse contains the response from method ManagementClient.PutBastionShareableLink.
type ManagementClientPutBastionShareableLinkResponse struct {
	BastionShareableLinkListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ManagementClientSupportedSecurityProvidersResponse contains the response from method ManagementClient.SupportedSecurityProviders.
type ManagementClientSupportedSecurityProvidersResponse struct {
	VirtualWanSecurityProviders
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysClientCreateOrUpdatePollerResponse contains the response from method NatGatewaysClient.CreateOrUpdate.
type NatGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NatGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NatGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysClientCreateOrUpdateResponse, error) {
	respType := NatGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NatGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NatGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NatGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NatGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NatGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NatGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NatGatewaysClientCreateOrUpdateResponse contains the response from method NatGatewaysClient.CreateOrUpdate.
type NatGatewaysClientCreateOrUpdateResponse struct {
	NatGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysClientDeletePollerResponse contains the response from method NatGatewaysClient.Delete.
type NatGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NatGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NatGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysClientDeleteResponse, error) {
	respType := NatGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NatGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *NatGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *NatGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NatGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NatGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NatGatewaysClientDeleteResponse contains the response from method NatGatewaysClient.Delete.
type NatGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysClientGetResponse contains the response from method NatGatewaysClient.Get.
type NatGatewaysClientGetResponse struct {
	NatGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysClientListAllResponse contains the response from method NatGatewaysClient.ListAll.
type NatGatewaysClientListAllResponse struct {
	NatGatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysClientListResponse contains the response from method NatGatewaysClient.List.
type NatGatewaysClientListResponse struct {
	NatGatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NatGatewaysClientUpdateTagsResponse contains the response from method NatGatewaysClient.UpdateTags.
type NatGatewaysClientUpdateTagsResponse struct {
	NatGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientCreateOrUpdatePollerResponse contains the response from method P2SVPNGatewaysClient.CreateOrUpdate.
type P2SVPNGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientCreateOrUpdateResponse, error) {
	respType := P2SVPNGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysClientCreateOrUpdateResponse contains the response from method P2SVPNGatewaysClient.CreateOrUpdate.
type P2SVPNGatewaysClientCreateOrUpdateResponse struct {
	P2SVPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientDeletePollerResponse contains the response from method P2SVPNGatewaysClient.Delete.
type P2SVPNGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientDeleteResponse, error) {
	respType := P2SVPNGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysClientDeleteResponse contains the response from method P2SVPNGatewaysClient.Delete.
type P2SVPNGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPollerResponse contains the response from method P2SVPNGatewaysClient.DisconnectP2SVPNConnections.
type P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse, error) {
	respType := P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.DisconnectP2SVPNConnections", token, client.pl)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse contains the response from method P2SVPNGatewaysClient.DisconnectP2SVPNConnections.
type P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientGenerateVPNProfilePollerResponse contains the response from method P2SVPNGatewaysClient.GenerateVPNProfile.
type P2SVPNGatewaysClientGenerateVPNProfilePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysClientGenerateVPNProfilePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysClientGenerateVPNProfilePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientGenerateVPNProfileResponse, error) {
	respType := P2SVPNGatewaysClientGenerateVPNProfileResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNProfileResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysClientGenerateVPNProfilePollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysClientGenerateVPNProfilePollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GenerateVPNProfile", token, client.pl)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysClientGenerateVPNProfilePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysClientGenerateVPNProfileResponse contains the response from method P2SVPNGatewaysClient.GenerateVPNProfile.
type P2SVPNGatewaysClientGenerateVPNProfileResponse struct {
	VPNProfileResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPollerResponse contains the response from method P2SVPNGatewaysClient.GetP2SVPNConnectionHealthDetailed.
type P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse, error) {
	respType := P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNConnectionHealth)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPollerResponse from the provided client and resume
// token.
func (l *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GetP2SVPNConnectionHealthDetailed", token, client.pl)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse contains the response from method P2SVPNGatewaysClient.GetP2SVPNConnectionHealthDetailed.
type P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse struct {
	P2SVPNConnectionHealth
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientGetP2SVPNConnectionHealthPollerResponse contains the response from method P2SVPNGatewaysClient.GetP2SVPNConnectionHealth.
type P2SVPNGatewaysClientGetP2SVPNConnectionHealthPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l P2SVPNGatewaysClientGetP2SVPNConnectionHealthPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a P2SVPNGatewaysClientGetP2SVPNConnectionHealthPollerResponse from the provided client and resume token.
func (l *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPollerResponse) Resume(ctx context.Context, client *P2SVPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GetP2SVPNConnectionHealth", token, client.pl)
	if err != nil {
		return err
	}
	poller := &P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse contains the response from method P2SVPNGatewaysClient.GetP2SVPNConnectionHealth.
type P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse struct {
	P2SVPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientGetResponse contains the response from method P2SVPNGatewaysClient.Get.
type P2SVPNGatewaysClientGetResponse struct {
	P2SVPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientListByResourceGroupResponse contains the response from method P2SVPNGatewaysClient.ListByResourceGroup.
type P2SVPNGatewaysClientListByResourceGroupResponse struct {
	ListP2SVPNGatewaysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientListResponse contains the response from method P2SVPNGatewaysClient.List.
type P2SVPNGatewaysClientListResponse struct {
	ListP2SVPNGatewaysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// P2SVPNGatewaysClientUpdateTagsResponse contains the response from method P2SVPNGatewaysClient.UpdateTags.
type P2SVPNGatewaysClientUpdateTagsResponse struct {
	P2SVPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesClientCreatePollerResponse contains the response from method PacketCapturesClient.Create.
type PacketCapturesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientCreateResponse, error) {
	respType := PacketCapturesClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PacketCaptureResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesClientCreatePollerResponse from the provided client and resume token.
func (l *PacketCapturesClientCreatePollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PacketCapturesClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesClientCreateResponse contains the response from method PacketCapturesClient.Create.
type PacketCapturesClientCreateResponse struct {
	PacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesClientDeletePollerResponse contains the response from method PacketCapturesClient.Delete.
type PacketCapturesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientDeleteResponse, error) {
	respType := PacketCapturesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesClientDeletePollerResponse from the provided client and resume token.
func (l *PacketCapturesClientDeletePollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PacketCapturesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesClientDeleteResponse contains the response from method PacketCapturesClient.Delete.
type PacketCapturesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesClientGetResponse contains the response from method PacketCapturesClient.Get.
type PacketCapturesClientGetResponse struct {
	PacketCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesClientGetStatusPollerResponse contains the response from method PacketCapturesClient.GetStatus.
type PacketCapturesClientGetStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesClientGetStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesClientGetStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientGetStatusResponse, error) {
	respType := PacketCapturesClientGetStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesClientGetStatusPollerResponse from the provided client and resume token.
func (l *PacketCapturesClientGetStatusPollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.GetStatus", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PacketCapturesClientGetStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesClientGetStatusResponse contains the response from method PacketCapturesClient.GetStatus.
type PacketCapturesClientGetStatusResponse struct {
	PacketCaptureQueryStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesClientListResponse contains the response from method PacketCapturesClient.List.
type PacketCapturesClientListResponse struct {
	PacketCaptureListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PacketCapturesClientStopPollerResponse contains the response from method PacketCapturesClient.Stop.
type PacketCapturesClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PacketCapturesClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PacketCapturesClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientStopResponse, error) {
	respType := PacketCapturesClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PacketCapturesClientStopPollerResponse from the provided client and resume token.
func (l *PacketCapturesClientStopPollerResponse) Resume(ctx context.Context, client *PacketCapturesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PacketCapturesClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PacketCapturesClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PacketCapturesClientStopResponse contains the response from method PacketCapturesClient.Stop.
type PacketCapturesClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PeerExpressRouteCircuitConnectionsClientGetResponse contains the response from method PeerExpressRouteCircuitConnectionsClient.Get.
type PeerExpressRouteCircuitConnectionsClientGetResponse struct {
	PeerExpressRouteCircuitConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PeerExpressRouteCircuitConnectionsClientListResponse contains the response from method PeerExpressRouteCircuitConnectionsClient.List.
type PeerExpressRouteCircuitConnectionsClientListResponse struct {
	PeerExpressRouteCircuitConnectionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsClientCreateOrUpdatePollerResponse contains the response from method PrivateDNSZoneGroupsClient.CreateOrUpdate.
type PrivateDNSZoneGroupsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateDNSZoneGroupsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateDNSZoneGroupsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsClientCreateOrUpdateResponse, error) {
	respType := PrivateDNSZoneGroupsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateDNSZoneGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateDNSZoneGroupsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateDNSZoneGroupsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateDNSZoneGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateDNSZoneGroupsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateDNSZoneGroupsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateDNSZoneGroupsClientCreateOrUpdateResponse contains the response from method PrivateDNSZoneGroupsClient.CreateOrUpdate.
type PrivateDNSZoneGroupsClientCreateOrUpdateResponse struct {
	PrivateDNSZoneGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsClientDeletePollerResponse contains the response from method PrivateDNSZoneGroupsClient.Delete.
type PrivateDNSZoneGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateDNSZoneGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateDNSZoneGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsClientDeleteResponse, error) {
	respType := PrivateDNSZoneGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateDNSZoneGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *PrivateDNSZoneGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *PrivateDNSZoneGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateDNSZoneGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateDNSZoneGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateDNSZoneGroupsClientDeleteResponse contains the response from method PrivateDNSZoneGroupsClient.Delete.
type PrivateDNSZoneGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsClientGetResponse contains the response from method PrivateDNSZoneGroupsClient.Get.
type PrivateDNSZoneGroupsClientGetResponse struct {
	PrivateDNSZoneGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateDNSZoneGroupsClientListResponse contains the response from method PrivateDNSZoneGroupsClient.List.
type PrivateDNSZoneGroupsClientListResponse struct {
	PrivateDNSZoneGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsClientCreateOrUpdatePollerResponse contains the response from method PrivateEndpointsClient.CreateOrUpdate.
type PrivateEndpointsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpoint)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateEndpointsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointsClientCreateOrUpdateResponse contains the response from method PrivateEndpointsClient.CreateOrUpdate.
type PrivateEndpointsClientCreateOrUpdateResponse struct {
	PrivateEndpoint
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsClientDeletePollerResponse contains the response from method PrivateEndpointsClient.Delete.
type PrivateEndpointsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateEndpointsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateEndpointsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsClientDeleteResponse, error) {
	respType := PrivateEndpointsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateEndpointsClientDeletePollerResponse from the provided client and resume token.
func (l *PrivateEndpointsClientDeletePollerResponse) Resume(ctx context.Context, client *PrivateEndpointsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateEndpointsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateEndpointsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateEndpointsClientDeleteResponse contains the response from method PrivateEndpointsClient.Delete.
type PrivateEndpointsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsClientGetResponse contains the response from method PrivateEndpointsClient.Get.
type PrivateEndpointsClientGetResponse struct {
	PrivateEndpoint
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsClientListBySubscriptionResponse contains the response from method PrivateEndpointsClient.ListBySubscription.
type PrivateEndpointsClientListBySubscriptionResponse struct {
	PrivateEndpointListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateEndpointsClientListResponse contains the response from method PrivateEndpointsClient.List.
type PrivateEndpointsClientListResponse struct {
	PrivateEndpointListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse contains the response from method
// PrivateLinkServicesClient.CheckPrivateLinkServiceVisibilityByResourceGroup.
type PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error) {
	respType := PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse from the provided
// client and resume token.
func (l *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CheckPrivateLinkServiceVisibilityByResourceGroup", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse contains the response from method PrivateLinkServicesClient.CheckPrivateLinkServiceVisibilityByResourceGroup.
type PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse struct {
	PrivateLinkServiceVisibility
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPollerResponse contains the response from method PrivateLinkServicesClient.CheckPrivateLinkServiceVisibility.
type PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPollerResponse from the provided client and
// resume token.
func (l *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CheckPrivateLinkServiceVisibility", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse contains the response from method PrivateLinkServicesClient.CheckPrivateLinkServiceVisibility.
type PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse struct {
	PrivateLinkServiceVisibility
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientCreateOrUpdatePollerResponse contains the response from method PrivateLinkServicesClient.CreateOrUpdate.
type PrivateLinkServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientCreateOrUpdateResponse, error) {
	respType := PrivateLinkServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesClientCreateOrUpdateResponse contains the response from method PrivateLinkServicesClient.CreateOrUpdate.
type PrivateLinkServicesClientCreateOrUpdateResponse struct {
	PrivateLinkService
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientDeletePollerResponse contains the response from method PrivateLinkServicesClient.Delete.
type PrivateLinkServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientDeleteResponse, error) {
	respType := PrivateLinkServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesClientDeletePollerResponse from the provided client and resume token.
func (l *PrivateLinkServicesClientDeletePollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesClientDeletePrivateEndpointConnectionPollerResponse contains the response from method PrivateLinkServicesClient.DeletePrivateEndpointConnection.
type PrivateLinkServicesClientDeletePrivateEndpointConnectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PrivateLinkServicesClientDeletePrivateEndpointConnectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse, error) {
	respType := PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PrivateLinkServicesClientDeletePrivateEndpointConnectionPollerResponse from the provided client and
// resume token.
func (l *PrivateLinkServicesClientDeletePrivateEndpointConnectionPollerResponse) Resume(ctx context.Context, client *PrivateLinkServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.DeletePrivateEndpointConnection", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse contains the response from method PrivateLinkServicesClient.DeletePrivateEndpointConnection.
type PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientDeleteResponse contains the response from method PrivateLinkServicesClient.Delete.
type PrivateLinkServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientGetPrivateEndpointConnectionResponse contains the response from method PrivateLinkServicesClient.GetPrivateEndpointConnection.
type PrivateLinkServicesClientGetPrivateEndpointConnectionResponse struct {
	PrivateEndpointConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientGetResponse contains the response from method PrivateLinkServicesClient.Get.
type PrivateLinkServicesClientGetResponse struct {
	PrivateLinkService
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse contains the response from method PrivateLinkServicesClient.ListAutoApprovedPrivateLinkServicesByResourceGroup.
type PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesByResourceGroupResponse struct {
	AutoApprovedPrivateLinkServicesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse contains the response from method PrivateLinkServicesClient.ListAutoApprovedPrivateLinkServices.
type PrivateLinkServicesClientListAutoApprovedPrivateLinkServicesResponse struct {
	AutoApprovedPrivateLinkServicesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientListBySubscriptionResponse contains the response from method PrivateLinkServicesClient.ListBySubscription.
type PrivateLinkServicesClientListBySubscriptionResponse struct {
	PrivateLinkServiceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientListPrivateEndpointConnectionsResponse contains the response from method PrivateLinkServicesClient.ListPrivateEndpointConnections.
type PrivateLinkServicesClientListPrivateEndpointConnectionsResponse struct {
	PrivateEndpointConnectionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientListResponse contains the response from method PrivateLinkServicesClient.List.
type PrivateLinkServicesClientListResponse struct {
	PrivateLinkServiceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PrivateLinkServicesClientUpdatePrivateEndpointConnectionResponse contains the response from method PrivateLinkServicesClient.UpdatePrivateEndpointConnection.
type PrivateLinkServicesClientUpdatePrivateEndpointConnectionResponse struct {
	PrivateEndpointConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientCreateOrUpdateResponse contains the response from method ProfilesClient.CreateOrUpdate.
type ProfilesClientCreateOrUpdateResponse struct {
	Profile
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientDeletePollerResponse contains the response from method ProfilesClient.Delete.
type ProfilesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ProfilesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ProfilesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesClientDeleteResponse, error) {
	respType := ProfilesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ProfilesClientDeletePollerResponse from the provided client and resume token.
func (l *ProfilesClientDeletePollerResponse) Resume(ctx context.Context, client *ProfilesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ProfilesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ProfilesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ProfilesClientDeleteResponse contains the response from method ProfilesClient.Delete.
type ProfilesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientGetResponse contains the response from method ProfilesClient.Get.
type ProfilesClientGetResponse struct {
	Profile
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientListAllResponse contains the response from method ProfilesClient.ListAll.
type ProfilesClientListAllResponse struct {
	ProfileListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientListResponse contains the response from method ProfilesClient.List.
type ProfilesClientListResponse struct {
	ProfileListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProfilesClientUpdateTagsResponse contains the response from method ProfilesClient.UpdateTags.
type ProfilesClientUpdateTagsResponse struct {
	Profile
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientCreateOrUpdatePollerResponse contains the response from method PublicIPAddressesClient.CreateOrUpdate.
type PublicIPAddressesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPAddressesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPAddressesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesClientCreateOrUpdateResponse, error) {
	respType := PublicIPAddressesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PublicIPAddress)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPAddressesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PublicIPAddressesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PublicIPAddressesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPAddressesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PublicIPAddressesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPAddressesClientCreateOrUpdateResponse contains the response from method PublicIPAddressesClient.CreateOrUpdate.
type PublicIPAddressesClientCreateOrUpdateResponse struct {
	PublicIPAddress
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientDeletePollerResponse contains the response from method PublicIPAddressesClient.Delete.
type PublicIPAddressesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPAddressesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPAddressesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesClientDeleteResponse, error) {
	respType := PublicIPAddressesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPAddressesClientDeletePollerResponse from the provided client and resume token.
func (l *PublicIPAddressesClientDeletePollerResponse) Resume(ctx context.Context, client *PublicIPAddressesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPAddressesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PublicIPAddressesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPAddressesClientDeleteResponse contains the response from method PublicIPAddressesClient.Delete.
type PublicIPAddressesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientGetResponse contains the response from method PublicIPAddressesClient.Get.
type PublicIPAddressesClientGetResponse struct {
	PublicIPAddress
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientGetVirtualMachineScaleSetPublicIPAddressResponse contains the response from method PublicIPAddressesClient.GetVirtualMachineScaleSetPublicIPAddress.
type PublicIPAddressesClientGetVirtualMachineScaleSetPublicIPAddressResponse struct {
	PublicIPAddress
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientListAllResponse contains the response from method PublicIPAddressesClient.ListAll.
type PublicIPAddressesClientListAllResponse struct {
	PublicIPAddressListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientListResponse contains the response from method PublicIPAddressesClient.List.
type PublicIPAddressesClientListResponse struct {
	PublicIPAddressListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse contains the response from method PublicIPAddressesClient.ListVirtualMachineScaleSetPublicIPAddresses.
type PublicIPAddressesClientListVirtualMachineScaleSetPublicIPAddressesResponse struct {
	PublicIPAddressListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse contains the response from method PublicIPAddressesClient.ListVirtualMachineScaleSetVMPublicIPAddresses.
type PublicIPAddressesClientListVirtualMachineScaleSetVMPublicIPAddressesResponse struct {
	PublicIPAddressListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPAddressesClientUpdateTagsResponse contains the response from method PublicIPAddressesClient.UpdateTags.
type PublicIPAddressesClientUpdateTagsResponse struct {
	PublicIPAddress
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesClientCreateOrUpdatePollerResponse contains the response from method PublicIPPrefixesClient.CreateOrUpdate.
type PublicIPPrefixesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPPrefixesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPPrefixesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesClientCreateOrUpdateResponse, error) {
	respType := PublicIPPrefixesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PublicIPPrefix)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPPrefixesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *PublicIPPrefixesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *PublicIPPrefixesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPPrefixesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PublicIPPrefixesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPPrefixesClientCreateOrUpdateResponse contains the response from method PublicIPPrefixesClient.CreateOrUpdate.
type PublicIPPrefixesClientCreateOrUpdateResponse struct {
	PublicIPPrefix
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesClientDeletePollerResponse contains the response from method PublicIPPrefixesClient.Delete.
type PublicIPPrefixesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PublicIPPrefixesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PublicIPPrefixesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesClientDeleteResponse, error) {
	respType := PublicIPPrefixesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PublicIPPrefixesClientDeletePollerResponse from the provided client and resume token.
func (l *PublicIPPrefixesClientDeletePollerResponse) Resume(ctx context.Context, client *PublicIPPrefixesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PublicIPPrefixesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PublicIPPrefixesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PublicIPPrefixesClientDeleteResponse contains the response from method PublicIPPrefixesClient.Delete.
type PublicIPPrefixesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesClientGetResponse contains the response from method PublicIPPrefixesClient.Get.
type PublicIPPrefixesClientGetResponse struct {
	PublicIPPrefix
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesClientListAllResponse contains the response from method PublicIPPrefixesClient.ListAll.
type PublicIPPrefixesClientListAllResponse struct {
	PublicIPPrefixListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesClientListResponse contains the response from method PublicIPPrefixesClient.List.
type PublicIPPrefixesClientListResponse struct {
	PublicIPPrefixListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PublicIPPrefixesClientUpdateTagsResponse contains the response from method PublicIPPrefixesClient.UpdateTags.
type PublicIPPrefixesClientUpdateTagsResponse struct {
	PublicIPPrefix
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceNavigationLinksClientListResponse contains the response from method ResourceNavigationLinksClient.List.
type ResourceNavigationLinksClientListResponse struct {
	ResourceNavigationLinksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesClientCreateOrUpdatePollerResponse contains the response from method RouteFilterRulesClient.CreateOrUpdate.
type RouteFilterRulesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFilterRulesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFilterRulesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesClientCreateOrUpdateResponse, error) {
	respType := RouteFilterRulesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RouteFilterRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFilterRulesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RouteFilterRulesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RouteFilterRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFilterRulesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RouteFilterRulesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFilterRulesClientCreateOrUpdateResponse contains the response from method RouteFilterRulesClient.CreateOrUpdate.
type RouteFilterRulesClientCreateOrUpdateResponse struct {
	RouteFilterRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesClientDeletePollerResponse contains the response from method RouteFilterRulesClient.Delete.
type RouteFilterRulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFilterRulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFilterRulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesClientDeleteResponse, error) {
	respType := RouteFilterRulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFilterRulesClientDeletePollerResponse from the provided client and resume token.
func (l *RouteFilterRulesClientDeletePollerResponse) Resume(ctx context.Context, client *RouteFilterRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFilterRulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RouteFilterRulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFilterRulesClientDeleteResponse contains the response from method RouteFilterRulesClient.Delete.
type RouteFilterRulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesClientGetResponse contains the response from method RouteFilterRulesClient.Get.
type RouteFilterRulesClientGetResponse struct {
	RouteFilterRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFilterRulesClientListByRouteFilterResponse contains the response from method RouteFilterRulesClient.ListByRouteFilter.
type RouteFilterRulesClientListByRouteFilterResponse struct {
	RouteFilterRuleListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersClientCreateOrUpdatePollerResponse contains the response from method RouteFiltersClient.CreateOrUpdate.
type RouteFiltersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFiltersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFiltersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersClientCreateOrUpdateResponse, error) {
	respType := RouteFiltersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RouteFilter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFiltersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RouteFiltersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RouteFiltersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFiltersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RouteFiltersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFiltersClientCreateOrUpdateResponse contains the response from method RouteFiltersClient.CreateOrUpdate.
type RouteFiltersClientCreateOrUpdateResponse struct {
	RouteFilter
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersClientDeletePollerResponse contains the response from method RouteFiltersClient.Delete.
type RouteFiltersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteFiltersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteFiltersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersClientDeleteResponse, error) {
	respType := RouteFiltersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteFiltersClientDeletePollerResponse from the provided client and resume token.
func (l *RouteFiltersClientDeletePollerResponse) Resume(ctx context.Context, client *RouteFiltersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteFiltersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RouteFiltersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteFiltersClientDeleteResponse contains the response from method RouteFiltersClient.Delete.
type RouteFiltersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersClientGetResponse contains the response from method RouteFiltersClient.Get.
type RouteFiltersClientGetResponse struct {
	RouteFilter
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersClientListByResourceGroupResponse contains the response from method RouteFiltersClient.ListByResourceGroup.
type RouteFiltersClientListByResourceGroupResponse struct {
	RouteFilterListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersClientListResponse contains the response from method RouteFiltersClient.List.
type RouteFiltersClientListResponse struct {
	RouteFilterListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteFiltersClientUpdateTagsResponse contains the response from method RouteFiltersClient.UpdateTags.
type RouteFiltersClientUpdateTagsResponse struct {
	RouteFilter
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesClientCreateOrUpdatePollerResponse contains the response from method RouteTablesClient.CreateOrUpdate.
type RouteTablesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteTablesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteTablesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesClientCreateOrUpdateResponse, error) {
	respType := RouteTablesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RouteTable)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteTablesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RouteTablesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RouteTablesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteTablesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RouteTablesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteTablesClientCreateOrUpdateResponse contains the response from method RouteTablesClient.CreateOrUpdate.
type RouteTablesClientCreateOrUpdateResponse struct {
	RouteTable
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesClientDeletePollerResponse contains the response from method RouteTablesClient.Delete.
type RouteTablesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RouteTablesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RouteTablesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesClientDeleteResponse, error) {
	respType := RouteTablesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RouteTablesClientDeletePollerResponse from the provided client and resume token.
func (l *RouteTablesClientDeletePollerResponse) Resume(ctx context.Context, client *RouteTablesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RouteTablesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RouteTablesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RouteTablesClientDeleteResponse contains the response from method RouteTablesClient.Delete.
type RouteTablesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesClientGetResponse contains the response from method RouteTablesClient.Get.
type RouteTablesClientGetResponse struct {
	RouteTable
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesClientListAllResponse contains the response from method RouteTablesClient.ListAll.
type RouteTablesClientListAllResponse struct {
	RouteTableListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesClientListResponse contains the response from method RouteTablesClient.List.
type RouteTablesClientListResponse struct {
	RouteTableListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RouteTablesClientUpdateTagsResponse contains the response from method RouteTablesClient.UpdateTags.
type RouteTablesClientUpdateTagsResponse struct {
	RouteTable
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientCreateOrUpdatePollerResponse contains the response from method RoutesClient.CreateOrUpdate.
type RoutesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientCreateOrUpdateResponse, error) {
	respType := RoutesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *RoutesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RoutesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesClientCreateOrUpdateResponse contains the response from method RoutesClient.CreateOrUpdate.
type RoutesClientCreateOrUpdateResponse struct {
	Route
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientDeletePollerResponse contains the response from method RoutesClient.Delete.
type RoutesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *RoutesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l RoutesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientDeleteResponse, error) {
	respType := RoutesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a RoutesClientDeletePollerResponse from the provided client and resume token.
func (l *RoutesClientDeletePollerResponse) Resume(ctx context.Context, client *RoutesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("RoutesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &RoutesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// RoutesClientDeleteResponse contains the response from method RoutesClient.Delete.
type RoutesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientGetResponse contains the response from method RoutesClient.Get.
type RoutesClientGetResponse struct {
	Route
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// RoutesClientListResponse contains the response from method RoutesClient.List.
type RoutesClientListResponse struct {
	RouteListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityGroupsClientCreateOrUpdatePollerResponse contains the response from method SecurityGroupsClient.CreateOrUpdate.
type SecurityGroupsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityGroupsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityGroupsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityGroupsClientCreateOrUpdateResponse, error) {
	respType := SecurityGroupsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityGroup)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityGroupsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecurityGroupsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityGroupsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityGroupsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityGroupsClientCreateOrUpdateResponse contains the response from method SecurityGroupsClient.CreateOrUpdate.
type SecurityGroupsClientCreateOrUpdateResponse struct {
	SecurityGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityGroupsClientDeletePollerResponse contains the response from method SecurityGroupsClient.Delete.
type SecurityGroupsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityGroupsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityGroupsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityGroupsClientDeleteResponse, error) {
	respType := SecurityGroupsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityGroupsClientDeletePollerResponse from the provided client and resume token.
func (l *SecurityGroupsClientDeletePollerResponse) Resume(ctx context.Context, client *SecurityGroupsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityGroupsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityGroupsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityGroupsClientDeleteResponse contains the response from method SecurityGroupsClient.Delete.
type SecurityGroupsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityGroupsClientGetResponse contains the response from method SecurityGroupsClient.Get.
type SecurityGroupsClientGetResponse struct {
	SecurityGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityGroupsClientListAllResponse contains the response from method SecurityGroupsClient.ListAll.
type SecurityGroupsClientListAllResponse struct {
	SecurityGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityGroupsClientListResponse contains the response from method SecurityGroupsClient.List.
type SecurityGroupsClientListResponse struct {
	SecurityGroupListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityGroupsClientUpdateTagsResponse contains the response from method SecurityGroupsClient.UpdateTags.
type SecurityGroupsClientUpdateTagsResponse struct {
	SecurityGroup
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersClientCreateOrUpdatePollerResponse contains the response from method SecurityPartnerProvidersClient.CreateOrUpdate.
type SecurityPartnerProvidersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPartnerProvidersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPartnerProvidersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersClientCreateOrUpdateResponse, error) {
	respType := SecurityPartnerProvidersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityPartnerProvider)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPartnerProvidersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecurityPartnerProvidersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecurityPartnerProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPartnerProvidersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityPartnerProvidersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPartnerProvidersClientCreateOrUpdateResponse contains the response from method SecurityPartnerProvidersClient.CreateOrUpdate.
type SecurityPartnerProvidersClientCreateOrUpdateResponse struct {
	SecurityPartnerProvider
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersClientDeletePollerResponse contains the response from method SecurityPartnerProvidersClient.Delete.
type SecurityPartnerProvidersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityPartnerProvidersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityPartnerProvidersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersClientDeleteResponse, error) {
	respType := SecurityPartnerProvidersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityPartnerProvidersClientDeletePollerResponse from the provided client and resume token.
func (l *SecurityPartnerProvidersClientDeletePollerResponse) Resume(ctx context.Context, client *SecurityPartnerProvidersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityPartnerProvidersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityPartnerProvidersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityPartnerProvidersClientDeleteResponse contains the response from method SecurityPartnerProvidersClient.Delete.
type SecurityPartnerProvidersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersClientGetResponse contains the response from method SecurityPartnerProvidersClient.Get.
type SecurityPartnerProvidersClientGetResponse struct {
	SecurityPartnerProvider
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersClientListByResourceGroupResponse contains the response from method SecurityPartnerProvidersClient.ListByResourceGroup.
type SecurityPartnerProvidersClientListByResourceGroupResponse struct {
	SecurityPartnerProviderListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersClientListResponse contains the response from method SecurityPartnerProvidersClient.List.
type SecurityPartnerProvidersClientListResponse struct {
	SecurityPartnerProviderListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityPartnerProvidersClientUpdateTagsResponse contains the response from method SecurityPartnerProvidersClient.UpdateTags.
type SecurityPartnerProvidersClientUpdateTagsResponse struct {
	SecurityPartnerProvider
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesClientCreateOrUpdatePollerResponse contains the response from method SecurityRulesClient.CreateOrUpdate.
type SecurityRulesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityRulesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityRulesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesClientCreateOrUpdateResponse, error) {
	respType := SecurityRulesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityRule)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityRulesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecurityRulesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecurityRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityRulesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityRulesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityRulesClientCreateOrUpdateResponse contains the response from method SecurityRulesClient.CreateOrUpdate.
type SecurityRulesClientCreateOrUpdateResponse struct {
	SecurityRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesClientDeletePollerResponse contains the response from method SecurityRulesClient.Delete.
type SecurityRulesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecurityRulesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecurityRulesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesClientDeleteResponse, error) {
	respType := SecurityRulesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SecurityRulesClientDeletePollerResponse from the provided client and resume token.
func (l *SecurityRulesClientDeletePollerResponse) Resume(ctx context.Context, client *SecurityRulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecurityRulesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecurityRulesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SecurityRulesClientDeleteResponse contains the response from method SecurityRulesClient.Delete.
type SecurityRulesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesClientGetResponse contains the response from method SecurityRulesClient.Get.
type SecurityRulesClientGetResponse struct {
	SecurityRule
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SecurityRulesClientListResponse contains the response from method SecurityRulesClient.List.
type SecurityRulesClientListResponse struct {
	SecurityRuleListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceAssociationLinksClientListResponse contains the response from method ServiceAssociationLinksClient.List.
type ServiceAssociationLinksClientListResponse struct {
	ServiceAssociationLinksListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesClientCreateOrUpdatePollerResponse contains the response from method ServiceEndpointPoliciesClient.CreateOrUpdate.
type ServiceEndpointPoliciesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPoliciesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPoliciesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesClientCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPoliciesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceEndpointPolicy)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPoliciesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPoliciesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPoliciesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPoliciesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPoliciesClientCreateOrUpdateResponse contains the response from method ServiceEndpointPoliciesClient.CreateOrUpdate.
type ServiceEndpointPoliciesClientCreateOrUpdateResponse struct {
	ServiceEndpointPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesClientDeletePollerResponse contains the response from method ServiceEndpointPoliciesClient.Delete.
type ServiceEndpointPoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesClientDeleteResponse, error) {
	respType := ServiceEndpointPoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPoliciesClientDeleteResponse contains the response from method ServiceEndpointPoliciesClient.Delete.
type ServiceEndpointPoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesClientGetResponse contains the response from method ServiceEndpointPoliciesClient.Get.
type ServiceEndpointPoliciesClientGetResponse struct {
	ServiceEndpointPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesClientListByResourceGroupResponse contains the response from method ServiceEndpointPoliciesClient.ListByResourceGroup.
type ServiceEndpointPoliciesClientListByResourceGroupResponse struct {
	ServiceEndpointPolicyListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesClientListResponse contains the response from method ServiceEndpointPoliciesClient.List.
type ServiceEndpointPoliciesClientListResponse struct {
	ServiceEndpointPolicyListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPoliciesClientUpdateTagsResponse contains the response from method ServiceEndpointPoliciesClient.UpdateTags.
type ServiceEndpointPoliciesClientUpdateTagsResponse struct {
	ServiceEndpointPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePollerResponse contains the response from method ServiceEndpointPolicyDefinitionsClient.CreateOrUpdate.
type ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPolicyDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPolicyDefinitionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse contains the response from method ServiceEndpointPolicyDefinitionsClient.CreateOrUpdate.
type ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse struct {
	ServiceEndpointPolicyDefinition
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsClientDeletePollerResponse contains the response from method ServiceEndpointPolicyDefinitionsClient.Delete.
type ServiceEndpointPolicyDefinitionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceEndpointPolicyDefinitionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceEndpointPolicyDefinitionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsClientDeleteResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServiceEndpointPolicyDefinitionsClientDeletePollerResponse from the provided client and resume token.
func (l *ServiceEndpointPolicyDefinitionsClientDeletePollerResponse) Resume(ctx context.Context, client *ServiceEndpointPolicyDefinitionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceEndpointPolicyDefinitionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceEndpointPolicyDefinitionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServiceEndpointPolicyDefinitionsClientDeleteResponse contains the response from method ServiceEndpointPolicyDefinitionsClient.Delete.
type ServiceEndpointPolicyDefinitionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsClientGetResponse contains the response from method ServiceEndpointPolicyDefinitionsClient.Get.
type ServiceEndpointPolicyDefinitionsClientGetResponse struct {
	ServiceEndpointPolicyDefinition
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse contains the response from method ServiceEndpointPolicyDefinitionsClient.ListByResourceGroup.
type ServiceEndpointPolicyDefinitionsClientListByResourceGroupResponse struct {
	ServiceEndpointPolicyDefinitionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTagsClientListResponse contains the response from method ServiceTagsClient.List.
type ServiceTagsClientListResponse struct {
	ServiceTagsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsClientCreateOrUpdatePollerResponse contains the response from method SubnetsClient.CreateOrUpdate.
type SubnetsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientCreateOrUpdateResponse, error) {
	respType := SubnetsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Subnet)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SubnetsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SubnetsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsClientCreateOrUpdateResponse contains the response from method SubnetsClient.CreateOrUpdate.
type SubnetsClientCreateOrUpdateResponse struct {
	Subnet
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsClientDeletePollerResponse contains the response from method SubnetsClient.Delete.
type SubnetsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientDeleteResponse, error) {
	respType := SubnetsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsClientDeletePollerResponse from the provided client and resume token.
func (l *SubnetsClientDeletePollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SubnetsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsClientDeleteResponse contains the response from method SubnetsClient.Delete.
type SubnetsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsClientGetResponse contains the response from method SubnetsClient.Get.
type SubnetsClientGetResponse struct {
	Subnet
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsClientListResponse contains the response from method SubnetsClient.List.
type SubnetsClientListResponse struct {
	SubnetListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsClientPrepareNetworkPoliciesPollerResponse contains the response from method SubnetsClient.PrepareNetworkPolicies.
type SubnetsClientPrepareNetworkPoliciesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsClientPrepareNetworkPoliciesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsClientPrepareNetworkPoliciesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientPrepareNetworkPoliciesResponse, error) {
	respType := SubnetsClientPrepareNetworkPoliciesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsClientPrepareNetworkPoliciesPollerResponse from the provided client and resume token.
func (l *SubnetsClientPrepareNetworkPoliciesPollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.PrepareNetworkPolicies", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SubnetsClientPrepareNetworkPoliciesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsClientPrepareNetworkPoliciesResponse contains the response from method SubnetsClient.PrepareNetworkPolicies.
type SubnetsClientPrepareNetworkPoliciesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubnetsClientUnprepareNetworkPoliciesPollerResponse contains the response from method SubnetsClient.UnprepareNetworkPolicies.
type SubnetsClientUnprepareNetworkPoliciesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubnetsClientUnprepareNetworkPoliciesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubnetsClientUnprepareNetworkPoliciesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientUnprepareNetworkPoliciesResponse, error) {
	respType := SubnetsClientUnprepareNetworkPoliciesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SubnetsClientUnprepareNetworkPoliciesPollerResponse from the provided client and resume token.
func (l *SubnetsClientUnprepareNetworkPoliciesPollerResponse) Resume(ctx context.Context, client *SubnetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubnetsClient.UnprepareNetworkPolicies", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SubnetsClientUnprepareNetworkPoliciesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SubnetsClientUnprepareNetworkPoliciesResponse contains the response from method SubnetsClient.UnprepareNetworkPolicies.
type SubnetsClientUnprepareNetworkPoliciesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsagesClientListResponse contains the response from method UsagesClient.List.
type UsagesClientListResponse struct {
	UsagesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsClientCreateOrUpdatePollerResponse contains the response from method VPNConnectionsClient.CreateOrUpdate.
type VPNConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsClientCreateOrUpdateResponse, error) {
	respType := VPNConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNConnectionsClientCreateOrUpdateResponse contains the response from method VPNConnectionsClient.CreateOrUpdate.
type VPNConnectionsClientCreateOrUpdateResponse struct {
	VPNConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsClientDeletePollerResponse contains the response from method VPNConnectionsClient.Delete.
type VPNConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsClientDeleteResponse, error) {
	respType := VPNConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *VPNConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *VPNConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNConnectionsClientDeleteResponse contains the response from method VPNConnectionsClient.Delete.
type VPNConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsClientGetResponse contains the response from method VPNConnectionsClient.Get.
type VPNConnectionsClientGetResponse struct {
	VPNConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNConnectionsClientListByVPNGatewayResponse contains the response from method VPNConnectionsClient.ListByVPNGateway.
type VPNConnectionsClientListByVPNGatewayResponse struct {
	ListVPNConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientCreateOrUpdatePollerResponse contains the response from method VPNGatewaysClient.CreateOrUpdate.
type VPNGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysClientCreateOrUpdateResponse, error) {
	respType := VPNGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysClientCreateOrUpdateResponse contains the response from method VPNGatewaysClient.CreateOrUpdate.
type VPNGatewaysClientCreateOrUpdateResponse struct {
	VPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientDeletePollerResponse contains the response from method VPNGatewaysClient.Delete.
type VPNGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysClientDeleteResponse, error) {
	respType := VPNGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *VPNGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysClientDeleteResponse contains the response from method VPNGatewaysClient.Delete.
type VPNGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientGetResponse contains the response from method VPNGatewaysClient.Get.
type VPNGatewaysClientGetResponse struct {
	VPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientListByResourceGroupResponse contains the response from method VPNGatewaysClient.ListByResourceGroup.
type VPNGatewaysClientListByResourceGroupResponse struct {
	ListVPNGatewaysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientListResponse contains the response from method VPNGatewaysClient.List.
type VPNGatewaysClientListResponse struct {
	ListVPNGatewaysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientResetPollerResponse contains the response from method VPNGatewaysClient.Reset.
type VPNGatewaysClientResetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNGatewaysClientResetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNGatewaysClientResetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysClientResetResponse, error) {
	respType := VPNGatewaysClientResetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNGatewaysClientResetPollerResponse from the provided client and resume token.
func (l *VPNGatewaysClientResetPollerResponse) Resume(ctx context.Context, client *VPNGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNGatewaysClient.Reset", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNGatewaysClientResetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNGatewaysClientResetResponse contains the response from method VPNGatewaysClient.Reset.
type VPNGatewaysClientResetResponse struct {
	VPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNGatewaysClientUpdateTagsResponse contains the response from method VPNGatewaysClient.UpdateTags.
type VPNGatewaysClientUpdateTagsResponse struct {
	VPNGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNLinkConnectionsClientListByVPNConnectionResponse contains the response from method VPNLinkConnectionsClient.ListByVPNConnection.
type VPNLinkConnectionsClientListByVPNConnectionResponse struct {
	ListVPNSiteLinkConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsAssociatedWithVirtualWanClientListPollerResponse contains the response from method VPNServerConfigurationsAssociatedWithVirtualWanClient.List.
type VPNServerConfigurationsAssociatedWithVirtualWanClientListPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNServerConfigurationsAssociatedWithVirtualWanClientListPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse, error) {
	respType := VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNServerConfigurationsResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNServerConfigurationsAssociatedWithVirtualWanClientListPollerResponse from the provided client and
// resume token.
func (l *VPNServerConfigurationsAssociatedWithVirtualWanClientListPollerResponse) Resume(ctx context.Context, client *VPNServerConfigurationsAssociatedWithVirtualWanClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNServerConfigurationsAssociatedWithVirtualWanClient.List", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse contains the response from method VPNServerConfigurationsAssociatedWithVirtualWanClient.List.
type VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse struct {
	VPNServerConfigurationsResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsClientCreateOrUpdatePollerResponse contains the response from method VPNServerConfigurationsClient.CreateOrUpdate.
type VPNServerConfigurationsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNServerConfigurationsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNServerConfigurationsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsClientCreateOrUpdateResponse, error) {
	respType := VPNServerConfigurationsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNServerConfiguration)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNServerConfigurationsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNServerConfigurationsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNServerConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNServerConfigurationsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNServerConfigurationsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNServerConfigurationsClientCreateOrUpdateResponse contains the response from method VPNServerConfigurationsClient.CreateOrUpdate.
type VPNServerConfigurationsClientCreateOrUpdateResponse struct {
	VPNServerConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsClientDeletePollerResponse contains the response from method VPNServerConfigurationsClient.Delete.
type VPNServerConfigurationsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNServerConfigurationsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNServerConfigurationsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsClientDeleteResponse, error) {
	respType := VPNServerConfigurationsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNServerConfigurationsClientDeletePollerResponse from the provided client and resume token.
func (l *VPNServerConfigurationsClientDeletePollerResponse) Resume(ctx context.Context, client *VPNServerConfigurationsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNServerConfigurationsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNServerConfigurationsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNServerConfigurationsClientDeleteResponse contains the response from method VPNServerConfigurationsClient.Delete.
type VPNServerConfigurationsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsClientGetResponse contains the response from method VPNServerConfigurationsClient.Get.
type VPNServerConfigurationsClientGetResponse struct {
	VPNServerConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsClientListByResourceGroupResponse contains the response from method VPNServerConfigurationsClient.ListByResourceGroup.
type VPNServerConfigurationsClientListByResourceGroupResponse struct {
	ListVPNServerConfigurationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsClientListResponse contains the response from method VPNServerConfigurationsClient.List.
type VPNServerConfigurationsClientListResponse struct {
	ListVPNServerConfigurationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNServerConfigurationsClientUpdateTagsResponse contains the response from method VPNServerConfigurationsClient.UpdateTags.
type VPNServerConfigurationsClientUpdateTagsResponse struct {
	VPNServerConfiguration
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSiteLinkConnectionsClientGetResponse contains the response from method VPNSiteLinkConnectionsClient.Get.
type VPNSiteLinkConnectionsClientGetResponse struct {
	VPNSiteLinkConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSiteLinksClientGetResponse contains the response from method VPNSiteLinksClient.Get.
type VPNSiteLinksClientGetResponse struct {
	VPNSiteLink
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSiteLinksClientListByVPNSiteResponse contains the response from method VPNSiteLinksClient.ListByVPNSite.
type VPNSiteLinksClientListByVPNSiteResponse struct {
	ListVPNSiteLinksResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesClientCreateOrUpdatePollerResponse contains the response from method VPNSitesClient.CreateOrUpdate.
type VPNSitesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNSitesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNSitesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesClientCreateOrUpdateResponse, error) {
	respType := VPNSitesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNSite)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNSitesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VPNSitesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VPNSitesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNSitesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNSitesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNSitesClientCreateOrUpdateResponse contains the response from method VPNSitesClient.CreateOrUpdate.
type VPNSitesClientCreateOrUpdateResponse struct {
	VPNSite
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesClientDeletePollerResponse contains the response from method VPNSitesClient.Delete.
type VPNSitesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNSitesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNSitesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesClientDeleteResponse, error) {
	respType := VPNSitesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNSitesClientDeletePollerResponse from the provided client and resume token.
func (l *VPNSitesClientDeletePollerResponse) Resume(ctx context.Context, client *VPNSitesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNSitesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNSitesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNSitesClientDeleteResponse contains the response from method VPNSitesClient.Delete.
type VPNSitesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesClientGetResponse contains the response from method VPNSitesClient.Get.
type VPNSitesClientGetResponse struct {
	VPNSite
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesClientListByResourceGroupResponse contains the response from method VPNSitesClient.ListByResourceGroup.
type VPNSitesClientListByResourceGroupResponse struct {
	ListVPNSitesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesClientListResponse contains the response from method VPNSitesClient.List.
type VPNSitesClientListResponse struct {
	ListVPNSitesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesClientUpdateTagsResponse contains the response from method VPNSitesClient.UpdateTags.
type VPNSitesClientUpdateTagsResponse struct {
	VPNSite
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VPNSitesConfigurationClientDownloadPollerResponse contains the response from method VPNSitesConfigurationClient.Download.
type VPNSitesConfigurationClientDownloadPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VPNSitesConfigurationClientDownloadPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VPNSitesConfigurationClientDownloadPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesConfigurationClientDownloadResponse, error) {
	respType := VPNSitesConfigurationClientDownloadResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VPNSitesConfigurationClientDownloadPollerResponse from the provided client and resume token.
func (l *VPNSitesConfigurationClientDownloadPollerResponse) Resume(ctx context.Context, client *VPNSitesConfigurationClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VPNSitesConfigurationClient.Download", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VPNSitesConfigurationClientDownloadPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VPNSitesConfigurationClientDownloadResponse contains the response from method VPNSitesConfigurationClient.Download.
type VPNSitesConfigurationClientDownloadResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualAppliancesClientCreateOrUpdatePollerResponse contains the response from method VirtualAppliancesClient.CreateOrUpdate.
type VirtualAppliancesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualAppliancesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualAppliancesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualAppliancesClientCreateOrUpdateResponse, error) {
	respType := VirtualAppliancesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualAppliance)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualAppliancesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualAppliancesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualAppliancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualAppliancesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualAppliancesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualAppliancesClientCreateOrUpdateResponse contains the response from method VirtualAppliancesClient.CreateOrUpdate.
type VirtualAppliancesClientCreateOrUpdateResponse struct {
	VirtualAppliance
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualAppliancesClientDeletePollerResponse contains the response from method VirtualAppliancesClient.Delete.
type VirtualAppliancesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualAppliancesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualAppliancesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualAppliancesClientDeleteResponse, error) {
	respType := VirtualAppliancesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualAppliancesClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualAppliancesClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualAppliancesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualAppliancesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualAppliancesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualAppliancesClientDeleteResponse contains the response from method VirtualAppliancesClient.Delete.
type VirtualAppliancesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualAppliancesClientGetResponse contains the response from method VirtualAppliancesClient.Get.
type VirtualAppliancesClientGetResponse struct {
	VirtualAppliance
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualAppliancesClientListByResourceGroupResponse contains the response from method VirtualAppliancesClient.ListByResourceGroup.
type VirtualAppliancesClientListByResourceGroupResponse struct {
	VirtualApplianceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualAppliancesClientListResponse contains the response from method VirtualAppliancesClient.List.
type VirtualAppliancesClientListResponse struct {
	VirtualApplianceListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualAppliancesClientUpdateTagsResponse contains the response from method VirtualAppliancesClient.UpdateTags.
type VirtualAppliancesClientUpdateTagsResponse struct {
	VirtualAppliance
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SClientCreateOrUpdatePollerResponse contains the response from method VirtualHubRouteTableV2SClient.CreateOrUpdate.
type VirtualHubRouteTableV2SClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubRouteTableV2SClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubRouteTableV2SClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SClientCreateOrUpdateResponse, error) {
	respType := VirtualHubRouteTableV2SClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualHubRouteTableV2)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubRouteTableV2SClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualHubRouteTableV2SClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualHubRouteTableV2SClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubRouteTableV2SClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualHubRouteTableV2SClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubRouteTableV2SClientCreateOrUpdateResponse contains the response from method VirtualHubRouteTableV2SClient.CreateOrUpdate.
type VirtualHubRouteTableV2SClientCreateOrUpdateResponse struct {
	VirtualHubRouteTableV2
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SClientDeletePollerResponse contains the response from method VirtualHubRouteTableV2SClient.Delete.
type VirtualHubRouteTableV2SClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubRouteTableV2SClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubRouteTableV2SClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SClientDeleteResponse, error) {
	respType := VirtualHubRouteTableV2SClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubRouteTableV2SClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualHubRouteTableV2SClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualHubRouteTableV2SClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubRouteTableV2SClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualHubRouteTableV2SClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubRouteTableV2SClientDeleteResponse contains the response from method VirtualHubRouteTableV2SClient.Delete.
type VirtualHubRouteTableV2SClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SClientGetResponse contains the response from method VirtualHubRouteTableV2SClient.Get.
type VirtualHubRouteTableV2SClientGetResponse struct {
	VirtualHubRouteTableV2
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubRouteTableV2SClientListResponse contains the response from method VirtualHubRouteTableV2SClient.List.
type VirtualHubRouteTableV2SClientListResponse struct {
	ListVirtualHubRouteTableV2SResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsClientCreateOrUpdatePollerResponse contains the response from method VirtualHubsClient.CreateOrUpdate.
type VirtualHubsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsClientCreateOrUpdateResponse, error) {
	respType := VirtualHubsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualHub)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualHubsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualHubsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualHubsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubsClientCreateOrUpdateResponse contains the response from method VirtualHubsClient.CreateOrUpdate.
type VirtualHubsClientCreateOrUpdateResponse struct {
	VirtualHub
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsClientDeletePollerResponse contains the response from method VirtualHubsClient.Delete.
type VirtualHubsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualHubsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualHubsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsClientDeleteResponse, error) {
	respType := VirtualHubsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualHubsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualHubsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualHubsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualHubsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualHubsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualHubsClientDeleteResponse contains the response from method VirtualHubsClient.Delete.
type VirtualHubsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsClientGetResponse contains the response from method VirtualHubsClient.Get.
type VirtualHubsClientGetResponse struct {
	VirtualHub
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsClientListByResourceGroupResponse contains the response from method VirtualHubsClient.ListByResourceGroup.
type VirtualHubsClientListByResourceGroupResponse struct {
	ListVirtualHubsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsClientListResponse contains the response from method VirtualHubsClient.List.
type VirtualHubsClientListResponse struct {
	ListVirtualHubsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualHubsClientUpdateTagsResponse contains the response from method VirtualHubsClient.UpdateTags.
type VirtualHubsClientUpdateTagsResponse struct {
	VirtualHub
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.CreateOrUpdate.
type VirtualNetworkGatewayConnectionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientCreateOrUpdatePollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse contains the response from method VirtualNetworkGatewayConnectionsClient.CreateOrUpdate.
type VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse struct {
	VirtualNetworkGatewayConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientDeletePollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.Delete.
type VirtualNetworkGatewayConnectionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientDeleteResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewayConnectionsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientDeleteResponse contains the response from method VirtualNetworkGatewayConnectionsClient.Delete.
type VirtualNetworkGatewayConnectionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientGetResponse contains the response from method VirtualNetworkGatewayConnectionsClient.Get.
type VirtualNetworkGatewayConnectionsClientGetResponse struct {
	VirtualNetworkGatewayConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientGetSharedKeyResponse contains the response from method VirtualNetworkGatewayConnectionsClient.GetSharedKey.
type VirtualNetworkGatewayConnectionsClientGetSharedKeyResponse struct {
	ConnectionSharedKey
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientListResponse contains the response from method VirtualNetworkGatewayConnectionsClient.List.
type VirtualNetworkGatewayConnectionsClientListResponse struct {
	VirtualNetworkGatewayConnectionListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientResetSharedKeyPollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.ResetSharedKey.
type VirtualNetworkGatewayConnectionsClientResetSharedKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientResetSharedKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionResetSharedKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientResetSharedKeyPollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewayConnectionsClientResetSharedKeyPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.ResetSharedKey", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse contains the response from method VirtualNetworkGatewayConnectionsClient.ResetSharedKey.
type VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse struct {
	ConnectionResetSharedKey
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientSetSharedKeyPollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.SetSharedKey.
type VirtualNetworkGatewayConnectionsClientSetSharedKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientSetSharedKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectionSharedKey)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientSetSharedKeyPollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewayConnectionsClientSetSharedKeyPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.SetSharedKey", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse contains the response from method VirtualNetworkGatewayConnectionsClient.SetSharedKey.
type VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse struct {
	ConnectionSharedKey
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewayConnectionsClientStartPacketCapturePollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.StartPacketCapture.
type VirtualNetworkGatewayConnectionsClientStartPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientStartPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientStartPacketCapturePollerResponse from the provided client and
// resume token.
func (l *VirtualNetworkGatewayConnectionsClientStartPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.StartPacketCapture", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse contains the response from method VirtualNetworkGatewayConnectionsClient.StartPacketCapture.
type VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewayConnectionsClientStopPacketCapturePollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.StopPacketCapture.
type VirtualNetworkGatewayConnectionsClientStopPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientStopPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientStopPacketCapturePollerResponse from the provided client and
// resume token.
func (l *VirtualNetworkGatewayConnectionsClientStopPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.StopPacketCapture", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse contains the response from method VirtualNetworkGatewayConnectionsClient.StopPacketCapture.
type VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewayConnectionsClientUpdateTagsPollerResponse contains the response from method VirtualNetworkGatewayConnectionsClient.UpdateTags.
type VirtualNetworkGatewayConnectionsClientUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewayConnectionsClientUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewayConnectionsClientUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientUpdateTagsPollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewayConnectionsClientUpdateTagsPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewayConnectionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.UpdateTags", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewayConnectionsClientUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewayConnectionsClientUpdateTagsResponse contains the response from method VirtualNetworkGatewayConnectionsClient.UpdateTags.
type VirtualNetworkGatewayConnectionsClientUpdateTagsResponse struct {
	VirtualNetworkGatewayConnection
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworkGatewaysClient.CreateOrUpdate.
type VirtualNetworkGatewaysClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewaysClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientCreateOrUpdateResponse contains the response from method VirtualNetworkGatewaysClient.CreateOrUpdate.
type VirtualNetworkGatewaysClientCreateOrUpdateResponse struct {
	VirtualNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientDeletePollerResponse contains the response from method VirtualNetworkGatewaysClient.Delete.
type VirtualNetworkGatewaysClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientDeleteResponse, error) {
	respType := VirtualNetworkGatewaysClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientDeleteResponse contains the response from method VirtualNetworkGatewaysClient.Delete.
type VirtualNetworkGatewaysClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse contains the response from method
// VirtualNetworkGatewaysClient.DisconnectVirtualNetworkGatewayVPNConnections.
type VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error) {
	respType := VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse from the provided
// client and resume token.
func (l *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.DisconnectVirtualNetworkGatewayVPNConnections", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse contains the response from method VirtualNetworkGatewaysClient.DisconnectVirtualNetworkGatewayVPNConnections.
type VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientGenerateVPNProfilePollerResponse contains the response from method VirtualNetworkGatewaysClient.GenerateVPNProfile.
type VirtualNetworkGatewaysClientGenerateVPNProfilePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGenerateVPNProfilePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGenerateVPNProfilePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGenerateVPNProfileResponse, error) {
	respType := VirtualNetworkGatewaysClientGenerateVPNProfileResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGenerateVPNProfilePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientGenerateVPNProfilePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GenerateVPNProfile", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGenerateVPNProfilePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGenerateVPNProfileResponse contains the response from method VirtualNetworkGatewaysClient.GenerateVPNProfile.
type VirtualNetworkGatewaysClientGenerateVPNProfileResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewaysClientGeneratevpnclientpackagePollerResponse contains the response from method VirtualNetworkGatewaysClient.Generatevpnclientpackage.
type VirtualNetworkGatewaysClientGeneratevpnclientpackagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGeneratevpnclientpackagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse, error) {
	respType := VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGeneratevpnclientpackagePollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewaysClientGeneratevpnclientpackagePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Generatevpnclientpackage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse contains the response from method VirtualNetworkGatewaysClient.Generatevpnclientpackage.
type VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewaysClientGetAdvertisedRoutesPollerResponse contains the response from method VirtualNetworkGatewaysClient.GetAdvertisedRoutes.
type VirtualNetworkGatewaysClientGetAdvertisedRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGetAdvertisedRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetAdvertisedRoutesPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientGetAdvertisedRoutesPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetAdvertisedRoutes", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse contains the response from method VirtualNetworkGatewaysClient.GetAdvertisedRoutes.
type VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse struct {
	GatewayRouteListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientGetBgpPeerStatusPollerResponse contains the response from method VirtualNetworkGatewaysClient.GetBgpPeerStatus.
type VirtualNetworkGatewaysClientGetBgpPeerStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGetBgpPeerStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetBgpPeerStatusResponse, error) {
	respType := VirtualNetworkGatewaysClientGetBgpPeerStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.BgpPeerStatusListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetBgpPeerStatusPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientGetBgpPeerStatusPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetBgpPeerStatus", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGetBgpPeerStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGetBgpPeerStatusResponse contains the response from method VirtualNetworkGatewaysClient.GetBgpPeerStatus.
type VirtualNetworkGatewaysClientGetBgpPeerStatusResponse struct {
	BgpPeerStatusListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientGetLearnedRoutesPollerResponse contains the response from method VirtualNetworkGatewaysClient.GetLearnedRoutes.
type VirtualNetworkGatewaysClientGetLearnedRoutesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGetLearnedRoutesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGetLearnedRoutesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetLearnedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysClientGetLearnedRoutesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetLearnedRoutesPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientGetLearnedRoutesPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetLearnedRoutes", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGetLearnedRoutesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGetLearnedRoutesResponse contains the response from method VirtualNetworkGatewaysClient.GetLearnedRoutes.
type VirtualNetworkGatewaysClientGetLearnedRoutesResponse struct {
	GatewayRouteListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientGetResponse contains the response from method VirtualNetworkGatewaysClient.Get.
type VirtualNetworkGatewaysClientGetResponse struct {
	VirtualNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientGetVPNProfilePackageURLPollerResponse contains the response from method VirtualNetworkGatewaysClient.GetVPNProfilePackageURL.
type VirtualNetworkGatewaysClientGetVPNProfilePackageURLPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGetVPNProfilePackageURLPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse, error) {
	respType := VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetVPNProfilePackageURLPollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVPNProfilePackageURL", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse contains the response from method VirtualNetworkGatewaysClient.GetVPNProfilePackageURL.
type VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPollerResponse contains the response from method VirtualNetworkGatewaysClient.GetVpnclientConnectionHealth.
type VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse, error) {
	respType := VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPollerResponse from the provided client and
// resume token.
func (l *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVpnclientConnectionHealth", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse contains the response from method VirtualNetworkGatewaysClient.GetVpnclientConnectionHealth.
type VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse struct {
	VPNClientConnectionHealthDetailListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPollerResponse contains the response from method VirtualNetworkGatewaysClient.GetVpnclientIPSecParameters.
type VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNClientIPsecParameters)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPollerResponse from the provided client and
// resume token.
func (l *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVpnclientIPSecParameters", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse contains the response from method VirtualNetworkGatewaysClient.GetVpnclientIPSecParameters.
type VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse struct {
	VPNClientIPsecParameters
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientListConnectionsResponse contains the response from method VirtualNetworkGatewaysClient.ListConnections.
type VirtualNetworkGatewaysClientListConnectionsResponse struct {
	VirtualNetworkGatewayListConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientListResponse contains the response from method VirtualNetworkGatewaysClient.List.
type VirtualNetworkGatewaysClientListResponse struct {
	VirtualNetworkGatewayListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientResetPollerResponse contains the response from method VirtualNetworkGatewaysClient.Reset.
type VirtualNetworkGatewaysClientResetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientResetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientResetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientResetResponse, error) {
	respType := VirtualNetworkGatewaysClientResetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientResetPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientResetPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Reset", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientResetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientResetResponse contains the response from method VirtualNetworkGatewaysClient.Reset.
type VirtualNetworkGatewaysClientResetResponse struct {
	VirtualNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientResetVPNClientSharedKeyPollerResponse contains the response from method VirtualNetworkGatewaysClient.ResetVPNClientSharedKey.
type VirtualNetworkGatewaysClientResetVPNClientSharedKeyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientResetVPNClientSharedKeyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse, error) {
	respType := VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientResetVPNClientSharedKeyPollerResponse from the provided client and resume
// token.
func (l *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.ResetVPNClientSharedKey", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse contains the response from method VirtualNetworkGatewaysClient.ResetVPNClientSharedKey.
type VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPollerResponse contains the response from method VirtualNetworkGatewaysClient.SetVpnclientIPSecParameters.
type VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VPNClientIPsecParameters)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPollerResponse from the provided client and
// resume token.
func (l *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.SetVpnclientIPSecParameters", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse contains the response from method VirtualNetworkGatewaysClient.SetVpnclientIPSecParameters.
type VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse struct {
	VPNClientIPsecParameters
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientStartPacketCapturePollerResponse contains the response from method VirtualNetworkGatewaysClient.StartPacketCapture.
type VirtualNetworkGatewaysClientStartPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientStartPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientStartPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysClientStartPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientStartPacketCapturePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientStartPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.StartPacketCapture", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientStartPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientStartPacketCaptureResponse contains the response from method VirtualNetworkGatewaysClient.StartPacketCapture.
type VirtualNetworkGatewaysClientStartPacketCaptureResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewaysClientStopPacketCapturePollerResponse contains the response from method VirtualNetworkGatewaysClient.StopPacketCapture.
type VirtualNetworkGatewaysClientStopPacketCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientStopPacketCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientStopPacketCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysClientStopPacketCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientStopPacketCapturePollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientStopPacketCapturePollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.StopPacketCapture", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientStopPacketCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientStopPacketCaptureResponse contains the response from method VirtualNetworkGatewaysClient.StopPacketCapture.
type VirtualNetworkGatewaysClientStopPacketCaptureResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewaysClientSupportedVPNDevicesResponse contains the response from method VirtualNetworkGatewaysClient.SupportedVPNDevices.
type VirtualNetworkGatewaysClientSupportedVPNDevicesResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkGatewaysClientUpdateTagsPollerResponse contains the response from method VirtualNetworkGatewaysClient.UpdateTags.
type VirtualNetworkGatewaysClientUpdateTagsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkGatewaysClientUpdateTagsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkGatewaysClientUpdateTagsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewaysClientUpdateTagsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkGatewaysClientUpdateTagsPollerResponse from the provided client and resume token.
func (l *VirtualNetworkGatewaysClientUpdateTagsPollerResponse) Resume(ctx context.Context, client *VirtualNetworkGatewaysClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.UpdateTags", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkGatewaysClientUpdateTagsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkGatewaysClientUpdateTagsResponse contains the response from method VirtualNetworkGatewaysClient.UpdateTags.
type VirtualNetworkGatewaysClientUpdateTagsResponse struct {
	VirtualNetworkGateway
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkGatewaysClientVPNDeviceConfigurationScriptResponse contains the response from method VirtualNetworkGatewaysClient.VPNDeviceConfigurationScript.
type VirtualNetworkGatewaysClientVPNDeviceConfigurationScriptResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Value       *string
}

// VirtualNetworkPeeringsClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworkPeeringsClient.CreateOrUpdate.
type VirtualNetworkPeeringsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkPeeringsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkPeeringsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworkPeeringsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkPeeringsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkPeeringsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkPeeringsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkPeeringsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkPeeringsClientCreateOrUpdateResponse contains the response from method VirtualNetworkPeeringsClient.CreateOrUpdate.
type VirtualNetworkPeeringsClientCreateOrUpdateResponse struct {
	VirtualNetworkPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsClientDeletePollerResponse contains the response from method VirtualNetworkPeeringsClient.Delete.
type VirtualNetworkPeeringsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkPeeringsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkPeeringsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsClientDeleteResponse, error) {
	respType := VirtualNetworkPeeringsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkPeeringsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkPeeringsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkPeeringsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkPeeringsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkPeeringsClientDeleteResponse contains the response from method VirtualNetworkPeeringsClient.Delete.
type VirtualNetworkPeeringsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsClientGetResponse contains the response from method VirtualNetworkPeeringsClient.Get.
type VirtualNetworkPeeringsClientGetResponse struct {
	VirtualNetworkPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkPeeringsClientListResponse contains the response from method VirtualNetworkPeeringsClient.List.
type VirtualNetworkPeeringsClientListResponse struct {
	VirtualNetworkPeeringListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworkTapsClient.CreateOrUpdate.
type VirtualNetworkTapsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkTapsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkTapsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworkTapsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkTap)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkTapsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworkTapsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworkTapsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkTapsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkTapsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkTapsClientCreateOrUpdateResponse contains the response from method VirtualNetworkTapsClient.CreateOrUpdate.
type VirtualNetworkTapsClientCreateOrUpdateResponse struct {
	VirtualNetworkTap
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsClientDeletePollerResponse contains the response from method VirtualNetworkTapsClient.Delete.
type VirtualNetworkTapsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworkTapsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworkTapsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsClientDeleteResponse, error) {
	respType := VirtualNetworkTapsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworkTapsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworkTapsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworkTapsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworkTapsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworkTapsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworkTapsClientDeleteResponse contains the response from method VirtualNetworkTapsClient.Delete.
type VirtualNetworkTapsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsClientGetResponse contains the response from method VirtualNetworkTapsClient.Get.
type VirtualNetworkTapsClientGetResponse struct {
	VirtualNetworkTap
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsClientListAllResponse contains the response from method VirtualNetworkTapsClient.ListAll.
type VirtualNetworkTapsClientListAllResponse struct {
	VirtualNetworkTapListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsClientListByResourceGroupResponse contains the response from method VirtualNetworkTapsClient.ListByResourceGroup.
type VirtualNetworkTapsClientListByResourceGroupResponse struct {
	VirtualNetworkTapListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworkTapsClientUpdateTagsResponse contains the response from method VirtualNetworkTapsClient.UpdateTags.
type VirtualNetworkTapsClientUpdateTagsResponse struct {
	VirtualNetworkTap
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientCheckIPAddressAvailabilityResponse contains the response from method VirtualNetworksClient.CheckIPAddressAvailability.
type VirtualNetworksClientCheckIPAddressAvailabilityResponse struct {
	IPAddressAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworksClient.CreateOrUpdate.
type VirtualNetworksClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworksClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetwork)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworksClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworksClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworksClientCreateOrUpdateResponse contains the response from method VirtualNetworksClient.CreateOrUpdate.
type VirtualNetworksClientCreateOrUpdateResponse struct {
	VirtualNetwork
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientDeletePollerResponse contains the response from method VirtualNetworksClient.Delete.
type VirtualNetworksClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksClientDeleteResponse, error) {
	respType := VirtualNetworksClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualNetworksClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworksClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualNetworksClientDeleteResponse contains the response from method VirtualNetworksClient.Delete.
type VirtualNetworksClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientGetResponse contains the response from method VirtualNetworksClient.Get.
type VirtualNetworksClientGetResponse struct {
	VirtualNetwork
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientListAllResponse contains the response from method VirtualNetworksClient.ListAll.
type VirtualNetworksClientListAllResponse struct {
	VirtualNetworkListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientListResponse contains the response from method VirtualNetworksClient.List.
type VirtualNetworksClientListResponse struct {
	VirtualNetworkListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientListUsageResponse contains the response from method VirtualNetworksClient.ListUsage.
type VirtualNetworksClientListUsageResponse struct {
	VirtualNetworkListUsageResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualNetworksClientUpdateTagsResponse contains the response from method VirtualNetworksClient.UpdateTags.
type VirtualNetworksClientUpdateTagsResponse struct {
	VirtualNetwork
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsClientCreateOrUpdatePollerResponse contains the response from method VirtualRouterPeeringsClient.CreateOrUpdate.
type VirtualRouterPeeringsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRouterPeeringsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRouterPeeringsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsClientCreateOrUpdateResponse, error) {
	respType := VirtualRouterPeeringsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualRouterPeering)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRouterPeeringsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualRouterPeeringsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualRouterPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRouterPeeringsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualRouterPeeringsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRouterPeeringsClientCreateOrUpdateResponse contains the response from method VirtualRouterPeeringsClient.CreateOrUpdate.
type VirtualRouterPeeringsClientCreateOrUpdateResponse struct {
	VirtualRouterPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsClientDeletePollerResponse contains the response from method VirtualRouterPeeringsClient.Delete.
type VirtualRouterPeeringsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRouterPeeringsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRouterPeeringsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsClientDeleteResponse, error) {
	respType := VirtualRouterPeeringsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRouterPeeringsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualRouterPeeringsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualRouterPeeringsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRouterPeeringsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualRouterPeeringsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRouterPeeringsClientDeleteResponse contains the response from method VirtualRouterPeeringsClient.Delete.
type VirtualRouterPeeringsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsClientGetResponse contains the response from method VirtualRouterPeeringsClient.Get.
type VirtualRouterPeeringsClientGetResponse struct {
	VirtualRouterPeering
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRouterPeeringsClientListResponse contains the response from method VirtualRouterPeeringsClient.List.
type VirtualRouterPeeringsClientListResponse struct {
	VirtualRouterPeeringListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersClientCreateOrUpdatePollerResponse contains the response from method VirtualRoutersClient.CreateOrUpdate.
type VirtualRoutersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRoutersClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRoutersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersClientCreateOrUpdateResponse, error) {
	respType := VirtualRoutersClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualRouter)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRoutersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualRoutersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualRoutersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRoutersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualRoutersClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRoutersClientCreateOrUpdateResponse contains the response from method VirtualRoutersClient.CreateOrUpdate.
type VirtualRoutersClientCreateOrUpdateResponse struct {
	VirtualRouter
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersClientDeletePollerResponse contains the response from method VirtualRoutersClient.Delete.
type VirtualRoutersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualRoutersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualRoutersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersClientDeleteResponse, error) {
	respType := VirtualRoutersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualRoutersClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualRoutersClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualRoutersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualRoutersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualRoutersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualRoutersClientDeleteResponse contains the response from method VirtualRoutersClient.Delete.
type VirtualRoutersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersClientGetResponse contains the response from method VirtualRoutersClient.Get.
type VirtualRoutersClientGetResponse struct {
	VirtualRouter
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersClientListByResourceGroupResponse contains the response from method VirtualRoutersClient.ListByResourceGroup.
type VirtualRoutersClientListByResourceGroupResponse struct {
	VirtualRouterListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualRoutersClientListResponse contains the response from method VirtualRoutersClient.List.
type VirtualRoutersClientListResponse struct {
	VirtualRouterListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansClientCreateOrUpdatePollerResponse contains the response from method VirtualWansClient.CreateOrUpdate.
type VirtualWansClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualWansClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualWansClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansClientCreateOrUpdateResponse, error) {
	respType := VirtualWansClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualWAN)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualWansClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualWansClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualWansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualWansClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualWansClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualWansClientCreateOrUpdateResponse contains the response from method VirtualWansClient.CreateOrUpdate.
type VirtualWansClientCreateOrUpdateResponse struct {
	VirtualWAN
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansClientDeletePollerResponse contains the response from method VirtualWansClient.Delete.
type VirtualWansClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualWansClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualWansClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansClientDeleteResponse, error) {
	respType := VirtualWansClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualWansClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualWansClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualWansClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualWansClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualWansClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualWansClientDeleteResponse contains the response from method VirtualWansClient.Delete.
type VirtualWansClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansClientGetResponse contains the response from method VirtualWansClient.Get.
type VirtualWansClientGetResponse struct {
	VirtualWAN
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansClientListByResourceGroupResponse contains the response from method VirtualWansClient.ListByResourceGroup.
type VirtualWansClientListByResourceGroupResponse struct {
	ListVirtualWANsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansClientListResponse contains the response from method VirtualWansClient.List.
type VirtualWansClientListResponse struct {
	ListVirtualWANsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualWansClientUpdateTagsResponse contains the response from method VirtualWansClient.UpdateTags.
type VirtualWansClientUpdateTagsResponse struct {
	VirtualWAN
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientCheckConnectivityPollerResponse contains the response from method WatchersClient.CheckConnectivity.
type WatchersClientCheckConnectivityPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientCheckConnectivityPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientCheckConnectivityPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientCheckConnectivityResponse, error) {
	respType := WatchersClientCheckConnectivityResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConnectivityInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientCheckConnectivityPollerResponse from the provided client and resume token.
func (l *WatchersClientCheckConnectivityPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.CheckConnectivity", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientCheckConnectivityPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientCheckConnectivityResponse contains the response from method WatchersClient.CheckConnectivity.
type WatchersClientCheckConnectivityResponse struct {
	ConnectivityInformation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientCreateOrUpdateResponse contains the response from method WatchersClient.CreateOrUpdate.
type WatchersClientCreateOrUpdateResponse struct {
	Watcher
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientDeletePollerResponse contains the response from method WatchersClient.Delete.
type WatchersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientDeleteResponse, error) {
	respType := WatchersClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientDeletePollerResponse from the provided client and resume token.
func (l *WatchersClientDeletePollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientDeleteResponse contains the response from method WatchersClient.Delete.
type WatchersClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetAzureReachabilityReportPollerResponse contains the response from method WatchersClient.GetAzureReachabilityReport.
type WatchersClientGetAzureReachabilityReportPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetAzureReachabilityReportPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetAzureReachabilityReportPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetAzureReachabilityReportResponse, error) {
	respType := WatchersClientGetAzureReachabilityReportResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AzureReachabilityReport)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetAzureReachabilityReportPollerResponse from the provided client and resume token.
func (l *WatchersClientGetAzureReachabilityReportPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetAzureReachabilityReport", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetAzureReachabilityReportPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetAzureReachabilityReportResponse contains the response from method WatchersClient.GetAzureReachabilityReport.
type WatchersClientGetAzureReachabilityReportResponse struct {
	AzureReachabilityReport
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetFlowLogStatusPollerResponse contains the response from method WatchersClient.GetFlowLogStatus.
type WatchersClientGetFlowLogStatusPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetFlowLogStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetFlowLogStatusPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetFlowLogStatusResponse, error) {
	respType := WatchersClientGetFlowLogStatusResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FlowLogInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetFlowLogStatusPollerResponse from the provided client and resume token.
func (l *WatchersClientGetFlowLogStatusPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetFlowLogStatus", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetFlowLogStatusPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetFlowLogStatusResponse contains the response from method WatchersClient.GetFlowLogStatus.
type WatchersClientGetFlowLogStatusResponse struct {
	FlowLogInformation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetNetworkConfigurationDiagnosticPollerResponse contains the response from method WatchersClient.GetNetworkConfigurationDiagnostic.
type WatchersClientGetNetworkConfigurationDiagnosticPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetNetworkConfigurationDiagnosticPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetNetworkConfigurationDiagnosticPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetNetworkConfigurationDiagnosticResponse, error) {
	respType := WatchersClientGetNetworkConfigurationDiagnosticResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ConfigurationDiagnosticResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetNetworkConfigurationDiagnosticPollerResponse from the provided client and resume token.
func (l *WatchersClientGetNetworkConfigurationDiagnosticPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetNetworkConfigurationDiagnostic", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetNetworkConfigurationDiagnosticPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetNetworkConfigurationDiagnosticResponse contains the response from method WatchersClient.GetNetworkConfigurationDiagnostic.
type WatchersClientGetNetworkConfigurationDiagnosticResponse struct {
	ConfigurationDiagnosticResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetNextHopPollerResponse contains the response from method WatchersClient.GetNextHop.
type WatchersClientGetNextHopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetNextHopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetNextHopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetNextHopResponse, error) {
	respType := WatchersClientGetNextHopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NextHopResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetNextHopPollerResponse from the provided client and resume token.
func (l *WatchersClientGetNextHopPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetNextHop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetNextHopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetNextHopResponse contains the response from method WatchersClient.GetNextHop.
type WatchersClientGetNextHopResponse struct {
	NextHopResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetResponse contains the response from method WatchersClient.Get.
type WatchersClientGetResponse struct {
	Watcher
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetTopologyResponse contains the response from method WatchersClient.GetTopology.
type WatchersClientGetTopologyResponse struct {
	Topology
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetTroubleshootingPollerResponse contains the response from method WatchersClient.GetTroubleshooting.
type WatchersClientGetTroubleshootingPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetTroubleshootingPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetTroubleshootingPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetTroubleshootingResponse, error) {
	respType := WatchersClientGetTroubleshootingResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TroubleshootingResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetTroubleshootingPollerResponse from the provided client and resume token.
func (l *WatchersClientGetTroubleshootingPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetTroubleshooting", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetTroubleshootingPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetTroubleshootingResponse contains the response from method WatchersClient.GetTroubleshooting.
type WatchersClientGetTroubleshootingResponse struct {
	TroubleshootingResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetTroubleshootingResultPollerResponse contains the response from method WatchersClient.GetTroubleshootingResult.
type WatchersClientGetTroubleshootingResultPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetTroubleshootingResultPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetTroubleshootingResultPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetTroubleshootingResultResponse, error) {
	respType := WatchersClientGetTroubleshootingResultResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TroubleshootingResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetTroubleshootingResultPollerResponse from the provided client and resume token.
func (l *WatchersClientGetTroubleshootingResultPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetTroubleshootingResult", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetTroubleshootingResultPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetTroubleshootingResultResponse contains the response from method WatchersClient.GetTroubleshootingResult.
type WatchersClientGetTroubleshootingResultResponse struct {
	TroubleshootingResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientGetVMSecurityRulesPollerResponse contains the response from method WatchersClient.GetVMSecurityRules.
type WatchersClientGetVMSecurityRulesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientGetVMSecurityRulesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientGetVMSecurityRulesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetVMSecurityRulesResponse, error) {
	respType := WatchersClientGetVMSecurityRulesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SecurityGroupViewResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientGetVMSecurityRulesPollerResponse from the provided client and resume token.
func (l *WatchersClientGetVMSecurityRulesPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.GetVMSecurityRules", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientGetVMSecurityRulesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientGetVMSecurityRulesResponse contains the response from method WatchersClient.GetVMSecurityRules.
type WatchersClientGetVMSecurityRulesResponse struct {
	SecurityGroupViewResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientListAllResponse contains the response from method WatchersClient.ListAll.
type WatchersClientListAllResponse struct {
	WatcherListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientListAvailableProvidersPollerResponse contains the response from method WatchersClient.ListAvailableProviders.
type WatchersClientListAvailableProvidersPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientListAvailableProvidersPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientListAvailableProvidersPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientListAvailableProvidersResponse, error) {
	respType := WatchersClientListAvailableProvidersResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AvailableProvidersList)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientListAvailableProvidersPollerResponse from the provided client and resume token.
func (l *WatchersClientListAvailableProvidersPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.ListAvailableProviders", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientListAvailableProvidersPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientListAvailableProvidersResponse contains the response from method WatchersClient.ListAvailableProviders.
type WatchersClientListAvailableProvidersResponse struct {
	AvailableProvidersList
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientListResponse contains the response from method WatchersClient.List.
type WatchersClientListResponse struct {
	WatcherListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientSetFlowLogConfigurationPollerResponse contains the response from method WatchersClient.SetFlowLogConfiguration.
type WatchersClientSetFlowLogConfigurationPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientSetFlowLogConfigurationPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientSetFlowLogConfigurationPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientSetFlowLogConfigurationResponse, error) {
	respType := WatchersClientSetFlowLogConfigurationResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.FlowLogInformation)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientSetFlowLogConfigurationPollerResponse from the provided client and resume token.
func (l *WatchersClientSetFlowLogConfigurationPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.SetFlowLogConfiguration", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientSetFlowLogConfigurationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientSetFlowLogConfigurationResponse contains the response from method WatchersClient.SetFlowLogConfiguration.
type WatchersClientSetFlowLogConfigurationResponse struct {
	FlowLogInformation
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientUpdateTagsResponse contains the response from method WatchersClient.UpdateTags.
type WatchersClientUpdateTagsResponse struct {
	Watcher
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WatchersClientVerifyIPFlowPollerResponse contains the response from method WatchersClient.VerifyIPFlow.
type WatchersClientVerifyIPFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WatchersClientVerifyIPFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WatchersClientVerifyIPFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientVerifyIPFlowResponse, error) {
	respType := WatchersClientVerifyIPFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VerificationIPFlowResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WatchersClientVerifyIPFlowPollerResponse from the provided client and resume token.
func (l *WatchersClientVerifyIPFlowPollerResponse) Resume(ctx context.Context, client *WatchersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WatchersClient.VerifyIPFlow", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WatchersClientVerifyIPFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WatchersClientVerifyIPFlowResponse contains the response from method WatchersClient.VerifyIPFlow.
type WatchersClientVerifyIPFlowResponse struct {
	VerificationIPFlowResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesClientCreateOrUpdateResponse contains the response from method WebApplicationFirewallPoliciesClient.CreateOrUpdate.
type WebApplicationFirewallPoliciesClientCreateOrUpdateResponse struct {
	WebApplicationFirewallPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesClientDeletePollerResponse contains the response from method WebApplicationFirewallPoliciesClient.Delete.
type WebApplicationFirewallPoliciesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *WebApplicationFirewallPoliciesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l WebApplicationFirewallPoliciesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (WebApplicationFirewallPoliciesClientDeleteResponse, error) {
	respType := WebApplicationFirewallPoliciesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a WebApplicationFirewallPoliciesClientDeletePollerResponse from the provided client and resume token.
func (l *WebApplicationFirewallPoliciesClientDeletePollerResponse) Resume(ctx context.Context, client *WebApplicationFirewallPoliciesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("WebApplicationFirewallPoliciesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &WebApplicationFirewallPoliciesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// WebApplicationFirewallPoliciesClientDeleteResponse contains the response from method WebApplicationFirewallPoliciesClient.Delete.
type WebApplicationFirewallPoliciesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesClientGetResponse contains the response from method WebApplicationFirewallPoliciesClient.Get.
type WebApplicationFirewallPoliciesClientGetResponse struct {
	WebApplicationFirewallPolicy
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesClientListAllResponse contains the response from method WebApplicationFirewallPoliciesClient.ListAll.
type WebApplicationFirewallPoliciesClientListAllResponse struct {
	WebApplicationFirewallPolicyListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WebApplicationFirewallPoliciesClientListResponse contains the response from method WebApplicationFirewallPoliciesClient.List.
type WebApplicationFirewallPoliciesClientListResponse struct {
	WebApplicationFirewallPolicyListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}
