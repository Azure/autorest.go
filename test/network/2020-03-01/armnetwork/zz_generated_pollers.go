// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// ApplicationGatewaysBackendHealthOnDemandPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysBackendHealthOnDemandPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewaysBackendHealthOnDemandResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewaysBackendHealthOnDemandResponse, error)
}

type applicationGatewaysBackendHealthOnDemandPoller struct {
	pt *armcore.LROPoller
}

func (p *applicationGatewaysBackendHealthOnDemandPoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationGatewaysBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationGatewaysBackendHealthOnDemandPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewaysBackendHealthOnDemandResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return ApplicationGatewaysBackendHealthOnDemandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationGatewaysBackendHealthOnDemandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewaysBackendHealthOnDemandPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysBackendHealthOnDemandResponse, error) {
	respType := ApplicationGatewaysBackendHealthOnDemandResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayBackendHealthOnDemand)
	if err != nil {
		return ApplicationGatewaysBackendHealthOnDemandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewaysBackendHealthPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysBackendHealthPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewaysBackendHealthResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewaysBackendHealthResponse, error)
}

type applicationGatewaysBackendHealthPoller struct {
	pt *armcore.LROPoller
}

func (p *applicationGatewaysBackendHealthPoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationGatewaysBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationGatewaysBackendHealthPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysBackendHealthResponse, error) {
	respType := ApplicationGatewaysBackendHealthResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return ApplicationGatewaysBackendHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationGatewaysBackendHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewaysBackendHealthPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysBackendHealthResponse, error) {
	respType := ApplicationGatewaysBackendHealthResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ApplicationGatewayBackendHealth)
	if err != nil {
		return ApplicationGatewaysBackendHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewaysCreateOrUpdateResponse, error)
}

type applicationGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *applicationGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ApplicationGatewaysCreateOrUpdateResponse, error) {
	respType := ApplicationGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationGateway)
	if err != nil {
		return ApplicationGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysCreateOrUpdateResponse, error) {
	respType := ApplicationGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ApplicationGateway)
	if err != nil {
		return ApplicationGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewaysDeleteResponse, error)
}

type applicationGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *applicationGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationGatewaysDeletePoller) FinalResponse(ctx context.Context) (ApplicationGatewaysDeleteResponse, error) {
	respType := ApplicationGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysDeleteResponse, error) {
	respType := ApplicationGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ApplicationGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewaysStartPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysStartPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewaysStartResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewaysStartResponse, error)
}

type applicationGatewaysStartPoller struct {
	pt *armcore.LROPoller
}

func (p *applicationGatewaysStartPoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationGatewaysStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationGatewaysStartPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysStartResponse, error) {
	respType := ApplicationGatewaysStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewaysStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationGatewaysStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewaysStartPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysStartResponse, error) {
	respType := ApplicationGatewaysStartResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ApplicationGatewaysStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationGatewaysStopPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysStopPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationGatewaysStopResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationGatewaysStopResponse, error)
}

type applicationGatewaysStopPoller struct {
	pt *armcore.LROPoller
}

func (p *applicationGatewaysStopPoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationGatewaysStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationGatewaysStopPoller) FinalResponse(ctx context.Context) (ApplicationGatewaysStopResponse, error) {
	respType := ApplicationGatewaysStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationGatewaysStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationGatewaysStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationGatewaysStopPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysStopResponse, error) {
	respType := ApplicationGatewaysStopResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ApplicationGatewaysStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationSecurityGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationSecurityGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationSecurityGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationSecurityGroupsCreateOrUpdateResponse, error)
}

type applicationSecurityGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *applicationSecurityGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationSecurityGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationSecurityGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ApplicationSecurityGroupsCreateOrUpdateResponse, error) {
	respType := ApplicationSecurityGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ApplicationSecurityGroup)
	if err != nil {
		return ApplicationSecurityGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationSecurityGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationSecurityGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsCreateOrUpdateResponse, error) {
	respType := ApplicationSecurityGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ApplicationSecurityGroup)
	if err != nil {
		return ApplicationSecurityGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ApplicationSecurityGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationSecurityGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ApplicationSecurityGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ApplicationSecurityGroupsDeleteResponse, error)
}

type applicationSecurityGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *applicationSecurityGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *applicationSecurityGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *applicationSecurityGroupsDeletePoller) FinalResponse(ctx context.Context) (ApplicationSecurityGroupsDeleteResponse, error) {
	respType := ApplicationSecurityGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ApplicationSecurityGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *applicationSecurityGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *applicationSecurityGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsDeleteResponse, error) {
	respType := ApplicationSecurityGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ApplicationSecurityGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureFirewallsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AzureFirewallsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (AzureFirewallsCreateOrUpdateResponse, error)
}

type azureFirewallsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *azureFirewallsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *azureFirewallsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *azureFirewallsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (AzureFirewallsCreateOrUpdateResponse, error) {
	respType := AzureFirewallsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureFirewall)
	if err != nil {
		return AzureFirewallsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *azureFirewallsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureFirewallsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsCreateOrUpdateResponse, error) {
	respType := AzureFirewallsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AzureFirewall)
	if err != nil {
		return AzureFirewallsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureFirewallsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AzureFirewallsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (AzureFirewallsDeleteResponse, error)
}

type azureFirewallsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *azureFirewallsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *azureFirewallsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *azureFirewallsDeletePoller) FinalResponse(ctx context.Context) (AzureFirewallsDeleteResponse, error) {
	respType := AzureFirewallsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AzureFirewallsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *azureFirewallsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureFirewallsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsDeleteResponse, error) {
	respType := AzureFirewallsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return AzureFirewallsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// AzureFirewallsUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsUpdateTagsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final AzureFirewallsUpdateTagsResponse will be returned.
	FinalResponse(ctx context.Context) (AzureFirewallsUpdateTagsResponse, error)
}

type azureFirewallsUpdateTagsPoller struct {
	pt *armcore.LROPoller
}

func (p *azureFirewallsUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

func (p *azureFirewallsUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *azureFirewallsUpdateTagsPoller) FinalResponse(ctx context.Context) (AzureFirewallsUpdateTagsResponse, error) {
	respType := AzureFirewallsUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureFirewall)
	if err != nil {
		return AzureFirewallsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *azureFirewallsUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *azureFirewallsUpdateTagsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsUpdateTagsResponse, error) {
	respType := AzureFirewallsUpdateTagsResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AzureFirewall)
	if err != nil {
		return AzureFirewallsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BastionHostsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BastionHostsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (BastionHostsCreateOrUpdateResponse, error)
}

type bastionHostsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *bastionHostsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *bastionHostsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *bastionHostsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BastionHostsCreateOrUpdateResponse, error) {
	respType := BastionHostsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BastionHost)
	if err != nil {
		return BastionHostsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *bastionHostsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionHostsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsCreateOrUpdateResponse, error) {
	respType := BastionHostsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BastionHost)
	if err != nil {
		return BastionHostsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// BastionHostsDeletePoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final BastionHostsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (BastionHostsDeleteResponse, error)
}

type bastionHostsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *bastionHostsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *bastionHostsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *bastionHostsDeletePoller) FinalResponse(ctx context.Context) (BastionHostsDeleteResponse, error) {
	respType := BastionHostsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BastionHostsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *bastionHostsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *bastionHostsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsDeleteResponse, error) {
	respType := BastionHostsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return BastionHostsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorsCreateOrUpdateResponse, error)
}

type connectionMonitorsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *connectionMonitorsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *connectionMonitorsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *connectionMonitorsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ConnectionMonitorsCreateOrUpdateResponse, error) {
	respType := ConnectionMonitorsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionMonitorResult)
	if err != nil {
		return ConnectionMonitorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *connectionMonitorsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsCreateOrUpdateResponse, error) {
	respType := ConnectionMonitorsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConnectionMonitorResult)
	if err != nil {
		return ConnectionMonitorsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorsDeleteResponse, error)
}

type connectionMonitorsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *connectionMonitorsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *connectionMonitorsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *connectionMonitorsDeletePoller) FinalResponse(ctx context.Context) (ConnectionMonitorsDeleteResponse, error) {
	respType := ConnectionMonitorsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectionMonitorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *connectionMonitorsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsDeleteResponse, error) {
	respType := ConnectionMonitorsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ConnectionMonitorsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorsQueryPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsQueryPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorsQueryResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorsQueryResponse, error)
}

type connectionMonitorsQueryPoller struct {
	pt *armcore.LROPoller
}

func (p *connectionMonitorsQueryPoller) Done() bool {
	return p.pt.Done()
}

func (p *connectionMonitorsQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *connectionMonitorsQueryPoller) FinalResponse(ctx context.Context) (ConnectionMonitorsQueryResponse, error) {
	respType := ConnectionMonitorsQueryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionMonitorQueryResult)
	if err != nil {
		return ConnectionMonitorsQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *connectionMonitorsQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorsQueryPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsQueryResponse, error) {
	respType := ConnectionMonitorsQueryResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConnectionMonitorQueryResult)
	if err != nil {
		return ConnectionMonitorsQueryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorsStartPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsStartPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorsStartResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorsStartResponse, error)
}

type connectionMonitorsStartPoller struct {
	pt *armcore.LROPoller
}

func (p *connectionMonitorsStartPoller) Done() bool {
	return p.pt.Done()
}

func (p *connectionMonitorsStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *connectionMonitorsStartPoller) FinalResponse(ctx context.Context) (ConnectionMonitorsStartResponse, error) {
	respType := ConnectionMonitorsStartResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectionMonitorsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *connectionMonitorsStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorsStartPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsStartResponse, error) {
	respType := ConnectionMonitorsStartResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ConnectionMonitorsStartResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ConnectionMonitorsStopPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsStopPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ConnectionMonitorsStopResponse will be returned.
	FinalResponse(ctx context.Context) (ConnectionMonitorsStopResponse, error)
}

type connectionMonitorsStopPoller struct {
	pt *armcore.LROPoller
}

func (p *connectionMonitorsStopPoller) Done() bool {
	return p.pt.Done()
}

func (p *connectionMonitorsStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *connectionMonitorsStopPoller) FinalResponse(ctx context.Context) (ConnectionMonitorsStopResponse, error) {
	respType := ConnectionMonitorsStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectionMonitorsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *connectionMonitorsStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *connectionMonitorsStopPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsStopResponse, error) {
	respType := ConnectionMonitorsStopResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ConnectionMonitorsStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosCustomPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DdosCustomPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DdosCustomPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DdosCustomPoliciesCreateOrUpdateResponse, error)
}

type ddosCustomPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *ddosCustomPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *ddosCustomPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ddosCustomPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DdosCustomPoliciesCreateOrUpdateResponse, error) {
	respType := DdosCustomPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DdosCustomPolicy)
	if err != nil {
		return DdosCustomPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ddosCustomPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosCustomPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesCreateOrUpdateResponse, error) {
	respType := DdosCustomPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DdosCustomPolicy)
	if err != nil {
		return DdosCustomPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosCustomPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type DdosCustomPoliciesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DdosCustomPoliciesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DdosCustomPoliciesDeleteResponse, error)
}

type ddosCustomPoliciesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *ddosCustomPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *ddosCustomPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ddosCustomPoliciesDeletePoller) FinalResponse(ctx context.Context) (DdosCustomPoliciesDeleteResponse, error) {
	respType := DdosCustomPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DdosCustomPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ddosCustomPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosCustomPoliciesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesDeleteResponse, error) {
	respType := DdosCustomPoliciesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DdosCustomPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosProtectionPlansCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DdosProtectionPlansCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DdosProtectionPlansCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (DdosProtectionPlansCreateOrUpdateResponse, error)
}

type ddosProtectionPlansCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *ddosProtectionPlansCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *ddosProtectionPlansCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ddosProtectionPlansCreateOrUpdatePoller) FinalResponse(ctx context.Context) (DdosProtectionPlansCreateOrUpdateResponse, error) {
	respType := DdosProtectionPlansCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DdosProtectionPlan)
	if err != nil {
		return DdosProtectionPlansCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ddosProtectionPlansCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosProtectionPlansCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansCreateOrUpdateResponse, error) {
	respType := DdosProtectionPlansCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.DdosProtectionPlan)
	if err != nil {
		return DdosProtectionPlansCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// DdosProtectionPlansDeletePoller provides polling facilities until the operation reaches a terminal state.
type DdosProtectionPlansDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final DdosProtectionPlansDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (DdosProtectionPlansDeleteResponse, error)
}

type ddosProtectionPlansDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *ddosProtectionPlansDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *ddosProtectionPlansDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ddosProtectionPlansDeletePoller) FinalResponse(ctx context.Context) (DdosProtectionPlansDeleteResponse, error) {
	respType := DdosProtectionPlansDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DdosProtectionPlansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ddosProtectionPlansDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ddosProtectionPlansDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansDeleteResponse, error) {
	respType := DdosProtectionPlansDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return DdosProtectionPlansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitAuthorizationsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse, error)
}

type expressRouteCircuitAuthorizationsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitAuthorizationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitAuthorizationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitAuthorizationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitAuthorizationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitAuthorizationsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitAuthorization)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitAuthorizationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitAuthorizationsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitAuthorizationsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationsDeleteResponse, error)
}

type expressRouteCircuitAuthorizationsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitAuthorizationsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitAuthorizationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitAuthorizationsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitAuthorizationsDeleteResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitAuthorizationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitAuthorizationsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsDeleteResponse, error) {
	respType := ExpressRouteCircuitAuthorizationsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteCircuitAuthorizationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionsCreateOrUpdateResponse, error)
}

type expressRouteCircuitConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitConnection)
	if err != nil {
		return ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitConnection)
	if err != nil {
		return ExpressRouteCircuitConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionsDeleteResponse, error)
}

type expressRouteCircuitConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitConnectionsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitConnectionsDeleteResponse, error) {
	respType := ExpressRouteCircuitConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsDeleteResponse, error) {
	respType := ExpressRouteCircuitConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteCircuitConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitPeeringsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitPeeringsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringsCreateOrUpdateResponse, error)
}

type expressRouteCircuitPeeringsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitPeering)
	if err != nil {
		return ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitPeeringsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitPeering)
	if err != nil {
		return ExpressRouteCircuitPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitPeeringsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitPeeringsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringsDeleteResponse, error)
}

type expressRouteCircuitPeeringsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitPeeringsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitPeeringsDeleteResponse, error) {
	respType := ExpressRouteCircuitPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitPeeringsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsDeleteResponse, error) {
	respType := ExpressRouteCircuitPeeringsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteCircuitPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsCreateOrUpdateResponse, error)
}

type expressRouteCircuitsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuit)
	if err != nil {
		return ExpressRouteCircuitsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCircuitsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuit)
	if err != nil {
		return ExpressRouteCircuitsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsDeleteResponse, error)
}

type expressRouteCircuitsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsDeleteResponse, error) {
	respType := ExpressRouteCircuitsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCircuitsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsDeleteResponse, error) {
	respType := ExpressRouteCircuitsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteCircuitsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsListArpTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsListArpTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsListArpTableResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsListArpTableResponse, error)
}

type expressRouteCircuitsListArpTablePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitsListArpTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitsListArpTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitsListArpTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsListArpTableResponse, error) {
	respType := ExpressRouteCircuitsListArpTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCircuitsListArpTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitsListArpTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsListArpTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsListArpTableResponse, error) {
	respType := ExpressRouteCircuitsListArpTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCircuitsListArpTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsListRoutesTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsListRoutesTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsListRoutesTableResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsListRoutesTableResponse, error)
}

type expressRouteCircuitsListRoutesTablePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitsListRoutesTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitsListRoutesTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitsListRoutesTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsListRoutesTableResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCircuitsListRoutesTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitsListRoutesTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsListRoutesTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsListRoutesTableResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCircuitsListRoutesTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCircuitsListRoutesTableSummaryPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsListRoutesTableSummaryPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCircuitsListRoutesTableSummaryResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCircuitsListRoutesTableSummaryResponse, error)
}

type expressRouteCircuitsListRoutesTableSummaryPoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCircuitsListRoutesTableSummaryPoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCircuitsListRoutesTableSummaryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCircuitsListRoutesTableSummaryPoller) FinalResponse(ctx context.Context) (ExpressRouteCircuitsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableSummaryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCircuitsListRoutesTableSummaryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCircuitsListRoutesTableSummaryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCircuitsListRoutesTableSummaryPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCircuitsListRoutesTableSummaryResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCircuitsListRoutesTableSummaryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteConnectionsCreateOrUpdateResponse, error)
}

type expressRouteConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteConnection)
	if err != nil {
		return ExpressRouteConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteConnection)
	if err != nil {
		return ExpressRouteConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteConnectionsDeleteResponse, error)
}

type expressRouteConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteConnectionsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteConnectionsDeleteResponse, error) {
	respType := ExpressRouteConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsDeleteResponse, error) {
	respType := ExpressRouteConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionPeeringsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse, error)
}

type expressRouteCrossConnectionPeeringsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCrossConnectionPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCrossConnectionPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCrossConnectionPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCrossConnectionPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionPeeringsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnectionPeering)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionPeeringsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionPeeringsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringsDeleteResponse, error)
}

type expressRouteCrossConnectionPeeringsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCrossConnectionPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCrossConnectionPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCrossConnectionPeeringsDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionPeeringsDeleteResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCrossConnectionPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionPeeringsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsDeleteResponse, error) {
	respType := ExpressRouteCrossConnectionPeeringsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteCrossConnectionPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsCreateOrUpdateResponse, error)
}

type expressRouteCrossConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCrossConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCrossConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCrossConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCrossConnection)
	if err != nil {
		return ExpressRouteCrossConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCrossConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsCreateOrUpdateResponse, error) {
	respType := ExpressRouteCrossConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnection)
	if err != nil {
		return ExpressRouteCrossConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionsListArpTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsListArpTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionsListArpTableResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListArpTableResponse, error)
}

type expressRouteCrossConnectionsListArpTablePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCrossConnectionsListArpTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCrossConnectionsListArpTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCrossConnectionsListArpTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListArpTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListArpTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListArpTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCrossConnectionsListArpTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionsListArpTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsListArpTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListArpTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsArpTableListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListArpTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionsListRoutesTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsListRoutesTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionsListRoutesTableResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListRoutesTableResponse, error)
}

type expressRouteCrossConnectionsListRoutesTablePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCrossConnectionsListRoutesTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCrossConnectionsListRoutesTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCrossConnectionsListRoutesTablePoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListRoutesTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListRoutesTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCrossConnectionsListRoutesTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionsListRoutesTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsListRoutesTableResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCircuitsRoutesTableListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListRoutesTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteCrossConnectionsListRoutesTableSummaryPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsListRoutesTableSummaryPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteCrossConnectionsListRoutesTableSummaryResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListRoutesTableSummaryResponse, error)
}

type expressRouteCrossConnectionsListRoutesTableSummaryPoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteCrossConnectionsListRoutesTableSummaryPoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteCrossConnectionsListRoutesTableSummaryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteCrossConnectionsListRoutesTableSummaryPoller) FinalResponse(ctx context.Context) (ExpressRouteCrossConnectionsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteCrossConnectionsListRoutesTableSummaryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteCrossConnectionsListRoutesTableSummaryPoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsListRoutesTableSummaryResponse, error) {
	respType := ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	if err != nil {
		return ExpressRouteCrossConnectionsListRoutesTableSummaryResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteGatewaysCreateOrUpdateResponse, error)
}

type expressRouteGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRouteGatewaysCreateOrUpdateResponse, error) {
	respType := ExpressRouteGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRouteGateway)
	if err != nil {
		return ExpressRouteGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysCreateOrUpdateResponse, error) {
	respType := ExpressRouteGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRouteGateway)
	if err != nil {
		return ExpressRouteGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRouteGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRouteGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRouteGatewaysDeleteResponse, error)
}

type expressRouteGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRouteGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRouteGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRouteGatewaysDeletePoller) FinalResponse(ctx context.Context) (ExpressRouteGatewaysDeleteResponse, error) {
	respType := ExpressRouteGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRouteGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRouteGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRouteGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysDeleteResponse, error) {
	respType := ExpressRouteGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRouteGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRoutePortsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRoutePortsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRoutePortsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRoutePortsCreateOrUpdateResponse, error)
}

type expressRoutePortsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRoutePortsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRoutePortsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRoutePortsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ExpressRoutePortsCreateOrUpdateResponse, error) {
	respType := ExpressRoutePortsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ExpressRoutePort)
	if err != nil {
		return ExpressRoutePortsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRoutePortsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRoutePortsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsCreateOrUpdateResponse, error) {
	respType := ExpressRoutePortsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ExpressRoutePort)
	if err != nil {
		return ExpressRoutePortsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ExpressRoutePortsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRoutePortsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ExpressRoutePortsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ExpressRoutePortsDeleteResponse, error)
}

type expressRoutePortsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *expressRoutePortsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *expressRoutePortsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *expressRoutePortsDeletePoller) FinalResponse(ctx context.Context) (ExpressRoutePortsDeleteResponse, error) {
	respType := ExpressRoutePortsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExpressRoutePortsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *expressRoutePortsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *expressRoutePortsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsDeleteResponse, error) {
	respType := ExpressRoutePortsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ExpressRoutePortsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FirewallPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (FirewallPoliciesCreateOrUpdateResponse, error)
}

type firewallPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *firewallPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *firewallPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *firewallPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FirewallPoliciesCreateOrUpdateResponse, error) {
	respType := FirewallPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FirewallPolicy)
	if err != nil {
		return FirewallPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *firewallPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesCreateOrUpdateResponse, error) {
	respType := FirewallPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FirewallPolicy)
	if err != nil {
		return FirewallPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPoliciesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FirewallPoliciesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (FirewallPoliciesDeleteResponse, error)
}

type firewallPoliciesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *firewallPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *firewallPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *firewallPoliciesDeletePoller) FinalResponse(ctx context.Context) (FirewallPoliciesDeleteResponse, error) {
	respType := FirewallPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FirewallPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *firewallPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPoliciesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesDeleteResponse, error) {
	respType := FirewallPoliciesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return FirewallPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPolicyRuleGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPolicyRuleGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FirewallPolicyRuleGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (FirewallPolicyRuleGroupsCreateOrUpdateResponse, error)
}

type firewallPolicyRuleGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *firewallPolicyRuleGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *firewallPolicyRuleGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *firewallPolicyRuleGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FirewallPolicyRuleGroupsCreateOrUpdateResponse, error) {
	respType := FirewallPolicyRuleGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FirewallPolicyRuleGroup)
	if err != nil {
		return FirewallPolicyRuleGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *firewallPolicyRuleGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPolicyRuleGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleGroupsCreateOrUpdateResponse, error) {
	respType := FirewallPolicyRuleGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FirewallPolicyRuleGroup)
	if err != nil {
		return FirewallPolicyRuleGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FirewallPolicyRuleGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPolicyRuleGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FirewallPolicyRuleGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (FirewallPolicyRuleGroupsDeleteResponse, error)
}

type firewallPolicyRuleGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *firewallPolicyRuleGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *firewallPolicyRuleGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *firewallPolicyRuleGroupsDeletePoller) FinalResponse(ctx context.Context) (FirewallPolicyRuleGroupsDeleteResponse, error) {
	respType := FirewallPolicyRuleGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FirewallPolicyRuleGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *firewallPolicyRuleGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *firewallPolicyRuleGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleGroupsDeleteResponse, error) {
	respType := FirewallPolicyRuleGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return FirewallPolicyRuleGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FlowLogsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FlowLogsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FlowLogsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (FlowLogsCreateOrUpdateResponse, error)
}

type flowLogsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *flowLogsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *flowLogsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *flowLogsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (FlowLogsCreateOrUpdateResponse, error) {
	respType := FlowLogsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FlowLog)
	if err != nil {
		return FlowLogsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *flowLogsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *flowLogsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsCreateOrUpdateResponse, error) {
	respType := FlowLogsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FlowLog)
	if err != nil {
		return FlowLogsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// FlowLogsDeletePoller provides polling facilities until the operation reaches a terminal state.
type FlowLogsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final FlowLogsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (FlowLogsDeleteResponse, error)
}

type flowLogsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *flowLogsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *flowLogsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *flowLogsDeletePoller) FinalResponse(ctx context.Context) (FlowLogsDeleteResponse, error) {
	respType := FlowLogsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return FlowLogsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *flowLogsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *flowLogsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsDeleteResponse, error) {
	respType := FlowLogsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return FlowLogsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPAllocationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPAllocationsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final IPAllocationsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (IPAllocationsCreateOrUpdateResponse, error)
}

type ipAllocationsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *ipAllocationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *ipAllocationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ipAllocationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (IPAllocationsCreateOrUpdateResponse, error) {
	respType := IPAllocationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IPAllocation)
	if err != nil {
		return IPAllocationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ipAllocationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipAllocationsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsCreateOrUpdateResponse, error) {
	respType := IPAllocationsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.IPAllocation)
	if err != nil {
		return IPAllocationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPAllocationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPAllocationsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final IPAllocationsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (IPAllocationsDeleteResponse, error)
}

type ipAllocationsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *ipAllocationsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *ipAllocationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ipAllocationsDeletePoller) FinalResponse(ctx context.Context) (IPAllocationsDeleteResponse, error) {
	respType := IPAllocationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IPAllocationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ipAllocationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipAllocationsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsDeleteResponse, error) {
	respType := IPAllocationsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return IPAllocationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final IPGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (IPGroupsCreateOrUpdateResponse, error)
}

type ipGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *ipGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *ipGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ipGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (IPGroupsCreateOrUpdateResponse, error) {
	respType := IPGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.IPGroup)
	if err != nil {
		return IPGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ipGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsCreateOrUpdateResponse, error) {
	respType := IPGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.IPGroup)
	if err != nil {
		return IPGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// IPGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final IPGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (IPGroupsDeleteResponse, error)
}

type ipGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *ipGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *ipGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *ipGroupsDeletePoller) FinalResponse(ctx context.Context) (IPGroupsDeleteResponse, error) {
	respType := IPGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return IPGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *ipGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *ipGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsDeleteResponse, error) {
	respType := IPGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return IPGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InboundNatRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InboundNatRulesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InboundNatRulesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (InboundNatRulesCreateOrUpdateResponse, error)
}

type inboundNatRulesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *inboundNatRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *inboundNatRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *inboundNatRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (InboundNatRulesCreateOrUpdateResponse, error) {
	respType := InboundNatRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.InboundNatRule)
	if err != nil {
		return InboundNatRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *inboundNatRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *inboundNatRulesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesCreateOrUpdateResponse, error) {
	respType := InboundNatRulesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.InboundNatRule)
	if err != nil {
		return InboundNatRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// InboundNatRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type InboundNatRulesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final InboundNatRulesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (InboundNatRulesDeleteResponse, error)
}

type inboundNatRulesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *inboundNatRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *inboundNatRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *inboundNatRulesDeletePoller) FinalResponse(ctx context.Context) (InboundNatRulesDeleteResponse, error) {
	respType := InboundNatRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return InboundNatRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *inboundNatRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *inboundNatRulesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesDeleteResponse, error) {
	respType := InboundNatRulesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return InboundNatRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LoadBalancersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LoadBalancersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (LoadBalancersCreateOrUpdateResponse, error)
}

type loadBalancersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *loadBalancersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *loadBalancersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *loadBalancersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LoadBalancersCreateOrUpdateResponse, error) {
	respType := LoadBalancersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LoadBalancer)
	if err != nil {
		return LoadBalancersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *loadBalancersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *loadBalancersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersCreateOrUpdateResponse, error) {
	respType := LoadBalancersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LoadBalancer)
	if err != nil {
		return LoadBalancersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LoadBalancersDeletePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LoadBalancersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (LoadBalancersDeleteResponse, error)
}

type loadBalancersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *loadBalancersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *loadBalancersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *loadBalancersDeletePoller) FinalResponse(ctx context.Context) (LoadBalancersDeleteResponse, error) {
	respType := LoadBalancersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LoadBalancersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *loadBalancersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *loadBalancersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersDeleteResponse, error) {
	respType := LoadBalancersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return LoadBalancersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LocalNetworkGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LocalNetworkGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LocalNetworkGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (LocalNetworkGatewaysCreateOrUpdateResponse, error)
}

type localNetworkGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *localNetworkGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *localNetworkGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *localNetworkGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (LocalNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := LocalNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LocalNetworkGateway)
	if err != nil {
		return LocalNetworkGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *localNetworkGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *localNetworkGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := LocalNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.LocalNetworkGateway)
	if err != nil {
		return LocalNetworkGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// LocalNetworkGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type LocalNetworkGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final LocalNetworkGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (LocalNetworkGatewaysDeleteResponse, error)
}

type localNetworkGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *localNetworkGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *localNetworkGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *localNetworkGatewaysDeletePoller) FinalResponse(ctx context.Context) (LocalNetworkGatewaysDeleteResponse, error) {
	respType := LocalNetworkGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LocalNetworkGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *localNetworkGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *localNetworkGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysDeleteResponse, error) {
	respType := LocalNetworkGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return LocalNetworkGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NatGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NatGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NatGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (NatGatewaysCreateOrUpdateResponse, error)
}

type natGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *natGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *natGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *natGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NatGatewaysCreateOrUpdateResponse, error) {
	respType := NatGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NatGateway)
	if err != nil {
		return NatGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *natGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *natGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysCreateOrUpdateResponse, error) {
	respType := NatGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NatGateway)
	if err != nil {
		return NatGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NatGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type NatGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NatGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NatGatewaysDeleteResponse, error)
}

type natGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *natGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *natGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *natGatewaysDeletePoller) FinalResponse(ctx context.Context) (NatGatewaysDeleteResponse, error) {
	respType := NatGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NatGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *natGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *natGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysDeleteResponse, error) {
	respType := NatGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NatGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfaceTapConfigurationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfaceTapConfigurationsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfaceTapConfigurationsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationsCreateOrUpdateResponse, error)
}

type networkInterfaceTapConfigurationsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *networkInterfaceTapConfigurationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkInterfaceTapConfigurationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkInterfaceTapConfigurationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationsCreateOrUpdateResponse, error) {
	respType := NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkInterfaceTapConfigurationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfaceTapConfigurationsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfaceTapConfigurationsCreateOrUpdateResponse, error) {
	respType := NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NetworkInterfaceTapConfiguration)
	if err != nil {
		return NetworkInterfaceTapConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfaceTapConfigurationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfaceTapConfigurationsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfaceTapConfigurationsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationsDeleteResponse, error)
}

type networkInterfaceTapConfigurationsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *networkInterfaceTapConfigurationsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkInterfaceTapConfigurationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkInterfaceTapConfigurationsDeletePoller) FinalResponse(ctx context.Context) (NetworkInterfaceTapConfigurationsDeleteResponse, error) {
	respType := NetworkInterfaceTapConfigurationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkInterfaceTapConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkInterfaceTapConfigurationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfaceTapConfigurationsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfaceTapConfigurationsDeleteResponse, error) {
	respType := NetworkInterfaceTapConfigurationsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkInterfaceTapConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfacesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfacesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfacesCreateOrUpdateResponse, error)
}

type networkInterfacesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *networkInterfacesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkInterfacesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkInterfacesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkInterfacesCreateOrUpdateResponse, error) {
	respType := NetworkInterfacesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkInterface)
	if err != nil {
		return NetworkInterfacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkInterfacesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfacesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesCreateOrUpdateResponse, error) {
	respType := NetworkInterfacesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NetworkInterface)
	if err != nil {
		return NetworkInterfacesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfacesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfacesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfacesDeleteResponse, error)
}

type networkInterfacesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *networkInterfacesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkInterfacesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkInterfacesDeletePoller) FinalResponse(ctx context.Context) (NetworkInterfacesDeleteResponse, error) {
	respType := NetworkInterfacesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkInterfacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkInterfacesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfacesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesDeleteResponse, error) {
	respType := NetworkInterfacesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkInterfacesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfacesGetEffectiveRouteTablePoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesGetEffectiveRouteTablePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfacesGetEffectiveRouteTableResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfacesGetEffectiveRouteTableResponse, error)
}

type networkInterfacesGetEffectiveRouteTablePoller struct {
	pt *armcore.LROPoller
}

func (p *networkInterfacesGetEffectiveRouteTablePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkInterfacesGetEffectiveRouteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkInterfacesGetEffectiveRouteTablePoller) FinalResponse(ctx context.Context) (NetworkInterfacesGetEffectiveRouteTableResponse, error) {
	respType := NetworkInterfacesGetEffectiveRouteTableResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EffectiveRouteListResult)
	if err != nil {
		return NetworkInterfacesGetEffectiveRouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkInterfacesGetEffectiveRouteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfacesGetEffectiveRouteTablePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesGetEffectiveRouteTableResponse, error) {
	respType := NetworkInterfacesGetEffectiveRouteTableResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EffectiveRouteListResult)
	if err != nil {
		return NetworkInterfacesGetEffectiveRouteTableResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller provides polling facilities until the operation reaches a terminal state.
type NetworkInterfacesListEffectiveNetworkSecurityGroupsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse, error)
}

type networkInterfacesListEffectiveNetworkSecurityGroupsPoller struct {
	pt *armcore.LROPoller
}

func (p *networkInterfacesListEffectiveNetworkSecurityGroupsPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkInterfacesListEffectiveNetworkSecurityGroupsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkInterfacesListEffectiveNetworkSecurityGroupsPoller) FinalResponse(ctx context.Context) (NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse, error) {
	respType := NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkInterfacesListEffectiveNetworkSecurityGroupsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkInterfacesListEffectiveNetworkSecurityGroupsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse, error) {
	respType := NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.EffectiveNetworkSecurityGroupListResult)
	if err != nil {
		return NetworkInterfacesListEffectiveNetworkSecurityGroupsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkManagementClientDeleteBastionShareableLinkPoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientDeleteBastionShareableLinkPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkManagementClientDeleteBastionShareableLinkResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkManagementClientDeleteBastionShareableLinkResponse, error)
}

type networkManagementClientDeleteBastionShareableLinkPoller struct {
	pt *armcore.LROPoller
}

func (p *networkManagementClientDeleteBastionShareableLinkPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkManagementClientDeleteBastionShareableLinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkManagementClientDeleteBastionShareableLinkPoller) FinalResponse(ctx context.Context) (NetworkManagementClientDeleteBastionShareableLinkResponse, error) {
	respType := NetworkManagementClientDeleteBastionShareableLinkResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkManagementClientDeleteBastionShareableLinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkManagementClientDeleteBastionShareableLinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkManagementClientDeleteBastionShareableLinkPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkManagementClientDeleteBastionShareableLinkResponse, error) {
	respType := NetworkManagementClientDeleteBastionShareableLinkResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkManagementClientDeleteBastionShareableLinkResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error)
}

type networkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller struct {
	pt *armcore.LROPoller
}

func (p *networkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) FinalResponse(ctx context.Context) (NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error) {
	respType := NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNProfileResponse)
	if err != nil {
		return NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error) {
	respType := NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNProfileResponse)
	if err != nil {
		return NetworkManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkManagementClientGetActiveSessionsPoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientGetActiveSessionsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkManagementClientGetActiveSessionsPager will be returned.
	FinalResponse(ctx context.Context) (NetworkManagementClientGetActiveSessionsPager, error)
}

type networkManagementClientGetActiveSessionsPoller struct {
	pt     *armcore.LROPoller
	client *NetworkManagementClient
}

func (p *networkManagementClientGetActiveSessionsPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkManagementClientGetActiveSessionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkManagementClientGetActiveSessionsPoller) FinalResponse(ctx context.Context) (NetworkManagementClientGetActiveSessionsPager, error) {
	respType := &networkManagementClientGetActiveSessionsPager{client: p.client}
	if _, err := p.pt.FinalResponse(ctx, &respType.current.BastionActiveSessionListResult); err != nil {
		return nil, err
	}
	return respType, nil
}

func (p *networkManagementClientGetActiveSessionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkManagementClientGetActiveSessionsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkManagementClientGetActiveSessionsPager, error) {
	respType := &networkManagementClientGetActiveSessionsPager{client: p.client}
	if _, err := p.pt.PollUntilDone(ctx, freq, &respType.current.BastionActiveSessionListResult); err != nil {
		return nil, err
	}
	return respType, nil
}

// NetworkManagementClientPutBastionShareableLinkPoller provides polling facilities until the operation reaches a terminal state.
type NetworkManagementClientPutBastionShareableLinkPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkManagementClientPutBastionShareableLinkPager will be returned.
	FinalResponse(ctx context.Context) (NetworkManagementClientPutBastionShareableLinkPager, error)
}

type networkManagementClientPutBastionShareableLinkPoller struct {
	pt     *armcore.LROPoller
	client *NetworkManagementClient
}

func (p *networkManagementClientPutBastionShareableLinkPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkManagementClientPutBastionShareableLinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkManagementClientPutBastionShareableLinkPoller) FinalResponse(ctx context.Context) (NetworkManagementClientPutBastionShareableLinkPager, error) {
	respType := &networkManagementClientPutBastionShareableLinkPager{client: p.client}
	if _, err := p.pt.FinalResponse(ctx, &respType.current.BastionShareableLinkListResult); err != nil {
		return nil, err
	}
	return respType, nil
}

func (p *networkManagementClientPutBastionShareableLinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkManagementClientPutBastionShareableLinkPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkManagementClientPutBastionShareableLinkPager, error) {
	respType := &networkManagementClientPutBastionShareableLinkPager{client: p.client}
	if _, err := p.pt.PollUntilDone(ctx, freq, &respType.current.BastionShareableLinkListResult); err != nil {
		return nil, err
	}
	return respType, nil
}

// NetworkProfilesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkProfilesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkProfilesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkProfilesDeleteResponse, error)
}

type networkProfilesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *networkProfilesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkProfilesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkProfilesDeletePoller) FinalResponse(ctx context.Context) (NetworkProfilesDeleteResponse, error) {
	respType := NetworkProfilesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkProfilesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkProfilesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkProfilesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkProfilesDeleteResponse, error) {
	respType := NetworkProfilesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkProfilesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkSecurityGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkSecurityGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkSecurityGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkSecurityGroupsCreateOrUpdateResponse, error)
}

type networkSecurityGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *networkSecurityGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkSecurityGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkSecurityGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkSecurityGroupsCreateOrUpdateResponse, error) {
	respType := NetworkSecurityGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkSecurityGroup)
	if err != nil {
		return NetworkSecurityGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkSecurityGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkSecurityGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkSecurityGroupsCreateOrUpdateResponse, error) {
	respType := NetworkSecurityGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NetworkSecurityGroup)
	if err != nil {
		return NetworkSecurityGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkSecurityGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkSecurityGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkSecurityGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkSecurityGroupsDeleteResponse, error)
}

type networkSecurityGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *networkSecurityGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkSecurityGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkSecurityGroupsDeletePoller) FinalResponse(ctx context.Context) (NetworkSecurityGroupsDeleteResponse, error) {
	respType := NetworkSecurityGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkSecurityGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkSecurityGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkSecurityGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkSecurityGroupsDeleteResponse, error) {
	respType := NetworkSecurityGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkSecurityGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkVirtualAppliancesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NetworkVirtualAppliancesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkVirtualAppliancesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkVirtualAppliancesCreateOrUpdateResponse, error)
}

type networkVirtualAppliancesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *networkVirtualAppliancesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkVirtualAppliancesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkVirtualAppliancesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (NetworkVirtualAppliancesCreateOrUpdateResponse, error) {
	respType := NetworkVirtualAppliancesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkVirtualAppliance)
	if err != nil {
		return NetworkVirtualAppliancesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkVirtualAppliancesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkVirtualAppliancesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkVirtualAppliancesCreateOrUpdateResponse, error) {
	respType := NetworkVirtualAppliancesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NetworkVirtualAppliance)
	if err != nil {
		return NetworkVirtualAppliancesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkVirtualAppliancesDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkVirtualAppliancesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkVirtualAppliancesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkVirtualAppliancesDeleteResponse, error)
}

type networkVirtualAppliancesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *networkVirtualAppliancesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkVirtualAppliancesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkVirtualAppliancesDeletePoller) FinalResponse(ctx context.Context) (NetworkVirtualAppliancesDeleteResponse, error) {
	respType := NetworkVirtualAppliancesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkVirtualAppliancesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkVirtualAppliancesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkVirtualAppliancesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkVirtualAppliancesDeleteResponse, error) {
	respType := NetworkVirtualAppliancesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkVirtualAppliancesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersCheckConnectivityPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersCheckConnectivityPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersCheckConnectivityResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersCheckConnectivityResponse, error)
}

type networkWatchersCheckConnectivityPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersCheckConnectivityPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersCheckConnectivityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersCheckConnectivityPoller) FinalResponse(ctx context.Context) (NetworkWatchersCheckConnectivityResponse, error) {
	respType := NetworkWatchersCheckConnectivityResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectivityInformation)
	if err != nil {
		return NetworkWatchersCheckConnectivityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersCheckConnectivityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersCheckConnectivityPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersCheckConnectivityResponse, error) {
	respType := NetworkWatchersCheckConnectivityResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConnectivityInformation)
	if err != nil {
		return NetworkWatchersCheckConnectivityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersDeletePoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersDeleteResponse, error)
}

type networkWatchersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersDeletePoller) FinalResponse(ctx context.Context) (NetworkWatchersDeleteResponse, error) {
	respType := NetworkWatchersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NetworkWatchersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersDeleteResponse, error) {
	respType := NetworkWatchersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return NetworkWatchersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetAzureReachabilityReportPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetAzureReachabilityReportPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetAzureReachabilityReportResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetAzureReachabilityReportResponse, error)
}

type networkWatchersGetAzureReachabilityReportPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetAzureReachabilityReportPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetAzureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetAzureReachabilityReportPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetAzureReachabilityReportResponse, error) {
	respType := NetworkWatchersGetAzureReachabilityReportResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AzureReachabilityReport)
	if err != nil {
		return NetworkWatchersGetAzureReachabilityReportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetAzureReachabilityReportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetAzureReachabilityReportPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetAzureReachabilityReportResponse, error) {
	respType := NetworkWatchersGetAzureReachabilityReportResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AzureReachabilityReport)
	if err != nil {
		return NetworkWatchersGetAzureReachabilityReportResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetFlowLogStatusPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetFlowLogStatusPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetFlowLogStatusResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetFlowLogStatusResponse, error)
}

type networkWatchersGetFlowLogStatusPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetFlowLogStatusPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetFlowLogStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetFlowLogStatusPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetFlowLogStatusResponse, error) {
	respType := NetworkWatchersGetFlowLogStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FlowLogInformation)
	if err != nil {
		return NetworkWatchersGetFlowLogStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetFlowLogStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetFlowLogStatusPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetFlowLogStatusResponse, error) {
	respType := NetworkWatchersGetFlowLogStatusResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FlowLogInformation)
	if err != nil {
		return NetworkWatchersGetFlowLogStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetNetworkConfigurationDiagnosticPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetNetworkConfigurationDiagnosticPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetNetworkConfigurationDiagnosticResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetNetworkConfigurationDiagnosticResponse, error)
}

type networkWatchersGetNetworkConfigurationDiagnosticPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetNetworkConfigurationDiagnosticPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetNetworkConfigurationDiagnosticPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetNetworkConfigurationDiagnosticPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetNetworkConfigurationDiagnosticResponse, error) {
	respType := NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetNetworkConfigurationDiagnosticPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetNetworkConfigurationDiagnosticPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetNetworkConfigurationDiagnosticResponse, error) {
	respType := NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NetworkConfigurationDiagnosticResponse)
	if err != nil {
		return NetworkWatchersGetNetworkConfigurationDiagnosticResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetNextHopPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetNextHopPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetNextHopResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetNextHopResponse, error)
}

type networkWatchersGetNextHopPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetNextHopPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetNextHopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetNextHopPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetNextHopResponse, error) {
	respType := NetworkWatchersGetNextHopResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NextHopResult)
	if err != nil {
		return NetworkWatchersGetNextHopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetNextHopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetNextHopPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetNextHopResponse, error) {
	respType := NetworkWatchersGetNextHopResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.NextHopResult)
	if err != nil {
		return NetworkWatchersGetNextHopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetTroubleshootingPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetTroubleshootingPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetTroubleshootingResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetTroubleshootingResponse, error)
}

type networkWatchersGetTroubleshootingPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetTroubleshootingPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetTroubleshootingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetTroubleshootingPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetTroubleshootingResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TroubleshootingResult)
	if err != nil {
		return NetworkWatchersGetTroubleshootingResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetTroubleshootingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetTroubleshootingPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetTroubleshootingResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.TroubleshootingResult)
	if err != nil {
		return NetworkWatchersGetTroubleshootingResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetTroubleshootingResultPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetTroubleshootingResultPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetTroubleshootingResultResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetTroubleshootingResultResponse, error)
}

type networkWatchersGetTroubleshootingResultPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetTroubleshootingResultPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetTroubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetTroubleshootingResultPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetTroubleshootingResultResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResultResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TroubleshootingResult)
	if err != nil {
		return NetworkWatchersGetTroubleshootingResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetTroubleshootingResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetTroubleshootingResultPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetTroubleshootingResultResponse, error) {
	respType := NetworkWatchersGetTroubleshootingResultResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.TroubleshootingResult)
	if err != nil {
		return NetworkWatchersGetTroubleshootingResultResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersGetVMSecurityRulesPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersGetVMSecurityRulesPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersGetVMSecurityRulesResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersGetVMSecurityRulesResponse, error)
}

type networkWatchersGetVMSecurityRulesPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersGetVMSecurityRulesPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersGetVMSecurityRulesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersGetVMSecurityRulesPoller) FinalResponse(ctx context.Context) (NetworkWatchersGetVMSecurityRulesResponse, error) {
	respType := NetworkWatchersGetVMSecurityRulesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityGroupViewResult)
	if err != nil {
		return NetworkWatchersGetVMSecurityRulesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersGetVMSecurityRulesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersGetVMSecurityRulesPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersGetVMSecurityRulesResponse, error) {
	respType := NetworkWatchersGetVMSecurityRulesResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SecurityGroupViewResult)
	if err != nil {
		return NetworkWatchersGetVMSecurityRulesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersListAvailableProvidersPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersListAvailableProvidersPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersListAvailableProvidersResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersListAvailableProvidersResponse, error)
}

type networkWatchersListAvailableProvidersPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersListAvailableProvidersPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersListAvailableProvidersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersListAvailableProvidersPoller) FinalResponse(ctx context.Context) (NetworkWatchersListAvailableProvidersResponse, error) {
	respType := NetworkWatchersListAvailableProvidersResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AvailableProvidersList)
	if err != nil {
		return NetworkWatchersListAvailableProvidersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersListAvailableProvidersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersListAvailableProvidersPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersListAvailableProvidersResponse, error) {
	respType := NetworkWatchersListAvailableProvidersResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.AvailableProvidersList)
	if err != nil {
		return NetworkWatchersListAvailableProvidersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersSetFlowLogConfigurationPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersSetFlowLogConfigurationPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersSetFlowLogConfigurationResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersSetFlowLogConfigurationResponse, error)
}

type networkWatchersSetFlowLogConfigurationPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersSetFlowLogConfigurationPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersSetFlowLogConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersSetFlowLogConfigurationPoller) FinalResponse(ctx context.Context) (NetworkWatchersSetFlowLogConfigurationResponse, error) {
	respType := NetworkWatchersSetFlowLogConfigurationResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.FlowLogInformation)
	if err != nil {
		return NetworkWatchersSetFlowLogConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersSetFlowLogConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersSetFlowLogConfigurationPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersSetFlowLogConfigurationResponse, error) {
	respType := NetworkWatchersSetFlowLogConfigurationResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.FlowLogInformation)
	if err != nil {
		return NetworkWatchersSetFlowLogConfigurationResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// NetworkWatchersVerifyIPFlowPoller provides polling facilities until the operation reaches a terminal state.
type NetworkWatchersVerifyIPFlowPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final NetworkWatchersVerifyIPFlowResponse will be returned.
	FinalResponse(ctx context.Context) (NetworkWatchersVerifyIPFlowResponse, error)
}

type networkWatchersVerifyIPFlowPoller struct {
	pt *armcore.LROPoller
}

func (p *networkWatchersVerifyIPFlowPoller) Done() bool {
	return p.pt.Done()
}

func (p *networkWatchersVerifyIPFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *networkWatchersVerifyIPFlowPoller) FinalResponse(ctx context.Context) (NetworkWatchersVerifyIPFlowResponse, error) {
	respType := NetworkWatchersVerifyIPFlowResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VerificationIPFlowResult)
	if err != nil {
		return NetworkWatchersVerifyIPFlowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *networkWatchersVerifyIPFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *networkWatchersVerifyIPFlowPoller) pollUntilDone(ctx context.Context, freq time.Duration) (NetworkWatchersVerifyIPFlowResponse, error) {
	respType := NetworkWatchersVerifyIPFlowResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VerificationIPFlowResult)
	if err != nil {
		return NetworkWatchersVerifyIPFlowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewaysCreateOrUpdateResponse, error)
}

type p2SVPNGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *p2SVPNGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *p2SVPNGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *p2SVPNGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysCreateOrUpdateResponse, error) {
	respType := P2SVPNGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *p2SVPNGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysCreateOrUpdateResponse, error) {
	respType := P2SVPNGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewaysDeleteResponse, error)
}

type p2SVPNGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *p2SVPNGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *p2SVPNGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *p2SVPNGatewaysDeletePoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysDeleteResponse, error) {
	respType := P2SVPNGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return P2SVPNGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *p2SVPNGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysDeleteResponse, error) {
	respType := P2SVPNGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return P2SVPNGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysDisconnectP2SVPNConnectionsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse, error)
}

type p2SVPNGatewaysDisconnectP2SVPNConnectionsPoller struct {
	pt *armcore.LROPoller
}

func (p *p2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) Done() bool {
	return p.pt.Done()
}

func (p *p2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *p2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse, error) {
	respType := P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *p2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewaysDisconnectP2SVPNConnectionsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse, error) {
	respType := P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return P2SVPNGatewaysDisconnectP2SVPNConnectionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewaysGenerateVPNProfilePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysGenerateVPNProfilePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewaysGenerateVPNProfileResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewaysGenerateVPNProfileResponse, error)
}

type p2SVPNGatewaysGenerateVPNProfilePoller struct {
	pt *armcore.LROPoller
}

func (p *p2SVPNGatewaysGenerateVPNProfilePoller) Done() bool {
	return p.pt.Done()
}

func (p *p2SVPNGatewaysGenerateVPNProfilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *p2SVPNGatewaysGenerateVPNProfilePoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysGenerateVPNProfileResponse, error) {
	respType := P2SVPNGatewaysGenerateVPNProfileResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNProfileResponse)
	if err != nil {
		return P2SVPNGatewaysGenerateVPNProfileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *p2SVPNGatewaysGenerateVPNProfilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewaysGenerateVPNProfilePoller) pollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysGenerateVPNProfileResponse, error) {
	respType := P2SVPNGatewaysGenerateVPNProfileResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNProfileResponse)
	if err != nil {
		return P2SVPNGatewaysGenerateVPNProfileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse, error)
}

type p2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller struct {
	pt *armcore.LROPoller
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) Done() bool {
	return p.pt.Done()
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNConnectionHealth)
	if err != nil {
		return P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthDetailedPoller) pollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.P2SVPNConnectionHealth)
	if err != nil {
		return P2SVPNGatewaysGetP2SVPNConnectionHealthDetailedResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// P2SVPNGatewaysGetP2SVPNConnectionHealthPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysGetP2SVPNConnectionHealthPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final P2SVPNGatewaysGetP2SVPNConnectionHealthResponse will be returned.
	FinalResponse(ctx context.Context) (P2SVPNGatewaysGetP2SVPNConnectionHealthResponse, error)
}

type p2SVPNGatewaysGetP2SVPNConnectionHealthPoller struct {
	pt *armcore.LROPoller
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthPoller) FinalResponse(ctx context.Context) (P2SVPNGatewaysGetP2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *p2SVPNGatewaysGetP2SVPNConnectionHealthPoller) pollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysGetP2SVPNConnectionHealthResponse, error) {
	respType := P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.P2SVPNGateway)
	if err != nil {
		return P2SVPNGatewaysGetP2SVPNConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCapturesCreatePoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesCreatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PacketCapturesCreateResponse will be returned.
	FinalResponse(ctx context.Context) (PacketCapturesCreateResponse, error)
}

type packetCapturesCreatePoller struct {
	pt *armcore.LROPoller
}

func (p *packetCapturesCreatePoller) Done() bool {
	return p.pt.Done()
}

func (p *packetCapturesCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *packetCapturesCreatePoller) FinalResponse(ctx context.Context) (PacketCapturesCreateResponse, error) {
	respType := PacketCapturesCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PacketCaptureResult)
	if err != nil {
		return PacketCapturesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *packetCapturesCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCapturesCreatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesCreateResponse, error) {
	respType := PacketCapturesCreateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PacketCaptureResult)
	if err != nil {
		return PacketCapturesCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCapturesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PacketCapturesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PacketCapturesDeleteResponse, error)
}

type packetCapturesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *packetCapturesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *packetCapturesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *packetCapturesDeletePoller) FinalResponse(ctx context.Context) (PacketCapturesDeleteResponse, error) {
	respType := PacketCapturesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PacketCapturesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *packetCapturesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCapturesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesDeleteResponse, error) {
	respType := PacketCapturesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PacketCapturesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCapturesGetStatusPoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesGetStatusPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PacketCapturesGetStatusResponse will be returned.
	FinalResponse(ctx context.Context) (PacketCapturesGetStatusResponse, error)
}

type packetCapturesGetStatusPoller struct {
	pt *armcore.LROPoller
}

func (p *packetCapturesGetStatusPoller) Done() bool {
	return p.pt.Done()
}

func (p *packetCapturesGetStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *packetCapturesGetStatusPoller) FinalResponse(ctx context.Context) (PacketCapturesGetStatusResponse, error) {
	respType := PacketCapturesGetStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return PacketCapturesGetStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *packetCapturesGetStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCapturesGetStatusPoller) pollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesGetStatusResponse, error) {
	respType := PacketCapturesGetStatusResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PacketCaptureQueryStatusResult)
	if err != nil {
		return PacketCapturesGetStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PacketCapturesStopPoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesStopPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PacketCapturesStopResponse will be returned.
	FinalResponse(ctx context.Context) (PacketCapturesStopResponse, error)
}

type packetCapturesStopPoller struct {
	pt *armcore.LROPoller
}

func (p *packetCapturesStopPoller) Done() bool {
	return p.pt.Done()
}

func (p *packetCapturesStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *packetCapturesStopPoller) FinalResponse(ctx context.Context) (PacketCapturesStopResponse, error) {
	respType := PacketCapturesStopResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PacketCapturesStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *packetCapturesStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *packetCapturesStopPoller) pollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesStopResponse, error) {
	respType := PacketCapturesStopResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PacketCapturesStopResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateDNSZoneGroupsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateDNSZoneGroupsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateDNSZoneGroupsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateDNSZoneGroupsCreateOrUpdateResponse, error)
}

type privateDNSZoneGroupsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *privateDNSZoneGroupsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateDNSZoneGroupsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateDNSZoneGroupsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateDNSZoneGroupsCreateOrUpdateResponse, error) {
	respType := PrivateDNSZoneGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateDNSZoneGroup)
	if err != nil {
		return PrivateDNSZoneGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateDNSZoneGroupsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateDNSZoneGroupsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsCreateOrUpdateResponse, error) {
	respType := PrivateDNSZoneGroupsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateDNSZoneGroup)
	if err != nil {
		return PrivateDNSZoneGroupsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateDNSZoneGroupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateDNSZoneGroupsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateDNSZoneGroupsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateDNSZoneGroupsDeleteResponse, error)
}

type privateDNSZoneGroupsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *privateDNSZoneGroupsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateDNSZoneGroupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateDNSZoneGroupsDeletePoller) FinalResponse(ctx context.Context) (PrivateDNSZoneGroupsDeleteResponse, error) {
	respType := PrivateDNSZoneGroupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateDNSZoneGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateDNSZoneGroupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateDNSZoneGroupsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsDeleteResponse, error) {
	respType := PrivateDNSZoneGroupsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateDNSZoneGroupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointsCreateOrUpdateResponse, error)
}

type privateEndpointsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpoint)
	if err != nil {
		return PrivateEndpointsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsCreateOrUpdateResponse, error) {
	respType := PrivateEndpointsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpoint)
	if err != nil {
		return PrivateEndpointsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateEndpointsDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateEndpointsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateEndpointsDeleteResponse, error)
}

type privateEndpointsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *privateEndpointsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateEndpointsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateEndpointsDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointsDeleteResponse, error) {
	respType := PrivateEndpointsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateEndpointsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateEndpointsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsDeleteResponse, error) {
	respType := PrivateEndpointsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateEndpointsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error)
}

type privateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller struct {
	pt *armcore.LROPoller
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) FinalResponse(ctx context.Context) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupPoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServicesCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesCheckPrivateLinkServiceVisibilityPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse, error)
}

type privateLinkServicesCheckPrivateLinkServiceVisibilityPoller struct {
	pt *armcore.LROPoller
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityPoller) Done() bool {
	return p.pt.Done()
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityPoller) FinalResponse(ctx context.Context) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicesCheckPrivateLinkServiceVisibilityPoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse, error) {
	respType := PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkServiceVisibility)
	if err != nil {
		return PrivateLinkServicesCheckPrivateLinkServiceVisibilityResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServicesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServicesCreateOrUpdateResponse, error)
}

type privateLinkServicesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *privateLinkServicesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateLinkServicesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateLinkServicesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateLinkServicesCreateOrUpdateResponse, error) {
	respType := PrivateLinkServicesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PrivateLinkService)
	if err != nil {
		return PrivateLinkServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateLinkServicesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesCreateOrUpdateResponse, error) {
	respType := PrivateLinkServicesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PrivateLinkService)
	if err != nil {
		return PrivateLinkServicesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServicesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServicesDeleteResponse, error)
}

type privateLinkServicesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *privateLinkServicesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *privateLinkServicesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateLinkServicesDeletePoller) FinalResponse(ctx context.Context) (PrivateLinkServicesDeleteResponse, error) {
	respType := PrivateLinkServicesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateLinkServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateLinkServicesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesDeleteResponse, error) {
	respType := PrivateLinkServicesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateLinkServicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PrivateLinkServicesDeletePrivateEndpointConnectionPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesDeletePrivateEndpointConnectionPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PrivateLinkServicesDeletePrivateEndpointConnectionResponse will be returned.
	FinalResponse(ctx context.Context) (PrivateLinkServicesDeletePrivateEndpointConnectionResponse, error)
}

type privateLinkServicesDeletePrivateEndpointConnectionPoller struct {
	pt *armcore.LROPoller
}

func (p *privateLinkServicesDeletePrivateEndpointConnectionPoller) Done() bool {
	return p.pt.Done()
}

func (p *privateLinkServicesDeletePrivateEndpointConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *privateLinkServicesDeletePrivateEndpointConnectionPoller) FinalResponse(ctx context.Context) (PrivateLinkServicesDeletePrivateEndpointConnectionResponse, error) {
	respType := PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *privateLinkServicesDeletePrivateEndpointConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *privateLinkServicesDeletePrivateEndpointConnectionPoller) pollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesDeletePrivateEndpointConnectionResponse, error) {
	respType := PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PrivateLinkServicesDeletePrivateEndpointConnectionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPAddressesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPAddressesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PublicIPAddressesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PublicIPAddressesCreateOrUpdateResponse, error)
}

type publicIPAddressesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *publicIPAddressesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *publicIPAddressesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *publicIPAddressesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PublicIPAddressesCreateOrUpdateResponse, error) {
	respType := PublicIPAddressesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PublicIPAddress)
	if err != nil {
		return PublicIPAddressesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *publicIPAddressesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPAddressesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesCreateOrUpdateResponse, error) {
	respType := PublicIPAddressesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PublicIPAddress)
	if err != nil {
		return PublicIPAddressesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPAddressesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPAddressesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PublicIPAddressesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PublicIPAddressesDeleteResponse, error)
}

type publicIPAddressesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *publicIPAddressesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *publicIPAddressesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *publicIPAddressesDeletePoller) FinalResponse(ctx context.Context) (PublicIPAddressesDeleteResponse, error) {
	respType := PublicIPAddressesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PublicIPAddressesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *publicIPAddressesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPAddressesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesDeleteResponse, error) {
	respType := PublicIPAddressesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PublicIPAddressesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPPrefixesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPPrefixesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PublicIPPrefixesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (PublicIPPrefixesCreateOrUpdateResponse, error)
}

type publicIPPrefixesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *publicIPPrefixesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *publicIPPrefixesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *publicIPPrefixesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PublicIPPrefixesCreateOrUpdateResponse, error) {
	respType := PublicIPPrefixesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PublicIPPrefix)
	if err != nil {
		return PublicIPPrefixesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *publicIPPrefixesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPPrefixesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesCreateOrUpdateResponse, error) {
	respType := PublicIPPrefixesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.PublicIPPrefix)
	if err != nil {
		return PublicIPPrefixesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// PublicIPPrefixesDeletePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPPrefixesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final PublicIPPrefixesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (PublicIPPrefixesDeleteResponse, error)
}

type publicIPPrefixesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *publicIPPrefixesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *publicIPPrefixesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *publicIPPrefixesDeletePoller) FinalResponse(ctx context.Context) (PublicIPPrefixesDeleteResponse, error) {
	respType := PublicIPPrefixesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PublicIPPrefixesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *publicIPPrefixesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *publicIPPrefixesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesDeleteResponse, error) {
	respType := PublicIPPrefixesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return PublicIPPrefixesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFilterRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteFilterRulesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteFilterRulesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (RouteFilterRulesCreateOrUpdateResponse, error)
}

type routeFilterRulesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *routeFilterRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *routeFilterRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routeFilterRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RouteFilterRulesCreateOrUpdateResponse, error) {
	respType := RouteFilterRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RouteFilterRule)
	if err != nil {
		return RouteFilterRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routeFilterRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFilterRulesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesCreateOrUpdateResponse, error) {
	respType := RouteFilterRulesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.RouteFilterRule)
	if err != nil {
		return RouteFilterRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFilterRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteFilterRulesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteFilterRulesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RouteFilterRulesDeleteResponse, error)
}

type routeFilterRulesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *routeFilterRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *routeFilterRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routeFilterRulesDeletePoller) FinalResponse(ctx context.Context) (RouteFilterRulesDeleteResponse, error) {
	respType := RouteFilterRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RouteFilterRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routeFilterRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFilterRulesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesDeleteResponse, error) {
	respType := RouteFilterRulesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RouteFilterRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFiltersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteFiltersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteFiltersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (RouteFiltersCreateOrUpdateResponse, error)
}

type routeFiltersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *routeFiltersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *routeFiltersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routeFiltersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RouteFiltersCreateOrUpdateResponse, error) {
	respType := RouteFiltersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RouteFilter)
	if err != nil {
		return RouteFiltersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routeFiltersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFiltersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersCreateOrUpdateResponse, error) {
	respType := RouteFiltersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.RouteFilter)
	if err != nil {
		return RouteFiltersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteFiltersDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteFiltersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteFiltersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RouteFiltersDeleteResponse, error)
}

type routeFiltersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *routeFiltersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *routeFiltersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routeFiltersDeletePoller) FinalResponse(ctx context.Context) (RouteFiltersDeleteResponse, error) {
	respType := RouteFiltersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RouteFiltersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routeFiltersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeFiltersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersDeleteResponse, error) {
	respType := RouteFiltersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RouteFiltersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteTablesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteTablesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteTablesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (RouteTablesCreateOrUpdateResponse, error)
}

type routeTablesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *routeTablesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *routeTablesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routeTablesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RouteTablesCreateOrUpdateResponse, error) {
	respType := RouteTablesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.RouteTable)
	if err != nil {
		return RouteTablesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routeTablesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeTablesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesCreateOrUpdateResponse, error) {
	respType := RouteTablesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.RouteTable)
	if err != nil {
		return RouteTablesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RouteTablesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteTablesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RouteTablesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RouteTablesDeleteResponse, error)
}

type routeTablesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *routeTablesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *routeTablesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routeTablesDeletePoller) FinalResponse(ctx context.Context) (RouteTablesDeleteResponse, error) {
	respType := RouteTablesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RouteTablesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routeTablesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routeTablesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesDeleteResponse, error) {
	respType := RouteTablesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RouteTablesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RoutesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (RoutesCreateOrUpdateResponse, error)
}

type routesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *routesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *routesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (RoutesCreateOrUpdateResponse, error) {
	respType := RoutesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Route)
	if err != nil {
		return RoutesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RoutesCreateOrUpdateResponse, error) {
	respType := RoutesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Route)
	if err != nil {
		return RoutesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// RoutesDeletePoller provides polling facilities until the operation reaches a terminal state.
type RoutesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final RoutesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (RoutesDeleteResponse, error)
}

type routesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *routesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *routesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *routesDeletePoller) FinalResponse(ctx context.Context) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RoutesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *routesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *routesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (RoutesDeleteResponse, error) {
	respType := RoutesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return RoutesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPartnerProvidersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPartnerProvidersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityPartnerProvidersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityPartnerProvidersCreateOrUpdateResponse, error)
}

type securityPartnerProvidersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *securityPartnerProvidersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *securityPartnerProvidersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityPartnerProvidersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SecurityPartnerProvidersCreateOrUpdateResponse, error) {
	respType := SecurityPartnerProvidersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityPartnerProvider)
	if err != nil {
		return SecurityPartnerProvidersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityPartnerProvidersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPartnerProvidersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersCreateOrUpdateResponse, error) {
	respType := SecurityPartnerProvidersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SecurityPartnerProvider)
	if err != nil {
		return SecurityPartnerProvidersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityPartnerProvidersDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPartnerProvidersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityPartnerProvidersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityPartnerProvidersDeleteResponse, error)
}

type securityPartnerProvidersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *securityPartnerProvidersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *securityPartnerProvidersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityPartnerProvidersDeletePoller) FinalResponse(ctx context.Context) (SecurityPartnerProvidersDeleteResponse, error) {
	respType := SecurityPartnerProvidersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecurityPartnerProvidersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityPartnerProvidersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityPartnerProvidersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersDeleteResponse, error) {
	respType := SecurityPartnerProvidersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SecurityPartnerProvidersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityRulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityRulesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityRulesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityRulesCreateOrUpdateResponse, error)
}

type securityRulesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *securityRulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *securityRulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityRulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SecurityRulesCreateOrUpdateResponse, error) {
	respType := SecurityRulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecurityRule)
	if err != nil {
		return SecurityRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityRulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityRulesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesCreateOrUpdateResponse, error) {
	respType := SecurityRulesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.SecurityRule)
	if err != nil {
		return SecurityRulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SecurityRulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityRulesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SecurityRulesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SecurityRulesDeleteResponse, error)
}

type securityRulesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *securityRulesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *securityRulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *securityRulesDeletePoller) FinalResponse(ctx context.Context) (SecurityRulesDeleteResponse, error) {
	respType := SecurityRulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SecurityRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *securityRulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *securityRulesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesDeleteResponse, error) {
	respType := SecurityRulesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SecurityRulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPoliciesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServiceEndpointPoliciesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServiceEndpointPoliciesCreateOrUpdateResponse, error)
}

type serviceEndpointPoliciesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serviceEndpointPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serviceEndpointPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serviceEndpointPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServiceEndpointPoliciesCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServiceEndpointPolicy)
	if err != nil {
		return ServiceEndpointPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serviceEndpointPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPoliciesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServiceEndpointPolicy)
	if err != nil {
		return ServiceEndpointPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPoliciesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServiceEndpointPoliciesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServiceEndpointPoliciesDeleteResponse, error)
}

type serviceEndpointPoliciesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serviceEndpointPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serviceEndpointPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serviceEndpointPoliciesDeletePoller) FinalResponse(ctx context.Context) (ServiceEndpointPoliciesDeleteResponse, error) {
	respType := ServiceEndpointPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServiceEndpointPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serviceEndpointPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPoliciesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesDeleteResponse, error) {
	respType := ServiceEndpointPoliciesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServiceEndpointPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPolicyDefinitionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse, error)
}

type serviceEndpointPolicyDefinitionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *serviceEndpointPolicyDefinitionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *serviceEndpointPolicyDefinitionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serviceEndpointPolicyDefinitionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serviceEndpointPolicyDefinitionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPolicyDefinitionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ServiceEndpointPolicyDefinition)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ServiceEndpointPolicyDefinitionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPolicyDefinitionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final ServiceEndpointPolicyDefinitionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionsDeleteResponse, error)
}

type serviceEndpointPolicyDefinitionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *serviceEndpointPolicyDefinitionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *serviceEndpointPolicyDefinitionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *serviceEndpointPolicyDefinitionsDeletePoller) FinalResponse(ctx context.Context) (ServiceEndpointPolicyDefinitionsDeleteResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *serviceEndpointPolicyDefinitionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *serviceEndpointPolicyDefinitionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsDeleteResponse, error) {
	respType := ServiceEndpointPolicyDefinitionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return ServiceEndpointPolicyDefinitionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SubnetsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SubnetsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SubnetsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (SubnetsCreateOrUpdateResponse, error)
}

type subnetsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *subnetsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *subnetsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *subnetsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (SubnetsCreateOrUpdateResponse, error) {
	respType := SubnetsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Subnet)
	if err != nil {
		return SubnetsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *subnetsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *subnetsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SubnetsCreateOrUpdateResponse, error) {
	respType := SubnetsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Subnet)
	if err != nil {
		return SubnetsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SubnetsDeletePoller provides polling facilities until the operation reaches a terminal state.
type SubnetsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SubnetsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (SubnetsDeleteResponse, error)
}

type subnetsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *subnetsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *subnetsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *subnetsDeletePoller) FinalResponse(ctx context.Context) (SubnetsDeleteResponse, error) {
	respType := SubnetsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SubnetsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *subnetsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *subnetsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (SubnetsDeleteResponse, error) {
	respType := SubnetsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SubnetsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SubnetsPrepareNetworkPoliciesPoller provides polling facilities until the operation reaches a terminal state.
type SubnetsPrepareNetworkPoliciesPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SubnetsPrepareNetworkPoliciesResponse will be returned.
	FinalResponse(ctx context.Context) (SubnetsPrepareNetworkPoliciesResponse, error)
}

type subnetsPrepareNetworkPoliciesPoller struct {
	pt *armcore.LROPoller
}

func (p *subnetsPrepareNetworkPoliciesPoller) Done() bool {
	return p.pt.Done()
}

func (p *subnetsPrepareNetworkPoliciesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *subnetsPrepareNetworkPoliciesPoller) FinalResponse(ctx context.Context) (SubnetsPrepareNetworkPoliciesResponse, error) {
	respType := SubnetsPrepareNetworkPoliciesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SubnetsPrepareNetworkPoliciesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *subnetsPrepareNetworkPoliciesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *subnetsPrepareNetworkPoliciesPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SubnetsPrepareNetworkPoliciesResponse, error) {
	respType := SubnetsPrepareNetworkPoliciesResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SubnetsPrepareNetworkPoliciesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// SubnetsUnprepareNetworkPoliciesPoller provides polling facilities until the operation reaches a terminal state.
type SubnetsUnprepareNetworkPoliciesPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final SubnetsUnprepareNetworkPoliciesResponse will be returned.
	FinalResponse(ctx context.Context) (SubnetsUnprepareNetworkPoliciesResponse, error)
}

type subnetsUnprepareNetworkPoliciesPoller struct {
	pt *armcore.LROPoller
}

func (p *subnetsUnprepareNetworkPoliciesPoller) Done() bool {
	return p.pt.Done()
}

func (p *subnetsUnprepareNetworkPoliciesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *subnetsUnprepareNetworkPoliciesPoller) FinalResponse(ctx context.Context) (SubnetsUnprepareNetworkPoliciesResponse, error) {
	respType := SubnetsUnprepareNetworkPoliciesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SubnetsUnprepareNetworkPoliciesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *subnetsUnprepareNetworkPoliciesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *subnetsUnprepareNetworkPoliciesPoller) pollUntilDone(ctx context.Context, freq time.Duration) (SubnetsUnprepareNetworkPoliciesResponse, error) {
	respType := SubnetsUnprepareNetworkPoliciesResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return SubnetsUnprepareNetworkPoliciesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VPNConnectionsCreateOrUpdateResponse, error)
}

type vpnConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNConnectionsCreateOrUpdateResponse, error) {
	respType := VPNConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNConnection)
	if err != nil {
		return VPNConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsCreateOrUpdateResponse, error) {
	respType := VPNConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNConnection)
	if err != nil {
		return VPNConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VPNConnectionsDeleteResponse, error)
}

type vpnConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnConnectionsDeletePoller) FinalResponse(ctx context.Context) (VPNConnectionsDeleteResponse, error) {
	respType := VPNConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsDeleteResponse, error) {
	respType := VPNConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VPNConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VPNGatewaysCreateOrUpdateResponse, error)
}

type vpnGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNGatewaysCreateOrUpdateResponse, error) {
	respType := VPNGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysCreateOrUpdateResponse, error) {
	respType := VPNGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VPNGatewaysDeleteResponse, error)
}

type vpnGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnGatewaysDeletePoller) FinalResponse(ctx context.Context) (VPNGatewaysDeleteResponse, error) {
	respType := VPNGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysDeleteResponse, error) {
	respType := VPNGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VPNGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNGatewaysResetPoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysResetPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNGatewaysResetResponse will be returned.
	FinalResponse(ctx context.Context) (VPNGatewaysResetResponse, error)
}

type vpnGatewaysResetPoller struct {
	pt *armcore.LROPoller
}

func (p *vpnGatewaysResetPoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnGatewaysResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnGatewaysResetPoller) FinalResponse(ctx context.Context) (VPNGatewaysResetResponse, error) {
	respType := VPNGatewaysResetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnGatewaysResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnGatewaysResetPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysResetResponse, error) {
	respType := VPNGatewaysResetResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNGateway)
	if err != nil {
		return VPNGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNServerConfigurationsAssociatedWithVirtualWanListPoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsAssociatedWithVirtualWanListPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNServerConfigurationsAssociatedWithVirtualWanListResponse will be returned.
	FinalResponse(ctx context.Context) (VPNServerConfigurationsAssociatedWithVirtualWanListResponse, error)
}

type vpnServerConfigurationsAssociatedWithVirtualWanListPoller struct {
	pt *armcore.LROPoller
}

func (p *vpnServerConfigurationsAssociatedWithVirtualWanListPoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnServerConfigurationsAssociatedWithVirtualWanListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnServerConfigurationsAssociatedWithVirtualWanListPoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsAssociatedWithVirtualWanListResponse, error) {
	respType := VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNServerConfigurationsResponse)
	if err != nil {
		return VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnServerConfigurationsAssociatedWithVirtualWanListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationsAssociatedWithVirtualWanListPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsAssociatedWithVirtualWanListResponse, error) {
	respType := VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNServerConfigurationsResponse)
	if err != nil {
		return VPNServerConfigurationsAssociatedWithVirtualWanListResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNServerConfigurationsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNServerConfigurationsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VPNServerConfigurationsCreateOrUpdateResponse, error)
}

type vpnServerConfigurationsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnServerConfigurationsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnServerConfigurationsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnServerConfigurationsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsCreateOrUpdateResponse, error) {
	respType := VPNServerConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNServerConfiguration)
	if err != nil {
		return VPNServerConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnServerConfigurationsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsCreateOrUpdateResponse, error) {
	respType := VPNServerConfigurationsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNServerConfiguration)
	if err != nil {
		return VPNServerConfigurationsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNServerConfigurationsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNServerConfigurationsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VPNServerConfigurationsDeleteResponse, error)
}

type vpnServerConfigurationsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnServerConfigurationsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnServerConfigurationsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnServerConfigurationsDeletePoller) FinalResponse(ctx context.Context) (VPNServerConfigurationsDeleteResponse, error) {
	respType := VPNServerConfigurationsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNServerConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnServerConfigurationsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnServerConfigurationsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsDeleteResponse, error) {
	respType := VPNServerConfigurationsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VPNServerConfigurationsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNSitesConfigurationDownloadPoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesConfigurationDownloadPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNSitesConfigurationDownloadResponse will be returned.
	FinalResponse(ctx context.Context) (VPNSitesConfigurationDownloadResponse, error)
}

type vpnSitesConfigurationDownloadPoller struct {
	pt *armcore.LROPoller
}

func (p *vpnSitesConfigurationDownloadPoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnSitesConfigurationDownloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnSitesConfigurationDownloadPoller) FinalResponse(ctx context.Context) (VPNSitesConfigurationDownloadResponse, error) {
	respType := VPNSitesConfigurationDownloadResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNSitesConfigurationDownloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnSitesConfigurationDownloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnSitesConfigurationDownloadPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesConfigurationDownloadResponse, error) {
	respType := VPNSitesConfigurationDownloadResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VPNSitesConfigurationDownloadResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNSitesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNSitesCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VPNSitesCreateOrUpdateResponse, error)
}

type vpnSitesCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnSitesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnSitesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnSitesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VPNSitesCreateOrUpdateResponse, error) {
	respType := VPNSitesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNSite)
	if err != nil {
		return VPNSitesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnSitesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnSitesCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesCreateOrUpdateResponse, error) {
	respType := VPNSitesCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNSite)
	if err != nil {
		return VPNSitesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VPNSitesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VPNSitesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VPNSitesDeleteResponse, error)
}

type vpnSitesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *vpnSitesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *vpnSitesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *vpnSitesDeletePoller) FinalResponse(ctx context.Context) (VPNSitesDeleteResponse, error) {
	respType := VPNSitesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VPNSitesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *vpnSitesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *vpnSitesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesDeleteResponse, error) {
	respType := VPNSitesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VPNSitesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubRouteTableV2SCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubRouteTableV2SCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualHubRouteTableV2SCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualHubRouteTableV2SCreateOrUpdateResponse, error)
}

type virtualHubRouteTableV2SCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualHubRouteTableV2SCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualHubRouteTableV2SCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualHubRouteTableV2SCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualHubRouteTableV2SCreateOrUpdateResponse, error) {
	respType := VirtualHubRouteTableV2SCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualHubRouteTableV2)
	if err != nil {
		return VirtualHubRouteTableV2SCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualHubRouteTableV2SCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubRouteTableV2SCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SCreateOrUpdateResponse, error) {
	respType := VirtualHubRouteTableV2SCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualHubRouteTableV2)
	if err != nil {
		return VirtualHubRouteTableV2SCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubRouteTableV2SDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubRouteTableV2SDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualHubRouteTableV2SDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualHubRouteTableV2SDeleteResponse, error)
}

type virtualHubRouteTableV2SDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualHubRouteTableV2SDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualHubRouteTableV2SDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualHubRouteTableV2SDeletePoller) FinalResponse(ctx context.Context) (VirtualHubRouteTableV2SDeleteResponse, error) {
	respType := VirtualHubRouteTableV2SDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubRouteTableV2SDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualHubRouteTableV2SDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubRouteTableV2SDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SDeleteResponse, error) {
	respType := VirtualHubRouteTableV2SDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualHubRouteTableV2SDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualHubsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualHubsCreateOrUpdateResponse, error)
}

type virtualHubsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualHubsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualHubsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualHubsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualHubsCreateOrUpdateResponse, error) {
	respType := VirtualHubsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualHub)
	if err != nil {
		return VirtualHubsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualHubsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsCreateOrUpdateResponse, error) {
	respType := VirtualHubsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualHub)
	if err != nil {
		return VirtualHubsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualHubsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualHubsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualHubsDeleteResponse, error)
}

type virtualHubsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualHubsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualHubsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualHubsDeletePoller) FinalResponse(ctx context.Context) (VirtualHubsDeleteResponse, error) {
	respType := VirtualHubsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualHubsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualHubsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualHubsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsDeleteResponse, error) {
	respType := VirtualHubsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualHubsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsCreateOrUpdateResponse, error)
}

type virtualNetworkGatewayConnectionsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsDeleteResponse, error)
}

type virtualNetworkGatewayConnectionsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsDeleteResponse, error) {
	respType := VirtualNetworkGatewayConnectionsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewayConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsDeleteResponse, error) {
	respType := VirtualNetworkGatewayConnectionsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkGatewayConnectionsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsResetSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsResetSharedKeyPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsResetSharedKeyResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsResetSharedKeyResponse, error)
}

type virtualNetworkGatewayConnectionsResetSharedKeyPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsResetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsResetSharedKeyPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsResetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionResetSharedKey)
	if err != nil {
		return VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsResetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsResetSharedKeyPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsResetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConnectionResetSharedKey)
	if err != nil {
		return VirtualNetworkGatewayConnectionsResetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsSetSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsSetSharedKeyPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsSetSharedKeyResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsSetSharedKeyResponse, error)
}

type virtualNetworkGatewayConnectionsSetSharedKeyPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsSetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsSetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsSetSharedKeyPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsSetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.ConnectionSharedKey)
	if err != nil {
		return VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsSetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsSetSharedKeyPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsSetSharedKeyResponse, error) {
	respType := VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.ConnectionSharedKey)
	if err != nil {
		return VirtualNetworkGatewayConnectionsSetSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsStartPacketCapturePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsStartPacketCaptureResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsStartPacketCaptureResponse, error)
}

type virtualNetworkGatewayConnectionsStartPacketCapturePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsStartPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsStartPacketCapturePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsStopPacketCapturePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsStopPacketCaptureResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsStopPacketCaptureResponse, error)
}

type virtualNetworkGatewayConnectionsStopPacketCapturePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsStopPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsStopPacketCapturePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewayConnectionsStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewayConnectionsUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsUpdateTagsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewayConnectionsUpdateTagsResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsUpdateTagsResponse, error)
}

type virtualNetworkGatewayConnectionsUpdateTagsPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewayConnectionsUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewayConnectionsUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewayConnectionsUpdateTagsPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewayConnectionsUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewayConnectionsUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewayConnectionsUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewayConnectionsUpdateTagsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewayConnectionsUpdateTagsResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGatewayConnection)
	if err != nil {
		return VirtualNetworkGatewayConnectionsUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysCreateOrUpdateResponse, error)
}

type virtualNetworkGatewaysCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysCreateOrUpdateResponse, error) {
	respType := VirtualNetworkGatewaysCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysDeleteResponse, error)
}

type virtualNetworkGatewaysDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysDeleteResponse, error) {
	respType := VirtualNetworkGatewaysDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysDeleteResponse, error) {
	respType := VirtualNetworkGatewaysDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkGatewaysDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error)
}

type virtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error) {
	respType := VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error) {
	respType := VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkGatewaysDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGenerateVPNProfilePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGenerateVPNProfilePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGenerateVPNProfileResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGenerateVPNProfileResponse, error)
}

type virtualNetworkGatewaysGenerateVPNProfilePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGenerateVPNProfilePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGenerateVPNProfilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGenerateVPNProfilePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGenerateVPNProfileResponse, error) {
	respType := VirtualNetworkGatewaysGenerateVPNProfileResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGenerateVPNProfileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGenerateVPNProfilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGenerateVPNProfilePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGenerateVPNProfileResponse, error) {
	respType := VirtualNetworkGatewaysGenerateVPNProfileResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGenerateVPNProfileResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGeneratevpnclientpackagePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGeneratevpnclientpackagePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGeneratevpnclientpackageResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGeneratevpnclientpackageResponse, error)
}

type virtualNetworkGatewaysGeneratevpnclientpackagePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGeneratevpnclientpackagePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGeneratevpnclientpackagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGeneratevpnclientpackagePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGeneratevpnclientpackageResponse, error) {
	respType := VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGeneratevpnclientpackagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGeneratevpnclientpackagePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGeneratevpnclientpackageResponse, error) {
	respType := VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGeneratevpnclientpackageResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGetAdvertisedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetAdvertisedRoutesPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGetAdvertisedRoutesResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetAdvertisedRoutesResponse, error)
}

type virtualNetworkGatewaysGetAdvertisedRoutesPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGetAdvertisedRoutesPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGetAdvertisedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGetAdvertisedRoutesPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetAdvertisedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GatewayRouteListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGetAdvertisedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGetAdvertisedRoutesPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetAdvertisedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetAdvertisedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGetBgpPeerStatusPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetBgpPeerStatusPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGetBgpPeerStatusResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetBgpPeerStatusResponse, error)
}

type virtualNetworkGatewaysGetBgpPeerStatusPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGetBgpPeerStatusPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGetBgpPeerStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGetBgpPeerStatusPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetBgpPeerStatusResponse, error) {
	respType := VirtualNetworkGatewaysGetBgpPeerStatusResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BgpPeerStatusListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetBgpPeerStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGetBgpPeerStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGetBgpPeerStatusPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetBgpPeerStatusResponse, error) {
	respType := VirtualNetworkGatewaysGetBgpPeerStatusResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.BgpPeerStatusListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetBgpPeerStatusResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGetLearnedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetLearnedRoutesPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGetLearnedRoutesResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetLearnedRoutesResponse, error)
}

type virtualNetworkGatewaysGetLearnedRoutesPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGetLearnedRoutesPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGetLearnedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGetLearnedRoutesPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetLearnedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetLearnedRoutesResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.GatewayRouteListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetLearnedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGetLearnedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGetLearnedRoutesPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetLearnedRoutesResponse, error) {
	respType := VirtualNetworkGatewaysGetLearnedRoutesResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.GatewayRouteListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetLearnedRoutesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGetVPNProfilePackageURLPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetVPNProfilePackageURLPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGetVPNProfilePackageURLResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVPNProfilePackageURLResponse, error)
}

type virtualNetworkGatewaysGetVPNProfilePackageURLPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGetVPNProfilePackageURLPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGetVPNProfilePackageURLPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGetVPNProfilePackageURLPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVPNProfilePackageURLResponse, error) {
	respType := VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGetVPNProfilePackageURLPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGetVPNProfilePackageURLPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetVPNProfilePackageURLResponse, error) {
	respType := VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysGetVPNProfilePackageURLResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetVpnclientConnectionHealthPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse, error)
}

type virtualNetworkGatewaysGetVpnclientConnectionHealthPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGetVpnclientConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGetVpnclientConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGetVpnclientConnectionHealthPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGetVpnclientConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGetVpnclientConnectionHealthPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNClientConnectionHealthDetailListResult)
	if err != nil {
		return VirtualNetworkGatewaysGetVpnclientConnectionHealthResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysGetVpnclientIPSecParametersPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse, error)
}

type virtualNetworkGatewaysGetVpnclientIPSecParametersPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysGetVpnclientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysGetVpnclientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysGetVpnclientIPSecParametersPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNClientIPsecParameters)
	if err != nil {
		return VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysGetVpnclientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysGetVpnclientIPSecParametersPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNClientIPsecParameters)
	if err != nil {
		return VirtualNetworkGatewaysGetVpnclientIPSecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysResetPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysResetPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysResetResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysResetResponse, error)
}

type virtualNetworkGatewaysResetPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysResetPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysResetPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysResetResponse, error) {
	respType := VirtualNetworkGatewaysResetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysResetPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysResetResponse, error) {
	respType := VirtualNetworkGatewaysResetResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysResetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysResetVPNClientSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysResetVPNClientSharedKeyPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysResetVPNClientSharedKeyResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysResetVPNClientSharedKeyResponse, error)
}

type virtualNetworkGatewaysResetVPNClientSharedKeyPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysResetVPNClientSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysResetVPNClientSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysResetVPNClientSharedKeyPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysResetVPNClientSharedKeyResponse, error) {
	respType := VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysResetVPNClientSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysResetVPNClientSharedKeyPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysResetVPNClientSharedKeyResponse, error) {
	respType := VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkGatewaysResetVPNClientSharedKeyResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysSetVpnclientIPSecParametersPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse, error)
}

type virtualNetworkGatewaysSetVpnclientIPSecParametersPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysSetVpnclientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysSetVpnclientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysSetVpnclientIPSecParametersPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VPNClientIPsecParameters)
	if err != nil {
		return VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysSetVpnclientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysSetVpnclientIPSecParametersPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse, error) {
	respType := VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VPNClientIPsecParameters)
	if err != nil {
		return VirtualNetworkGatewaysSetVpnclientIPSecParametersResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysStartPacketCapturePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysStartPacketCaptureResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysStartPacketCaptureResponse, error)
}

type virtualNetworkGatewaysStartPacketCapturePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysStartPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStartPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysStartPacketCapturePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysStartPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStartPacketCaptureResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysStartPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysStopPacketCapturePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysStopPacketCaptureResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysStopPacketCaptureResponse, error)
}

type virtualNetworkGatewaysStopPacketCapturePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysStopPacketCapturePoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStopPacketCaptureResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysStopPacketCapturePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysStopPacketCaptureResponse, error) {
	respType := VirtualNetworkGatewaysStopPacketCaptureResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.Value)
	if err != nil {
		return VirtualNetworkGatewaysStopPacketCaptureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkGatewaysUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysUpdateTagsPoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkGatewaysUpdateTagsResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkGatewaysUpdateTagsResponse, error)
}

type virtualNetworkGatewaysUpdateTagsPoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkGatewaysUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkGatewaysUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkGatewaysUpdateTagsPoller) FinalResponse(ctx context.Context) (VirtualNetworkGatewaysUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewaysUpdateTagsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkGatewaysUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkGatewaysUpdateTagsPoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysUpdateTagsResponse, error) {
	respType := VirtualNetworkGatewaysUpdateTagsResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkGateway)
	if err != nil {
		return VirtualNetworkGatewaysUpdateTagsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkPeeringsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkPeeringsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkPeeringsCreateOrUpdateResponse, error)
}

type virtualNetworkPeeringsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkPeering)
	if err != nil {
		return VirtualNetworkPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkPeeringsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkPeering)
	if err != nil {
		return VirtualNetworkPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkPeeringsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkPeeringsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkPeeringsDeleteResponse, error)
}

type virtualNetworkPeeringsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkPeeringsDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkPeeringsDeleteResponse, error) {
	respType := VirtualNetworkPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkPeeringsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsDeleteResponse, error) {
	respType := VirtualNetworkPeeringsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkTapsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkTapsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkTapsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkTapsCreateOrUpdateResponse, error)
}

type virtualNetworkTapsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkTapsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkTapsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkTapsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworkTapsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkTapsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetworkTap)
	if err != nil {
		return VirtualNetworkTapsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkTapsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkTapsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsCreateOrUpdateResponse, error) {
	respType := VirtualNetworkTapsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetworkTap)
	if err != nil {
		return VirtualNetworkTapsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworkTapsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkTapsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworkTapsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworkTapsDeleteResponse, error)
}

type virtualNetworkTapsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworkTapsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworkTapsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworkTapsDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworkTapsDeleteResponse, error) {
	respType := VirtualNetworkTapsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworkTapsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworkTapsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworkTapsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsDeleteResponse, error) {
	respType := VirtualNetworkTapsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworkTapsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworksCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworksCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworksCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworksCreateOrUpdateResponse, error)
}

type virtualNetworksCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworksCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworksCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworksCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualNetworksCreateOrUpdateResponse, error) {
	respType := VirtualNetworksCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualNetwork)
	if err != nil {
		return VirtualNetworksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworksCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworksCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksCreateOrUpdateResponse, error) {
	respType := VirtualNetworksCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualNetwork)
	if err != nil {
		return VirtualNetworksCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualNetworksDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworksDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualNetworksDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualNetworksDeleteResponse, error)
}

type virtualNetworksDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualNetworksDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualNetworksDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualNetworksDeletePoller) FinalResponse(ctx context.Context) (VirtualNetworksDeleteResponse, error) {
	respType := VirtualNetworksDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualNetworksDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualNetworksDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualNetworksDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksDeleteResponse, error) {
	respType := VirtualNetworksDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualNetworksDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRouterPeeringsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRouterPeeringsCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualRouterPeeringsCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualRouterPeeringsCreateOrUpdateResponse, error)
}

type virtualRouterPeeringsCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualRouterPeeringsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualRouterPeeringsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualRouterPeeringsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualRouterPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualRouterPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualRouterPeering)
	if err != nil {
		return VirtualRouterPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualRouterPeeringsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRouterPeeringsCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsCreateOrUpdateResponse, error) {
	respType := VirtualRouterPeeringsCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualRouterPeering)
	if err != nil {
		return VirtualRouterPeeringsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRouterPeeringsDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRouterPeeringsDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualRouterPeeringsDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualRouterPeeringsDeleteResponse, error)
}

type virtualRouterPeeringsDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualRouterPeeringsDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualRouterPeeringsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualRouterPeeringsDeletePoller) FinalResponse(ctx context.Context) (VirtualRouterPeeringsDeleteResponse, error) {
	respType := VirtualRouterPeeringsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualRouterPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualRouterPeeringsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRouterPeeringsDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsDeleteResponse, error) {
	respType := VirtualRouterPeeringsDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualRouterPeeringsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRoutersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRoutersCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualRoutersCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualRoutersCreateOrUpdateResponse, error)
}

type virtualRoutersCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualRoutersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualRoutersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualRoutersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualRoutersCreateOrUpdateResponse, error) {
	respType := VirtualRoutersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualRouter)
	if err != nil {
		return VirtualRoutersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualRoutersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRoutersCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersCreateOrUpdateResponse, error) {
	respType := VirtualRoutersCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualRouter)
	if err != nil {
		return VirtualRoutersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualRoutersDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRoutersDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualRoutersDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualRoutersDeleteResponse, error)
}

type virtualRoutersDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualRoutersDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualRoutersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualRoutersDeletePoller) FinalResponse(ctx context.Context) (VirtualRoutersDeleteResponse, error) {
	respType := VirtualRoutersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualRoutersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualRoutersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualRoutersDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersDeleteResponse, error) {
	respType := VirtualRoutersDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualRoutersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualWansCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualWansCreateOrUpdatePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualWansCreateOrUpdateResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualWansCreateOrUpdateResponse, error)
}

type virtualWansCreateOrUpdatePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualWansCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualWansCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualWansCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VirtualWansCreateOrUpdateResponse, error) {
	respType := VirtualWansCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VirtualWAN)
	if err != nil {
		return VirtualWansCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualWansCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualWansCreateOrUpdatePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansCreateOrUpdateResponse, error) {
	respType := VirtualWansCreateOrUpdateResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, &respType.VirtualWAN)
	if err != nil {
		return VirtualWansCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// VirtualWansDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualWansDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final VirtualWansDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (VirtualWansDeleteResponse, error)
}

type virtualWansDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *virtualWansDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *virtualWansDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *virtualWansDeletePoller) FinalResponse(ctx context.Context) (VirtualWansDeleteResponse, error) {
	respType := VirtualWansDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VirtualWansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *virtualWansDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *virtualWansDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansDeleteResponse, error) {
	respType := VirtualWansDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return VirtualWansDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// WebApplicationFirewallPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type WebApplicationFirewallPoliciesDeletePoller interface {
	azcore.Poller
	// FinalResponse performs a final GET to the service and returns the final response
	// for the polling operation. If there is an error performing the final GET then an error is returned.
	// If the final GET succeeded then the final WebApplicationFirewallPoliciesDeleteResponse will be returned.
	FinalResponse(ctx context.Context) (WebApplicationFirewallPoliciesDeleteResponse, error)
}

type webApplicationFirewallPoliciesDeletePoller struct {
	pt *armcore.LROPoller
}

func (p *webApplicationFirewallPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

func (p *webApplicationFirewallPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

func (p *webApplicationFirewallPoliciesDeletePoller) FinalResponse(ctx context.Context) (WebApplicationFirewallPoliciesDeleteResponse, error) {
	respType := WebApplicationFirewallPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WebApplicationFirewallPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

func (p *webApplicationFirewallPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

func (p *webApplicationFirewallPoliciesDeletePoller) pollUntilDone(ctx context.Context, freq time.Duration) (WebApplicationFirewallPoliciesDeleteResponse, error) {
	respType := WebApplicationFirewallPoliciesDeleteResponse{}
	resp, err := p.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return WebApplicationFirewallPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}
