//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armnetwork

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// ApplicationGatewaysClientBackendHealthOnDemandPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysClientBackendHealthOnDemandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysClientBackendHealthOnDemandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationGatewaysClientBackendHealthOnDemandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationGatewaysClientBackendHealthOnDemandPoller) Result(ctx context.Context) (resp ApplicationGatewaysClientBackendHealthOnDemandResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationGatewaysClientBackendHealthOnDemandPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientBackendHealthOnDemandResponse, error) {
	result := ApplicationGatewaysClientBackendHealthOnDemandResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ApplicationGatewayBackendHealthOnDemand)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationGatewaysClientBackendHealthOnDemandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationGatewaysClientBackendHealthOnDemandPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationGatewaysClientBackendHealthOnDemandPoller) Resume(token string, client *ApplicationGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.BackendHealthOnDemand", token, client.pl)
	return
}

// ApplicationGatewaysClientBackendHealthPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysClientBackendHealthPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysClientBackendHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationGatewaysClientBackendHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationGatewaysClientBackendHealthPoller) Result(ctx context.Context) (resp ApplicationGatewaysClientBackendHealthResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationGatewaysClientBackendHealthPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientBackendHealthResponse, error) {
	result := ApplicationGatewaysClientBackendHealthResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ApplicationGatewayBackendHealth)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationGatewaysClientBackendHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationGatewaysClientBackendHealthPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationGatewaysClientBackendHealthPoller) Resume(token string, client *ApplicationGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.BackendHealth", token, client.pl)
	return
}

// ApplicationGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ApplicationGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientCreateOrUpdateResponse, error) {
	result := ApplicationGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ApplicationGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationGatewaysClientCreateOrUpdatePoller) Resume(token string, client *ApplicationGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// ApplicationGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationGatewaysClientDeletePoller) Result(ctx context.Context) (resp ApplicationGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientDeleteResponse, error) {
	result := ApplicationGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationGatewaysClientDeletePoller) Resume(token string, client *ApplicationGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Delete", token, client.pl)
	return
}

// ApplicationGatewaysClientStartPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationGatewaysClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationGatewaysClientStartPoller) Result(ctx context.Context) (resp ApplicationGatewaysClientStartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationGatewaysClientStartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientStartResponse, error) {
	result := ApplicationGatewaysClientStartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationGatewaysClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationGatewaysClientStartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationGatewaysClientStartPoller) Resume(token string, client *ApplicationGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Start", token, client.pl)
	return
}

// ApplicationGatewaysClientStopPoller provides polling facilities until the operation reaches a terminal state.
type ApplicationGatewaysClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationGatewaysClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationGatewaysClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationGatewaysClientStopPoller) Result(ctx context.Context) (resp ApplicationGatewaysClientStopResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationGatewaysClientStopPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationGatewaysClientStopResponse, error) {
	result := ApplicationGatewaysClientStopResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationGatewaysClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationGatewaysClientStopPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationGatewaysClientStopPoller) Resume(token string, client *ApplicationGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationGatewaysClient.Stop", token, client.pl)
	return
}

// ApplicationSecurityGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationSecurityGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationSecurityGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationSecurityGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationSecurityGroupsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ApplicationSecurityGroupsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationSecurityGroupsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsClientCreateOrUpdateResponse, error) {
	result := ApplicationSecurityGroupsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ApplicationSecurityGroup)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationSecurityGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationSecurityGroupsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationSecurityGroupsClientCreateOrUpdatePoller) Resume(token string, client *ApplicationSecurityGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationSecurityGroupsClient.CreateOrUpdate", token, client.pl)
	return
}

// ApplicationSecurityGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ApplicationSecurityGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ApplicationSecurityGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ApplicationSecurityGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ApplicationSecurityGroupsClientDeletePoller) Result(ctx context.Context) (resp ApplicationSecurityGroupsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ApplicationSecurityGroupsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ApplicationSecurityGroupsClientDeleteResponse, error) {
	result := ApplicationSecurityGroupsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ApplicationSecurityGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ApplicationSecurityGroupsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ApplicationSecurityGroupsClientDeletePoller) Resume(token string, client *ApplicationSecurityGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ApplicationSecurityGroupsClient.Delete", token, client.pl)
	return
}

// AzureFirewallsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureFirewallsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *AzureFirewallsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *AzureFirewallsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp AzureFirewallsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *AzureFirewallsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsClientCreateOrUpdateResponse, error) {
	result := AzureFirewallsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.AzureFirewall)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *AzureFirewallsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a AzureFirewallsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *AzureFirewallsClientCreateOrUpdatePoller) Resume(token string, client *AzureFirewallsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("AzureFirewallsClient.CreateOrUpdate", token, client.pl)
	return
}

// AzureFirewallsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureFirewallsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *AzureFirewallsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *AzureFirewallsClientDeletePoller) Result(ctx context.Context) (resp AzureFirewallsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *AzureFirewallsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsClientDeleteResponse, error) {
	result := AzureFirewallsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *AzureFirewallsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a AzureFirewallsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *AzureFirewallsClientDeletePoller) Resume(token string, client *AzureFirewallsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("AzureFirewallsClient.Delete", token, client.pl)
	return
}

// AzureFirewallsClientUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type AzureFirewallsClientUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AzureFirewallsClientUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *AzureFirewallsClientUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *AzureFirewallsClientUpdateTagsPoller) Result(ctx context.Context) (resp AzureFirewallsClientUpdateTagsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *AzureFirewallsClientUpdateTagsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (AzureFirewallsClientUpdateTagsResponse, error) {
	result := AzureFirewallsClientUpdateTagsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.AzureFirewall)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *AzureFirewallsClientUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a AzureFirewallsClientUpdateTagsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *AzureFirewallsClientUpdateTagsPoller) Resume(token string, client *AzureFirewallsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("AzureFirewallsClient.UpdateTags", token, client.pl)
	return
}

// BastionHostsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BastionHostsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *BastionHostsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *BastionHostsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp BastionHostsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *BastionHostsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsClientCreateOrUpdateResponse, error) {
	result := BastionHostsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.BastionHost)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *BastionHostsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a BastionHostsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *BastionHostsClientCreateOrUpdatePoller) Resume(token string, client *BastionHostsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("BastionHostsClient.CreateOrUpdate", token, client.pl)
	return
}

// BastionHostsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type BastionHostsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BastionHostsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *BastionHostsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *BastionHostsClientDeletePoller) Result(ctx context.Context) (resp BastionHostsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *BastionHostsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (BastionHostsClientDeleteResponse, error) {
	result := BastionHostsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *BastionHostsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a BastionHostsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *BastionHostsClientDeletePoller) Resume(token string, client *BastionHostsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("BastionHostsClient.Delete", token, client.pl)
	return
}

// ConnectionMonitorsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ConnectionMonitorsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ConnectionMonitorsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ConnectionMonitorsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ConnectionMonitorsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientCreateOrUpdateResponse, error) {
	result := ConnectionMonitorsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ConnectionMonitorResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ConnectionMonitorsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ConnectionMonitorsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ConnectionMonitorsClientCreateOrUpdatePoller) Resume(token string, client *ConnectionMonitorsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.CreateOrUpdate", token, client.pl)
	return
}

// ConnectionMonitorsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ConnectionMonitorsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ConnectionMonitorsClientDeletePoller) Result(ctx context.Context) (resp ConnectionMonitorsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ConnectionMonitorsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientDeleteResponse, error) {
	result := ConnectionMonitorsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ConnectionMonitorsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ConnectionMonitorsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ConnectionMonitorsClientDeletePoller) Resume(token string, client *ConnectionMonitorsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Delete", token, client.pl)
	return
}

// ConnectionMonitorsClientQueryPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsClientQueryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsClientQueryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ConnectionMonitorsClientQueryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ConnectionMonitorsClientQueryPoller) Result(ctx context.Context) (resp ConnectionMonitorsClientQueryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ConnectionMonitorsClientQueryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientQueryResponse, error) {
	result := ConnectionMonitorsClientQueryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ConnectionMonitorQueryResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ConnectionMonitorsClientQueryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ConnectionMonitorsClientQueryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ConnectionMonitorsClientQueryPoller) Resume(token string, client *ConnectionMonitorsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Query", token, client.pl)
	return
}

// ConnectionMonitorsClientStartPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsClientStartPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsClientStartPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ConnectionMonitorsClientStartPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ConnectionMonitorsClientStartPoller) Result(ctx context.Context) (resp ConnectionMonitorsClientStartResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ConnectionMonitorsClientStartPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientStartResponse, error) {
	result := ConnectionMonitorsClientStartResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ConnectionMonitorsClientStartPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ConnectionMonitorsClientStartPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ConnectionMonitorsClientStartPoller) Resume(token string, client *ConnectionMonitorsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Start", token, client.pl)
	return
}

// ConnectionMonitorsClientStopPoller provides polling facilities until the operation reaches a terminal state.
type ConnectionMonitorsClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectionMonitorsClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ConnectionMonitorsClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ConnectionMonitorsClientStopPoller) Result(ctx context.Context) (resp ConnectionMonitorsClientStopResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ConnectionMonitorsClientStopPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ConnectionMonitorsClientStopResponse, error) {
	result := ConnectionMonitorsClientStopResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ConnectionMonitorsClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ConnectionMonitorsClientStopPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ConnectionMonitorsClientStopPoller) Resume(token string, client *ConnectionMonitorsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ConnectionMonitorsClient.Stop", token, client.pl)
	return
}

// DdosCustomPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DdosCustomPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosCustomPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DdosCustomPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DdosCustomPoliciesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp DdosCustomPoliciesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DdosCustomPoliciesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesClientCreateOrUpdateResponse, error) {
	result := DdosCustomPoliciesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DdosCustomPolicy)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DdosCustomPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DdosCustomPoliciesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DdosCustomPoliciesClientCreateOrUpdatePoller) Resume(token string, client *DdosCustomPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DdosCustomPoliciesClient.CreateOrUpdate", token, client.pl)
	return
}

// DdosCustomPoliciesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DdosCustomPoliciesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosCustomPoliciesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DdosCustomPoliciesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DdosCustomPoliciesClientDeletePoller) Result(ctx context.Context) (resp DdosCustomPoliciesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DdosCustomPoliciesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DdosCustomPoliciesClientDeleteResponse, error) {
	result := DdosCustomPoliciesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DdosCustomPoliciesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DdosCustomPoliciesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DdosCustomPoliciesClientDeletePoller) Resume(token string, client *DdosCustomPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DdosCustomPoliciesClient.Delete", token, client.pl)
	return
}

// DdosProtectionPlansClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type DdosProtectionPlansClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosProtectionPlansClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DdosProtectionPlansClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DdosProtectionPlansClientCreateOrUpdatePoller) Result(ctx context.Context) (resp DdosProtectionPlansClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DdosProtectionPlansClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansClientCreateOrUpdateResponse, error) {
	result := DdosProtectionPlansClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DdosProtectionPlan)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DdosProtectionPlansClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DdosProtectionPlansClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DdosProtectionPlansClientCreateOrUpdatePoller) Resume(token string, client *DdosProtectionPlansClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DdosProtectionPlansClient.CreateOrUpdate", token, client.pl)
	return
}

// DdosProtectionPlansClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type DdosProtectionPlansClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DdosProtectionPlansClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *DdosProtectionPlansClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *DdosProtectionPlansClientDeletePoller) Result(ctx context.Context) (resp DdosProtectionPlansClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *DdosProtectionPlansClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (DdosProtectionPlansClientDeleteResponse, error) {
	result := DdosProtectionPlansClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *DdosProtectionPlansClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a DdosProtectionPlansClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *DdosProtectionPlansClientDeletePoller) Resume(token string, client *DdosProtectionPlansClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("DdosProtectionPlansClient.Delete", token, client.pl)
	return
}

// ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteCircuitAuthorizationsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitAuthorization)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitAuthorizationsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteCircuitAuthorizationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitAuthorizationsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteCircuitAuthorizationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitAuthorizationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitAuthorizationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitAuthorizationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitAuthorizationsClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteCircuitAuthorizationsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitAuthorizationsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitAuthorizationsClientDeleteResponse, error) {
	result := ExpressRouteCircuitAuthorizationsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitAuthorizationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitAuthorizationsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitAuthorizationsClientDeletePoller) Resume(token string, client *ExpressRouteCircuitAuthorizationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitAuthorizationsClient.Delete", token, client.pl)
	return
}

// ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteCircuitConnectionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitConnection)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitConnectionsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteCircuitConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitConnectionsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteCircuitConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitConnectionsClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteCircuitConnectionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitConnectionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitConnectionsClientDeleteResponse, error) {
	result := ExpressRouteCircuitConnectionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitConnectionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitConnectionsClientDeletePoller) Resume(token string, client *ExpressRouteCircuitConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitConnectionsClient.Delete", token, client.pl)
	return
}

// ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteCircuitPeeringsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitPeering)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitPeeringsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteCircuitPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitPeeringsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteCircuitPeeringsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitPeeringsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitPeeringsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitPeeringsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitPeeringsClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteCircuitPeeringsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitPeeringsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitPeeringsClientDeleteResponse, error) {
	result := ExpressRouteCircuitPeeringsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitPeeringsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitPeeringsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitPeeringsClientDeletePoller) Resume(token string, client *ExpressRouteCircuitPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitPeeringsClient.Delete", token, client.pl)
	return
}

// ExpressRouteCircuitsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteCircuitsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteCircuitsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuit)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteCircuitsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteCircuitsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitsClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteCircuitsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientDeleteResponse, error) {
	result := ExpressRouteCircuitsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitsClientDeletePoller) Resume(token string, client *ExpressRouteCircuitsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.Delete", token, client.pl)
	return
}

// ExpressRouteCircuitsClientListArpTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsClientListArpTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsClientListArpTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitsClientListArpTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitsClientListArpTablePoller) Result(ctx context.Context) (resp ExpressRouteCircuitsClientListArpTableResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitsClientListArpTablePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientListArpTableResponse, error) {
	result := ExpressRouteCircuitsClientListArpTableResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitsArpTableListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitsClientListArpTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitsClientListArpTablePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitsClientListArpTablePoller) Resume(token string, client *ExpressRouteCircuitsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListArpTable", token, client.pl)
	return
}

// ExpressRouteCircuitsClientListRoutesTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsClientListRoutesTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsClientListRoutesTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitsClientListRoutesTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitsClientListRoutesTablePoller) Result(ctx context.Context) (resp ExpressRouteCircuitsClientListRoutesTableResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitsClientListRoutesTablePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientListRoutesTableResponse, error) {
	result := ExpressRouteCircuitsClientListRoutesTableResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitsRoutesTableListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitsClientListRoutesTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitsClientListRoutesTablePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitsClientListRoutesTablePoller) Resume(token string, client *ExpressRouteCircuitsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListRoutesTable", token, client.pl)
	return
}

// ExpressRouteCircuitsClientListRoutesTableSummaryPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCircuitsClientListRoutesTableSummaryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCircuitsClientListRoutesTableSummaryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCircuitsClientListRoutesTableSummaryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCircuitsClientListRoutesTableSummaryPoller) Result(ctx context.Context) (resp ExpressRouteCircuitsClientListRoutesTableSummaryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCircuitsClientListRoutesTableSummaryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCircuitsClientListRoutesTableSummaryResponse, error) {
	result := ExpressRouteCircuitsClientListRoutesTableSummaryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitsRoutesTableSummaryListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCircuitsClientListRoutesTableSummaryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCircuitsClientListRoutesTableSummaryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCircuitsClientListRoutesTableSummaryPoller) Resume(token string, client *ExpressRouteCircuitsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCircuitsClient.ListRoutesTableSummary", token, client.pl)
	return
}

// ExpressRouteConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteConnectionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteConnectionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteConnectionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteConnectionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteConnection)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteConnectionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteConnectionsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteConnectionsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteConnectionsClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteConnectionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteConnectionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteConnectionsClientDeleteResponse, error) {
	result := ExpressRouteConnectionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteConnectionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteConnectionsClientDeletePoller) Resume(token string, client *ExpressRouteConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteConnectionsClient.Delete", token, client.pl)
	return
}

// ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteCrossConnectionPeeringsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCrossConnectionPeering)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCrossConnectionPeeringsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteCrossConnectionPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionPeeringsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteCrossConnectionPeeringsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionPeeringsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionPeeringsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCrossConnectionPeeringsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCrossConnectionPeeringsClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteCrossConnectionPeeringsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCrossConnectionPeeringsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionPeeringsClientDeleteResponse, error) {
	result := ExpressRouteCrossConnectionPeeringsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCrossConnectionPeeringsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCrossConnectionPeeringsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCrossConnectionPeeringsClientDeletePoller) Resume(token string, client *ExpressRouteCrossConnectionPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionPeeringsClient.Delete", token, client.pl)
	return
}

// ExpressRouteCrossConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteCrossConnectionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientCreateOrUpdateResponse, error) {
	result := ExpressRouteCrossConnectionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCrossConnection)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCrossConnectionsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteCrossConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteCrossConnectionsClientListArpTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsClientListArpTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsClientListArpTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCrossConnectionsClientListArpTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCrossConnectionsClientListArpTablePoller) Result(ctx context.Context) (resp ExpressRouteCrossConnectionsClientListArpTableResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCrossConnectionsClientListArpTablePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientListArpTableResponse, error) {
	result := ExpressRouteCrossConnectionsClientListArpTableResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitsArpTableListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCrossConnectionsClientListArpTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientListArpTablePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCrossConnectionsClientListArpTablePoller) Resume(token string, client *ExpressRouteCrossConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListArpTable", token, client.pl)
	return
}

// ExpressRouteCrossConnectionsClientListRoutesTablePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsClientListRoutesTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsClientListRoutesTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCrossConnectionsClientListRoutesTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCrossConnectionsClientListRoutesTablePoller) Result(ctx context.Context) (resp ExpressRouteCrossConnectionsClientListRoutesTableResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCrossConnectionsClientListRoutesTablePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientListRoutesTableResponse, error) {
	result := ExpressRouteCrossConnectionsClientListRoutesTableResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCircuitsRoutesTableListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCrossConnectionsClientListRoutesTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientListRoutesTablePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCrossConnectionsClientListRoutesTablePoller) Resume(token string, client *ExpressRouteCrossConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListRoutesTable", token, client.pl)
	return
}

// ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller) Result(ctx context.Context) (resp ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse, error) {
	result := ExpressRouteCrossConnectionsClientListRoutesTableSummaryResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteCrossConnectionsRoutesTableSummaryListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteCrossConnectionsClientListRoutesTableSummaryPoller) Resume(token string, client *ExpressRouteCrossConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteCrossConnectionsClient.ListRoutesTableSummary", token, client.pl)
	return
}

// ExpressRouteGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRouteGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysClientCreateOrUpdateResponse, error) {
	result := ExpressRouteGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRouteGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteGatewaysClientCreateOrUpdatePoller) Resume(token string, client *ExpressRouteGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRouteGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRouteGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRouteGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRouteGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRouteGatewaysClientDeletePoller) Result(ctx context.Context) (resp ExpressRouteGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRouteGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRouteGatewaysClientDeleteResponse, error) {
	result := ExpressRouteGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRouteGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRouteGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRouteGatewaysClientDeletePoller) Resume(token string, client *ExpressRouteGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRouteGatewaysClient.Delete", token, client.pl)
	return
}

// ExpressRoutePortsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRoutePortsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRoutePortsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRoutePortsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRoutePortsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ExpressRoutePortsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRoutePortsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsClientCreateOrUpdateResponse, error) {
	result := ExpressRoutePortsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ExpressRoutePort)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRoutePortsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRoutePortsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRoutePortsClientCreateOrUpdatePoller) Resume(token string, client *ExpressRoutePortsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRoutePortsClient.CreateOrUpdate", token, client.pl)
	return
}

// ExpressRoutePortsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExpressRoutePortsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExpressRoutePortsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ExpressRoutePortsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ExpressRoutePortsClientDeletePoller) Result(ctx context.Context) (resp ExpressRoutePortsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ExpressRoutePortsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ExpressRoutePortsClientDeleteResponse, error) {
	result := ExpressRoutePortsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ExpressRoutePortsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ExpressRoutePortsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ExpressRoutePortsClientDeletePoller) Resume(token string, client *ExpressRoutePortsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ExpressRoutePortsClient.Delete", token, client.pl)
	return
}

// FirewallPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *FirewallPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *FirewallPoliciesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp FirewallPoliciesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *FirewallPoliciesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesClientCreateOrUpdateResponse, error) {
	result := FirewallPoliciesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.FirewallPolicy)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *FirewallPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a FirewallPoliciesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *FirewallPoliciesClientCreateOrUpdatePoller) Resume(token string, client *FirewallPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("FirewallPoliciesClient.CreateOrUpdate", token, client.pl)
	return
}

// FirewallPoliciesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPoliciesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPoliciesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *FirewallPoliciesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *FirewallPoliciesClientDeletePoller) Result(ctx context.Context) (resp FirewallPoliciesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *FirewallPoliciesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPoliciesClientDeleteResponse, error) {
	result := FirewallPoliciesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *FirewallPoliciesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a FirewallPoliciesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *FirewallPoliciesClientDeletePoller) Resume(token string, client *FirewallPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("FirewallPoliciesClient.Delete", token, client.pl)
	return
}

// FirewallPolicyRuleGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPolicyRuleGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp FirewallPolicyRuleGroupsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleGroupsClientCreateOrUpdateResponse, error) {
	result := FirewallPolicyRuleGroupsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.FirewallPolicyRuleGroup)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a FirewallPolicyRuleGroupsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *FirewallPolicyRuleGroupsClientCreateOrUpdatePoller) Resume(token string, client *FirewallPolicyRuleGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("FirewallPolicyRuleGroupsClient.CreateOrUpdate", token, client.pl)
	return
}

// FirewallPolicyRuleGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type FirewallPolicyRuleGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FirewallPolicyRuleGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *FirewallPolicyRuleGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *FirewallPolicyRuleGroupsClientDeletePoller) Result(ctx context.Context) (resp FirewallPolicyRuleGroupsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *FirewallPolicyRuleGroupsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (FirewallPolicyRuleGroupsClientDeleteResponse, error) {
	result := FirewallPolicyRuleGroupsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *FirewallPolicyRuleGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a FirewallPolicyRuleGroupsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *FirewallPolicyRuleGroupsClientDeletePoller) Resume(token string, client *FirewallPolicyRuleGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("FirewallPolicyRuleGroupsClient.Delete", token, client.pl)
	return
}

// FlowLogsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type FlowLogsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FlowLogsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *FlowLogsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *FlowLogsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp FlowLogsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *FlowLogsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsClientCreateOrUpdateResponse, error) {
	result := FlowLogsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.FlowLog)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *FlowLogsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a FlowLogsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *FlowLogsClientCreateOrUpdatePoller) Resume(token string, client *FlowLogsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("FlowLogsClient.CreateOrUpdate", token, client.pl)
	return
}

// FlowLogsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type FlowLogsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *FlowLogsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *FlowLogsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *FlowLogsClientDeletePoller) Result(ctx context.Context) (resp FlowLogsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *FlowLogsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (FlowLogsClientDeleteResponse, error) {
	result := FlowLogsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *FlowLogsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a FlowLogsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *FlowLogsClientDeletePoller) Resume(token string, client *FlowLogsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("FlowLogsClient.Delete", token, client.pl)
	return
}

// IPAllocationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPAllocationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPAllocationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *IPAllocationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *IPAllocationsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp IPAllocationsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *IPAllocationsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsClientCreateOrUpdateResponse, error) {
	result := IPAllocationsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.IPAllocation)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *IPAllocationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a IPAllocationsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *IPAllocationsClientCreateOrUpdatePoller) Resume(token string, client *IPAllocationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("IPAllocationsClient.CreateOrUpdate", token, client.pl)
	return
}

// IPAllocationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPAllocationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPAllocationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *IPAllocationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *IPAllocationsClientDeletePoller) Result(ctx context.Context) (resp IPAllocationsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *IPAllocationsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (IPAllocationsClientDeleteResponse, error) {
	result := IPAllocationsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *IPAllocationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a IPAllocationsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *IPAllocationsClientDeletePoller) Resume(token string, client *IPAllocationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("IPAllocationsClient.Delete", token, client.pl)
	return
}

// IPGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type IPGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *IPGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *IPGroupsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp IPGroupsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *IPGroupsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsClientCreateOrUpdateResponse, error) {
	result := IPGroupsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.IPGroup)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *IPGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a IPGroupsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *IPGroupsClientCreateOrUpdatePoller) Resume(token string, client *IPGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("IPGroupsClient.CreateOrUpdate", token, client.pl)
	return
}

// IPGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type IPGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *IPGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *IPGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *IPGroupsClientDeletePoller) Result(ctx context.Context) (resp IPGroupsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *IPGroupsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (IPGroupsClientDeleteResponse, error) {
	result := IPGroupsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *IPGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a IPGroupsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *IPGroupsClientDeletePoller) Resume(token string, client *IPGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("IPGroupsClient.Delete", token, client.pl)
	return
}

// InboundNatRulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InboundNatRulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InboundNatRulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InboundNatRulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InboundNatRulesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp InboundNatRulesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InboundNatRulesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesClientCreateOrUpdateResponse, error) {
	result := InboundNatRulesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.InboundNatRule)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InboundNatRulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InboundNatRulesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InboundNatRulesClientCreateOrUpdatePoller) Resume(token string, client *InboundNatRulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InboundNatRulesClient.CreateOrUpdate", token, client.pl)
	return
}

// InboundNatRulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type InboundNatRulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InboundNatRulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InboundNatRulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InboundNatRulesClientDeletePoller) Result(ctx context.Context) (resp InboundNatRulesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InboundNatRulesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InboundNatRulesClientDeleteResponse, error) {
	result := InboundNatRulesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InboundNatRulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InboundNatRulesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InboundNatRulesClientDeletePoller) Resume(token string, client *InboundNatRulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InboundNatRulesClient.Delete", token, client.pl)
	return
}

// InterfaceTapConfigurationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InterfaceTapConfigurationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InterfaceTapConfigurationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InterfaceTapConfigurationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InterfaceTapConfigurationsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp InterfaceTapConfigurationsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InterfaceTapConfigurationsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InterfaceTapConfigurationsClientCreateOrUpdateResponse, error) {
	result := InterfaceTapConfigurationsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.InterfaceTapConfiguration)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InterfaceTapConfigurationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InterfaceTapConfigurationsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InterfaceTapConfigurationsClientCreateOrUpdatePoller) Resume(token string, client *InterfaceTapConfigurationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InterfaceTapConfigurationsClient.CreateOrUpdate", token, client.pl)
	return
}

// InterfaceTapConfigurationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type InterfaceTapConfigurationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InterfaceTapConfigurationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InterfaceTapConfigurationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InterfaceTapConfigurationsClientDeletePoller) Result(ctx context.Context) (resp InterfaceTapConfigurationsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InterfaceTapConfigurationsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InterfaceTapConfigurationsClientDeleteResponse, error) {
	result := InterfaceTapConfigurationsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InterfaceTapConfigurationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InterfaceTapConfigurationsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InterfaceTapConfigurationsClientDeletePoller) Resume(token string, client *InterfaceTapConfigurationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InterfaceTapConfigurationsClient.Delete", token, client.pl)
	return
}

// InterfacesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type InterfacesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InterfacesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InterfacesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InterfacesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp InterfacesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InterfacesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientCreateOrUpdateResponse, error) {
	result := InterfacesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Interface)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InterfacesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InterfacesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InterfacesClientCreateOrUpdatePoller) Resume(token string, client *InterfacesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InterfacesClient.CreateOrUpdate", token, client.pl)
	return
}

// InterfacesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type InterfacesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InterfacesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InterfacesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InterfacesClientDeletePoller) Result(ctx context.Context) (resp InterfacesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InterfacesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientDeleteResponse, error) {
	result := InterfacesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InterfacesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InterfacesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InterfacesClientDeletePoller) Resume(token string, client *InterfacesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InterfacesClient.Delete", token, client.pl)
	return
}

// InterfacesClientGetEffectiveRouteTablePoller provides polling facilities until the operation reaches a terminal state.
type InterfacesClientGetEffectiveRouteTablePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InterfacesClientGetEffectiveRouteTablePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InterfacesClientGetEffectiveRouteTablePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InterfacesClientGetEffectiveRouteTablePoller) Result(ctx context.Context) (resp InterfacesClientGetEffectiveRouteTableResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InterfacesClientGetEffectiveRouteTablePoller) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientGetEffectiveRouteTableResponse, error) {
	result := InterfacesClientGetEffectiveRouteTableResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.EffectiveRouteListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InterfacesClientGetEffectiveRouteTablePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InterfacesClientGetEffectiveRouteTablePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InterfacesClientGetEffectiveRouteTablePoller) Resume(token string, client *InterfacesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InterfacesClient.GetEffectiveRouteTable", token, client.pl)
	return
}

// InterfacesClientListEffectiveNetworkSecurityGroupsPoller provides polling facilities until the operation reaches a terminal state.
type InterfacesClientListEffectiveNetworkSecurityGroupsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *InterfacesClientListEffectiveNetworkSecurityGroupsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *InterfacesClientListEffectiveNetworkSecurityGroupsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *InterfacesClientListEffectiveNetworkSecurityGroupsPoller) Result(ctx context.Context) (resp InterfacesClientListEffectiveNetworkSecurityGroupsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *InterfacesClientListEffectiveNetworkSecurityGroupsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (InterfacesClientListEffectiveNetworkSecurityGroupsResponse, error) {
	result := InterfacesClientListEffectiveNetworkSecurityGroupsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.EffectiveNetworkSecurityGroupListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *InterfacesClientListEffectiveNetworkSecurityGroupsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a InterfacesClientListEffectiveNetworkSecurityGroupsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *InterfacesClientListEffectiveNetworkSecurityGroupsPoller) Resume(token string, client *InterfacesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("InterfacesClient.ListEffectiveNetworkSecurityGroups", token, client.pl)
	return
}

// LoadBalancersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LoadBalancersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LoadBalancersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp LoadBalancersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *LoadBalancersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersClientCreateOrUpdateResponse, error) {
	result := LoadBalancersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LoadBalancer)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LoadBalancersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LoadBalancersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LoadBalancersClientCreateOrUpdatePoller) Resume(token string, client *LoadBalancersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LoadBalancersClient.CreateOrUpdate", token, client.pl)
	return
}

// LoadBalancersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type LoadBalancersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LoadBalancersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LoadBalancersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LoadBalancersClientDeletePoller) Result(ctx context.Context) (resp LoadBalancersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *LoadBalancersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LoadBalancersClientDeleteResponse, error) {
	result := LoadBalancersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LoadBalancersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LoadBalancersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LoadBalancersClientDeletePoller) Resume(token string, client *LoadBalancersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LoadBalancersClient.Delete", token, client.pl)
	return
}

// LocalNetworkGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type LocalNetworkGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LocalNetworkGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LocalNetworkGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LocalNetworkGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp LocalNetworkGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *LocalNetworkGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysClientCreateOrUpdateResponse, error) {
	result := LocalNetworkGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LocalNetworkGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LocalNetworkGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LocalNetworkGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LocalNetworkGatewaysClientCreateOrUpdatePoller) Resume(token string, client *LocalNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LocalNetworkGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// LocalNetworkGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type LocalNetworkGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LocalNetworkGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *LocalNetworkGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *LocalNetworkGatewaysClientDeletePoller) Result(ctx context.Context) (resp LocalNetworkGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *LocalNetworkGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (LocalNetworkGatewaysClientDeleteResponse, error) {
	result := LocalNetworkGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *LocalNetworkGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a LocalNetworkGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *LocalNetworkGatewaysClientDeletePoller) Resume(token string, client *LocalNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("LocalNetworkGatewaysClient.Delete", token, client.pl)
	return
}

// ManagementClientDeleteBastionShareableLinkPoller provides polling facilities until the operation reaches a terminal state.
type ManagementClientDeleteBastionShareableLinkPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagementClientDeleteBastionShareableLinkPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ManagementClientDeleteBastionShareableLinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ManagementClientDeleteBastionShareableLinkPoller) Result(ctx context.Context) (resp ManagementClientDeleteBastionShareableLinkResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ManagementClientDeleteBastionShareableLinkPoller) PollUntilDone(ctx context.Context, freq time.Duration) (ManagementClientDeleteBastionShareableLinkResponse, error) {
	result := ManagementClientDeleteBastionShareableLinkResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ManagementClientDeleteBastionShareableLinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ManagementClientDeleteBastionShareableLinkPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ManagementClientDeleteBastionShareableLinkPoller) Resume(token string, client *ManagementClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ManagementClient.DeleteBastionShareableLink", token, client.pl)
	return
}

// ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller provides polling facilities until the operation reaches a terminal state.
type ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Result(ctx context.Context) (resp ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse, error) {
	result := ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofileResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNProfileResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ManagementClientGeneratevirtualwanvpnserverconfigurationvpnprofilePoller) Resume(token string, client *ManagementClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ManagementClient.Generatevirtualwanvpnserverconfigurationvpnprofile", token, client.pl)
	return
}

// ManagementClientGetActiveSessionsPoller provides polling facilities until the operation reaches a terminal state.
type ManagementClientGetActiveSessionsPoller struct {
	pt     *azcore.Poller
	client *ManagementClient
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagementClientGetActiveSessionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ManagementClientGetActiveSessionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ManagementClientGetActiveSessionsPoller) Result(ctx context.Context) (resp *ManagementClientGetActiveSessionsPager, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ManagementClientGetActiveSessionsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (*ManagementClientGetActiveSessionsPager, error) {
	result := &ManagementClientGetActiveSessionsPager{client: p.client}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.current.BastionActiveSessionListResult)
	if err != nil {
		return nil, err
	}
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ManagementClientGetActiveSessionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ManagementClientGetActiveSessionsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ManagementClientGetActiveSessionsPoller) Resume(token string, client *ManagementClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ManagementClient.GetActiveSessions", token, client.pl)
	p.client = client
	return
}

// ManagementClientPutBastionShareableLinkPoller provides polling facilities until the operation reaches a terminal state.
type ManagementClientPutBastionShareableLinkPoller struct {
	pt     *azcore.Poller
	client *ManagementClient
}

// Done returns true if the LRO has reached a terminal state.
func (p *ManagementClientPutBastionShareableLinkPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ManagementClientPutBastionShareableLinkPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ManagementClientPutBastionShareableLinkPoller) Result(ctx context.Context) (resp *ManagementClientPutBastionShareableLinkPager, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ManagementClientPutBastionShareableLinkPoller) PollUntilDone(ctx context.Context, freq time.Duration) (*ManagementClientPutBastionShareableLinkPager, error) {
	result := &ManagementClientPutBastionShareableLinkPager{client: p.client}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.current.BastionShareableLinkListResult)
	if err != nil {
		return nil, err
	}
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ManagementClientPutBastionShareableLinkPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ManagementClientPutBastionShareableLinkPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ManagementClientPutBastionShareableLinkPoller) Resume(token string, client *ManagementClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ManagementClient.PutBastionShareableLink", token, client.pl)
	p.client = client
	return
}

// NatGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type NatGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NatGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *NatGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *NatGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp NatGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *NatGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysClientCreateOrUpdateResponse, error) {
	result := NatGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.NatGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *NatGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a NatGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *NatGatewaysClientCreateOrUpdatePoller) Resume(token string, client *NatGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("NatGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// NatGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type NatGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NatGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *NatGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *NatGatewaysClientDeletePoller) Result(ctx context.Context) (resp NatGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *NatGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (NatGatewaysClientDeleteResponse, error) {
	result := NatGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *NatGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a NatGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *NatGatewaysClientDeletePoller) Resume(token string, client *NatGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("NatGatewaysClient.Delete", token, client.pl)
	return
}

// P2SVPNGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *P2SVPNGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *P2SVPNGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp P2SVPNGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *P2SVPNGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientCreateOrUpdateResponse, error) {
	result := P2SVPNGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.P2SVPNGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *P2SVPNGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a P2SVPNGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *P2SVPNGatewaysClientCreateOrUpdatePoller) Resume(token string, client *P2SVPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// P2SVPNGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *P2SVPNGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *P2SVPNGatewaysClientDeletePoller) Result(ctx context.Context) (resp P2SVPNGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *P2SVPNGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientDeleteResponse, error) {
	result := P2SVPNGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *P2SVPNGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a P2SVPNGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *P2SVPNGatewaysClientDeletePoller) Resume(token string, client *P2SVPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.Delete", token, client.pl)
	return
}

// P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller) Result(ctx context.Context) (resp P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse, error) {
	result := P2SVPNGatewaysClientDisconnectP2SVPNConnectionsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *P2SVPNGatewaysClientDisconnectP2SVPNConnectionsPoller) Resume(token string, client *P2SVPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.DisconnectP2SVPNConnections", token, client.pl)
	return
}

// P2SVPNGatewaysClientGenerateVPNProfilePoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysClientGenerateVPNProfilePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysClientGenerateVPNProfilePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *P2SVPNGatewaysClientGenerateVPNProfilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *P2SVPNGatewaysClientGenerateVPNProfilePoller) Result(ctx context.Context) (resp P2SVPNGatewaysClientGenerateVPNProfileResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *P2SVPNGatewaysClientGenerateVPNProfilePoller) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientGenerateVPNProfileResponse, error) {
	result := P2SVPNGatewaysClientGenerateVPNProfileResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNProfileResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *P2SVPNGatewaysClientGenerateVPNProfilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a P2SVPNGatewaysClientGenerateVPNProfilePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *P2SVPNGatewaysClientGenerateVPNProfilePoller) Resume(token string, client *P2SVPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GenerateVPNProfile", token, client.pl)
	return
}

// P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller) Result(ctx context.Context) (resp P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse, error) {
	result := P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.P2SVPNConnectionHealth)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthDetailedPoller) Resume(token string, client *P2SVPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GetP2SVPNConnectionHealthDetailed", token, client.pl)
	return
}

// P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller provides polling facilities until the operation reaches a terminal state.
type P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller) Result(ctx context.Context) (resp P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller) PollUntilDone(ctx context.Context, freq time.Duration) (P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse, error) {
	result := P2SVPNGatewaysClientGetP2SVPNConnectionHealthResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.P2SVPNGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *P2SVPNGatewaysClientGetP2SVPNConnectionHealthPoller) Resume(token string, client *P2SVPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("P2SVPNGatewaysClient.GetP2SVPNConnectionHealth", token, client.pl)
	return
}

// PacketCapturesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PacketCapturesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PacketCapturesClientCreatePoller) Result(ctx context.Context) (resp PacketCapturesClientCreateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PacketCapturesClientCreatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientCreateResponse, error) {
	result := PacketCapturesClientCreateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PacketCaptureResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PacketCapturesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PacketCapturesClientCreatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PacketCapturesClientCreatePoller) Resume(token string, client *PacketCapturesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PacketCapturesClient.Create", token, client.pl)
	return
}

// PacketCapturesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PacketCapturesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PacketCapturesClientDeletePoller) Result(ctx context.Context) (resp PacketCapturesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PacketCapturesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientDeleteResponse, error) {
	result := PacketCapturesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PacketCapturesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PacketCapturesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PacketCapturesClientDeletePoller) Resume(token string, client *PacketCapturesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PacketCapturesClient.Delete", token, client.pl)
	return
}

// PacketCapturesClientGetStatusPoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesClientGetStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesClientGetStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PacketCapturesClientGetStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PacketCapturesClientGetStatusPoller) Result(ctx context.Context) (resp PacketCapturesClientGetStatusResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PacketCapturesClientGetStatusPoller) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientGetStatusResponse, error) {
	result := PacketCapturesClientGetStatusResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PacketCaptureQueryStatusResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PacketCapturesClientGetStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PacketCapturesClientGetStatusPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PacketCapturesClientGetStatusPoller) Resume(token string, client *PacketCapturesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PacketCapturesClient.GetStatus", token, client.pl)
	return
}

// PacketCapturesClientStopPoller provides polling facilities until the operation reaches a terminal state.
type PacketCapturesClientStopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PacketCapturesClientStopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PacketCapturesClientStopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PacketCapturesClientStopPoller) Result(ctx context.Context) (resp PacketCapturesClientStopResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PacketCapturesClientStopPoller) PollUntilDone(ctx context.Context, freq time.Duration) (PacketCapturesClientStopResponse, error) {
	result := PacketCapturesClientStopResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PacketCapturesClientStopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PacketCapturesClientStopPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PacketCapturesClientStopPoller) Resume(token string, client *PacketCapturesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PacketCapturesClient.Stop", token, client.pl)
	return
}

// PrivateDNSZoneGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateDNSZoneGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateDNSZoneGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateDNSZoneGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateDNSZoneGroupsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp PrivateDNSZoneGroupsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateDNSZoneGroupsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsClientCreateOrUpdateResponse, error) {
	result := PrivateDNSZoneGroupsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PrivateDNSZoneGroup)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateDNSZoneGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateDNSZoneGroupsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateDNSZoneGroupsClientCreateOrUpdatePoller) Resume(token string, client *PrivateDNSZoneGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateDNSZoneGroupsClient.CreateOrUpdate", token, client.pl)
	return
}

// PrivateDNSZoneGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateDNSZoneGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateDNSZoneGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateDNSZoneGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateDNSZoneGroupsClientDeletePoller) Result(ctx context.Context) (resp PrivateDNSZoneGroupsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateDNSZoneGroupsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateDNSZoneGroupsClientDeleteResponse, error) {
	result := PrivateDNSZoneGroupsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateDNSZoneGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateDNSZoneGroupsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateDNSZoneGroupsClientDeletePoller) Resume(token string, client *PrivateDNSZoneGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateDNSZoneGroupsClient.Delete", token, client.pl)
	return
}

// PrivateEndpointsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateEndpointsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateEndpointsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp PrivateEndpointsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateEndpointsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsClientCreateOrUpdateResponse, error) {
	result := PrivateEndpointsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PrivateEndpoint)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateEndpointsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateEndpointsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateEndpointsClientCreateOrUpdatePoller) Resume(token string, client *PrivateEndpointsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateEndpointsClient.CreateOrUpdate", token, client.pl)
	return
}

// PrivateEndpointsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateEndpointsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateEndpointsClientDeletePoller) Result(ctx context.Context) (resp PrivateEndpointsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateEndpointsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateEndpointsClientDeleteResponse, error) {
	result := PrivateEndpointsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateEndpointsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateEndpointsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateEndpointsClientDeletePoller) Resume(token string, client *PrivateEndpointsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateEndpointsClient.Delete", token, client.pl)
	return
}

// PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Result(ctx context.Context) (resp PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse, error) {
	result := PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PrivateLinkServiceVisibility)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityByResourceGroupPoller) Resume(token string, client *PrivateLinkServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CheckPrivateLinkServiceVisibilityByResourceGroup", token, client.pl)
	return
}

// PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller) Result(ctx context.Context) (resp PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse, error) {
	result := PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PrivateLinkServiceVisibility)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateLinkServicesClientCheckPrivateLinkServiceVisibilityPoller) Resume(token string, client *PrivateLinkServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CheckPrivateLinkServiceVisibility", token, client.pl)
	return
}

// PrivateLinkServicesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateLinkServicesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateLinkServicesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp PrivateLinkServicesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateLinkServicesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientCreateOrUpdateResponse, error) {
	result := PrivateLinkServicesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PrivateLinkService)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateLinkServicesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateLinkServicesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateLinkServicesClientCreateOrUpdatePoller) Resume(token string, client *PrivateLinkServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.CreateOrUpdate", token, client.pl)
	return
}

// PrivateLinkServicesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateLinkServicesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateLinkServicesClientDeletePoller) Result(ctx context.Context) (resp PrivateLinkServicesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateLinkServicesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientDeleteResponse, error) {
	result := PrivateLinkServicesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateLinkServicesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateLinkServicesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateLinkServicesClientDeletePoller) Resume(token string, client *PrivateLinkServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.Delete", token, client.pl)
	return
}

// PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller provides polling facilities until the operation reaches a terminal state.
type PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller) Result(ctx context.Context) (resp PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse, error) {
	result := PrivateLinkServicesClientDeletePrivateEndpointConnectionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PrivateLinkServicesClientDeletePrivateEndpointConnectionPoller) Resume(token string, client *PrivateLinkServicesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PrivateLinkServicesClient.DeletePrivateEndpointConnection", token, client.pl)
	return
}

// ProfilesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ProfilesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ProfilesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ProfilesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ProfilesClientDeletePoller) Result(ctx context.Context) (resp ProfilesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ProfilesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ProfilesClientDeleteResponse, error) {
	result := ProfilesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ProfilesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ProfilesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ProfilesClientDeletePoller) Resume(token string, client *ProfilesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ProfilesClient.Delete", token, client.pl)
	return
}

// PublicIPAddressesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPAddressesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPAddressesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PublicIPAddressesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PublicIPAddressesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp PublicIPAddressesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PublicIPAddressesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesClientCreateOrUpdateResponse, error) {
	result := PublicIPAddressesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PublicIPAddress)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PublicIPAddressesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PublicIPAddressesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PublicIPAddressesClientCreateOrUpdatePoller) Resume(token string, client *PublicIPAddressesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PublicIPAddressesClient.CreateOrUpdate", token, client.pl)
	return
}

// PublicIPAddressesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPAddressesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPAddressesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PublicIPAddressesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PublicIPAddressesClientDeletePoller) Result(ctx context.Context) (resp PublicIPAddressesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PublicIPAddressesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPAddressesClientDeleteResponse, error) {
	result := PublicIPAddressesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PublicIPAddressesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PublicIPAddressesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PublicIPAddressesClientDeletePoller) Resume(token string, client *PublicIPAddressesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PublicIPAddressesClient.Delete", token, client.pl)
	return
}

// PublicIPPrefixesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPPrefixesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPPrefixesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PublicIPPrefixesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PublicIPPrefixesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp PublicIPPrefixesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PublicIPPrefixesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesClientCreateOrUpdateResponse, error) {
	result := PublicIPPrefixesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PublicIPPrefix)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PublicIPPrefixesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PublicIPPrefixesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PublicIPPrefixesClientCreateOrUpdatePoller) Resume(token string, client *PublicIPPrefixesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PublicIPPrefixesClient.CreateOrUpdate", token, client.pl)
	return
}

// PublicIPPrefixesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PublicIPPrefixesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PublicIPPrefixesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *PublicIPPrefixesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *PublicIPPrefixesClientDeletePoller) Result(ctx context.Context) (resp PublicIPPrefixesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *PublicIPPrefixesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (PublicIPPrefixesClientDeleteResponse, error) {
	result := PublicIPPrefixesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *PublicIPPrefixesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a PublicIPPrefixesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *PublicIPPrefixesClientDeletePoller) Resume(token string, client *PublicIPPrefixesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("PublicIPPrefixesClient.Delete", token, client.pl)
	return
}

// RouteFilterRulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteFilterRulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFilterRulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RouteFilterRulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RouteFilterRulesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp RouteFilterRulesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RouteFilterRulesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesClientCreateOrUpdateResponse, error) {
	result := RouteFilterRulesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.RouteFilterRule)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RouteFilterRulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RouteFilterRulesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RouteFilterRulesClientCreateOrUpdatePoller) Resume(token string, client *RouteFilterRulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RouteFilterRulesClient.CreateOrUpdate", token, client.pl)
	return
}

// RouteFilterRulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteFilterRulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFilterRulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RouteFilterRulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RouteFilterRulesClientDeletePoller) Result(ctx context.Context) (resp RouteFilterRulesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RouteFilterRulesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFilterRulesClientDeleteResponse, error) {
	result := RouteFilterRulesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RouteFilterRulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RouteFilterRulesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RouteFilterRulesClientDeletePoller) Resume(token string, client *RouteFilterRulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RouteFilterRulesClient.Delete", token, client.pl)
	return
}

// RouteFiltersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteFiltersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFiltersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RouteFiltersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RouteFiltersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp RouteFiltersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RouteFiltersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersClientCreateOrUpdateResponse, error) {
	result := RouteFiltersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.RouteFilter)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RouteFiltersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RouteFiltersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RouteFiltersClientCreateOrUpdatePoller) Resume(token string, client *RouteFiltersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RouteFiltersClient.CreateOrUpdate", token, client.pl)
	return
}

// RouteFiltersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteFiltersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteFiltersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RouteFiltersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RouteFiltersClientDeletePoller) Result(ctx context.Context) (resp RouteFiltersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RouteFiltersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RouteFiltersClientDeleteResponse, error) {
	result := RouteFiltersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RouteFiltersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RouteFiltersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RouteFiltersClientDeletePoller) Resume(token string, client *RouteFiltersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RouteFiltersClient.Delete", token, client.pl)
	return
}

// RouteTablesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RouteTablesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteTablesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RouteTablesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RouteTablesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp RouteTablesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RouteTablesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesClientCreateOrUpdateResponse, error) {
	result := RouteTablesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.RouteTable)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RouteTablesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RouteTablesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RouteTablesClientCreateOrUpdatePoller) Resume(token string, client *RouteTablesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RouteTablesClient.CreateOrUpdate", token, client.pl)
	return
}

// RouteTablesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RouteTablesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RouteTablesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RouteTablesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RouteTablesClientDeletePoller) Result(ctx context.Context) (resp RouteTablesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RouteTablesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RouteTablesClientDeleteResponse, error) {
	result := RouteTablesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RouteTablesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RouteTablesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RouteTablesClientDeletePoller) Resume(token string, client *RouteTablesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RouteTablesClient.Delete", token, client.pl)
	return
}

// RoutesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RoutesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RoutesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RoutesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp RoutesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RoutesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientCreateOrUpdateResponse, error) {
	result := RoutesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Route)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RoutesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RoutesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RoutesClientCreateOrUpdatePoller) Resume(token string, client *RoutesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RoutesClient.CreateOrUpdate", token, client.pl)
	return
}

// RoutesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RoutesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RoutesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *RoutesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *RoutesClientDeletePoller) Result(ctx context.Context) (resp RoutesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *RoutesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (RoutesClientDeleteResponse, error) {
	result := RoutesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *RoutesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a RoutesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *RoutesClientDeletePoller) Resume(token string, client *RoutesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("RoutesClient.Delete", token, client.pl)
	return
}

// SecurityGroupsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityGroupsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityGroupsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SecurityGroupsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SecurityGroupsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp SecurityGroupsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SecurityGroupsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityGroupsClientCreateOrUpdateResponse, error) {
	result := SecurityGroupsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SecurityGroup)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SecurityGroupsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SecurityGroupsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SecurityGroupsClientCreateOrUpdatePoller) Resume(token string, client *SecurityGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SecurityGroupsClient.CreateOrUpdate", token, client.pl)
	return
}

// SecurityGroupsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityGroupsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityGroupsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SecurityGroupsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SecurityGroupsClientDeletePoller) Result(ctx context.Context) (resp SecurityGroupsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SecurityGroupsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityGroupsClientDeleteResponse, error) {
	result := SecurityGroupsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SecurityGroupsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SecurityGroupsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SecurityGroupsClientDeletePoller) Resume(token string, client *SecurityGroupsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SecurityGroupsClient.Delete", token, client.pl)
	return
}

// SecurityPartnerProvidersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPartnerProvidersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPartnerProvidersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SecurityPartnerProvidersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SecurityPartnerProvidersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp SecurityPartnerProvidersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SecurityPartnerProvidersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersClientCreateOrUpdateResponse, error) {
	result := SecurityPartnerProvidersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SecurityPartnerProvider)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SecurityPartnerProvidersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SecurityPartnerProvidersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SecurityPartnerProvidersClientCreateOrUpdatePoller) Resume(token string, client *SecurityPartnerProvidersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SecurityPartnerProvidersClient.CreateOrUpdate", token, client.pl)
	return
}

// SecurityPartnerProvidersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityPartnerProvidersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityPartnerProvidersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SecurityPartnerProvidersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SecurityPartnerProvidersClientDeletePoller) Result(ctx context.Context) (resp SecurityPartnerProvidersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SecurityPartnerProvidersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityPartnerProvidersClientDeleteResponse, error) {
	result := SecurityPartnerProvidersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SecurityPartnerProvidersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SecurityPartnerProvidersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SecurityPartnerProvidersClientDeletePoller) Resume(token string, client *SecurityPartnerProvidersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SecurityPartnerProvidersClient.Delete", token, client.pl)
	return
}

// SecurityRulesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SecurityRulesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityRulesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SecurityRulesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SecurityRulesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp SecurityRulesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SecurityRulesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesClientCreateOrUpdateResponse, error) {
	result := SecurityRulesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SecurityRule)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SecurityRulesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SecurityRulesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SecurityRulesClientCreateOrUpdatePoller) Resume(token string, client *SecurityRulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SecurityRulesClient.CreateOrUpdate", token, client.pl)
	return
}

// SecurityRulesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SecurityRulesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SecurityRulesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SecurityRulesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SecurityRulesClientDeletePoller) Result(ctx context.Context) (resp SecurityRulesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SecurityRulesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SecurityRulesClientDeleteResponse, error) {
	result := SecurityRulesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SecurityRulesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SecurityRulesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SecurityRulesClientDeletePoller) Resume(token string, client *SecurityRulesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SecurityRulesClient.Delete", token, client.pl)
	return
}

// ServiceEndpointPoliciesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPoliciesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPoliciesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ServiceEndpointPoliciesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ServiceEndpointPoliciesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ServiceEndpointPoliciesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ServiceEndpointPoliciesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesClientCreateOrUpdateResponse, error) {
	result := ServiceEndpointPoliciesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ServiceEndpointPolicy)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ServiceEndpointPoliciesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ServiceEndpointPoliciesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ServiceEndpointPoliciesClientCreateOrUpdatePoller) Resume(token string, client *ServiceEndpointPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ServiceEndpointPoliciesClient.CreateOrUpdate", token, client.pl)
	return
}

// ServiceEndpointPoliciesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPoliciesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPoliciesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ServiceEndpointPoliciesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ServiceEndpointPoliciesClientDeletePoller) Result(ctx context.Context) (resp ServiceEndpointPoliciesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ServiceEndpointPoliciesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPoliciesClientDeleteResponse, error) {
	result := ServiceEndpointPoliciesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ServiceEndpointPoliciesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ServiceEndpointPoliciesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ServiceEndpointPoliciesClientDeletePoller) Resume(token string, client *ServiceEndpointPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ServiceEndpointPoliciesClient.Delete", token, client.pl)
	return
}

// ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse, error) {
	result := ServiceEndpointPolicyDefinitionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ServiceEndpointPolicyDefinition)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ServiceEndpointPolicyDefinitionsClientCreateOrUpdatePoller) Resume(token string, client *ServiceEndpointPolicyDefinitionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ServiceEndpointPolicyDefinitionsClient.CreateOrUpdate", token, client.pl)
	return
}

// ServiceEndpointPolicyDefinitionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ServiceEndpointPolicyDefinitionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ServiceEndpointPolicyDefinitionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *ServiceEndpointPolicyDefinitionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *ServiceEndpointPolicyDefinitionsClientDeletePoller) Result(ctx context.Context) (resp ServiceEndpointPolicyDefinitionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *ServiceEndpointPolicyDefinitionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceEndpointPolicyDefinitionsClientDeleteResponse, error) {
	result := ServiceEndpointPolicyDefinitionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *ServiceEndpointPolicyDefinitionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a ServiceEndpointPolicyDefinitionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *ServiceEndpointPolicyDefinitionsClientDeletePoller) Resume(token string, client *ServiceEndpointPolicyDefinitionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("ServiceEndpointPolicyDefinitionsClient.Delete", token, client.pl)
	return
}

// SubnetsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type SubnetsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SubnetsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SubnetsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp SubnetsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SubnetsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientCreateOrUpdateResponse, error) {
	result := SubnetsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Subnet)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SubnetsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SubnetsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SubnetsClientCreateOrUpdatePoller) Resume(token string, client *SubnetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SubnetsClient.CreateOrUpdate", token, client.pl)
	return
}

// SubnetsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type SubnetsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SubnetsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SubnetsClientDeletePoller) Result(ctx context.Context) (resp SubnetsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SubnetsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientDeleteResponse, error) {
	result := SubnetsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SubnetsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SubnetsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SubnetsClientDeletePoller) Resume(token string, client *SubnetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SubnetsClient.Delete", token, client.pl)
	return
}

// SubnetsClientPrepareNetworkPoliciesPoller provides polling facilities until the operation reaches a terminal state.
type SubnetsClientPrepareNetworkPoliciesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsClientPrepareNetworkPoliciesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SubnetsClientPrepareNetworkPoliciesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SubnetsClientPrepareNetworkPoliciesPoller) Result(ctx context.Context) (resp SubnetsClientPrepareNetworkPoliciesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SubnetsClientPrepareNetworkPoliciesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientPrepareNetworkPoliciesResponse, error) {
	result := SubnetsClientPrepareNetworkPoliciesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SubnetsClientPrepareNetworkPoliciesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SubnetsClientPrepareNetworkPoliciesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SubnetsClientPrepareNetworkPoliciesPoller) Resume(token string, client *SubnetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SubnetsClient.PrepareNetworkPolicies", token, client.pl)
	return
}

// SubnetsClientUnprepareNetworkPoliciesPoller provides polling facilities until the operation reaches a terminal state.
type SubnetsClientUnprepareNetworkPoliciesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SubnetsClientUnprepareNetworkPoliciesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *SubnetsClientUnprepareNetworkPoliciesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *SubnetsClientUnprepareNetworkPoliciesPoller) Result(ctx context.Context) (resp SubnetsClientUnprepareNetworkPoliciesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *SubnetsClientUnprepareNetworkPoliciesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (SubnetsClientUnprepareNetworkPoliciesResponse, error) {
	result := SubnetsClientUnprepareNetworkPoliciesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *SubnetsClientUnprepareNetworkPoliciesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a SubnetsClientUnprepareNetworkPoliciesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *SubnetsClientUnprepareNetworkPoliciesPoller) Resume(token string, client *SubnetsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("SubnetsClient.UnprepareNetworkPolicies", token, client.pl)
	return
}

// VPNConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNConnectionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VPNConnectionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNConnectionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsClientCreateOrUpdateResponse, error) {
	result := VPNConnectionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNConnection)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNConnectionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNConnectionsClientCreateOrUpdatePoller) Resume(token string, client *VPNConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNConnectionsClient.CreateOrUpdate", token, client.pl)
	return
}

// VPNConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNConnectionsClientDeletePoller) Result(ctx context.Context) (resp VPNConnectionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNConnectionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNConnectionsClientDeleteResponse, error) {
	result := VPNConnectionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNConnectionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNConnectionsClientDeletePoller) Resume(token string, client *VPNConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNConnectionsClient.Delete", token, client.pl)
	return
}

// VPNGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VPNGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysClientCreateOrUpdateResponse, error) {
	result := VPNGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNGatewaysClientCreateOrUpdatePoller) Resume(token string, client *VPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// VPNGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNGatewaysClientDeletePoller) Result(ctx context.Context) (resp VPNGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysClientDeleteResponse, error) {
	result := VPNGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNGatewaysClientDeletePoller) Resume(token string, client *VPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNGatewaysClient.Delete", token, client.pl)
	return
}

// VPNGatewaysClientResetPoller provides polling facilities until the operation reaches a terminal state.
type VPNGatewaysClientResetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNGatewaysClientResetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNGatewaysClientResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNGatewaysClientResetPoller) Result(ctx context.Context) (resp VPNGatewaysClientResetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNGatewaysClientResetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNGatewaysClientResetResponse, error) {
	result := VPNGatewaysClientResetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNGatewaysClientResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNGatewaysClientResetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNGatewaysClientResetPoller) Resume(token string, client *VPNGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNGatewaysClient.Reset", token, client.pl)
	return
}

// VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller) Result(ctx context.Context) (resp VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse, error) {
	result := VPNServerConfigurationsAssociatedWithVirtualWanClientListResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNServerConfigurationsResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNServerConfigurationsAssociatedWithVirtualWanClientListPoller) Resume(token string, client *VPNServerConfigurationsAssociatedWithVirtualWanClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNServerConfigurationsAssociatedWithVirtualWanClient.List", token, client.pl)
	return
}

// VPNServerConfigurationsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNServerConfigurationsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNServerConfigurationsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNServerConfigurationsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VPNServerConfigurationsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNServerConfigurationsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsClientCreateOrUpdateResponse, error) {
	result := VPNServerConfigurationsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNServerConfiguration)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNServerConfigurationsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNServerConfigurationsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNServerConfigurationsClientCreateOrUpdatePoller) Resume(token string, client *VPNServerConfigurationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNServerConfigurationsClient.CreateOrUpdate", token, client.pl)
	return
}

// VPNServerConfigurationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNServerConfigurationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNServerConfigurationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNServerConfigurationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNServerConfigurationsClientDeletePoller) Result(ctx context.Context) (resp VPNServerConfigurationsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNServerConfigurationsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNServerConfigurationsClientDeleteResponse, error) {
	result := VPNServerConfigurationsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNServerConfigurationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNServerConfigurationsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNServerConfigurationsClientDeletePoller) Resume(token string, client *VPNServerConfigurationsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNServerConfigurationsClient.Delete", token, client.pl)
	return
}

// VPNSitesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNSitesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNSitesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNSitesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VPNSitesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNSitesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesClientCreateOrUpdateResponse, error) {
	result := VPNSitesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNSite)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNSitesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNSitesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNSitesClientCreateOrUpdatePoller) Resume(token string, client *VPNSitesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNSitesClient.CreateOrUpdate", token, client.pl)
	return
}

// VPNSitesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNSitesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNSitesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNSitesClientDeletePoller) Result(ctx context.Context) (resp VPNSitesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNSitesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesClientDeleteResponse, error) {
	result := VPNSitesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNSitesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNSitesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNSitesClientDeletePoller) Resume(token string, client *VPNSitesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNSitesClient.Delete", token, client.pl)
	return
}

// VPNSitesConfigurationClientDownloadPoller provides polling facilities until the operation reaches a terminal state.
type VPNSitesConfigurationClientDownloadPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VPNSitesConfigurationClientDownloadPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VPNSitesConfigurationClientDownloadPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VPNSitesConfigurationClientDownloadPoller) Result(ctx context.Context) (resp VPNSitesConfigurationClientDownloadResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VPNSitesConfigurationClientDownloadPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VPNSitesConfigurationClientDownloadResponse, error) {
	result := VPNSitesConfigurationClientDownloadResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VPNSitesConfigurationClientDownloadPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VPNSitesConfigurationClientDownloadPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VPNSitesConfigurationClientDownloadPoller) Resume(token string, client *VPNSitesConfigurationClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VPNSitesConfigurationClient.Download", token, client.pl)
	return
}

// VirtualAppliancesClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualAppliancesClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualAppliancesClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualAppliancesClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualAppliancesClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualAppliancesClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualAppliancesClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualAppliancesClientCreateOrUpdateResponse, error) {
	result := VirtualAppliancesClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualAppliance)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualAppliancesClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualAppliancesClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualAppliancesClientCreateOrUpdatePoller) Resume(token string, client *VirtualAppliancesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualAppliancesClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualAppliancesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualAppliancesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualAppliancesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualAppliancesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualAppliancesClientDeletePoller) Result(ctx context.Context) (resp VirtualAppliancesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualAppliancesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualAppliancesClientDeleteResponse, error) {
	result := VirtualAppliancesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualAppliancesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualAppliancesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualAppliancesClientDeletePoller) Resume(token string, client *VirtualAppliancesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualAppliancesClient.Delete", token, client.pl)
	return
}

// VirtualHubRouteTableV2SClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubRouteTableV2SClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubRouteTableV2SClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualHubRouteTableV2SClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualHubRouteTableV2SClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualHubRouteTableV2SClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualHubRouteTableV2SClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SClientCreateOrUpdateResponse, error) {
	result := VirtualHubRouteTableV2SClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualHubRouteTableV2)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualHubRouteTableV2SClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualHubRouteTableV2SClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualHubRouteTableV2SClientCreateOrUpdatePoller) Resume(token string, client *VirtualHubRouteTableV2SClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualHubRouteTableV2SClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualHubRouteTableV2SClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubRouteTableV2SClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubRouteTableV2SClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualHubRouteTableV2SClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualHubRouteTableV2SClientDeletePoller) Result(ctx context.Context) (resp VirtualHubRouteTableV2SClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualHubRouteTableV2SClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubRouteTableV2SClientDeleteResponse, error) {
	result := VirtualHubRouteTableV2SClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualHubRouteTableV2SClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualHubRouteTableV2SClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualHubRouteTableV2SClientDeletePoller) Resume(token string, client *VirtualHubRouteTableV2SClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualHubRouteTableV2SClient.Delete", token, client.pl)
	return
}

// VirtualHubsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualHubsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualHubsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualHubsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualHubsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsClientCreateOrUpdateResponse, error) {
	result := VirtualHubsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualHub)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualHubsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualHubsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualHubsClientCreateOrUpdatePoller) Resume(token string, client *VirtualHubsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualHubsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualHubsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualHubsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualHubsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualHubsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualHubsClientDeletePoller) Result(ctx context.Context) (resp VirtualHubsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualHubsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualHubsClientDeleteResponse, error) {
	result := VirtualHubsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualHubsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualHubsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualHubsClientDeletePoller) Resume(token string, client *VirtualHubsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualHubsClient.Delete", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkGatewayConnection)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientCreateOrUpdatePoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientDeletePoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientDeleteResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientDeletePoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.Delete", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientResetSharedKeyResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ConnectionResetSharedKey)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientResetSharedKeyPoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.ResetSharedKey", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientSetSharedKeyResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ConnectionSharedKey)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientSetSharedKeyPoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.SetSharedKey", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientStartPacketCaptureResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientStartPacketCapturePoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.StartPacketCapture", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientStopPacketCaptureResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientStopPacketCapturePoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.StopPacketCapture", token, client.pl)
	return
}

// VirtualNetworkGatewayConnectionsClientUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewayConnectionsClientUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller) Result(ctx context.Context) (resp VirtualNetworkGatewayConnectionsClientUpdateTagsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewayConnectionsClientUpdateTagsResponse, error) {
	result := VirtualNetworkGatewayConnectionsClientUpdateTagsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkGatewayConnection)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewayConnectionsClientUpdateTagsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewayConnectionsClientUpdateTagsPoller) Resume(token string, client *VirtualNetworkGatewayConnectionsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewayConnectionsClient.UpdateTags", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientCreateOrUpdateResponse, error) {
	result := VirtualNetworkGatewaysClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientCreateOrUpdatePoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientDeletePoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientDeleteResponse, error) {
	result := VirtualNetworkGatewaysClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientDeletePoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Delete", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse, error) {
	result := VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientDisconnectVirtualNetworkGatewayVPNConnectionsPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.DisconnectVirtualNetworkGatewayVPNConnections", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGenerateVPNProfilePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGenerateVPNProfilePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGenerateVPNProfilePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGenerateVPNProfilePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGenerateVPNProfilePoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGenerateVPNProfileResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGenerateVPNProfilePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGenerateVPNProfileResponse, error) {
	result := VirtualNetworkGatewaysClientGenerateVPNProfileResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGenerateVPNProfilePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGenerateVPNProfilePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGenerateVPNProfilePoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GenerateVPNProfile", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse, error) {
	result := VirtualNetworkGatewaysClientGeneratevpnclientpackageResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGeneratevpnclientpackagePoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Generatevpnclientpackage", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse, error) {
	result := VirtualNetworkGatewaysClientGetAdvertisedRoutesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GatewayRouteListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGetAdvertisedRoutesPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetAdvertisedRoutes", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGetBgpPeerStatusPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGetBgpPeerStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGetBgpPeerStatusResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetBgpPeerStatusResponse, error) {
	result := VirtualNetworkGatewaysClientGetBgpPeerStatusResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.BgpPeerStatusListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetBgpPeerStatusPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGetBgpPeerStatusPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetBgpPeerStatus", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGetLearnedRoutesPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGetLearnedRoutesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGetLearnedRoutesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGetLearnedRoutesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGetLearnedRoutesPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGetLearnedRoutesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGetLearnedRoutesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetLearnedRoutesResponse, error) {
	result := VirtualNetworkGatewaysClientGetLearnedRoutesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.GatewayRouteListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGetLearnedRoutesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetLearnedRoutesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGetLearnedRoutesPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetLearnedRoutes", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse, error) {
	result := VirtualNetworkGatewaysClientGetVPNProfilePackageURLResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGetVPNProfilePackageURLPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVPNProfilePackageURL", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse, error) {
	result := VirtualNetworkGatewaysClientGetVpnclientConnectionHealthResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNClientConnectionHealthDetailListResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGetVpnclientConnectionHealthPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVpnclientConnectionHealth", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse, error) {
	result := VirtualNetworkGatewaysClientGetVpnclientIPSecParametersResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNClientIPsecParameters)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientGetVpnclientIPSecParametersPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.GetVpnclientIPSecParameters", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientResetPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientResetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientResetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientResetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientResetPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientResetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientResetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientResetResponse, error) {
	result := VirtualNetworkGatewaysClientResetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientResetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientResetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientResetPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.Reset", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse, error) {
	result := VirtualNetworkGatewaysClientResetVPNClientSharedKeyResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientResetVPNClientSharedKeyPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.ResetVPNClientSharedKey", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse, error) {
	result := VirtualNetworkGatewaysClientSetVpnclientIPSecParametersResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VPNClientIPsecParameters)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientSetVpnclientIPSecParametersPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.SetVpnclientIPSecParameters", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientStartPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientStartPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientStartPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientStartPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientStartPacketCapturePoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientStartPacketCaptureResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientStartPacketCapturePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientStartPacketCaptureResponse, error) {
	result := VirtualNetworkGatewaysClientStartPacketCaptureResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientStartPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientStartPacketCapturePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientStartPacketCapturePoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.StartPacketCapture", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientStopPacketCapturePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientStopPacketCapturePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientStopPacketCapturePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientStopPacketCapturePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientStopPacketCapturePoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientStopPacketCaptureResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientStopPacketCapturePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientStopPacketCaptureResponse, error) {
	result := VirtualNetworkGatewaysClientStopPacketCaptureResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.Value)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientStopPacketCapturePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientStopPacketCapturePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientStopPacketCapturePoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.StopPacketCapture", token, client.pl)
	return
}

// VirtualNetworkGatewaysClientUpdateTagsPoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkGatewaysClientUpdateTagsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkGatewaysClientUpdateTagsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkGatewaysClientUpdateTagsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkGatewaysClientUpdateTagsPoller) Result(ctx context.Context) (resp VirtualNetworkGatewaysClientUpdateTagsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkGatewaysClientUpdateTagsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkGatewaysClientUpdateTagsResponse, error) {
	result := VirtualNetworkGatewaysClientUpdateTagsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkGateway)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkGatewaysClientUpdateTagsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkGatewaysClientUpdateTagsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkGatewaysClientUpdateTagsPoller) Resume(token string, client *VirtualNetworkGatewaysClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkGatewaysClient.UpdateTags", token, client.pl)
	return
}

// VirtualNetworkPeeringsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkPeeringsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkPeeringsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkPeeringsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkPeeringsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualNetworkPeeringsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkPeeringsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsClientCreateOrUpdateResponse, error) {
	result := VirtualNetworkPeeringsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkPeering)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkPeeringsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkPeeringsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkPeeringsClientCreateOrUpdatePoller) Resume(token string, client *VirtualNetworkPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkPeeringsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualNetworkPeeringsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkPeeringsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkPeeringsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkPeeringsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkPeeringsClientDeletePoller) Result(ctx context.Context) (resp VirtualNetworkPeeringsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkPeeringsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkPeeringsClientDeleteResponse, error) {
	result := VirtualNetworkPeeringsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkPeeringsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkPeeringsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkPeeringsClientDeletePoller) Resume(token string, client *VirtualNetworkPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkPeeringsClient.Delete", token, client.pl)
	return
}

// VirtualNetworkTapsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkTapsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkTapsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkTapsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkTapsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualNetworkTapsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkTapsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsClientCreateOrUpdateResponse, error) {
	result := VirtualNetworkTapsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetworkTap)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkTapsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkTapsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkTapsClientCreateOrUpdatePoller) Resume(token string, client *VirtualNetworkTapsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkTapsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualNetworkTapsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworkTapsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworkTapsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworkTapsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworkTapsClientDeletePoller) Result(ctx context.Context) (resp VirtualNetworkTapsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworkTapsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworkTapsClientDeleteResponse, error) {
	result := VirtualNetworkTapsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworkTapsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworkTapsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworkTapsClientDeletePoller) Resume(token string, client *VirtualNetworkTapsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworkTapsClient.Delete", token, client.pl)
	return
}

// VirtualNetworksClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworksClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworksClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworksClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworksClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualNetworksClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworksClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksClientCreateOrUpdateResponse, error) {
	result := VirtualNetworksClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualNetwork)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworksClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworksClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworksClientCreateOrUpdatePoller) Resume(token string, client *VirtualNetworksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworksClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualNetworksClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualNetworksClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualNetworksClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualNetworksClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualNetworksClientDeletePoller) Result(ctx context.Context) (resp VirtualNetworksClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualNetworksClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksClientDeleteResponse, error) {
	result := VirtualNetworksClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualNetworksClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualNetworksClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualNetworksClientDeletePoller) Resume(token string, client *VirtualNetworksClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualNetworksClient.Delete", token, client.pl)
	return
}

// VirtualRouterPeeringsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRouterPeeringsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRouterPeeringsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualRouterPeeringsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualRouterPeeringsClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualRouterPeeringsClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualRouterPeeringsClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsClientCreateOrUpdateResponse, error) {
	result := VirtualRouterPeeringsClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualRouterPeering)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualRouterPeeringsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualRouterPeeringsClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualRouterPeeringsClientCreateOrUpdatePoller) Resume(token string, client *VirtualRouterPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualRouterPeeringsClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualRouterPeeringsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRouterPeeringsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRouterPeeringsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualRouterPeeringsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualRouterPeeringsClientDeletePoller) Result(ctx context.Context) (resp VirtualRouterPeeringsClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualRouterPeeringsClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRouterPeeringsClientDeleteResponse, error) {
	result := VirtualRouterPeeringsClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualRouterPeeringsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualRouterPeeringsClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualRouterPeeringsClientDeletePoller) Resume(token string, client *VirtualRouterPeeringsClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualRouterPeeringsClient.Delete", token, client.pl)
	return
}

// VirtualRoutersClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRoutersClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRoutersClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualRoutersClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualRoutersClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualRoutersClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualRoutersClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersClientCreateOrUpdateResponse, error) {
	result := VirtualRoutersClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualRouter)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualRoutersClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualRoutersClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualRoutersClientCreateOrUpdatePoller) Resume(token string, client *VirtualRoutersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualRoutersClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualRoutersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualRoutersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualRoutersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualRoutersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualRoutersClientDeletePoller) Result(ctx context.Context) (resp VirtualRoutersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualRoutersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualRoutersClientDeleteResponse, error) {
	result := VirtualRoutersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualRoutersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualRoutersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualRoutersClientDeletePoller) Resume(token string, client *VirtualRoutersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualRoutersClient.Delete", token, client.pl)
	return
}

// VirtualWansClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VirtualWansClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualWansClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualWansClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualWansClientCreateOrUpdatePoller) Result(ctx context.Context) (resp VirtualWansClientCreateOrUpdateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualWansClientCreateOrUpdatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansClientCreateOrUpdateResponse, error) {
	result := VirtualWansClientCreateOrUpdateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VirtualWAN)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualWansClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualWansClientCreateOrUpdatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualWansClientCreateOrUpdatePoller) Resume(token string, client *VirtualWansClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualWansClient.CreateOrUpdate", token, client.pl)
	return
}

// VirtualWansClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type VirtualWansClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VirtualWansClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *VirtualWansClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *VirtualWansClientDeletePoller) Result(ctx context.Context) (resp VirtualWansClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *VirtualWansClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualWansClientDeleteResponse, error) {
	result := VirtualWansClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *VirtualWansClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a VirtualWansClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *VirtualWansClientDeletePoller) Resume(token string, client *VirtualWansClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("VirtualWansClient.Delete", token, client.pl)
	return
}

// WatchersClientCheckConnectivityPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientCheckConnectivityPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientCheckConnectivityPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientCheckConnectivityPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientCheckConnectivityPoller) Result(ctx context.Context) (resp WatchersClientCheckConnectivityResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientCheckConnectivityPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientCheckConnectivityResponse, error) {
	result := WatchersClientCheckConnectivityResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ConnectivityInformation)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientCheckConnectivityPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientCheckConnectivityPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientCheckConnectivityPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.CheckConnectivity", token, client.pl)
	return
}

// WatchersClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientDeletePoller) Result(ctx context.Context) (resp WatchersClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientDeleteResponse, error) {
	result := WatchersClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientDeletePoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.Delete", token, client.pl)
	return
}

// WatchersClientGetAzureReachabilityReportPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetAzureReachabilityReportPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetAzureReachabilityReportPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetAzureReachabilityReportPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetAzureReachabilityReportPoller) Result(ctx context.Context) (resp WatchersClientGetAzureReachabilityReportResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetAzureReachabilityReportPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetAzureReachabilityReportResponse, error) {
	result := WatchersClientGetAzureReachabilityReportResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.AzureReachabilityReport)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetAzureReachabilityReportPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetAzureReachabilityReportPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetAzureReachabilityReportPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetAzureReachabilityReport", token, client.pl)
	return
}

// WatchersClientGetFlowLogStatusPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetFlowLogStatusPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetFlowLogStatusPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetFlowLogStatusPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetFlowLogStatusPoller) Result(ctx context.Context) (resp WatchersClientGetFlowLogStatusResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetFlowLogStatusPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetFlowLogStatusResponse, error) {
	result := WatchersClientGetFlowLogStatusResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.FlowLogInformation)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetFlowLogStatusPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetFlowLogStatusPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetFlowLogStatusPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetFlowLogStatus", token, client.pl)
	return
}

// WatchersClientGetNetworkConfigurationDiagnosticPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetNetworkConfigurationDiagnosticPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetNetworkConfigurationDiagnosticPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetNetworkConfigurationDiagnosticPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetNetworkConfigurationDiagnosticPoller) Result(ctx context.Context) (resp WatchersClientGetNetworkConfigurationDiagnosticResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetNetworkConfigurationDiagnosticPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetNetworkConfigurationDiagnosticResponse, error) {
	result := WatchersClientGetNetworkConfigurationDiagnosticResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.ConfigurationDiagnosticResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetNetworkConfigurationDiagnosticPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetNetworkConfigurationDiagnosticPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetNetworkConfigurationDiagnosticPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetNetworkConfigurationDiagnostic", token, client.pl)
	return
}

// WatchersClientGetNextHopPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetNextHopPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetNextHopPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetNextHopPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetNextHopPoller) Result(ctx context.Context) (resp WatchersClientGetNextHopResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetNextHopPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetNextHopResponse, error) {
	result := WatchersClientGetNextHopResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.NextHopResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetNextHopPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetNextHopPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetNextHopPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetNextHop", token, client.pl)
	return
}

// WatchersClientGetTroubleshootingPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetTroubleshootingPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetTroubleshootingPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetTroubleshootingPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetTroubleshootingPoller) Result(ctx context.Context) (resp WatchersClientGetTroubleshootingResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetTroubleshootingPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetTroubleshootingResponse, error) {
	result := WatchersClientGetTroubleshootingResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TroubleshootingResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetTroubleshootingPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetTroubleshootingPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetTroubleshootingPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetTroubleshooting", token, client.pl)
	return
}

// WatchersClientGetTroubleshootingResultPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetTroubleshootingResultPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetTroubleshootingResultPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetTroubleshootingResultPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetTroubleshootingResultPoller) Result(ctx context.Context) (resp WatchersClientGetTroubleshootingResultResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetTroubleshootingResultPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetTroubleshootingResultResponse, error) {
	result := WatchersClientGetTroubleshootingResultResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TroubleshootingResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetTroubleshootingResultPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetTroubleshootingResultPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetTroubleshootingResultPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetTroubleshootingResult", token, client.pl)
	return
}

// WatchersClientGetVMSecurityRulesPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientGetVMSecurityRulesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientGetVMSecurityRulesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientGetVMSecurityRulesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientGetVMSecurityRulesPoller) Result(ctx context.Context) (resp WatchersClientGetVMSecurityRulesResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientGetVMSecurityRulesPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientGetVMSecurityRulesResponse, error) {
	result := WatchersClientGetVMSecurityRulesResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SecurityGroupViewResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientGetVMSecurityRulesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientGetVMSecurityRulesPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientGetVMSecurityRulesPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.GetVMSecurityRules", token, client.pl)
	return
}

// WatchersClientListAvailableProvidersPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientListAvailableProvidersPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientListAvailableProvidersPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientListAvailableProvidersPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientListAvailableProvidersPoller) Result(ctx context.Context) (resp WatchersClientListAvailableProvidersResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientListAvailableProvidersPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientListAvailableProvidersResponse, error) {
	result := WatchersClientListAvailableProvidersResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.AvailableProvidersList)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientListAvailableProvidersPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientListAvailableProvidersPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientListAvailableProvidersPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.ListAvailableProviders", token, client.pl)
	return
}

// WatchersClientSetFlowLogConfigurationPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientSetFlowLogConfigurationPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientSetFlowLogConfigurationPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientSetFlowLogConfigurationPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientSetFlowLogConfigurationPoller) Result(ctx context.Context) (resp WatchersClientSetFlowLogConfigurationResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientSetFlowLogConfigurationPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientSetFlowLogConfigurationResponse, error) {
	result := WatchersClientSetFlowLogConfigurationResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.FlowLogInformation)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientSetFlowLogConfigurationPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientSetFlowLogConfigurationPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientSetFlowLogConfigurationPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.SetFlowLogConfiguration", token, client.pl)
	return
}

// WatchersClientVerifyIPFlowPoller provides polling facilities until the operation reaches a terminal state.
type WatchersClientVerifyIPFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WatchersClientVerifyIPFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WatchersClientVerifyIPFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WatchersClientVerifyIPFlowPoller) Result(ctx context.Context) (resp WatchersClientVerifyIPFlowResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WatchersClientVerifyIPFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (WatchersClientVerifyIPFlowResponse, error) {
	result := WatchersClientVerifyIPFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.VerificationIPFlowResult)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WatchersClientVerifyIPFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WatchersClientVerifyIPFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WatchersClientVerifyIPFlowPoller) Resume(token string, client *WatchersClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WatchersClient.VerifyIPFlow", token, client.pl)
	return
}

// WebApplicationFirewallPoliciesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WebApplicationFirewallPoliciesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WebApplicationFirewallPoliciesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *WebApplicationFirewallPoliciesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *WebApplicationFirewallPoliciesClientDeletePoller) Result(ctx context.Context) (resp WebApplicationFirewallPoliciesClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (p *WebApplicationFirewallPoliciesClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (WebApplicationFirewallPoliciesClientDeleteResponse, error) {
	result := WebApplicationFirewallPoliciesClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *WebApplicationFirewallPoliciesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a WebApplicationFirewallPoliciesClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *WebApplicationFirewallPoliciesClientDeletePoller) Resume(token string, client *WebApplicationFirewallPoliciesClient) (err error) {
	p.pt, err = armruntime.NewPollerFromResumeToken("WebApplicationFirewallPoliciesClient.Delete", token, client.pl)
	return
}
