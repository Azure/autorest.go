//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azkeyvault

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
	"time"
)

// Action - The action that will be executed.
type Action struct {
	// The type of the action.
	ActionType *ActionType `json:"action_type,omitempty"`
}

// AdministratorDetails - Details of the organization administrator of the certificate issuer.
type AdministratorDetails struct {
	// Email address.
	EmailAddress *string `json:"email,omitempty"`

	// First name.
	FirstName *string `json:"first_name,omitempty"`

	// Last name.
	LastName *string `json:"last_name,omitempty"`

	// Phone number.
	Phone *string `json:"phone,omitempty"`
}

// Attributes - The object attributes managed by the KeyVault service.
type Attributes struct {
	// Determines whether the object is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Expiry date in UTC.
	Expires *time.Time `json:"exp,omitempty"`

	// Not before date in UTC.
	NotBefore *time.Time `json:"nbf,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Attributes.
func (a Attributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", a.Created)
	populate(objectMap, "enabled", a.Enabled)
	populateTimeUnix(objectMap, "exp", a.Expires)
	populateTimeUnix(objectMap, "nbf", a.NotBefore)
	populateTimeUnix(objectMap, "updated", a.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Attributes.
func (a *Attributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &a.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &a.Enabled)
			delete(rawMsg, key)
		case "exp":
			err = unpopulateTimeUnix(val, &a.Expires)
			delete(rawMsg, key)
		case "nbf":
			err = unpopulateTimeUnix(val, &a.NotBefore)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &a.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupCertificateResult - The backup certificate result, containing the backup blob.
type BackupCertificateResult struct {
	// READ-ONLY; The backup blob containing the backed up certificate.
	Value []byte `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupCertificateResult.
func (b BackupCertificateResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", b.Value, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupCertificateResult.
func (b *BackupCertificateResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &b.Value, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupKeyResult - The backup key result, containing the backup blob.
type BackupKeyResult struct {
	// READ-ONLY; The backup blob containing the backed up key.
	Value []byte `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupKeyResult.
func (b BackupKeyResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", b.Value, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupKeyResult.
func (b *BackupKeyResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &b.Value, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupSecretResult - The backup secret result, containing the backup blob.
type BackupSecretResult struct {
	// READ-ONLY; The backup blob containing the backed up secret.
	Value []byte `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupSecretResult.
func (b BackupSecretResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", b.Value, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupSecretResult.
func (b *BackupSecretResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &b.Value, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupStorageResult - The backup storage result, containing the backup blob.
type BackupStorageResult struct {
	// READ-ONLY; The backup blob containing the backed up storage account.
	Value []byte `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupStorageResult.
func (b BackupStorageResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", b.Value, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupStorageResult.
func (b *BackupStorageResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &b.Value, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateAttributes - The certificate management attributes.
type CertificateAttributes struct {
	// Determines whether the object is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Expiry date in UTC.
	Expires *time.Time `json:"exp,omitempty"`

	// Not before date in UTC.
	NotBefore *time.Time `json:"nbf,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
	RecoverableDays *int32 `json:"recoverableDays,omitempty" azure:"ro"`

	// READ-ONLY; Reflects the deletion recovery level currently in effect for certificates in the current vault. If it contains
	// 'Purgeable', the certificate can be permanently deleted by a privileged user; otherwise,
	// only the system can purge the certificate, at the end of the retention interval.
	RecoveryLevel *DeletionRecoveryLevel `json:"recoveryLevel,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateAttributes.
func (c CertificateAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", c.Created)
	populate(objectMap, "enabled", c.Enabled)
	populateTimeUnix(objectMap, "exp", c.Expires)
	populateTimeUnix(objectMap, "nbf", c.NotBefore)
	populate(objectMap, "recoverableDays", c.RecoverableDays)
	populate(objectMap, "recoveryLevel", c.RecoveryLevel)
	populateTimeUnix(objectMap, "updated", c.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateAttributes.
func (c *CertificateAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &c.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &c.Enabled)
			delete(rawMsg, key)
		case "exp":
			err = unpopulateTimeUnix(val, &c.Expires)
			delete(rawMsg, key)
		case "nbf":
			err = unpopulateTimeUnix(val, &c.NotBefore)
			delete(rawMsg, key)
		case "recoverableDays":
			err = unpopulate(val, &c.RecoverableDays)
			delete(rawMsg, key)
		case "recoveryLevel":
			err = unpopulate(val, &c.RecoveryLevel)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &c.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateBundle - A certificate bundle consists of a certificate (X509) plus its attributes.
type CertificateBundle struct {
	// The certificate attributes.
	Attributes *CertificateAttributes `json:"attributes,omitempty"`

	// CER contents of x509 certificate.
	Cer []byte `json:"cer,omitempty"`

	// The content type of the secret.
	ContentType *string `json:"contentType,omitempty"`

	// Application specific metadata in the form of key-value pairs
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The certificate id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The key id.
	Kid *string `json:"kid,omitempty" azure:"ro"`

	// READ-ONLY; The management policy.
	Policy *CertificatePolicy `json:"policy,omitempty" azure:"ro"`

	// READ-ONLY; The secret id.
	Sid *string `json:"sid,omitempty" azure:"ro"`

	// READ-ONLY; Thumbprint of the certificate.
	X509Thumbprint []byte `json:"x5t,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateBundle.
func (c CertificateBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.Attributes)
	populateByteArray(objectMap, "cer", c.Cer, runtime.Base64StdFormat)
	populate(objectMap, "contentType", c.ContentType)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "kid", c.Kid)
	populate(objectMap, "policy", c.Policy)
	populate(objectMap, "sid", c.Sid)
	populate(objectMap, "tags", c.Tags)
	populateByteArray(objectMap, "x5t", c.X509Thumbprint, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateBundle.
func (c *CertificateBundle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &c.Attributes)
			delete(rawMsg, key)
		case "cer":
			err = runtime.DecodeByteArray(string(val), &c.Cer, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &c.ContentType)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, &c.Kid)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &c.Policy)
			delete(rawMsg, key)
		case "sid":
			err = unpopulate(val, &c.Sid)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &c.Tags)
			delete(rawMsg, key)
		case "x5t":
			err = runtime.DecodeByteArray(string(val), &c.X509Thumbprint, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateCreateParameters - The certificate create parameters.
type CertificateCreateParameters struct {
	// The attributes of the certificate (optional).
	CertificateAttributes *CertificateAttributes `json:"attributes,omitempty"`

	// The management policy for the certificate.
	CertificatePolicy *CertificatePolicy `json:"policy,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateCreateParameters.
func (c CertificateCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.CertificateAttributes)
	populate(objectMap, "policy", c.CertificatePolicy)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// CertificateImportParameters - The certificate import parameters.
type CertificateImportParameters struct {
	// REQUIRED; Base64 encoded representation of the certificate object to import. This certificate needs to contain the private
	// key.
	Base64EncodedCertificate *string `json:"value,omitempty"`

	// The attributes of the certificate (optional).
	CertificateAttributes *CertificateAttributes `json:"attributes,omitempty"`

	// The management policy for the certificate.
	CertificatePolicy *CertificatePolicy `json:"policy,omitempty"`

	// If the private key in base64EncodedCertificate is encrypted, the password used for encryption.
	Password *string `json:"pwd,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateImportParameters.
func (c CertificateImportParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", c.Base64EncodedCertificate)
	populate(objectMap, "attributes", c.CertificateAttributes)
	populate(objectMap, "policy", c.CertificatePolicy)
	populate(objectMap, "pwd", c.Password)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

type CertificateInfoObject struct {
	// REQUIRED; Certificates needed from customer
	Certificates []*SecurityDomainCertificateItem `json:"certificates,omitempty"`

	// Customer to specify the number of certificates (minimum 2 and maximum 10) to restore Security Domain
	Required *int32 `json:"required,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateInfoObject.
func (c CertificateInfoObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "certificates", c.Certificates)
	populate(objectMap, "required", c.Required)
	return json.Marshal(objectMap)
}

// CertificateIssuerItem - The certificate issuer item containing certificate issuer metadata.
type CertificateIssuerItem struct {
	// Certificate Identifier.
	ID *string `json:"id,omitempty"`

	// The issuer provider.
	Provider *string `json:"provider,omitempty"`
}

// CertificateIssuerListResult - The certificate issuer list result.
type CertificateIssuerListResult struct {
	// READ-ONLY; The URL to get the next set of certificate issuers.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of certificate issuers in the key vault along with a link to the next page
	// of certificate issuers.
	Value []*CertificateIssuerItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateIssuerListResult.
func (c CertificateIssuerListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CertificateIssuerSetParameters - The certificate issuer set parameters.
type CertificateIssuerSetParameters struct {
	// REQUIRED; The issuer provider.
	Provider *string `json:"provider,omitempty"`

	// Attributes of the issuer object.
	Attributes *IssuerAttributes `json:"attributes,omitempty"`

	// The credentials to be used for the issuer.
	Credentials *IssuerCredentials `json:"credentials,omitempty"`

	// Details of the organization as provided to the issuer.
	OrganizationDetails *OrganizationDetails `json:"org_details,omitempty"`
}

// CertificateIssuerUpdateParameters - The certificate issuer update parameters.
type CertificateIssuerUpdateParameters struct {
	// Attributes of the issuer object.
	Attributes *IssuerAttributes `json:"attributes,omitempty"`

	// The credentials to be used for the issuer.
	Credentials *IssuerCredentials `json:"credentials,omitempty"`

	// Details of the organization as provided to the issuer.
	OrganizationDetails *OrganizationDetails `json:"org_details,omitempty"`

	// The issuer provider.
	Provider *string `json:"provider,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateIssuerUpdateParameters.
func (c CertificateIssuerUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.Attributes)
	populate(objectMap, "credentials", c.Credentials)
	populate(objectMap, "org_details", c.OrganizationDetails)
	populate(objectMap, "provider", c.Provider)
	return json.Marshal(objectMap)
}

// CertificateItem - The certificate item containing certificate metadata.
type CertificateItem struct {
	// The certificate management attributes.
	Attributes *CertificateAttributes `json:"attributes,omitempty"`

	// Certificate identifier.
	ID *string `json:"id,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// Thumbprint of the certificate.
	X509Thumbprint []byte `json:"x5t,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateItem.
func (c CertificateItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.Attributes)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "tags", c.Tags)
	populateByteArray(objectMap, "x5t", c.X509Thumbprint, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateItem.
func (c *CertificateItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &c.Attributes)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &c.Tags)
			delete(rawMsg, key)
		case "x5t":
			err = runtime.DecodeByteArray(string(val), &c.X509Thumbprint, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateListResult - The certificate list result.
type CertificateListResult struct {
	// READ-ONLY; The URL to get the next set of certificates.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of certificates in the key vault along with a link to the next page of
	// certificates.
	Value []*CertificateItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateListResult.
func (c CertificateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CertificateMergeParameters - The certificate merge parameters
type CertificateMergeParameters struct {
	// REQUIRED; The certificate or the certificate chain to merge.
	X509Certificates [][]byte `json:"x5c,omitempty"`

	// The attributes of the certificate (optional).
	CertificateAttributes *CertificateAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateMergeParameters.
func (c CertificateMergeParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.CertificateAttributes)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "x5c", c.X509Certificates)
	return json.Marshal(objectMap)
}

// CertificateOperation - A certificate operation is returned in case of asynchronous requests.
type CertificateOperation struct {
	// Indicates if cancellation was requested on the certificate operation.
	CancellationRequested *bool `json:"cancellation_requested,omitempty"`

	// The certificate signing request (CSR) that is being used in the certificate operation.
	Csr []byte `json:"csr,omitempty"`

	// Error encountered, if any, during the certificate operation.
	Error *ErrorInfo `json:"error,omitempty"`

	// Parameters for the issuer of the X509 component of a certificate.
	IssuerParameters *IssuerParameters `json:"issuer,omitempty"`

	// Identifier for the certificate operation.
	RequestID *string `json:"request_id,omitempty"`

	// Status of the certificate operation.
	Status *string `json:"status,omitempty"`

	// The status details of the certificate operation.
	StatusDetails *string `json:"status_details,omitempty"`

	// Location which contains the result of the certificate operation.
	Target *string `json:"target,omitempty"`

	// READ-ONLY; The certificate id.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateOperation.
func (c CertificateOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cancellation_requested", c.CancellationRequested)
	populateByteArray(objectMap, "csr", c.Csr, runtime.Base64StdFormat)
	populate(objectMap, "error", c.Error)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "issuer", c.IssuerParameters)
	populate(objectMap, "request_id", c.RequestID)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "status_details", c.StatusDetails)
	populate(objectMap, "target", c.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateOperation.
func (c *CertificateOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cancellation_requested":
			err = unpopulate(val, &c.CancellationRequested)
			delete(rawMsg, key)
		case "csr":
			err = runtime.DecodeByteArray(string(val), &c.Csr, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &c.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "issuer":
			err = unpopulate(val, &c.IssuerParameters)
			delete(rawMsg, key)
		case "request_id":
			err = unpopulate(val, &c.RequestID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &c.Status)
			delete(rawMsg, key)
		case "status_details":
			err = unpopulate(val, &c.StatusDetails)
			delete(rawMsg, key)
		case "target":
			err = unpopulate(val, &c.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateOperationUpdateParameter - The certificate operation update parameters.
type CertificateOperationUpdateParameter struct {
	// REQUIRED; Indicates if cancellation was requested on the certificate operation.
	CancellationRequested *bool `json:"cancellation_requested,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateOperationUpdateParameter.
func (c CertificateOperationUpdateParameter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cancellation_requested", c.CancellationRequested)
	return json.Marshal(objectMap)
}

// CertificatePolicy - Management policy for a certificate.
type CertificatePolicy struct {
	// The certificate attributes.
	Attributes *CertificateAttributes `json:"attributes,omitempty"`

	// Parameters for the issuer of the X509 component of a certificate.
	IssuerParameters *IssuerParameters `json:"issuer,omitempty"`

	// Properties of the key backing a certificate.
	KeyProperties *KeyProperties `json:"key_props,omitempty"`

	// Actions that will be performed by Key Vault over the lifetime of a certificate.
	LifetimeActions []*LifetimeAction `json:"lifetime_actions,omitempty"`

	// Properties of the secret backing a certificate.
	SecretProperties *SecretProperties `json:"secret_props,omitempty"`

	// Properties of the X509 component of a certificate.
	X509CertificateProperties *X509CertificateProperties `json:"x509_props,omitempty"`

	// READ-ONLY; The certificate id.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificatePolicy.
func (c CertificatePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.Attributes)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "issuer", c.IssuerParameters)
	populate(objectMap, "key_props", c.KeyProperties)
	populate(objectMap, "lifetime_actions", c.LifetimeActions)
	populate(objectMap, "secret_props", c.SecretProperties)
	populate(objectMap, "x509_props", c.X509CertificateProperties)
	return json.Marshal(objectMap)
}

// CertificateRestoreParameters - The certificate restore parameters.
type CertificateRestoreParameters struct {
	// REQUIRED; The backup blob associated with a certificate bundle.
	CertificateBundleBackup []byte `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateRestoreParameters.
func (c CertificateRestoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", c.CertificateBundleBackup, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CertificateRestoreParameters.
func (c *CertificateRestoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &c.CertificateBundleBackup, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CertificateUpdateParameters - The certificate update parameters.
type CertificateUpdateParameters struct {
	// The attributes of the certificate (optional).
	CertificateAttributes *CertificateAttributes `json:"attributes,omitempty"`

	// The management policy for the certificate.
	CertificatePolicy *CertificatePolicy `json:"policy,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CertificateUpdateParameters.
func (c CertificateUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", c.CertificateAttributes)
	populate(objectMap, "policy", c.CertificatePolicy)
	populate(objectMap, "tags", c.Tags)
	return json.Marshal(objectMap)
}

// ClientBackupCertificateOptions contains the optional parameters for the Client.BackupCertificate method.
type ClientBackupCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientBackupKeyOptions contains the optional parameters for the Client.BackupKey method.
type ClientBackupKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientBackupSecretOptions contains the optional parameters for the Client.BackupSecret method.
type ClientBackupSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientBackupStorageAccountOptions contains the optional parameters for the Client.BackupStorageAccount method.
type ClientBackupStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientBeginFullBackupOptions contains the optional parameters for the Client.BeginFullBackup method.
type ClientBeginFullBackupOptions struct {
	// Azure blob shared access signature token pointing to a valid Azure blob container where full backup needs to be stored.
	// This token needs to be valid for at least next 24 hours from the time of making
	// this call
	AzureStorageBlobContainerURI *SASTokenParameter
}

// ClientBeginFullRestoreOperationOptions contains the optional parameters for the Client.BeginFullRestoreOperation method.
type ClientBeginFullRestoreOperationOptions struct {
	// The Azure blob SAS token pointing to a folder where the previous successful full backup was stored
	RestoreBlobDetails *RestoreOperationParameters
}

// ClientBeginSelectiveKeyRestoreOperationOptions contains the optional parameters for the Client.BeginSelectiveKeyRestoreOperation
// method.
type ClientBeginSelectiveKeyRestoreOperationOptions struct {
	// The Azure blob SAS token pointing to a folder where the previous successful full backup was stored
	RestoreBlobDetails *SelectiveKeyRestoreOperationParameters
}

// ClientCreateCertificateOptions contains the optional parameters for the Client.CreateCertificate method.
type ClientCreateCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientCreateKeyOptions contains the optional parameters for the Client.CreateKey method.
type ClientCreateKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientDecryptOptions contains the optional parameters for the Client.Decrypt method.
type ClientDecryptOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteCertificateContactsOptions contains the optional parameters for the Client.DeleteCertificateContacts method.
type ClientDeleteCertificateContactsOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteCertificateIssuerOptions contains the optional parameters for the Client.DeleteCertificateIssuer method.
type ClientDeleteCertificateIssuerOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteCertificateOperationOptions contains the optional parameters for the Client.DeleteCertificateOperation method.
type ClientDeleteCertificateOperationOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteCertificateOptions contains the optional parameters for the Client.DeleteCertificate method.
type ClientDeleteCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteKeyOptions contains the optional parameters for the Client.DeleteKey method.
type ClientDeleteKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteSasDefinitionOptions contains the optional parameters for the Client.DeleteSasDefinition method.
type ClientDeleteSasDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteSecretOptions contains the optional parameters for the Client.DeleteSecret method.
type ClientDeleteSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientDeleteStorageAccountOptions contains the optional parameters for the Client.DeleteStorageAccount method.
type ClientDeleteStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientEncryptOptions contains the optional parameters for the Client.Encrypt method.
type ClientEncryptOptions struct {
	// placeholder for future optional parameters
}

// ClientFullBackupStatusOptions contains the optional parameters for the Client.FullBackupStatus method.
type ClientFullBackupStatusOptions struct {
	// placeholder for future optional parameters
}

// ClientGetCertificateContactsOptions contains the optional parameters for the Client.GetCertificateContacts method.
type ClientGetCertificateContactsOptions struct {
	// placeholder for future optional parameters
}

// ClientGetCertificateIssuerOptions contains the optional parameters for the Client.GetCertificateIssuer method.
type ClientGetCertificateIssuerOptions struct {
	// placeholder for future optional parameters
}

// ClientGetCertificateIssuersOptions contains the optional parameters for the Client.GetCertificateIssuers method.
type ClientGetCertificateIssuersOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetCertificateOperationOptions contains the optional parameters for the Client.GetCertificateOperation method.
type ClientGetCertificateOperationOptions struct {
	// placeholder for future optional parameters
}

// ClientGetCertificateOptions contains the optional parameters for the Client.GetCertificate method.
type ClientGetCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientGetCertificatePolicyOptions contains the optional parameters for the Client.GetCertificatePolicy method.
type ClientGetCertificatePolicyOptions struct {
	// placeholder for future optional parameters
}

// ClientGetCertificateVersionsOptions contains the optional parameters for the Client.GetCertificateVersions method.
type ClientGetCertificateVersionsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetCertificatesOptions contains the optional parameters for the Client.GetCertificates method.
type ClientGetCertificatesOptions struct {
	// Specifies whether to include certificates which are not completely provisioned.
	IncludePending *bool
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetDeletedCertificateOptions contains the optional parameters for the Client.GetDeletedCertificate method.
type ClientGetDeletedCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientGetDeletedCertificatesOptions contains the optional parameters for the Client.GetDeletedCertificates method.
type ClientGetDeletedCertificatesOptions struct {
	// Specifies whether to include certificates which are not completely provisioned.
	IncludePending *bool
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetDeletedKeyOptions contains the optional parameters for the Client.GetDeletedKey method.
type ClientGetDeletedKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientGetDeletedKeysOptions contains the optional parameters for the Client.GetDeletedKeys method.
type ClientGetDeletedKeysOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetDeletedSasDefinitionOptions contains the optional parameters for the Client.GetDeletedSasDefinition method.
type ClientGetDeletedSasDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ClientGetDeletedSasDefinitionsOptions contains the optional parameters for the Client.GetDeletedSasDefinitions method.
type ClientGetDeletedSasDefinitionsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetDeletedSecretOptions contains the optional parameters for the Client.GetDeletedSecret method.
type ClientGetDeletedSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientGetDeletedSecretsOptions contains the optional parameters for the Client.GetDeletedSecrets method.
type ClientGetDeletedSecretsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetDeletedStorageAccountOptions contains the optional parameters for the Client.GetDeletedStorageAccount method.
type ClientGetDeletedStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientGetDeletedStorageAccountsOptions contains the optional parameters for the Client.GetDeletedStorageAccounts method.
type ClientGetDeletedStorageAccountsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetKeyOptions contains the optional parameters for the Client.GetKey method.
type ClientGetKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientGetKeyVersionsOptions contains the optional parameters for the Client.GetKeyVersions method.
type ClientGetKeyVersionsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetKeysOptions contains the optional parameters for the Client.GetKeys method.
type ClientGetKeysOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetSasDefinitionOptions contains the optional parameters for the Client.GetSasDefinition method.
type ClientGetSasDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ClientGetSasDefinitionsOptions contains the optional parameters for the Client.GetSasDefinitions method.
type ClientGetSasDefinitionsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetSecretOptions contains the optional parameters for the Client.GetSecret method.
type ClientGetSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientGetSecretVersionsOptions contains the optional parameters for the Client.GetSecretVersions method.
type ClientGetSecretVersionsOptions struct {
	// Maximum number of results to return in a page. If not specified, the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetSecretsOptions contains the optional parameters for the Client.GetSecrets method.
type ClientGetSecretsOptions struct {
	// Maximum number of results to return in a page. If not specified, the service will return up to 25 results.
	Maxresults *int32
}

// ClientGetStorageAccountOptions contains the optional parameters for the Client.GetStorageAccount method.
type ClientGetStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientGetStorageAccountsOptions contains the optional parameters for the Client.GetStorageAccounts method.
type ClientGetStorageAccountsOptions struct {
	// Maximum number of results to return in a page. If not specified the service will return up to 25 results.
	Maxresults *int32
}

// ClientImportCertificateOptions contains the optional parameters for the Client.ImportCertificate method.
type ClientImportCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientImportKeyOptions contains the optional parameters for the Client.ImportKey method.
type ClientImportKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientMergeCertificateOptions contains the optional parameters for the Client.MergeCertificate method.
type ClientMergeCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientPurgeDeletedCertificateOptions contains the optional parameters for the Client.PurgeDeletedCertificate method.
type ClientPurgeDeletedCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientPurgeDeletedKeyOptions contains the optional parameters for the Client.PurgeDeletedKey method.
type ClientPurgeDeletedKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientPurgeDeletedSecretOptions contains the optional parameters for the Client.PurgeDeletedSecret method.
type ClientPurgeDeletedSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientPurgeDeletedStorageAccountOptions contains the optional parameters for the Client.PurgeDeletedStorageAccount method.
type ClientPurgeDeletedStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientRecoverDeletedCertificateOptions contains the optional parameters for the Client.RecoverDeletedCertificate method.
type ClientRecoverDeletedCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientRecoverDeletedKeyOptions contains the optional parameters for the Client.RecoverDeletedKey method.
type ClientRecoverDeletedKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientRecoverDeletedSasDefinitionOptions contains the optional parameters for the Client.RecoverDeletedSasDefinition method.
type ClientRecoverDeletedSasDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ClientRecoverDeletedSecretOptions contains the optional parameters for the Client.RecoverDeletedSecret method.
type ClientRecoverDeletedSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientRecoverDeletedStorageAccountOptions contains the optional parameters for the Client.RecoverDeletedStorageAccount
// method.
type ClientRecoverDeletedStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientRegenerateStorageAccountKeyOptions contains the optional parameters for the Client.RegenerateStorageAccountKey method.
type ClientRegenerateStorageAccountKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientRestoreCertificateOptions contains the optional parameters for the Client.RestoreCertificate method.
type ClientRestoreCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientRestoreKeyOptions contains the optional parameters for the Client.RestoreKey method.
type ClientRestoreKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientRestoreSecretOptions contains the optional parameters for the Client.RestoreSecret method.
type ClientRestoreSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientRestoreStatusOptions contains the optional parameters for the Client.RestoreStatus method.
type ClientRestoreStatusOptions struct {
	// placeholder for future optional parameters
}

// ClientRestoreStorageAccountOptions contains the optional parameters for the Client.RestoreStorageAccount method.
type ClientRestoreStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientSetCertificateContactsOptions contains the optional parameters for the Client.SetCertificateContacts method.
type ClientSetCertificateContactsOptions struct {
	// placeholder for future optional parameters
}

// ClientSetCertificateIssuerOptions contains the optional parameters for the Client.SetCertificateIssuer method.
type ClientSetCertificateIssuerOptions struct {
	// placeholder for future optional parameters
}

// ClientSetSasDefinitionOptions contains the optional parameters for the Client.SetSasDefinition method.
type ClientSetSasDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ClientSetSecretOptions contains the optional parameters for the Client.SetSecret method.
type ClientSetSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientSetStorageAccountOptions contains the optional parameters for the Client.SetStorageAccount method.
type ClientSetStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientSignOptions contains the optional parameters for the Client.Sign method.
type ClientSignOptions struct {
	// placeholder for future optional parameters
}

// ClientUnwrapKeyOptions contains the optional parameters for the Client.UnwrapKey method.
type ClientUnwrapKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateCertificateIssuerOptions contains the optional parameters for the Client.UpdateCertificateIssuer method.
type ClientUpdateCertificateIssuerOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateCertificateOperationOptions contains the optional parameters for the Client.UpdateCertificateOperation method.
type ClientUpdateCertificateOperationOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateCertificateOptions contains the optional parameters for the Client.UpdateCertificate method.
type ClientUpdateCertificateOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateCertificatePolicyOptions contains the optional parameters for the Client.UpdateCertificatePolicy method.
type ClientUpdateCertificatePolicyOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateKeyOptions contains the optional parameters for the Client.UpdateKey method.
type ClientUpdateKeyOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateSasDefinitionOptions contains the optional parameters for the Client.UpdateSasDefinition method.
type ClientUpdateSasDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateSecretOptions contains the optional parameters for the Client.UpdateSecret method.
type ClientUpdateSecretOptions struct {
	// placeholder for future optional parameters
}

// ClientUpdateStorageAccountOptions contains the optional parameters for the Client.UpdateStorageAccount method.
type ClientUpdateStorageAccountOptions struct {
	// placeholder for future optional parameters
}

// ClientVerifyOptions contains the optional parameters for the Client.Verify method.
type ClientVerifyOptions struct {
	// placeholder for future optional parameters
}

// ClientWrapKeyOptions contains the optional parameters for the Client.WrapKey method.
type ClientWrapKeyOptions struct {
	// placeholder for future optional parameters
}

// Contact - The contact information for the vault certificates.
type Contact struct {
	// Email address.
	EmailAddress *string `json:"email,omitempty"`

	// Name.
	Name *string `json:"name,omitempty"`

	// Phone number.
	Phone *string `json:"phone,omitempty"`
}

// Contacts - The contacts for the vault certificates.
type Contacts struct {
	// The contact list for the vault certificates.
	ContactList []*Contact `json:"contacts,omitempty"`

	// READ-ONLY; Identifier for the contacts collection.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Contacts.
func (c Contacts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contacts", c.ContactList)
	populate(objectMap, "id", c.ID)
	return json.Marshal(objectMap)
}

// DeletedCertificateBundle - A Deleted Certificate consisting of its previous id, attributes and its tags, as well as information
// on when it will be purged.
type DeletedCertificateBundle struct {
	// The certificate attributes.
	Attributes *CertificateAttributes `json:"attributes,omitempty"`

	// CER contents of x509 certificate.
	Cer []byte `json:"cer,omitempty"`

	// The content type of the secret.
	ContentType *string `json:"contentType,omitempty"`

	// The url of the recovery object, used to identify and recover the deleted certificate.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// Application specific metadata in the form of key-value pairs
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The time when the certificate was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; The certificate id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The key id.
	Kid *string `json:"kid,omitempty" azure:"ro"`

	// READ-ONLY; The management policy.
	Policy *CertificatePolicy `json:"policy,omitempty" azure:"ro"`

	// READ-ONLY; The time when the certificate is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`

	// READ-ONLY; The secret id.
	Sid *string `json:"sid,omitempty" azure:"ro"`

	// READ-ONLY; Thumbprint of the certificate.
	X509Thumbprint []byte `json:"x5t,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedCertificateBundle.
func (d DeletedCertificateBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateByteArray(objectMap, "cer", d.Cer, runtime.Base64StdFormat)
	populate(objectMap, "contentType", d.ContentType)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "kid", d.Kid)
	populate(objectMap, "policy", d.Policy)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "sid", d.Sid)
	populate(objectMap, "tags", d.Tags)
	populateByteArray(objectMap, "x5t", d.X509Thumbprint, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedCertificateBundle.
func (d *DeletedCertificateBundle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "cer":
			err = runtime.DecodeByteArray(string(val), &d.Cer, runtime.Base64StdFormat)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &d.ContentType)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, &d.Kid)
			delete(rawMsg, key)
		case "policy":
			err = unpopulate(val, &d.Policy)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "sid":
			err = unpopulate(val, &d.Sid)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		case "x5t":
			err = runtime.DecodeByteArray(string(val), &d.X509Thumbprint, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedCertificateItem - The deleted certificate item containing metadata about the deleted certificate.
type DeletedCertificateItem struct {
	// The certificate management attributes.
	Attributes *CertificateAttributes `json:"attributes,omitempty"`

	// Certificate identifier.
	ID *string `json:"id,omitempty"`

	// The url of the recovery object, used to identify and recover the deleted certificate.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// Thumbprint of the certificate.
	X509Thumbprint []byte `json:"x5t,omitempty"`

	// READ-ONLY; The time when the certificate was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; The time when the certificate is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedCertificateItem.
func (d DeletedCertificateItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	populateByteArray(objectMap, "x5t", d.X509Thumbprint, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedCertificateItem.
func (d *DeletedCertificateItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		case "x5t":
			err = runtime.DecodeByteArray(string(val), &d.X509Thumbprint, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedCertificateListResult - A list of certificates that have been deleted in this vault.
type DeletedCertificateListResult struct {
	// READ-ONLY; The URL to get the next set of deleted certificates.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of deleted certificates in the vault along with a link to the next page
	// of deleted certificates
	Value []*DeletedCertificateItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedCertificateListResult.
func (d DeletedCertificateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DeletedKeyBundle - A DeletedKeyBundle consisting of a WebKey plus its Attributes and deletion info
type DeletedKeyBundle struct {
	// The key management attributes.
	Attributes *KeyAttributes `json:"attributes,omitempty"`

	// The Json web key.
	Key *JSONWebKey `json:"key,omitempty"`

	// The url of the recovery object, used to identify and recover the deleted key.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The time when the key was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will
	// be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`

	// READ-ONLY; The time when the key is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedKeyBundle.
func (d DeletedKeyBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "key", d.Key)
	populate(objectMap, "managed", d.Managed)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedKeyBundle.
func (d *DeletedKeyBundle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "key":
			err = unpopulate(val, &d.Key)
			delete(rawMsg, key)
		case "managed":
			err = unpopulate(val, &d.Managed)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedKeyItem - The deleted key item containing the deleted key metadata and information about deletion.
type DeletedKeyItem struct {
	// The key management attributes.
	Attributes *KeyAttributes `json:"attributes,omitempty"`

	// Key identifier.
	Kid *string `json:"kid,omitempty"`

	// The url of the recovery object, used to identify and recover the deleted key.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The time when the key was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will
	// be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`

	// READ-ONLY; The time when the key is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedKeyItem.
func (d DeletedKeyItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "kid", d.Kid)
	populate(objectMap, "managed", d.Managed)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedKeyItem.
func (d *DeletedKeyItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, &d.Kid)
			delete(rawMsg, key)
		case "managed":
			err = unpopulate(val, &d.Managed)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedKeyListResult - A list of keys that have been deleted in this vault.
type DeletedKeyListResult struct {
	// READ-ONLY; The URL to get the next set of deleted keys.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of deleted keys in the vault along with a link to the next page of deleted
	// keys
	Value []*DeletedKeyItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedKeyListResult.
func (d DeletedKeyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DeletedSasDefinitionBundle - A deleted SAS definition bundle consisting of its previous id, attributes and its tags, as
// well as information on when it will be purged.
type DeletedSasDefinitionBundle struct {
	// The url of the recovery object, used to identify and recover the deleted SAS definition.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// READ-ONLY; The SAS definition attributes.
	Attributes *SasDefinitionAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; The time when the SAS definition was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; The SAS definition id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The type of SAS token the SAS definition will create.
	SasType *SasTokenType `json:"sasType,omitempty" azure:"ro"`

	// READ-ONLY; The time when the SAS definition is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`

	// READ-ONLY; Storage account SAS definition secret id.
	SecretID *string `json:"sid,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; The SAS definition token template signed with an arbitrary key. Tokens created according to the SAS definition
	// will have the same properties as the template.
	TemplateURI *string `json:"templateUri,omitempty" azure:"ro"`

	// READ-ONLY; The validity period of SAS tokens created according to the SAS definition.
	ValidityPeriod *string `json:"validityPeriod,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedSasDefinitionBundle.
func (d DeletedSasDefinitionBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populate(objectMap, "sasType", d.SasType)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "sid", d.SecretID)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "templateUri", d.TemplateURI)
	populate(objectMap, "validityPeriod", d.ValidityPeriod)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedSasDefinitionBundle.
func (d *DeletedSasDefinitionBundle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "sasType":
			err = unpopulate(val, &d.SasType)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "sid":
			err = unpopulate(val, &d.SecretID)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		case "templateUri":
			err = unpopulate(val, &d.TemplateURI)
			delete(rawMsg, key)
		case "validityPeriod":
			err = unpopulate(val, &d.ValidityPeriod)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedSasDefinitionItem - The deleted SAS definition item containing metadata about the deleted SAS definition.
type DeletedSasDefinitionItem struct {
	// The url of the recovery object, used to identify and recover the deleted SAS definition.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// READ-ONLY; The SAS definition management attributes.
	Attributes *SasDefinitionAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; The time when the SAS definition was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; The storage SAS identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The time when the SAS definition is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`

	// READ-ONLY; The storage account SAS definition secret id.
	SecretID *string `json:"sid,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedSasDefinitionItem.
func (d DeletedSasDefinitionItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "sid", d.SecretID)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedSasDefinitionItem.
func (d *DeletedSasDefinitionItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "sid":
			err = unpopulate(val, &d.SecretID)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedSasDefinitionListResult - The deleted SAS definition list result
type DeletedSasDefinitionListResult struct {
	// READ-ONLY; The URL to get the next set of deleted SAS definitions.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of the deleted SAS definitions in the vault along with a link to the next
	// page of deleted sas definitions
	Value []*DeletedSasDefinitionItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedSasDefinitionListResult.
func (d DeletedSasDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DeletedSecretBundle - A Deleted Secret consisting of its previous id, attributes and its tags, as well as information on
// when it will be purged.
type DeletedSecretBundle struct {
	// The secret management attributes.
	Attributes *SecretAttributes `json:"attributes,omitempty"`

	// The content type of the secret.
	ContentType *string `json:"contentType,omitempty"`

	// The secret id.
	ID *string `json:"id,omitempty"`

	// The url of the recovery object, used to identify and recover the deleted secret.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// The secret value.
	Value *string `json:"value,omitempty"`

	// READ-ONLY; The time when the secret was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV
	// certificate.
	Kid *string `json:"kid,omitempty" azure:"ro"`

	// READ-ONLY; True if the secret's lifetime is managed by key vault. If this is a secret backing a certificate, then managed
	// will be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`

	// READ-ONLY; The time when the secret is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedSecretBundle.
func (d DeletedSecretBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populate(objectMap, "contentType", d.ContentType)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "kid", d.Kid)
	populate(objectMap, "managed", d.Managed)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedSecretBundle.
func (d *DeletedSecretBundle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &d.ContentType)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, &d.Kid)
			delete(rawMsg, key)
		case "managed":
			err = unpopulate(val, &d.Managed)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, &d.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedSecretItem - The deleted secret item containing metadata about the deleted secret.
type DeletedSecretItem struct {
	// The secret management attributes.
	Attributes *SecretAttributes `json:"attributes,omitempty"`

	// Type of the secret value such as a password.
	ContentType *string `json:"contentType,omitempty"`

	// Secret identifier.
	ID *string `json:"id,omitempty"`

	// The url of the recovery object, used to identify and recover the deleted secret.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The time when the secret was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; True if the secret's lifetime is managed by key vault. If this is a key backing a certificate, then managed
	// will be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`

	// READ-ONLY; The time when the secret is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedSecretItem.
func (d DeletedSecretItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populate(objectMap, "contentType", d.ContentType)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "managed", d.Managed)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedSecretItem.
func (d *DeletedSecretItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "contentType":
			err = unpopulate(val, &d.ContentType)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "managed":
			err = unpopulate(val, &d.Managed)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedSecretListResult - The deleted secret list result
type DeletedSecretListResult struct {
	// READ-ONLY; The URL to get the next set of deleted secrets.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of the deleted secrets in the vault along with a link to the next page
	// of deleted secrets
	Value []*DeletedSecretItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedSecretListResult.
func (d DeletedSecretListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DeletedStorageAccountItem - The deleted storage account item containing metadata about the deleted storage account.
type DeletedStorageAccountItem struct {
	// The url of the recovery object, used to identify and recover the deleted storage account.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// READ-ONLY; The storage account management attributes.
	Attributes *StorageAccountAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; The time when the storage account was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; Storage identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Storage account resource Id.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; The time when the storage account is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedStorageAccountItem.
func (d DeletedStorageAccountItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", d.Attributes)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populate(objectMap, "resourceId", d.ResourceID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedStorageAccountItem.
func (d *DeletedStorageAccountItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &d.ResourceID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedStorageBundle - A deleted storage account bundle consisting of its previous id, attributes and its tags, as well
// as information on when it will be purged.
type DeletedStorageBundle struct {
	// The url of the recovery object, used to identify and recover the deleted storage account.
	RecoveryID *string `json:"recoveryId,omitempty"`

	// READ-ONLY; The current active storage account key name.
	ActiveKeyName *string `json:"activeKeyName,omitempty" azure:"ro"`

	// READ-ONLY; The storage account attributes.
	Attributes *StorageAccountAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; whether keyvault should manage the storage account for the user.
	AutoRegenerateKey *bool `json:"autoRegenerateKey,omitempty" azure:"ro"`

	// READ-ONLY; The time when the storage account was deleted, in UTC
	DeletedDate *time.Time `json:"deletedDate,omitempty" azure:"ro"`

	// READ-ONLY; The storage account id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The key regeneration time duration specified in ISO-8601 format.
	RegenerationPeriod *string `json:"regenerationPeriod,omitempty" azure:"ro"`

	// READ-ONLY; The storage account resource id.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; The time when the storage account is scheduled to be purged, in UTC
	ScheduledPurgeDate *time.Time `json:"scheduledPurgeDate,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedStorageBundle.
func (d DeletedStorageBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeKeyName", d.ActiveKeyName)
	populate(objectMap, "attributes", d.Attributes)
	populate(objectMap, "autoRegenerateKey", d.AutoRegenerateKey)
	populateTimeUnix(objectMap, "deletedDate", d.DeletedDate)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "recoveryId", d.RecoveryID)
	populate(objectMap, "regenerationPeriod", d.RegenerationPeriod)
	populate(objectMap, "resourceId", d.ResourceID)
	populateTimeUnix(objectMap, "scheduledPurgeDate", d.ScheduledPurgeDate)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeletedStorageBundle.
func (d *DeletedStorageBundle) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeKeyName":
			err = unpopulate(val, &d.ActiveKeyName)
			delete(rawMsg, key)
		case "attributes":
			err = unpopulate(val, &d.Attributes)
			delete(rawMsg, key)
		case "autoRegenerateKey":
			err = unpopulate(val, &d.AutoRegenerateKey)
			delete(rawMsg, key)
		case "deletedDate":
			err = unpopulateTimeUnix(val, &d.DeletedDate)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "recoveryId":
			err = unpopulate(val, &d.RecoveryID)
			delete(rawMsg, key)
		case "regenerationPeriod":
			err = unpopulate(val, &d.RegenerationPeriod)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &d.ResourceID)
			delete(rawMsg, key)
		case "scheduledPurgeDate":
			err = unpopulateTimeUnix(val, &d.ScheduledPurgeDate)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &d.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeletedStorageListResult - The deleted storage account list result
type DeletedStorageListResult struct {
	// READ-ONLY; The URL to get the next set of deleted storage accounts.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of the deleted storage accounts in the vault along with a link to the next
	// page of deleted storage accounts
	Value []*DeletedStorageAccountItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeletedStorageListResult.
func (d DeletedStorageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// Error - The key vault error exception.
// Implements the error and azcore.HTTPResponse interfaces.
type Error struct {
	raw string
	// READ-ONLY; The key vault server error.
	InnerError *ErrorInfo `json:"error,omitempty" azure:"ro"`
}

// Error implements the error interface for type Error.
// The contents of the error text are not contractual and subject to change.
func (e Error) Error() string {
	return e.raw
}

// ErrorInfo - The key vault server error.
type ErrorInfo struct {
	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The key vault server error.
	InnerError *ErrorInfo `json:"innererror,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// FullBackupOperation - Full backup operation
type FullBackupOperation struct {
	// The Azure blob storage container Uri which contains the full backup
	AzureStorageBlobContainerURI *string `json:"azureStorageBlobContainerUri,omitempty"`

	// The end time of the backup operation in UTC
	EndTime *time.Time `json:"endTime,omitempty"`

	// Error encountered, if any, during the full backup operation.
	Error *ErrorInfo `json:"error,omitempty"`

	// Identifier for the full backup operation.
	JobID *string `json:"jobId,omitempty"`

	// The start time of the backup operation in UTC
	StartTime *time.Time `json:"startTime,omitempty"`

	// Status of the backup operation.
	Status *string `json:"status,omitempty"`

	// The status details of backup operation.
	StatusDetails *string `json:"statusDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FullBackupOperation.
func (f FullBackupOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureStorageBlobContainerUri", f.AzureStorageBlobContainerURI)
	populateTimeUnix(objectMap, "endTime", f.EndTime)
	populate(objectMap, "error", f.Error)
	populate(objectMap, "jobId", f.JobID)
	populateTimeUnix(objectMap, "startTime", f.StartTime)
	populate(objectMap, "status", f.Status)
	populate(objectMap, "statusDetails", f.StatusDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FullBackupOperation.
func (f *FullBackupOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureStorageBlobContainerUri":
			err = unpopulate(val, &f.AzureStorageBlobContainerURI)
			delete(rawMsg, key)
		case "endTime":
			err = unpopulateTimeUnix(val, &f.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &f.Error)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, &f.JobID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeUnix(val, &f.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &f.Status)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &f.StatusDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HSMSecurityDomainClientBeginDownloadOptions contains the optional parameters for the HSMSecurityDomainClient.BeginDownload
// method.
type HSMSecurityDomainClientBeginDownloadOptions struct {
	// placeholder for future optional parameters
}

// HSMSecurityDomainClientBeginUploadOptions contains the optional parameters for the HSMSecurityDomainClient.BeginUpload
// method.
type HSMSecurityDomainClientBeginUploadOptions struct {
	// placeholder for future optional parameters
}

// HSMSecurityDomainClientDownloadPendingOptions contains the optional parameters for the HSMSecurityDomainClient.DownloadPending
// method.
type HSMSecurityDomainClientDownloadPendingOptions struct {
	// placeholder for future optional parameters
}

// HSMSecurityDomainClientTransferKeyOptions contains the optional parameters for the HSMSecurityDomainClient.TransferKey
// method.
type HSMSecurityDomainClientTransferKeyOptions struct {
	// placeholder for future optional parameters
}

// HSMSecurityDomainClientUploadPendingOptions contains the optional parameters for the HSMSecurityDomainClient.UploadPending
// method.
type HSMSecurityDomainClientUploadPendingOptions struct {
	// placeholder for future optional parameters
}

// IssuerAttributes - The attributes of an issuer managed by the Key Vault service.
type IssuerAttributes struct {
	// Determines whether the issuer is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IssuerAttributes.
func (i IssuerAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", i.Created)
	populate(objectMap, "enabled", i.Enabled)
	populateTimeUnix(objectMap, "updated", i.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IssuerAttributes.
func (i *IssuerAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &i.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &i.Enabled)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &i.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IssuerBundle - The issuer for Key Vault certificate.
type IssuerBundle struct {
	// Attributes of the issuer object.
	Attributes *IssuerAttributes `json:"attributes,omitempty"`

	// The credentials to be used for the issuer.
	Credentials *IssuerCredentials `json:"credentials,omitempty"`

	// Details of the organization as provided to the issuer.
	OrganizationDetails *OrganizationDetails `json:"org_details,omitempty"`

	// The issuer provider.
	Provider *string `json:"provider,omitempty"`

	// READ-ONLY; Identifier for the issuer object.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// IssuerCredentials - The credentials to be used for the certificate issuer.
type IssuerCredentials struct {
	// The user name/account name/account id.
	AccountID *string `json:"account_id,omitempty"`

	// The password/secret/account key.
	Password *string `json:"pwd,omitempty"`
}

// IssuerParameters - Parameters for the issuer of the X509 component of a certificate.
type IssuerParameters struct {
	// Indicates if the certificates generated under this policy should be published to certificate transparency logs.
	CertificateTransparency *bool `json:"cert_transparency,omitempty"`

	// Certificate type as supported by the provider (optional); for example 'OV-SSL', 'EV-SSL'
	CertificateType *string `json:"cty,omitempty"`

	// Name of the referenced issuer object or reserved names; for example, 'Self' or 'Unknown'.
	Name *string `json:"name,omitempty"`
}

// JSONWebKey - As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18
type JSONWebKey struct {
	// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
	Crv *JSONWebKeyCurveName `json:"crv,omitempty"`

	// RSA private exponent, or the D component of an EC private key.
	D []byte `json:"d,omitempty"`

	// RSA private key parameter.
	DP []byte `json:"dp,omitempty"`

	// RSA private key parameter.
	DQ []byte `json:"dq,omitempty"`

	// RSA public exponent.
	E []byte `json:"e,omitempty"`

	// Symmetric key.
	K      []byte    `json:"k,omitempty"`
	KeyOps []*string `json:"key_ops,omitempty"`

	// Key identifier.
	Kid *string `json:"kid,omitempty"`

	// JsonWebKey Key Type (kty), as defined in https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
	Kty *JSONWebKeyType `json:"kty,omitempty"`

	// RSA modulus.
	N []byte `json:"n,omitempty"`

	// RSA secret prime.
	P []byte `json:"p,omitempty"`

	// RSA secret prime, with p < q.
	Q []byte `json:"q,omitempty"`

	// RSA private key parameter.
	QI []byte `json:"qi,omitempty"`

	// Protected Key, used with 'Bring Your Own Key'.
	T []byte `json:"key_hsm,omitempty"`

	// X component of an EC public key.
	X []byte `json:"x,omitempty"`

	// Y component of an EC public key.
	Y []byte `json:"y,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONWebKey.
func (j JSONWebKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "crv", j.Crv)
	populateByteArray(objectMap, "d", j.D, runtime.Base64URLFormat)
	populateByteArray(objectMap, "dp", j.DP, runtime.Base64URLFormat)
	populateByteArray(objectMap, "dq", j.DQ, runtime.Base64URLFormat)
	populateByteArray(objectMap, "e", j.E, runtime.Base64URLFormat)
	populateByteArray(objectMap, "k", j.K, runtime.Base64URLFormat)
	populate(objectMap, "key_ops", j.KeyOps)
	populate(objectMap, "kid", j.Kid)
	populate(objectMap, "kty", j.Kty)
	populateByteArray(objectMap, "n", j.N, runtime.Base64URLFormat)
	populateByteArray(objectMap, "p", j.P, runtime.Base64URLFormat)
	populateByteArray(objectMap, "q", j.Q, runtime.Base64URLFormat)
	populateByteArray(objectMap, "qi", j.QI, runtime.Base64URLFormat)
	populateByteArray(objectMap, "key_hsm", j.T, runtime.Base64URLFormat)
	populateByteArray(objectMap, "x", j.X, runtime.Base64URLFormat)
	populateByteArray(objectMap, "y", j.Y, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONWebKey.
func (j *JSONWebKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "crv":
			err = unpopulate(val, &j.Crv)
			delete(rawMsg, key)
		case "d":
			err = runtime.DecodeByteArray(string(val), &j.D, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "dp":
			err = runtime.DecodeByteArray(string(val), &j.DP, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "dq":
			err = runtime.DecodeByteArray(string(val), &j.DQ, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "e":
			err = runtime.DecodeByteArray(string(val), &j.E, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "k":
			err = runtime.DecodeByteArray(string(val), &j.K, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "key_ops":
			err = unpopulate(val, &j.KeyOps)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, &j.Kid)
			delete(rawMsg, key)
		case "kty":
			err = unpopulate(val, &j.Kty)
			delete(rawMsg, key)
		case "n":
			err = runtime.DecodeByteArray(string(val), &j.N, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "p":
			err = runtime.DecodeByteArray(string(val), &j.P, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "q":
			err = runtime.DecodeByteArray(string(val), &j.Q, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "qi":
			err = runtime.DecodeByteArray(string(val), &j.QI, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "key_hsm":
			err = runtime.DecodeByteArray(string(val), &j.T, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "x":
			err = runtime.DecodeByteArray(string(val), &j.X, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "y":
			err = runtime.DecodeByteArray(string(val), &j.Y, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyAttributes - The attributes of a key managed by the key vault service.
type KeyAttributes struct {
	// Determines whether the object is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Expiry date in UTC.
	Expires *time.Time `json:"exp,omitempty"`

	// Not before date in UTC.
	NotBefore *time.Time `json:"nbf,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
	RecoverableDays *int32 `json:"recoverableDays,omitempty" azure:"ro"`

	// READ-ONLY; Reflects the deletion recovery level currently in effect for keys in the current vault. If it contains 'Purgeable'
	// the key can be permanently deleted by a privileged user; otherwise, only the system
	// can purge the key, at the end of the retention interval.
	RecoveryLevel *DeletionRecoveryLevel `json:"recoveryLevel,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyAttributes.
func (k KeyAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", k.Created)
	populate(objectMap, "enabled", k.Enabled)
	populateTimeUnix(objectMap, "exp", k.Expires)
	populateTimeUnix(objectMap, "nbf", k.NotBefore)
	populate(objectMap, "recoverableDays", k.RecoverableDays)
	populate(objectMap, "recoveryLevel", k.RecoveryLevel)
	populateTimeUnix(objectMap, "updated", k.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyAttributes.
func (k *KeyAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &k.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &k.Enabled)
			delete(rawMsg, key)
		case "exp":
			err = unpopulateTimeUnix(val, &k.Expires)
			delete(rawMsg, key)
		case "nbf":
			err = unpopulateTimeUnix(val, &k.NotBefore)
			delete(rawMsg, key)
		case "recoverableDays":
			err = unpopulate(val, &k.RecoverableDays)
			delete(rawMsg, key)
		case "recoveryLevel":
			err = unpopulate(val, &k.RecoveryLevel)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &k.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyBundle - A KeyBundle consisting of a WebKey plus its attributes.
type KeyBundle struct {
	// The key management attributes.
	Attributes *KeyAttributes `json:"attributes,omitempty"`

	// The Json web key.
	Key *JSONWebKey `json:"key,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will
	// be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyBundle.
func (k KeyBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", k.Attributes)
	populate(objectMap, "key", k.Key)
	populate(objectMap, "managed", k.Managed)
	populate(objectMap, "tags", k.Tags)
	return json.Marshal(objectMap)
}

// KeyCreateParameters - The key create parameters.
type KeyCreateParameters struct {
	// REQUIRED; The type of key to create. For valid values, see JsonWebKeyType.
	Kty *JSONWebKeyType `json:"kty,omitempty"`

	// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
	Curve *JSONWebKeyCurveName `json:"crv,omitempty"`

	// The attributes of a key managed by the key vault service.
	KeyAttributes *KeyAttributes         `json:"attributes,omitempty"`
	KeyOps        []*JSONWebKeyOperation `json:"key_ops,omitempty"`

	// The key size in bits. For example: 2048, 3072, or 4096 for RSA.
	KeySize *int32 `json:"key_size,omitempty"`

	// The public exponent for a RSA key.
	PublicExponent *int32 `json:"public_exponent,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyCreateParameters.
func (k KeyCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "crv", k.Curve)
	populate(objectMap, "attributes", k.KeyAttributes)
	populate(objectMap, "key_ops", k.KeyOps)
	populate(objectMap, "key_size", k.KeySize)
	populate(objectMap, "kty", k.Kty)
	populate(objectMap, "public_exponent", k.PublicExponent)
	populate(objectMap, "tags", k.Tags)
	return json.Marshal(objectMap)
}

// KeyImportParameters - The key import parameters.
type KeyImportParameters struct {
	// REQUIRED; The Json web key
	Key *JSONWebKey `json:"key,omitempty"`

	// Whether to import as a hardware key (HSM) or software key.
	Hsm *bool `json:"Hsm,omitempty"`

	// The key management attributes.
	KeyAttributes *KeyAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyImportParameters.
func (k KeyImportParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "Hsm", k.Hsm)
	populate(objectMap, "key", k.Key)
	populate(objectMap, "attributes", k.KeyAttributes)
	populate(objectMap, "tags", k.Tags)
	return json.Marshal(objectMap)
}

// KeyItem - The key item containing key metadata.
type KeyItem struct {
	// The key management attributes.
	Attributes *KeyAttributes `json:"attributes,omitempty"`

	// Key identifier.
	Kid *string `json:"kid,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; True if the key's lifetime is managed by key vault. If this is a key backing a certificate, then managed will
	// be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyItem.
func (k KeyItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", k.Attributes)
	populate(objectMap, "kid", k.Kid)
	populate(objectMap, "managed", k.Managed)
	populate(objectMap, "tags", k.Tags)
	return json.Marshal(objectMap)
}

// KeyListResult - The key list result.
type KeyListResult struct {
	// READ-ONLY; The URL to get the next set of keys.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of keys in the key vault along with a link to the next page of keys.
	Value []*KeyItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyListResult.
func (k KeyListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", k.NextLink)
	populate(objectMap, "value", k.Value)
	return json.Marshal(objectMap)
}

// KeyOperationResult - The key operation result.
type KeyOperationResult struct {
	// READ-ONLY
	AdditionalAuthenticatedData []byte `json:"aad,omitempty" azure:"ro"`

	// READ-ONLY
	AuthenticationTag []byte `json:"tag,omitempty" azure:"ro"`

	// READ-ONLY
	Iv []byte `json:"iv,omitempty" azure:"ro"`

	// READ-ONLY; Key identifier
	Kid *string `json:"kid,omitempty" azure:"ro"`

	// READ-ONLY
	Result []byte `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyOperationResult.
func (k KeyOperationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "aad", k.AdditionalAuthenticatedData, runtime.Base64URLFormat)
	populateByteArray(objectMap, "tag", k.AuthenticationTag, runtime.Base64URLFormat)
	populateByteArray(objectMap, "iv", k.Iv, runtime.Base64URLFormat)
	populate(objectMap, "kid", k.Kid)
	populateByteArray(objectMap, "value", k.Result, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyOperationResult.
func (k *KeyOperationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aad":
			err = runtime.DecodeByteArray(string(val), &k.AdditionalAuthenticatedData, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "tag":
			err = runtime.DecodeByteArray(string(val), &k.AuthenticationTag, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "iv":
			err = runtime.DecodeByteArray(string(val), &k.Iv, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "kid":
			err = unpopulate(val, &k.Kid)
			delete(rawMsg, key)
		case "value":
			err = runtime.DecodeByteArray(string(val), &k.Result, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyOperationsParameters - The key operations parameters.
type KeyOperationsParameters struct {
	// REQUIRED; algorithm identifier
	Algorithm *JSONWebKeyEncryptionAlgorithm `json:"alg,omitempty"`

	// REQUIRED
	Value []byte `json:"value,omitempty"`

	// Additional data to authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
	AAD []byte `json:"aad,omitempty"`

	// Initialization vector for symmetric algorithms.
	Iv []byte `json:"iv,omitempty"`

	// The tag to authenticate when performing decryption with an authenticated algorithm.
	Tag []byte `json:"tag,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyOperationsParameters.
func (k KeyOperationsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "aad", k.AAD, runtime.Base64URLFormat)
	populate(objectMap, "alg", k.Algorithm)
	populateByteArray(objectMap, "iv", k.Iv, runtime.Base64URLFormat)
	populateByteArray(objectMap, "tag", k.Tag, runtime.Base64URLFormat)
	populateByteArray(objectMap, "value", k.Value, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyOperationsParameters.
func (k *KeyOperationsParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aad":
			err = runtime.DecodeByteArray(string(val), &k.AAD, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "alg":
			err = unpopulate(val, &k.Algorithm)
			delete(rawMsg, key)
		case "iv":
			err = runtime.DecodeByteArray(string(val), &k.Iv, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "tag":
			err = runtime.DecodeByteArray(string(val), &k.Tag, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "value":
			err = runtime.DecodeByteArray(string(val), &k.Value, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyProperties - Properties of the key pair backing a certificate.
type KeyProperties struct {
	// Elliptic curve name. For valid values, see JsonWebKeyCurveName.
	Curve *JSONWebKeyCurveName `json:"crv,omitempty"`

	// Not supported in this version. Indicates if the private key can be exported.
	Exportable *bool `json:"exportable,omitempty"`

	// The key size in bits. For example: 2048, 3072, or 4096 for RSA.
	KeySize *int32 `json:"key_size,omitempty"`

	// The type of key pair to be used for the certificate.
	KeyType *JSONWebKeyType `json:"kty,omitempty"`

	// Indicates if the same key pair will be used on certificate renewal.
	ReuseKey *bool `json:"reuse_key,omitempty"`
}

// KeyRestoreParameters - The key restore parameters.
type KeyRestoreParameters struct {
	// REQUIRED; The backup blob associated with a key bundle.
	KeyBundleBackup []byte `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyRestoreParameters.
func (k KeyRestoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", k.KeyBundleBackup, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyRestoreParameters.
func (k *KeyRestoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &k.KeyBundleBackup, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeySignParameters - The key operations parameters.
type KeySignParameters struct {
	// REQUIRED; The signing/verification algorithm identifier. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
	Algorithm *JSONWebKeySignatureAlgorithm `json:"alg,omitempty"`

	// REQUIRED
	Value []byte `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeySignParameters.
func (k KeySignParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alg", k.Algorithm)
	populateByteArray(objectMap, "value", k.Value, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeySignParameters.
func (k *KeySignParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alg":
			err = unpopulate(val, &k.Algorithm)
			delete(rawMsg, key)
		case "value":
			err = runtime.DecodeByteArray(string(val), &k.Value, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyUpdateParameters - The key update parameters.
type KeyUpdateParameters struct {
	// The attributes of a key managed by the key vault service.
	KeyAttributes *KeyAttributes `json:"attributes,omitempty"`

	// Json web key operations. For more information on possible key operations, see JsonWebKeyOperation.
	KeyOps []*JSONWebKeyOperation `json:"key_ops,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyUpdateParameters.
func (k KeyUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", k.KeyAttributes)
	populate(objectMap, "key_ops", k.KeyOps)
	populate(objectMap, "tags", k.Tags)
	return json.Marshal(objectMap)
}

// KeyVerifyParameters - The key verify parameters.
type KeyVerifyParameters struct {
	// REQUIRED; The signing/verification algorithm. For more information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
	Algorithm *JSONWebKeySignatureAlgorithm `json:"alg,omitempty"`

	// REQUIRED; The digest used for signing.
	Digest []byte `json:"digest,omitempty"`

	// REQUIRED; The signature to be verified.
	Signature []byte `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type KeyVerifyParameters.
func (k KeyVerifyParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alg", k.Algorithm)
	populateByteArray(objectMap, "digest", k.Digest, runtime.Base64URLFormat)
	populateByteArray(objectMap, "value", k.Signature, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KeyVerifyParameters.
func (k *KeyVerifyParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alg":
			err = unpopulate(val, &k.Algorithm)
			delete(rawMsg, key)
		case "digest":
			err = runtime.DecodeByteArray(string(val), &k.Digest, runtime.Base64URLFormat)
			delete(rawMsg, key)
		case "value":
			err = runtime.DecodeByteArray(string(val), &k.Signature, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyVerifyResult - The key verify result.
type KeyVerifyResult struct {
	// READ-ONLY; True if the signature is verified, otherwise false.
	Value *bool `json:"value,omitempty" azure:"ro"`
}

// LifetimeAction - Action and its trigger that will be performed by Key Vault over the lifetime of a certificate.
type LifetimeAction struct {
	// The action that will be executed.
	Action *Action `json:"action,omitempty"`

	// The condition that will execute the action.
	Trigger *Trigger `json:"trigger,omitempty"`
}

// OrganizationDetails - Details of the organization of the certificate issuer.
type OrganizationDetails struct {
	// Details of the organization administrator.
	AdminDetails []*AdministratorDetails `json:"admin_details,omitempty"`

	// Id of the organization.
	ID *string `json:"id,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OrganizationDetails.
func (o OrganizationDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "admin_details", o.AdminDetails)
	populate(objectMap, "id", o.ID)
	return json.Marshal(objectMap)
}

// PendingCertificateSigningRequestResult - The pending certificate signing request result.
type PendingCertificateSigningRequestResult struct {
	// READ-ONLY; The pending certificate signing request as Base64 encoded string.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// Permission - Role definition permissions.
type Permission struct {
	// Action permissions that are granted.
	Actions []*string `json:"actions,omitempty"`

	// Data action permissions that are granted.
	DataActions []*DataAction `json:"dataActions,omitempty"`

	// Action permissions that are excluded but not denied. They may be granted by other role definitions assigned to a principal.
	NotActions []*string `json:"notActions,omitempty"`

	// Data action permissions that are excluded but not denied. They may be granted by other role definitions assigned to a principal.
	NotDataActions []*DataAction `json:"notDataActions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Permission.
func (p Permission) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "actions", p.Actions)
	populate(objectMap, "dataActions", p.DataActions)
	populate(objectMap, "notActions", p.NotActions)
	populate(objectMap, "notDataActions", p.NotDataActions)
	return json.Marshal(objectMap)
}

// RestoreOperation - Restore operation
type RestoreOperation struct {
	// The end time of the restore operation
	EndTime *time.Time `json:"endTime,omitempty"`

	// Error encountered, if any, during the restore operation.
	Error *ErrorInfo `json:"error,omitempty"`

	// Identifier for the restore operation.
	JobID *string `json:"jobId,omitempty"`

	// The start time of the restore operation
	StartTime *time.Time `json:"startTime,omitempty"`

	// Status of the restore operation.
	Status *string `json:"status,omitempty"`

	// The status details of restore operation.
	StatusDetails *string `json:"statusDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestoreOperation.
func (r RestoreOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "endTime", r.EndTime)
	populate(objectMap, "error", r.Error)
	populate(objectMap, "jobId", r.JobID)
	populateTimeUnix(objectMap, "startTime", r.StartTime)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "statusDetails", r.StatusDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreOperation.
func (r *RestoreOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeUnix(val, &r.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &r.Error)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, &r.JobID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeUnix(val, &r.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &r.StatusDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type RestoreOperationParameters struct {
	// REQUIRED; The Folder name of the blob where the previous successful full backup was stored
	FolderToRestore *string `json:"folderToRestore,omitempty"`

	// REQUIRED; SAS token parameter object containing Azure storage resourceUri and token
	SasTokenParameters *SASTokenParameter `json:"sasTokenParameters,omitempty"`
}

// RoleAssignment - Role Assignments
type RoleAssignment struct {
	// Role assignment properties.
	Properties *RoleAssignmentPropertiesWithScope `json:"properties,omitempty"`

	// READ-ONLY; The role assignment ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role assignment type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// RoleAssignmentCreateParameters - Role assignment create parameters.
type RoleAssignmentCreateParameters struct {
	// REQUIRED; Role assignment properties.
	Properties *RoleAssignmentProperties `json:"properties,omitempty"`
}

// RoleAssignmentFilter - Role Assignments filter
type RoleAssignmentFilter struct {
	// Returns role assignment of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
}

// RoleAssignmentListResult - Role assignment list operation result.
type RoleAssignmentListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role assignment list.
	Value []*RoleAssignment `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleAssignmentListResult.
func (r RoleAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleAssignmentProperties - Role assignment properties.
type RoleAssignmentProperties struct {
	// REQUIRED; The principal ID assigned to the role. This maps to the ID inside the Active Directory. It can point to a user,
	// service principal, or security group.
	PrincipalID *string `json:"principalId,omitempty"`

	// REQUIRED; The role definition ID used in the role assignment.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
}

// RoleAssignmentPropertiesWithScope - Role assignment properties with scope.
type RoleAssignmentPropertiesWithScope struct {
	// The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`

	// The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`

	// The role scope.
	Scope *RoleScope `json:"scope,omitempty"`
}

// RoleAssignmentsClientCreateOptions contains the optional parameters for the RoleAssignmentsClient.Create method.
type RoleAssignmentsClientCreateOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentsClientDeleteOptions contains the optional parameters for the RoleAssignmentsClient.Delete method.
type RoleAssignmentsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentsClientGetOptions contains the optional parameters for the RoleAssignmentsClient.Get method.
type RoleAssignmentsClientGetOptions struct {
	// placeholder for future optional parameters
}

// RoleAssignmentsClientListForScopeOptions contains the optional parameters for the RoleAssignmentsClient.ListForScope method.
type RoleAssignmentsClientListForScopeOptions struct {
	// The filter to apply on the operation. Use $filter=atScope() to return all role assignments at or above the scope. Use $filter=principalId
	// eq {id} to return all role assignments at, above or below the
	// scope for the specified principal.
	Filter *string
}

// RoleDefinition - Role definition.
type RoleDefinition struct {
	// Role definition properties.
	Properties *RoleDefinitionProperties `json:"properties,omitempty"`

	// READ-ONLY; The role definition ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The role definition name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The role definition type.
	Type *RoleDefinitionType `json:"type,omitempty" azure:"ro"`
}

// RoleDefinitionCreateParameters - Role definition create parameters.
type RoleDefinitionCreateParameters struct {
	// REQUIRED; Role definition properties.
	Properties *RoleDefinitionProperties `json:"properties,omitempty"`
}

// RoleDefinitionFilter - Role Definitions filter
type RoleDefinitionFilter struct {
	// Returns role definition with the specific name.
	RoleName *string `json:"roleName,omitempty"`
}

// RoleDefinitionListResult - Role definition list operation result.
type RoleDefinitionListResult struct {
	// The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`

	// Role definition list.
	Value []*RoleDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleDefinitionListResult.
func (r RoleDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RoleDefinitionProperties - Role definition properties.
type RoleDefinitionProperties struct {
	// Role definition assignable scopes.
	AssignableScopes []*RoleScope `json:"assignableScopes,omitempty"`

	// The role definition description.
	Description *string `json:"description,omitempty"`

	// Role definition permissions.
	Permissions []*Permission `json:"permissions,omitempty"`

	// The role name.
	RoleName *string `json:"roleName,omitempty"`

	// The role type.
	RoleType *RoleType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RoleDefinitionProperties.
func (r RoleDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assignableScopes", r.AssignableScopes)
	populate(objectMap, "description", r.Description)
	populate(objectMap, "permissions", r.Permissions)
	populate(objectMap, "roleName", r.RoleName)
	populate(objectMap, "type", r.RoleType)
	return json.Marshal(objectMap)
}

// RoleDefinitionsClientCreateOrUpdateOptions contains the optional parameters for the RoleDefinitionsClient.CreateOrUpdate
// method.
type RoleDefinitionsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsClientDeleteOptions contains the optional parameters for the RoleDefinitionsClient.Delete method.
type RoleDefinitionsClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsClientGetOptions contains the optional parameters for the RoleDefinitionsClient.Get method.
type RoleDefinitionsClientGetOptions struct {
	// placeholder for future optional parameters
}

// RoleDefinitionsClientListOptions contains the optional parameters for the RoleDefinitionsClient.List method.
type RoleDefinitionsClientListOptions struct {
	// The filter to apply on the operation. Use atScopeAndBelow filter to search below the given scope as well.
	Filter *string
}

type SASTokenParameter struct {
	// REQUIRED; Azure Blob storage container Uri
	StorageResourceURI *string `json:"storageResourceUri,omitempty"`

	// REQUIRED; The SAS token pointing to an Azure Blob storage container
	Token *string `json:"token,omitempty"`
}

// SasDefinitionAttributes - The SAS definition management attributes.
type SasDefinitionAttributes struct {
	// the enabled state of the object.
	Enabled *bool `json:"enabled,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
	RecoverableDays *int32 `json:"recoverableDays,omitempty" azure:"ro"`

	// READ-ONLY; Reflects the deletion recovery level currently in effect for SAS definitions in the current vault. If it contains
	// 'Purgeable' the SAS definition can be permanently deleted by a privileged user;
	// otherwise, only the system can purge the SAS definition, at the end of the retention interval.
	RecoveryLevel *DeletionRecoveryLevel `json:"recoveryLevel,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SasDefinitionAttributes.
func (s SasDefinitionAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", s.Created)
	populate(objectMap, "enabled", s.Enabled)
	populate(objectMap, "recoverableDays", s.RecoverableDays)
	populate(objectMap, "recoveryLevel", s.RecoveryLevel)
	populateTimeUnix(objectMap, "updated", s.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SasDefinitionAttributes.
func (s *SasDefinitionAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &s.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &s.Enabled)
			delete(rawMsg, key)
		case "recoverableDays":
			err = unpopulate(val, &s.RecoverableDays)
			delete(rawMsg, key)
		case "recoveryLevel":
			err = unpopulate(val, &s.RecoveryLevel)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &s.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SasDefinitionBundle - A SAS definition bundle consists of key vault SAS definition details plus its attributes.
type SasDefinitionBundle struct {
	// READ-ONLY; The SAS definition attributes.
	Attributes *SasDefinitionAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; The SAS definition id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The type of SAS token the SAS definition will create.
	SasType *SasTokenType `json:"sasType,omitempty" azure:"ro"`

	// READ-ONLY; Storage account SAS definition secret id.
	SecretID *string `json:"sid,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`

	// READ-ONLY; The SAS definition token template signed with an arbitrary key. Tokens created according to the SAS definition
	// will have the same properties as the template.
	TemplateURI *string `json:"templateUri,omitempty" azure:"ro"`

	// READ-ONLY; The validity period of SAS tokens created according to the SAS definition.
	ValidityPeriod *string `json:"validityPeriod,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SasDefinitionBundle.
func (s SasDefinitionBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.Attributes)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "sasType", s.SasType)
	populate(objectMap, "sid", s.SecretID)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "templateUri", s.TemplateURI)
	populate(objectMap, "validityPeriod", s.ValidityPeriod)
	return json.Marshal(objectMap)
}

// SasDefinitionCreateParameters - The SAS definition create parameters.
type SasDefinitionCreateParameters struct {
	// REQUIRED; The type of SAS token the SAS definition will create.
	SasType *SasTokenType `json:"sasType,omitempty"`

	// REQUIRED; The SAS definition token template signed with an arbitrary key. Tokens created according to the SAS definition
	// will have the same properties as the template.
	TemplateURI *string `json:"templateUri,omitempty"`

	// REQUIRED; The validity period of SAS tokens created according to the SAS definition.
	ValidityPeriod *string `json:"validityPeriod,omitempty"`

	// The attributes of the SAS definition.
	SasDefinitionAttributes *SasDefinitionAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SasDefinitionCreateParameters.
func (s SasDefinitionCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.SasDefinitionAttributes)
	populate(objectMap, "sasType", s.SasType)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "templateUri", s.TemplateURI)
	populate(objectMap, "validityPeriod", s.ValidityPeriod)
	return json.Marshal(objectMap)
}

// SasDefinitionItem - The SAS definition item containing storage SAS definition metadata.
type SasDefinitionItem struct {
	// READ-ONLY; The SAS definition management attributes.
	Attributes *SasDefinitionAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; The storage SAS identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The storage account SAS definition secret id.
	SecretID *string `json:"sid,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SasDefinitionItem.
func (s SasDefinitionItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.Attributes)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "sid", s.SecretID)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SasDefinitionListResult - The storage account SAS definition list result.
type SasDefinitionListResult struct {
	// READ-ONLY; The URL to get the next set of SAS definitions.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of SAS definitions along with a link to the next page of SAS definitions.
	Value []*SasDefinitionItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SasDefinitionListResult.
func (s SasDefinitionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SasDefinitionUpdateParameters - The SAS definition update parameters.
type SasDefinitionUpdateParameters struct {
	// The attributes of the SAS definition.
	SasDefinitionAttributes *SasDefinitionAttributes `json:"attributes,omitempty"`

	// The type of SAS token the SAS definition will create.
	SasType *SasTokenType `json:"sasType,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// The SAS definition token template signed with an arbitrary key. Tokens created according to the SAS definition will have
	// the same properties as the template.
	TemplateURI *string `json:"templateUri,omitempty"`

	// The validity period of SAS tokens created according to the SAS definition.
	ValidityPeriod *string `json:"validityPeriod,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SasDefinitionUpdateParameters.
func (s SasDefinitionUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.SasDefinitionAttributes)
	populate(objectMap, "sasType", s.SasType)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "templateUri", s.TemplateURI)
	populate(objectMap, "validityPeriod", s.ValidityPeriod)
	return json.Marshal(objectMap)
}

// SecretAttributes - The secret management attributes.
type SecretAttributes struct {
	// Determines whether the object is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Expiry date in UTC.
	Expires *time.Time `json:"exp,omitempty"`

	// Not before date in UTC.
	NotBefore *time.Time `json:"nbf,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
	RecoverableDays *int32 `json:"recoverableDays,omitempty" azure:"ro"`

	// READ-ONLY; Reflects the deletion recovery level currently in effect for secrets in the current vault. If it contains 'Purgeable',
	// the secret can be permanently deleted by a privileged user; otherwise, only the
	// system can purge the secret, at the end of the retention interval.
	RecoveryLevel *DeletionRecoveryLevel `json:"recoveryLevel,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretAttributes.
func (s SecretAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", s.Created)
	populate(objectMap, "enabled", s.Enabled)
	populateTimeUnix(objectMap, "exp", s.Expires)
	populateTimeUnix(objectMap, "nbf", s.NotBefore)
	populate(objectMap, "recoverableDays", s.RecoverableDays)
	populate(objectMap, "recoveryLevel", s.RecoveryLevel)
	populateTimeUnix(objectMap, "updated", s.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretAttributes.
func (s *SecretAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &s.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &s.Enabled)
			delete(rawMsg, key)
		case "exp":
			err = unpopulateTimeUnix(val, &s.Expires)
			delete(rawMsg, key)
		case "nbf":
			err = unpopulateTimeUnix(val, &s.NotBefore)
			delete(rawMsg, key)
		case "recoverableDays":
			err = unpopulate(val, &s.RecoverableDays)
			delete(rawMsg, key)
		case "recoveryLevel":
			err = unpopulate(val, &s.RecoveryLevel)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &s.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SecretBundle - A secret consisting of a value, id and its attributes.
type SecretBundle struct {
	// The secret management attributes.
	Attributes *SecretAttributes `json:"attributes,omitempty"`

	// The content type of the secret.
	ContentType *string `json:"contentType,omitempty"`

	// The secret id.
	ID *string `json:"id,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// The secret value.
	Value *string `json:"value,omitempty"`

	// READ-ONLY; If this is a secret backing a KV certificate, then this field specifies the corresponding key backing the KV
	// certificate.
	Kid *string `json:"kid,omitempty" azure:"ro"`

	// READ-ONLY; True if the secret's lifetime is managed by key vault. If this is a secret backing a certificate, then managed
	// will be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretBundle.
func (s SecretBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.Attributes)
	populate(objectMap, "contentType", s.ContentType)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "kid", s.Kid)
	populate(objectMap, "managed", s.Managed)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SecretItem - The secret item containing secret metadata.
type SecretItem struct {
	// The secret management attributes.
	Attributes *SecretAttributes `json:"attributes,omitempty"`

	// Type of the secret value such as a password.
	ContentType *string `json:"contentType,omitempty"`

	// Secret identifier.
	ID *string `json:"id,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; True if the secret's lifetime is managed by key vault. If this is a key backing a certificate, then managed
	// will be true.
	Managed *bool `json:"managed,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretItem.
func (s SecretItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.Attributes)
	populate(objectMap, "contentType", s.ContentType)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "managed", s.Managed)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SecretListResult - The secret list result.
type SecretListResult struct {
	// READ-ONLY; The URL to get the next set of secrets.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of secrets in the key vault along with a link to the next page of secrets.
	Value []*SecretItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretListResult.
func (s SecretListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SecretProperties - Properties of the key backing a certificate.
type SecretProperties struct {
	// The media type (MIME type).
	ContentType *string `json:"contentType,omitempty"`
}

// SecretRestoreParameters - The secret restore parameters.
type SecretRestoreParameters struct {
	// REQUIRED; The backup blob associated with a secret bundle.
	SecretBundleBackup []byte `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretRestoreParameters.
func (s SecretRestoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", s.SecretBundleBackup, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretRestoreParameters.
func (s *SecretRestoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &s.SecretBundleBackup, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SecretSetParameters - The secret set parameters.
type SecretSetParameters struct {
	// REQUIRED; The value of the secret.
	Value *string `json:"value,omitempty"`

	// Type of the secret value such as a password.
	ContentType *string `json:"contentType,omitempty"`

	// The secret management attributes.
	SecretAttributes *SecretAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretSetParameters.
func (s SecretSetParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentType", s.ContentType)
	populate(objectMap, "attributes", s.SecretAttributes)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SecretUpdateParameters - The secret update parameters.
type SecretUpdateParameters struct {
	// Type of the secret value such as a password.
	ContentType *string `json:"contentType,omitempty"`

	// The secret management attributes.
	SecretAttributes *SecretAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecretUpdateParameters.
func (s SecretUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentType", s.ContentType)
	populate(objectMap, "attributes", s.SecretAttributes)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

type SecurityDomainCertificateItem struct {
	// REQUIRED; Customer generated certificate containing public key in JWK format
	Value *SecurityDomainJSONWebKey `json:"value,omitempty"`
}

type SecurityDomainJSONWebKey struct {
	// REQUIRED; Algorithm intended for use with the key.
	Alg *string `json:"alg,omitempty"`

	// REQUIRED; RSA public exponent.
	E *string `json:"e,omitempty"`

	// REQUIRED
	KeyOps []*string `json:"key_ops,omitempty"`

	// REQUIRED; Key identifier.
	Kid *string `json:"kid,omitempty"`

	// REQUIRED; JsonWebKey Key Type (kty), as defined in https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40.
	// For Security Domain this value must be RSA.
	Kty *string `json:"kty,omitempty"`

	// REQUIRED; RSA modulus.
	N *string `json:"n,omitempty"`

	// REQUIRED; X509 certificate chain parameter
	X5C []*string `json:"x5c,omitempty"`

	// REQUIRED; X509 certificate SHA256 thumbprint.
	X5TS256 *string `json:"x5t#S256,omitempty"`

	// Public Key Use Parameter. This is optional and if present must be enc.
	Use *string `json:"use,omitempty"`

	// X509 certificate SHA1 thumbprint. This is optional.
	X5T *string `json:"x5t,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecurityDomainJSONWebKey.
func (s SecurityDomainJSONWebKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alg", s.Alg)
	populate(objectMap, "e", s.E)
	populate(objectMap, "key_ops", s.KeyOps)
	populate(objectMap, "kid", s.Kid)
	populate(objectMap, "kty", s.Kty)
	populate(objectMap, "n", s.N)
	populate(objectMap, "use", s.Use)
	populate(objectMap, "x5c", s.X5C)
	populate(objectMap, "x5t", s.X5T)
	populate(objectMap, "x5t#S256", s.X5TS256)
	return json.Marshal(objectMap)
}

// SecurityDomainObject - The Security Domain.
type SecurityDomainObject struct {
	// REQUIRED; The Security Domain.
	Value *string `json:"value,omitempty"`
}

type SecurityDomainOperationStatus struct {
	// operation status
	Status        *OperationStatus `json:"status,omitempty"`
	StatusDetails *string          `json:"status_details,omitempty"`
}

// SelectiveKeyRestoreOperation - Selective Key Restore operation
type SelectiveKeyRestoreOperation struct {
	// The end time of the restore operation
	EndTime *time.Time `json:"endTime,omitempty"`

	// Error encountered, if any, during the selective key restore operation.
	Error *ErrorInfo `json:"error,omitempty"`

	// Identifier for the selective key restore operation.
	JobID *string `json:"jobId,omitempty"`

	// The start time of the restore operation
	StartTime *time.Time `json:"startTime,omitempty"`

	// Status of the restore operation.
	Status *string `json:"status,omitempty"`

	// The status details of restore operation.
	StatusDetails *string `json:"statusDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelectiveKeyRestoreOperation.
func (s SelectiveKeyRestoreOperation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "endTime", s.EndTime)
	populate(objectMap, "error", s.Error)
	populate(objectMap, "jobId", s.JobID)
	populateTimeUnix(objectMap, "startTime", s.StartTime)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "statusDetails", s.StatusDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelectiveKeyRestoreOperation.
func (s *SelectiveKeyRestoreOperation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeUnix(val, &s.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &s.Error)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, &s.JobID)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeUnix(val, &s.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &s.StatusDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type SelectiveKeyRestoreOperationParameters struct {
	// REQUIRED; The Folder name of the blob where the previous successful full backup was stored
	Folder *string `json:"folder,omitempty"`

	// REQUIRED; SAS token parameter object containing Azure storage resourceUri and token
	SasTokenParameters *SASTokenParameter `json:"sasTokenParameters,omitempty"`
}

// StorageAccountAttributes - The storage account management attributes.
type StorageAccountAttributes struct {
	// the enabled state of the object.
	Enabled *bool `json:"enabled,omitempty"`

	// READ-ONLY; Creation time in UTC.
	Created *time.Time `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; softDelete data retention days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
	RecoverableDays *int32 `json:"recoverableDays,omitempty" azure:"ro"`

	// READ-ONLY; Reflects the deletion recovery level currently in effect for storage accounts in the current vault. If it contains
	// 'Purgeable' the storage account can be permanently deleted by a privileged user;
	// otherwise, only the system can purge the storage account, at the end of the retention interval.
	RecoveryLevel *DeletionRecoveryLevel `json:"recoveryLevel,omitempty" azure:"ro"`

	// READ-ONLY; Last updated time in UTC.
	Updated *time.Time `json:"updated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountAttributes.
func (s StorageAccountAttributes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeUnix(objectMap, "created", s.Created)
	populate(objectMap, "enabled", s.Enabled)
	populate(objectMap, "recoverableDays", s.RecoverableDays)
	populate(objectMap, "recoveryLevel", s.RecoveryLevel)
	populateTimeUnix(objectMap, "updated", s.Updated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageAccountAttributes.
func (s *StorageAccountAttributes) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "created":
			err = unpopulateTimeUnix(val, &s.Created)
			delete(rawMsg, key)
		case "enabled":
			err = unpopulate(val, &s.Enabled)
			delete(rawMsg, key)
		case "recoverableDays":
			err = unpopulate(val, &s.RecoverableDays)
			delete(rawMsg, key)
		case "recoveryLevel":
			err = unpopulate(val, &s.RecoveryLevel)
			delete(rawMsg, key)
		case "updated":
			err = unpopulateTimeUnix(val, &s.Updated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageAccountCreateParameters - The storage account create parameters.
type StorageAccountCreateParameters struct {
	// REQUIRED; Current active storage account key name.
	ActiveKeyName *string `json:"activeKeyName,omitempty"`

	// REQUIRED; whether keyvault should manage the storage account for the user.
	AutoRegenerateKey *bool `json:"autoRegenerateKey,omitempty"`

	// REQUIRED; Storage account resource id.
	ResourceID *string `json:"resourceId,omitempty"`

	// The key regeneration time duration specified in ISO-8601 format.
	RegenerationPeriod *string `json:"regenerationPeriod,omitempty"`

	// The attributes of the storage account.
	StorageAccountAttributes *StorageAccountAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountCreateParameters.
func (s StorageAccountCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeKeyName", s.ActiveKeyName)
	populate(objectMap, "autoRegenerateKey", s.AutoRegenerateKey)
	populate(objectMap, "regenerationPeriod", s.RegenerationPeriod)
	populate(objectMap, "resourceId", s.ResourceID)
	populate(objectMap, "attributes", s.StorageAccountAttributes)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// StorageAccountItem - The storage account item containing storage account metadata.
type StorageAccountItem struct {
	// READ-ONLY; The storage account management attributes.
	Attributes *StorageAccountAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; Storage identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Storage account resource Id.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountItem.
func (s StorageAccountItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "attributes", s.Attributes)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "resourceId", s.ResourceID)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// StorageAccountRegenerteKeyParameters - The storage account key regenerate parameters.
type StorageAccountRegenerteKeyParameters struct {
	// REQUIRED; The storage account key name.
	KeyName *string `json:"keyName,omitempty"`
}

// StorageAccountUpdateParameters - The storage account update parameters.
type StorageAccountUpdateParameters struct {
	// The current active storage account key name.
	ActiveKeyName *string `json:"activeKeyName,omitempty"`

	// whether keyvault should manage the storage account for the user.
	AutoRegenerateKey *bool `json:"autoRegenerateKey,omitempty"`

	// The key regeneration time duration specified in ISO-8601 format.
	RegenerationPeriod *string `json:"regenerationPeriod,omitempty"`

	// The attributes of the storage account.
	StorageAccountAttributes *StorageAccountAttributes `json:"attributes,omitempty"`

	// Application specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountUpdateParameters.
func (s StorageAccountUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeKeyName", s.ActiveKeyName)
	populate(objectMap, "autoRegenerateKey", s.AutoRegenerateKey)
	populate(objectMap, "regenerationPeriod", s.RegenerationPeriod)
	populate(objectMap, "attributes", s.StorageAccountAttributes)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// StorageBundle - A Storage account bundle consists of key vault storage account details plus its attributes.
type StorageBundle struct {
	// READ-ONLY; The current active storage account key name.
	ActiveKeyName *string `json:"activeKeyName,omitempty" azure:"ro"`

	// READ-ONLY; The storage account attributes.
	Attributes *StorageAccountAttributes `json:"attributes,omitempty" azure:"ro"`

	// READ-ONLY; whether keyvault should manage the storage account for the user.
	AutoRegenerateKey *bool `json:"autoRegenerateKey,omitempty" azure:"ro"`

	// READ-ONLY; The storage account id.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The key regeneration time duration specified in ISO-8601 format.
	RegenerationPeriod *string `json:"regenerationPeriod,omitempty" azure:"ro"`

	// READ-ONLY; The storage account resource id.
	ResourceID *string `json:"resourceId,omitempty" azure:"ro"`

	// READ-ONLY; Application specific metadata in the form of key-value pairs
	Tags map[string]*string `json:"tags,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageBundle.
func (s StorageBundle) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeKeyName", s.ActiveKeyName)
	populate(objectMap, "attributes", s.Attributes)
	populate(objectMap, "autoRegenerateKey", s.AutoRegenerateKey)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "regenerationPeriod", s.RegenerationPeriod)
	populate(objectMap, "resourceId", s.ResourceID)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// StorageListResult - The storage accounts list result.
type StorageListResult struct {
	// READ-ONLY; The URL to get the next set of storage accounts.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A response message containing a list of storage accounts in the key vault along with a link to the next page
	// of storage accounts.
	Value []*StorageAccountItem `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageListResult.
func (s StorageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageRestoreParameters - The secret restore parameters.
type StorageRestoreParameters struct {
	// REQUIRED; The backup blob associated with a storage account.
	StorageBundleBackup []byte `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageRestoreParameters.
func (s StorageRestoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateByteArray(objectMap, "value", s.StorageBundleBackup, runtime.Base64URLFormat)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageRestoreParameters.
func (s *StorageRestoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			err = runtime.DecodeByteArray(string(val), &s.StorageBundleBackup, runtime.Base64URLFormat)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubjectAlternativeNames - The subject alternate names of a X509 object.
type SubjectAlternativeNames struct {
	// Domain names.
	DNSNames []*string `json:"dns_names,omitempty"`

	// Email addresses.
	Emails []*string `json:"emails,omitempty"`

	// User principal names.
	Upns []*string `json:"upns,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubjectAlternativeNames.
func (s SubjectAlternativeNames) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dns_names", s.DNSNames)
	populate(objectMap, "emails", s.Emails)
	populate(objectMap, "upns", s.Upns)
	return json.Marshal(objectMap)
}

type TransferKey struct {
	// REQUIRED; Specifies the transfer key in JWK format
	TransferKey *SecurityDomainJSONWebKey `json:"transfer_key,omitempty"`

	// Specifies the format of the transfer key
	KeyFormat *string `json:"key_format,omitempty"`
}

// Trigger - A condition to be satisfied for an action to be executed.
type Trigger struct {
	// Days before expiry to attempt renewal. Value should be between 1 and validityinmonths multiplied by 27. If validityinmonths
	// is 36, then value should be between 1 and 972 (36 * 27).
	DaysBeforeExpiry *int32 `json:"days_before_expiry,omitempty"`

	// Percentage of lifetime at which to trigger. Value should be between 1 and 99.
	LifetimePercentage *int32 `json:"lifetime_percentage,omitempty"`
}

// X509CertificateProperties - Properties of the X509 component of a certificate.
type X509CertificateProperties struct {
	// The enhanced key usage.
	Ekus []*string `json:"ekus,omitempty"`

	// List of key usages.
	KeyUsage []*KeyUsageType `json:"key_usage,omitempty"`

	// The subject name. Should be a valid X509 distinguished Name.
	Subject *string `json:"subject,omitempty"`

	// The subject alternative names.
	SubjectAlternativeNames *SubjectAlternativeNames `json:"sans,omitempty"`

	// The duration that the certificate is valid in months.
	ValidityInMonths *int32 `json:"validity_months,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type X509CertificateProperties.
func (x X509CertificateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ekus", x.Ekus)
	populate(objectMap, "key_usage", x.KeyUsage)
	populate(objectMap, "subject", x.Subject)
	populate(objectMap, "sans", x.SubjectAlternativeNames)
	populate(objectMap, "validity_months", x.ValidityInMonths)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray(m map[string]interface{}, k string, b []byte, f runtime.Base64Encoding) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = runtime.EncodeByteArray(b, f)
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
