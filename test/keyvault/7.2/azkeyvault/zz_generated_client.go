//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azkeyvault

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// Client contains the methods for the KeyVaultClient group.
// Don't use this type directly, use NewClient() instead.
type Client struct {
	pl runtime.Pipeline
}

// NewClient creates a new instance of Client with the specified values.
// pl - the pipeline used for sending requests and handling responses.
func NewClient(pl runtime.Pipeline) *Client {
	client := &Client{
		pl: pl,
	}
	return client
}

// BackupCertificate - Requests that a backup of the specified certificate be downloaded to the client. All versions of the
// certificate will be downloaded. This operation requires the certificates/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// options - ClientBackupCertificateOptions contains the optional parameters for the Client.BackupCertificate method.
func (client *Client) BackupCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientBackupCertificateOptions) (ClientBackupCertificateResponse, error) {
	req, err := client.backupCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientBackupCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientBackupCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientBackupCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.backupCertificateHandleResponse(resp)
}

// backupCertificateCreateRequest creates the BackupCertificate request.
func (client *Client) backupCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientBackupCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/backup"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupCertificateHandleResponse handles the BackupCertificate response.
func (client *Client) backupCertificateHandleResponse(resp *http.Response) (ClientBackupCertificateResponse, error) {
	result := ClientBackupCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupCertificateResult); err != nil {
		return ClientBackupCertificateResponse{}, err
	}
	return result, nil
}

// BackupKey - The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does
// NOT return key material in a form that can be used outside the Azure Key Vault system,
// the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this
// operation is to allow a client to GENERATE a key in one Azure Key Vault
// instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP operation may be used to
// export, in protected form, any key type from Azure Key Vault. Individual
// versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that
// a BACKUP from one geographical area cannot be restored to another
// geographical area. For example, a backup from the US geographical area cannot be restored in an EU geographical area. This
// operation requires the key/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// options - ClientBackupKeyOptions contains the optional parameters for the Client.BackupKey method.
func (client *Client) BackupKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientBackupKeyOptions) (ClientBackupKeyResponse, error) {
	req, err := client.backupKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return ClientBackupKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientBackupKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientBackupKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.backupKeyHandleResponse(resp)
}

// backupKeyCreateRequest creates the BackupKey request.
func (client *Client) backupKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientBackupKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/backup"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupKeyHandleResponse handles the BackupKey response.
func (client *Client) backupKeyHandleResponse(resp *http.Response) (ClientBackupKeyResponse, error) {
	result := ClientBackupKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupKeyResult); err != nil {
		return ClientBackupKeyResponse{}, err
	}
	return result, nil
}

// BackupSecret - Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will
// be downloaded. This operation requires the secrets/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// options - ClientBackupSecretOptions contains the optional parameters for the Client.BackupSecret method.
func (client *Client) BackupSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientBackupSecretOptions) (ClientBackupSecretResponse, error) {
	req, err := client.backupSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return ClientBackupSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientBackupSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientBackupSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.backupSecretHandleResponse(resp)
}

// backupSecretCreateRequest creates the BackupSecret request.
func (client *Client) backupSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientBackupSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/backup"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupSecretHandleResponse handles the BackupSecret response.
func (client *Client) backupSecretHandleResponse(resp *http.Response) (ClientBackupSecretResponse, error) {
	result := ClientBackupSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupSecretResult); err != nil {
		return ClientBackupSecretResponse{}, err
	}
	return result, nil
}

// BackupStorageAccount - Requests that a backup of the specified storage account be downloaded to the client. This operation
// requires the storage/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientBackupStorageAccountOptions contains the optional parameters for the Client.BackupStorageAccount method.
func (client *Client) BackupStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientBackupStorageAccountOptions) (ClientBackupStorageAccountResponse, error) {
	req, err := client.backupStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return ClientBackupStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientBackupStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientBackupStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.backupStorageAccountHandleResponse(resp)
}

// backupStorageAccountCreateRequest creates the BackupStorageAccount request.
func (client *Client) backupStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientBackupStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/backup"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupStorageAccountHandleResponse handles the BackupStorageAccount response.
func (client *Client) backupStorageAccountHandleResponse(resp *http.Response) (ClientBackupStorageAccountResponse, error) {
	result := ClientBackupStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupStorageResult); err != nil {
		return ClientBackupStorageAccountResponse{}, err
	}
	return result, nil
}

// CreateCertificate - If this is the first version, the certificate resource is created. This operation requires the certificates/create
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// parameters - The parameters to create a certificate.
// options - ClientCreateCertificateOptions contains the optional parameters for the Client.CreateCertificate method.
func (client *Client) CreateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *ClientCreateCertificateOptions) (ClientCreateCertificateResponse, error) {
	req, err := client.createCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return ClientCreateCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return ClientCreateCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createCertificateHandleResponse(resp)
}

// createCertificateCreateRequest creates the CreateCertificate request.
func (client *Client) createCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *ClientCreateCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/create"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createCertificateHandleResponse handles the CreateCertificate response.
func (client *Client) createCertificateHandleResponse(resp *http.Response) (ClientCreateCertificateResponse, error) {
	result := ClientCreateCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return ClientCreateCertificateResponse{}, err
	}
	return result, nil
}

// CreateKey - The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists,
// Azure Key Vault creates a new version of the key. It requires the keys/create
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name for the new key. The system will generate the version name for the new key.
// parameters - The parameters to create a key.
// options - ClientCreateKeyOptions contains the optional parameters for the Client.CreateKey method.
func (client *Client) CreateKey(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyCreateParameters, options *ClientCreateKeyOptions) (ClientCreateKeyResponse, error) {
	req, err := client.createKeyCreateRequest(ctx, vaultBaseURL, keyName, parameters, options)
	if err != nil {
		return ClientCreateKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientCreateKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.createKeyHandleResponse(resp)
}

// createKeyCreateRequest creates the CreateKey request.
func (client *Client) createKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyCreateParameters, options *ClientCreateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/create"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createKeyHandleResponse handles the CreateKey response.
func (client *Client) createKeyHandleResponse(resp *http.Response) (ClientCreateKeyResponse, error) {
	result := ClientCreateKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return ClientCreateKeyResponse{}, err
	}
	return result, nil
}

// Decrypt - The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified
// algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of
// data may be decrypted, the size of this block is dependent on the target key and the algorithm to be used. The DECRYPT
// operation applies to asymmetric and symmetric keys stored in Azure Key Vault
// since it uses the private portion of the key. This operation requires the keys/decrypt permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// keyVersion - The version of the key.
// parameters - The parameters for the decryption operation.
// options - ClientDecryptOptions contains the optional parameters for the Client.Decrypt method.
func (client *Client) Decrypt(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientDecryptOptions) (ClientDecryptResponse, error) {
	req, err := client.decryptCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientDecryptResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDecryptResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDecryptResponse{}, runtime.NewResponseError(resp)
	}
	return client.decryptHandleResponse(resp)
}

// decryptCreateRequest creates the Decrypt request.
func (client *Client) decryptCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientDecryptOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/decrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// decryptHandleResponse handles the Decrypt response.
func (client *Client) decryptHandleResponse(resp *http.Response) (ClientDecryptResponse, error) {
	result := ClientDecryptResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return ClientDecryptResponse{}, err
	}
	return result, nil
}

// DeleteCertificate - Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot
// be used to remove individual versions of a certificate object. This operation requires the
// certificates/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// options - ClientDeleteCertificateOptions contains the optional parameters for the Client.DeleteCertificate method.
func (client *Client) DeleteCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOptions) (ClientDeleteCertificateResponse, error) {
	req, err := client.deleteCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientDeleteCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteCertificateHandleResponse(resp)
}

// deleteCertificateCreateRequest creates the DeleteCertificate request.
func (client *Client) deleteCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateHandleResponse handles the DeleteCertificate response.
func (client *Client) deleteCertificateHandleResponse(resp *http.Response) (ClientDeleteCertificateResponse, error) {
	result := ClientDeleteCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateBundle); err != nil {
		return ClientDeleteCertificateResponse{}, err
	}
	return result, nil
}

// DeleteCertificateContacts - Deletes the certificate contacts for a specified key vault certificate. This operation requires
// the certificates/managecontacts permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientDeleteCertificateContactsOptions contains the optional parameters for the Client.DeleteCertificateContacts
// method.
func (client *Client) DeleteCertificateContacts(ctx context.Context, vaultBaseURL string, options *ClientDeleteCertificateContactsOptions) (ClientDeleteCertificateContactsResponse, error) {
	req, err := client.deleteCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return ClientDeleteCertificateContactsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteCertificateContactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteCertificateContactsResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteCertificateContactsHandleResponse(resp)
}

// deleteCertificateContactsCreateRequest creates the DeleteCertificateContacts request.
func (client *Client) deleteCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientDeleteCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateContactsHandleResponse handles the DeleteCertificateContacts response.
func (client *Client) deleteCertificateContactsHandleResponse(resp *http.Response) (ClientDeleteCertificateContactsResponse, error) {
	result := ClientDeleteCertificateContactsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		return ClientDeleteCertificateContactsResponse{}, err
	}
	return result, nil
}

// DeleteCertificateIssuer - The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from
// the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// issuerName - The name of the issuer.
// options - ClientDeleteCertificateIssuerOptions contains the optional parameters for the Client.DeleteCertificateIssuer
// method.
func (client *Client) DeleteCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientDeleteCertificateIssuerOptions) (ClientDeleteCertificateIssuerResponse, error) {
	req, err := client.deleteCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return ClientDeleteCertificateIssuerResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteCertificateIssuerResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteCertificateIssuerHandleResponse(resp)
}

// deleteCertificateIssuerCreateRequest creates the DeleteCertificateIssuer request.
func (client *Client) deleteCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientDeleteCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateIssuerHandleResponse handles the DeleteCertificateIssuer response.
func (client *Client) deleteCertificateIssuerHandleResponse(resp *http.Response) (ClientDeleteCertificateIssuerResponse, error) {
	result := ClientDeleteCertificateIssuerResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return ClientDeleteCertificateIssuerResponse{}, err
	}
	return result, nil
}

// DeleteCertificateOperation - Deletes the creation operation for a specified certificate that is in the process of being
// created. The certificate is no longer created. This operation requires the certificates/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// options - ClientDeleteCertificateOperationOptions contains the optional parameters for the Client.DeleteCertificateOperation
// method.
func (client *Client) DeleteCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOperationOptions) (ClientDeleteCertificateOperationResponse, error) {
	req, err := client.deleteCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientDeleteCertificateOperationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteCertificateOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteCertificateOperationResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteCertificateOperationHandleResponse(resp)
}

// deleteCertificateOperationCreateRequest creates the DeleteCertificateOperation request.
func (client *Client) deleteCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateOperationHandleResponse handles the DeleteCertificateOperation response.
func (client *Client) deleteCertificateOperationHandleResponse(resp *http.Response) (ClientDeleteCertificateOperationResponse, error) {
	result := ClientDeleteCertificateOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return ClientDeleteCertificateOperationResponse{}, err
	}
	return result, nil
}

// DeleteKey - The delete key operation cannot be used to remove individual versions of a key. This operation removes the
// cryptographic material associated with the key, which means the key is not usable for
// Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key to delete.
// options - ClientDeleteKeyOptions contains the optional parameters for the Client.DeleteKey method.
func (client *Client) DeleteKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientDeleteKeyOptions) (ClientDeleteKeyResponse, error) {
	req, err := client.deleteKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return ClientDeleteKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteKeyHandleResponse(resp)
}

// deleteKeyCreateRequest creates the DeleteKey request.
func (client *Client) deleteKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientDeleteKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteKeyHandleResponse handles the DeleteKey response.
func (client *Client) deleteKeyHandleResponse(resp *http.Response) (ClientDeleteKeyResponse, error) {
	result := ClientDeleteKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedKeyBundle); err != nil {
		return ClientDeleteKeyResponse{}, err
	}
	return result, nil
}

// DeleteSasDefinition - Deletes a SAS definition from a specified storage account. This operation requires the storage/deletesas
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// sasDefinitionName - The name of the SAS definition.
// options - ClientDeleteSasDefinitionOptions contains the optional parameters for the Client.DeleteSasDefinition method.
func (client *Client) DeleteSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientDeleteSasDefinitionOptions) (ClientDeleteSasDefinitionResponse, error) {
	req, err := client.deleteSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return ClientDeleteSasDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteSasDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteSasDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteSasDefinitionHandleResponse(resp)
}

// deleteSasDefinitionCreateRequest creates the DeleteSasDefinition request.
func (client *Client) deleteSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientDeleteSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteSasDefinitionHandleResponse handles the DeleteSasDefinition response.
func (client *Client) deleteSasDefinitionHandleResponse(resp *http.Response) (ClientDeleteSasDefinitionResponse, error) {
	result := ClientDeleteSasDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSasDefinitionBundle); err != nil {
		return ClientDeleteSasDefinitionResponse{}, err
	}
	return result, nil
}

// DeleteSecret - The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual
// version of a secret. This operation requires the secrets/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// options - ClientDeleteSecretOptions contains the optional parameters for the Client.DeleteSecret method.
func (client *Client) DeleteSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientDeleteSecretOptions) (ClientDeleteSecretResponse, error) {
	req, err := client.deleteSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return ClientDeleteSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteSecretHandleResponse(resp)
}

// deleteSecretCreateRequest creates the DeleteSecret request.
func (client *Client) deleteSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientDeleteSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteSecretHandleResponse handles the DeleteSecret response.
func (client *Client) deleteSecretHandleResponse(resp *http.Response) (ClientDeleteSecretResponse, error) {
	result := ClientDeleteSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSecretBundle); err != nil {
		return ClientDeleteSecretResponse{}, err
	}
	return result, nil
}

// DeleteStorageAccount - Deletes a storage account. This operation requires the storage/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientDeleteStorageAccountOptions contains the optional parameters for the Client.DeleteStorageAccount method.
func (client *Client) DeleteStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientDeleteStorageAccountOptions) (ClientDeleteStorageAccountResponse, error) {
	req, err := client.deleteStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return ClientDeleteStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteStorageAccountHandleResponse(resp)
}

// deleteStorageAccountCreateRequest creates the DeleteStorageAccount request.
func (client *Client) deleteStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientDeleteStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteStorageAccountHandleResponse handles the DeleteStorageAccount response.
func (client *Client) deleteStorageAccountHandleResponse(resp *http.Response) (ClientDeleteStorageAccountResponse, error) {
	result := ClientDeleteStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedStorageBundle); err != nil {
		return ClientDeleteStorageAccountResponse{}, err
	}
	return result, nil
}

// Encrypt - The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure
// Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size
// of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT operation is only strictly
// necessary for symmetric keys stored in Azure Key Vault since protection with an
// asymmetric key can be performed using public portion of the key. This operation is supported for asymmetric keys as a convenience
// for callers that have a key-reference but do not have access to the
// public key material. This operation requires the keys/encrypt permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// keyVersion - The version of the key.
// parameters - The parameters for the encryption operation.
// options - ClientEncryptOptions contains the optional parameters for the Client.Encrypt method.
func (client *Client) Encrypt(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientEncryptOptions) (ClientEncryptResponse, error) {
	req, err := client.encryptCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientEncryptResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientEncryptResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientEncryptResponse{}, runtime.NewResponseError(resp)
	}
	return client.encryptHandleResponse(resp)
}

// encryptCreateRequest creates the Encrypt request.
func (client *Client) encryptCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientEncryptOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/encrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// encryptHandleResponse handles the Encrypt response.
func (client *Client) encryptHandleResponse(resp *http.Response) (ClientEncryptResponse, error) {
	result := ClientEncryptResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return ClientEncryptResponse{}, err
	}
	return result, nil
}

// BeginFullBackup - Creates a full backup using a user-provided SAS token to an Azure blob storage container.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientBeginFullBackupOptions contains the optional parameters for the Client.BeginFullBackup method.
func (client *Client) BeginFullBackup(ctx context.Context, vaultBaseURL string, options *ClientBeginFullBackupOptions) (*runtime.Poller[ClientFullBackupResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.fullBackup(ctx, vaultBaseURL, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.pl, &runtime.NewPollerOptions[ClientFullBackupResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
		})
	} else {
		return runtime.NewPollerFromResumeToken[ClientFullBackupResponse](options.ResumeToken, client.pl, nil)
	}
}

// FullBackup - Creates a full backup using a user-provided SAS token to an Azure blob storage container.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
func (client *Client) fullBackup(ctx context.Context, vaultBaseURL string, options *ClientBeginFullBackupOptions) (*http.Response, error) {
	req, err := client.fullBackupCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// fullBackupCreateRequest creates the FullBackup request.
func (client *Client) fullBackupCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientBeginFullBackupOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/backup"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.AzureStorageBlobContainerURI != nil {
		return req, runtime.MarshalAsJSON(req, *options.AzureStorageBlobContainerURI)
	}
	return req, nil
}

// FullBackupStatus - Returns the status of full backup operation
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// jobID - The id returned as part of the backup request
// options - ClientFullBackupStatusOptions contains the optional parameters for the Client.FullBackupStatus method.
func (client *Client) FullBackupStatus(ctx context.Context, vaultBaseURL string, jobID string, options *ClientFullBackupStatusOptions) (ClientFullBackupStatusResponse, error) {
	req, err := client.fullBackupStatusCreateRequest(ctx, vaultBaseURL, jobID, options)
	if err != nil {
		return ClientFullBackupStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientFullBackupStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientFullBackupStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.fullBackupStatusHandleResponse(resp)
}

// fullBackupStatusCreateRequest creates the FullBackupStatus request.
func (client *Client) fullBackupStatusCreateRequest(ctx context.Context, vaultBaseURL string, jobID string, options *ClientFullBackupStatusOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/backup/{jobId}/pending"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// fullBackupStatusHandleResponse handles the FullBackupStatus response.
func (client *Client) fullBackupStatusHandleResponse(resp *http.Response) (ClientFullBackupStatusResponse, error) {
	result := ClientFullBackupStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FullBackupOperation); err != nil {
		return ClientFullBackupStatusResponse{}, err
	}
	return result, nil
}

// BeginFullRestoreOperation - Restores all key materials using the SAS token pointing to a previously stored Azure Blob storage
// backup folder
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// restoreBlobDetails - The Azure blob SAS token pointing to a folder where the previous successful full backup was stored
// options - ClientBeginFullRestoreOperationOptions contains the optional parameters for the Client.BeginFullRestoreOperation
// method.
func (client *Client) BeginFullRestoreOperation(ctx context.Context, vaultBaseURL string, restoreBlobDetails RestoreOperationParameters, options *ClientBeginFullRestoreOperationOptions) (*runtime.Poller[ClientFullRestoreOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.fullRestoreOperation(ctx, vaultBaseURL, restoreBlobDetails, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.pl, &runtime.NewPollerOptions[ClientFullRestoreOperationResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
		})
	} else {
		return runtime.NewPollerFromResumeToken[ClientFullRestoreOperationResponse](options.ResumeToken, client.pl, nil)
	}
}

// FullRestoreOperation - Restores all key materials using the SAS token pointing to a previously stored Azure Blob storage
// backup folder
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
func (client *Client) fullRestoreOperation(ctx context.Context, vaultBaseURL string, restoreBlobDetails RestoreOperationParameters, options *ClientBeginFullRestoreOperationOptions) (*http.Response, error) {
	req, err := client.fullRestoreOperationCreateRequest(ctx, vaultBaseURL, restoreBlobDetails, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// fullRestoreOperationCreateRequest creates the FullRestoreOperation request.
func (client *Client) fullRestoreOperationCreateRequest(ctx context.Context, vaultBaseURL string, restoreBlobDetails RestoreOperationParameters, options *ClientBeginFullRestoreOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, restoreBlobDetails)
}

// GetCertificate - Gets information about a specific certificate. This operation requires the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate in the given vault.
// certificateVersion - The version of the certificate. This URI fragment is optional. If not specified, the latest version
// of the certificate is returned.
// options - ClientGetCertificateOptions contains the optional parameters for the Client.GetCertificate method.
func (client *Client) GetCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *ClientGetCertificateOptions) (ClientGetCertificateResponse, error) {
	req, err := client.getCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, options)
	if err != nil {
		return ClientGetCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCertificateHandleResponse(resp)
}

// getCertificateCreateRequest creates the GetCertificate request.
func (client *Client) getCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *ClientGetCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateHandleResponse handles the GetCertificate response.
func (client *Client) getCertificateHandleResponse(resp *http.Response) (ClientGetCertificateResponse, error) {
	result := ClientGetCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return ClientGetCertificateResponse{}, err
	}
	return result, nil
}

// GetCertificateContacts - The GetCertificateContacts operation returns the set of certificate contact resources in the specified
// key vault. This operation requires the certificates/managecontacts permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetCertificateContactsOptions contains the optional parameters for the Client.GetCertificateContacts method.
func (client *Client) GetCertificateContacts(ctx context.Context, vaultBaseURL string, options *ClientGetCertificateContactsOptions) (ClientGetCertificateContactsResponse, error) {
	req, err := client.getCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return ClientGetCertificateContactsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetCertificateContactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetCertificateContactsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCertificateContactsHandleResponse(resp)
}

// getCertificateContactsCreateRequest creates the GetCertificateContacts request.
func (client *Client) getCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateContactsHandleResponse handles the GetCertificateContacts response.
func (client *Client) getCertificateContactsHandleResponse(resp *http.Response) (ClientGetCertificateContactsResponse, error) {
	result := ClientGetCertificateContactsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		return ClientGetCertificateContactsResponse{}, err
	}
	return result, nil
}

// GetCertificateIssuer - The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified
// key vault. This operation requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// issuerName - The name of the issuer.
// options - ClientGetCertificateIssuerOptions contains the optional parameters for the Client.GetCertificateIssuer method.
func (client *Client) GetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientGetCertificateIssuerOptions) (ClientGetCertificateIssuerResponse, error) {
	req, err := client.getCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return ClientGetCertificateIssuerResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetCertificateIssuerResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCertificateIssuerHandleResponse(resp)
}

// getCertificateIssuerCreateRequest creates the GetCertificateIssuer request.
func (client *Client) getCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientGetCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateIssuerHandleResponse handles the GetCertificateIssuer response.
func (client *Client) getCertificateIssuerHandleResponse(resp *http.Response) (ClientGetCertificateIssuerResponse, error) {
	result := ClientGetCertificateIssuerResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return ClientGetCertificateIssuerResponse{}, err
	}
	return result, nil
}

// NewGetCertificateIssuersPager - The GetCertificateIssuers operation returns the set of certificate issuer resources in
// the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetCertificateIssuersOptions contains the optional parameters for the Client.GetCertificateIssuers method.
func (client *Client) NewGetCertificateIssuersPager(vaultBaseURL string, options *ClientGetCertificateIssuersOptions) *runtime.Pager[ClientGetCertificateIssuersResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetCertificateIssuersResponse]{
		More: func(page ClientGetCertificateIssuersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetCertificateIssuersResponse) (ClientGetCertificateIssuersResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getCertificateIssuersCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetCertificateIssuersResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetCertificateIssuersResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetCertificateIssuersResponse{}, runtime.NewResponseError(resp)
			}
			return client.getCertificateIssuersHandleResponse(resp)
		},
	})
}

// getCertificateIssuersCreateRequest creates the GetCertificateIssuers request.
func (client *Client) getCertificateIssuersCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetCertificateIssuersOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateIssuersHandleResponse handles the GetCertificateIssuers response.
func (client *Client) getCertificateIssuersHandleResponse(resp *http.Response) (ClientGetCertificateIssuersResponse, error) {
	result := ClientGetCertificateIssuersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateIssuerListResult); err != nil {
		return ClientGetCertificateIssuersResponse{}, err
	}
	return result, nil
}

// GetCertificateOperation - Gets the creation operation associated with a specified certificate. This operation requires
// the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// options - ClientGetCertificateOperationOptions contains the optional parameters for the Client.GetCertificateOperation
// method.
func (client *Client) GetCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificateOperationOptions) (ClientGetCertificateOperationResponse, error) {
	req, err := client.getCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientGetCertificateOperationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetCertificateOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetCertificateOperationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCertificateOperationHandleResponse(resp)
}

// getCertificateOperationCreateRequest creates the GetCertificateOperation request.
func (client *Client) getCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateOperationHandleResponse handles the GetCertificateOperation response.
func (client *Client) getCertificateOperationHandleResponse(resp *http.Response) (ClientGetCertificateOperationResponse, error) {
	result := ClientGetCertificateOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return ClientGetCertificateOperationResponse{}, err
	}
	return result, nil
}

// GetCertificatePolicy - The GetCertificatePolicy operation returns the specified certificate policy resources in the specified
// key vault. This operation requires the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate in a given key vault.
// options - ClientGetCertificatePolicyOptions contains the optional parameters for the Client.GetCertificatePolicy method.
func (client *Client) GetCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificatePolicyOptions) (ClientGetCertificatePolicyResponse, error) {
	req, err := client.getCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientGetCertificatePolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetCertificatePolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetCertificatePolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getCertificatePolicyHandleResponse(resp)
}

// getCertificatePolicyCreateRequest creates the GetCertificatePolicy request.
func (client *Client) getCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificatePolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificatePolicyHandleResponse handles the GetCertificatePolicy response.
func (client *Client) getCertificatePolicyHandleResponse(resp *http.Response) (ClientGetCertificatePolicyResponse, error) {
	result := ClientGetCertificatePolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificatePolicy); err != nil {
		return ClientGetCertificatePolicyResponse{}, err
	}
	return result, nil
}

// NewGetCertificateVersionsPager - The GetCertificateVersions operation returns the versions of a certificate in the specified
// key vault. This operation requires the certificates/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// options - ClientGetCertificateVersionsOptions contains the optional parameters for the Client.GetCertificateVersions method.
func (client *Client) NewGetCertificateVersionsPager(vaultBaseURL string, certificateName string, options *ClientGetCertificateVersionsOptions) *runtime.Pager[ClientGetCertificateVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetCertificateVersionsResponse]{
		More: func(page ClientGetCertificateVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetCertificateVersionsResponse) (ClientGetCertificateVersionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getCertificateVersionsCreateRequest(ctx, vaultBaseURL, certificateName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetCertificateVersionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetCertificateVersionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetCertificateVersionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getCertificateVersionsHandleResponse(resp)
		},
	})
}

// getCertificateVersionsCreateRequest creates the GetCertificateVersions request.
func (client *Client) getCertificateVersionsCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificateVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/versions"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateVersionsHandleResponse handles the GetCertificateVersions response.
func (client *Client) getCertificateVersionsHandleResponse(resp *http.Response) (ClientGetCertificateVersionsResponse, error) {
	result := ClientGetCertificateVersionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateListResult); err != nil {
		return ClientGetCertificateVersionsResponse{}, err
	}
	return result, nil
}

// NewGetCertificatesPager - The GetCertificates operation returns the set of certificates resources in the specified key
// vault. This operation requires the certificates/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetCertificatesOptions contains the optional parameters for the Client.GetCertificates method.
func (client *Client) NewGetCertificatesPager(vaultBaseURL string, options *ClientGetCertificatesOptions) *runtime.Pager[ClientGetCertificatesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetCertificatesResponse]{
		More: func(page ClientGetCertificatesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetCertificatesResponse) (ClientGetCertificatesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getCertificatesCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetCertificatesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetCertificatesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetCertificatesResponse{}, runtime.NewResponseError(resp)
			}
			return client.getCertificatesHandleResponse(resp)
		},
	})
}

// getCertificatesCreateRequest creates the GetCertificates request.
func (client *Client) getCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetCertificatesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificatesHandleResponse handles the GetCertificates response.
func (client *Client) getCertificatesHandleResponse(resp *http.Response) (ClientGetCertificatesResponse, error) {
	result := ClientGetCertificatesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateListResult); err != nil {
		return ClientGetCertificatesResponse{}, err
	}
	return result, nil
}

// GetDeletedCertificate - The GetDeletedCertificate operation retrieves the deleted certificate information plus its attributes,
// such as retention interval, scheduled permanent deletion and the current deletion recovery level.
// This operation requires the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate
// options - ClientGetDeletedCertificateOptions contains the optional parameters for the Client.GetDeletedCertificate method.
func (client *Client) GetDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetDeletedCertificateOptions) (ClientGetDeletedCertificateResponse, error) {
	req, err := client.getDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientGetDeletedCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeletedCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetDeletedCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeletedCertificateHandleResponse(resp)
}

// getDeletedCertificateCreateRequest creates the GetDeletedCertificate request.
func (client *Client) getDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedCertificateHandleResponse handles the GetDeletedCertificate response.
func (client *Client) getDeletedCertificateHandleResponse(resp *http.Response) (ClientGetDeletedCertificateResponse, error) {
	result := ClientGetDeletedCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateBundle); err != nil {
		return ClientGetDeletedCertificateResponse{}, err
	}
	return result, nil
}

// NewGetDeletedCertificatesPager - The GetDeletedCertificates operation retrieves the certificates in the current vault which
// are in a deleted state and ready for recovery or purging. This operation includes deletion-specific
// information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete
// enabled vaults.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetDeletedCertificatesOptions contains the optional parameters for the Client.GetDeletedCertificates method.
func (client *Client) NewGetDeletedCertificatesPager(vaultBaseURL string, options *ClientGetDeletedCertificatesOptions) *runtime.Pager[ClientGetDeletedCertificatesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedCertificatesResponse]{
		More: func(page ClientGetDeletedCertificatesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedCertificatesResponse) (ClientGetDeletedCertificatesResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getDeletedCertificatesCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetDeletedCertificatesResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetDeletedCertificatesResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetDeletedCertificatesResponse{}, runtime.NewResponseError(resp)
			}
			return client.getDeletedCertificatesHandleResponse(resp)
		},
	})
}

// getDeletedCertificatesCreateRequest creates the GetDeletedCertificates request.
func (client *Client) getDeletedCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedCertificatesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedCertificatesHandleResponse handles the GetDeletedCertificates response.
func (client *Client) getDeletedCertificatesHandleResponse(resp *http.Response) (ClientGetDeletedCertificatesResponse, error) {
	result := ClientGetDeletedCertificatesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateListResult); err != nil {
		return ClientGetDeletedCertificatesResponse{}, err
	}
	return result, nil
}

// GetDeletedKey - The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be
// invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This
// operation requires the keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// options - ClientGetDeletedKeyOptions contains the optional parameters for the Client.GetDeletedKey method.
func (client *Client) GetDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientGetDeletedKeyOptions) (ClientGetDeletedKeyResponse, error) {
	req, err := client.getDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return ClientGetDeletedKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeletedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetDeletedKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeletedKeyHandleResponse(resp)
}

// getDeletedKeyCreateRequest creates the GetDeletedKey request.
func (client *Client) getDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientGetDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedKeyHandleResponse handles the GetDeletedKey response.
func (client *Client) getDeletedKeyHandleResponse(resp *http.Response) (ClientGetDeletedKeyResponse, error) {
	result := ClientGetDeletedKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedKeyBundle); err != nil {
		return ClientGetDeletedKeyResponse{}, err
	}
	return result, nil
}

// NewGetDeletedKeysPager - Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public
// part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys
// operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on any vault, it will return
// an error if invoked on a non soft-delete enabled vault. This operation
// requires the keys/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetDeletedKeysOptions contains the optional parameters for the Client.GetDeletedKeys method.
func (client *Client) NewGetDeletedKeysPager(vaultBaseURL string, options *ClientGetDeletedKeysOptions) *runtime.Pager[ClientGetDeletedKeysResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedKeysResponse]{
		More: func(page ClientGetDeletedKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedKeysResponse) (ClientGetDeletedKeysResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getDeletedKeysCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetDeletedKeysResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetDeletedKeysResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetDeletedKeysResponse{}, runtime.NewResponseError(resp)
			}
			return client.getDeletedKeysHandleResponse(resp)
		},
	})
}

// getDeletedKeysCreateRequest creates the GetDeletedKeys request.
func (client *Client) getDeletedKeysCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedKeysOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedKeysHandleResponse handles the GetDeletedKeys response.
func (client *Client) getDeletedKeysHandleResponse(resp *http.Response) (ClientGetDeletedKeysResponse, error) {
	result := ClientGetDeletedKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedKeyListResult); err != nil {
		return ClientGetDeletedKeysResponse{}, err
	}
	return result, nil
}

// GetDeletedSasDefinition - The Get Deleted SAS Definition operation returns the specified deleted SAS definition along with
// its attributes. This operation requires the storage/getsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// sasDefinitionName - The name of the SAS definition.
// options - ClientGetDeletedSasDefinitionOptions contains the optional parameters for the Client.GetDeletedSasDefinition
// method.
func (client *Client) GetDeletedSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetDeletedSasDefinitionOptions) (ClientGetDeletedSasDefinitionResponse, error) {
	req, err := client.getDeletedSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return ClientGetDeletedSasDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeletedSasDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetDeletedSasDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeletedSasDefinitionHandleResponse(resp)
}

// getDeletedSasDefinitionCreateRequest creates the GetDeletedSasDefinition request.
func (client *Client) getDeletedSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetDeletedSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSasDefinitionHandleResponse handles the GetDeletedSasDefinition response.
func (client *Client) getDeletedSasDefinitionHandleResponse(resp *http.Response) (ClientGetDeletedSasDefinitionResponse, error) {
	result := ClientGetDeletedSasDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSasDefinitionBundle); err != nil {
		return ClientGetDeletedSasDefinitionResponse{}, err
	}
	return result, nil
}

// NewGetDeletedSasDefinitionsPager - The Get Deleted Sas Definitions operation returns the SAS definitions that have been
// deleted for a vault enabled for soft-delete. This operation requires the storage/listsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientGetDeletedSasDefinitionsOptions contains the optional parameters for the Client.GetDeletedSasDefinitions
// method.
func (client *Client) NewGetDeletedSasDefinitionsPager(vaultBaseURL string, storageAccountName string, options *ClientGetDeletedSasDefinitionsOptions) *runtime.Pager[ClientGetDeletedSasDefinitionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedSasDefinitionsResponse]{
		More: func(page ClientGetDeletedSasDefinitionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedSasDefinitionsResponse) (ClientGetDeletedSasDefinitionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getDeletedSasDefinitionsCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetDeletedSasDefinitionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetDeletedSasDefinitionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetDeletedSasDefinitionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getDeletedSasDefinitionsHandleResponse(resp)
		},
	})
}

// getDeletedSasDefinitionsCreateRequest creates the GetDeletedSasDefinitions request.
func (client *Client) getDeletedSasDefinitionsCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetDeletedSasDefinitionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSasDefinitionsHandleResponse handles the GetDeletedSasDefinitions response.
func (client *Client) getDeletedSasDefinitionsHandleResponse(resp *http.Response) (ClientGetDeletedSasDefinitionsResponse, error) {
	result := ClientGetDeletedSasDefinitionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSasDefinitionListResult); err != nil {
		return ClientGetDeletedSasDefinitionsResponse{}, err
	}
	return result, nil
}

// GetDeletedSecret - The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This
// operation requires the secrets/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// options - ClientGetDeletedSecretOptions contains the optional parameters for the Client.GetDeletedSecret method.
func (client *Client) GetDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientGetDeletedSecretOptions) (ClientGetDeletedSecretResponse, error) {
	req, err := client.getDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return ClientGetDeletedSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeletedSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetDeletedSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeletedSecretHandleResponse(resp)
}

// getDeletedSecretCreateRequest creates the GetDeletedSecret request.
func (client *Client) getDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientGetDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSecretHandleResponse handles the GetDeletedSecret response.
func (client *Client) getDeletedSecretHandleResponse(resp *http.Response) (ClientGetDeletedSecretResponse, error) {
	result := ClientGetDeletedSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSecretBundle); err != nil {
		return ClientGetDeletedSecretResponse{}, err
	}
	return result, nil
}

// NewGetDeletedSecretsPager - The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled
// for soft-delete. This operation requires the secrets/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetDeletedSecretsOptions contains the optional parameters for the Client.GetDeletedSecrets method.
func (client *Client) NewGetDeletedSecretsPager(vaultBaseURL string, options *ClientGetDeletedSecretsOptions) *runtime.Pager[ClientGetDeletedSecretsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedSecretsResponse]{
		More: func(page ClientGetDeletedSecretsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedSecretsResponse) (ClientGetDeletedSecretsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getDeletedSecretsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetDeletedSecretsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetDeletedSecretsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetDeletedSecretsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getDeletedSecretsHandleResponse(resp)
		},
	})
}

// getDeletedSecretsCreateRequest creates the GetDeletedSecrets request.
func (client *Client) getDeletedSecretsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedSecretsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSecretsHandleResponse handles the GetDeletedSecrets response.
func (client *Client) getDeletedSecretsHandleResponse(resp *http.Response) (ClientGetDeletedSecretsResponse, error) {
	result := ClientGetDeletedSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedSecretListResult); err != nil {
		return ClientGetDeletedSecretsResponse{}, err
	}
	return result, nil
}

// GetDeletedStorageAccount - The Get Deleted Storage Account operation returns the specified deleted storage account along
// with its attributes. This operation requires the storage/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientGetDeletedStorageAccountOptions contains the optional parameters for the Client.GetDeletedStorageAccount
// method.
func (client *Client) GetDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetDeletedStorageAccountOptions) (ClientGetDeletedStorageAccountResponse, error) {
	req, err := client.getDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return ClientGetDeletedStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeletedStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetDeletedStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeletedStorageAccountHandleResponse(resp)
}

// getDeletedStorageAccountCreateRequest creates the GetDeletedStorageAccount request.
func (client *Client) getDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetDeletedStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedStorageAccountHandleResponse handles the GetDeletedStorageAccount response.
func (client *Client) getDeletedStorageAccountHandleResponse(resp *http.Response) (ClientGetDeletedStorageAccountResponse, error) {
	result := ClientGetDeletedStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedStorageBundle); err != nil {
		return ClientGetDeletedStorageAccountResponse{}, err
	}
	return result, nil
}

// NewGetDeletedStorageAccountsPager - The Get Deleted Storage Accounts operation returns the storage accounts that have been
// deleted for a vault enabled for soft-delete. This operation requires the storage/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetDeletedStorageAccountsOptions contains the optional parameters for the Client.GetDeletedStorageAccounts
// method.
func (client *Client) NewGetDeletedStorageAccountsPager(vaultBaseURL string, options *ClientGetDeletedStorageAccountsOptions) *runtime.Pager[ClientGetDeletedStorageAccountsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedStorageAccountsResponse]{
		More: func(page ClientGetDeletedStorageAccountsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedStorageAccountsResponse) (ClientGetDeletedStorageAccountsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getDeletedStorageAccountsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetDeletedStorageAccountsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetDeletedStorageAccountsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetDeletedStorageAccountsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getDeletedStorageAccountsHandleResponse(resp)
		},
	})
}

// getDeletedStorageAccountsCreateRequest creates the GetDeletedStorageAccounts request.
func (client *Client) getDeletedStorageAccountsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedStorageAccountsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedStorageAccountsHandleResponse handles the GetDeletedStorageAccounts response.
func (client *Client) getDeletedStorageAccountsHandleResponse(resp *http.Response) (ClientGetDeletedStorageAccountsResponse, error) {
	result := ClientGetDeletedStorageAccountsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeletedStorageListResult); err != nil {
		return ClientGetDeletedStorageAccountsResponse{}, err
	}
	return result, nil
}

// GetKey - The get key operation is applicable to all key types. If the requested key is symmetric, then no key material
// is released in the response. This operation requires the keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key to get.
// keyVersion - Adding the version parameter retrieves a specific version of a key. This URI fragment is optional. If not
// specified, the latest version of the key is returned.
// options - ClientGetKeyOptions contains the optional parameters for the Client.GetKey method.
func (client *Client) GetKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, options *ClientGetKeyOptions) (ClientGetKeyResponse, error) {
	req, err := client.getKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, options)
	if err != nil {
		return ClientGetKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getKeyHandleResponse(resp)
}

// getKeyCreateRequest creates the GetKey request.
func (client *Client) getKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, options *ClientGetKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyHandleResponse handles the GetKey response.
func (client *Client) getKeyHandleResponse(resp *http.Response) (ClientGetKeyResponse, error) {
	result := ClientGetKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return ClientGetKeyResponse{}, err
	}
	return result, nil
}

// NewGetKeyVersionsPager - The full key identifier, attributes, and tags are provided in the response. This operation requires
// the keys/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// options - ClientGetKeyVersionsOptions contains the optional parameters for the Client.GetKeyVersions method.
func (client *Client) NewGetKeyVersionsPager(vaultBaseURL string, keyName string, options *ClientGetKeyVersionsOptions) *runtime.Pager[ClientGetKeyVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetKeyVersionsResponse]{
		More: func(page ClientGetKeyVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetKeyVersionsResponse) (ClientGetKeyVersionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getKeyVersionsCreateRequest(ctx, vaultBaseURL, keyName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetKeyVersionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetKeyVersionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetKeyVersionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getKeyVersionsHandleResponse(resp)
		},
	})
}

// getKeyVersionsCreateRequest creates the GetKeyVersions request.
func (client *Client) getKeyVersionsCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientGetKeyVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/versions"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyVersionsHandleResponse handles the GetKeyVersions response.
func (client *Client) getKeyVersionsHandleResponse(resp *http.Response) (ClientGetKeyVersionsResponse, error) {
	result := ClientGetKeyVersionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		return ClientGetKeyVersionsResponse{}, err
	}
	return result, nil
}

// NewGetKeysPager - Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part
// of a stored key. The LIST operation is applicable to all key types, however only the base key
// identifier, attributes, and tags are provided in the response. Individual versions of a key are not listed in the response.
// This operation requires the keys/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetKeysOptions contains the optional parameters for the Client.GetKeys method.
func (client *Client) NewGetKeysPager(vaultBaseURL string, options *ClientGetKeysOptions) *runtime.Pager[ClientGetKeysResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetKeysResponse]{
		More: func(page ClientGetKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetKeysResponse) (ClientGetKeysResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getKeysCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetKeysResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetKeysResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetKeysResponse{}, runtime.NewResponseError(resp)
			}
			return client.getKeysHandleResponse(resp)
		},
	})
}

// getKeysCreateRequest creates the GetKeys request.
func (client *Client) getKeysCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetKeysOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeysHandleResponse handles the GetKeys response.
func (client *Client) getKeysHandleResponse(resp *http.Response) (ClientGetKeysResponse, error) {
	result := ClientGetKeysResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		return ClientGetKeysResponse{}, err
	}
	return result, nil
}

// GetSasDefinition - Gets information about a SAS definition for the specified storage account. This operation requires the
// storage/getsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// sasDefinitionName - The name of the SAS definition.
// options - ClientGetSasDefinitionOptions contains the optional parameters for the Client.GetSasDefinition method.
func (client *Client) GetSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetSasDefinitionOptions) (ClientGetSasDefinitionResponse, error) {
	req, err := client.getSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return ClientGetSasDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetSasDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetSasDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSasDefinitionHandleResponse(resp)
}

// getSasDefinitionCreateRequest creates the GetSasDefinition request.
func (client *Client) getSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSasDefinitionHandleResponse handles the GetSasDefinition response.
func (client *Client) getSasDefinitionHandleResponse(resp *http.Response) (ClientGetSasDefinitionResponse, error) {
	result := ClientGetSasDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		return ClientGetSasDefinitionResponse{}, err
	}
	return result, nil
}

// NewGetSasDefinitionsPager - List storage SAS definitions for the given storage account. This operation requires the storage/listsas
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientGetSasDefinitionsOptions contains the optional parameters for the Client.GetSasDefinitions method.
func (client *Client) NewGetSasDefinitionsPager(vaultBaseURL string, storageAccountName string, options *ClientGetSasDefinitionsOptions) *runtime.Pager[ClientGetSasDefinitionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetSasDefinitionsResponse]{
		More: func(page ClientGetSasDefinitionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetSasDefinitionsResponse) (ClientGetSasDefinitionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getSasDefinitionsCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetSasDefinitionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetSasDefinitionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetSasDefinitionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getSasDefinitionsHandleResponse(resp)
		},
	})
}

// getSasDefinitionsCreateRequest creates the GetSasDefinitions request.
func (client *Client) getSasDefinitionsCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetSasDefinitionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSasDefinitionsHandleResponse handles the GetSasDefinitions response.
func (client *Client) getSasDefinitionsHandleResponse(resp *http.Response) (ClientGetSasDefinitionsResponse, error) {
	result := ClientGetSasDefinitionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SasDefinitionListResult); err != nil {
		return ClientGetSasDefinitionsResponse{}, err
	}
	return result, nil
}

// GetSecret - The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// secretVersion - The version of the secret. This URI fragment is optional. If not specified, the latest version of the secret
// is returned.
// options - ClientGetSecretOptions contains the optional parameters for the Client.GetSecret method.
func (client *Client) GetSecret(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, options *ClientGetSecretOptions) (ClientGetSecretResponse, error) {
	req, err := client.getSecretCreateRequest(ctx, vaultBaseURL, secretName, secretVersion, options)
	if err != nil {
		return ClientGetSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSecretHandleResponse(resp)
}

// getSecretCreateRequest creates the GetSecret request.
func (client *Client) getSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, options *ClientGetSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/{secret-version}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-version}", url.PathEscape(secretVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretHandleResponse handles the GetSecret response.
func (client *Client) getSecretHandleResponse(resp *http.Response) (ClientGetSecretResponse, error) {
	result := ClientGetSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return ClientGetSecretResponse{}, err
	}
	return result, nil
}

// NewGetSecretVersionsPager - The full secret identifier and attributes are provided in the response. No values are returned
// for the secrets. This operations requires the secrets/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// options - ClientGetSecretVersionsOptions contains the optional parameters for the Client.GetSecretVersions method.
func (client *Client) NewGetSecretVersionsPager(vaultBaseURL string, secretName string, options *ClientGetSecretVersionsOptions) *runtime.Pager[ClientGetSecretVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetSecretVersionsResponse]{
		More: func(page ClientGetSecretVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetSecretVersionsResponse) (ClientGetSecretVersionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getSecretVersionsCreateRequest(ctx, vaultBaseURL, secretName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetSecretVersionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetSecretVersionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetSecretVersionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getSecretVersionsHandleResponse(resp)
		},
	})
}

// getSecretVersionsCreateRequest creates the GetSecretVersions request.
func (client *Client) getSecretVersionsCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientGetSecretVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/versions"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretVersionsHandleResponse handles the GetSecretVersions response.
func (client *Client) getSecretVersionsHandleResponse(resp *http.Response) (ClientGetSecretVersionsResponse, error) {
	result := ClientGetSecretVersionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretListResult); err != nil {
		return ClientGetSecretVersionsResponse{}, err
	}
	return result, nil
}

// NewGetSecretsPager - The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier
// and its attributes are provided in the response. Individual secret versions are not listed in the
// response. This operation requires the secrets/list permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetSecretsOptions contains the optional parameters for the Client.GetSecrets method.
func (client *Client) NewGetSecretsPager(vaultBaseURL string, options *ClientGetSecretsOptions) *runtime.Pager[ClientGetSecretsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetSecretsResponse]{
		More: func(page ClientGetSecretsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetSecretsResponse) (ClientGetSecretsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getSecretsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetSecretsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetSecretsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetSecretsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getSecretsHandleResponse(resp)
		},
	})
}

// getSecretsCreateRequest creates the GetSecrets request.
func (client *Client) getSecretsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetSecretsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretsHandleResponse handles the GetSecrets response.
func (client *Client) getSecretsHandleResponse(resp *http.Response) (ClientGetSecretsResponse, error) {
	result := ClientGetSecretsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretListResult); err != nil {
		return ClientGetSecretsResponse{}, err
	}
	return result, nil
}

// GetStorageAccount - Gets information about a specified storage account. This operation requires the storage/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientGetStorageAccountOptions contains the optional parameters for the Client.GetStorageAccount method.
func (client *Client) GetStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetStorageAccountOptions) (ClientGetStorageAccountResponse, error) {
	req, err := client.getStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return ClientGetStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.getStorageAccountHandleResponse(resp)
}

// getStorageAccountCreateRequest creates the GetStorageAccount request.
func (client *Client) getStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStorageAccountHandleResponse handles the GetStorageAccount response.
func (client *Client) getStorageAccountHandleResponse(resp *http.Response) (ClientGetStorageAccountResponse, error) {
	result := ClientGetStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		return ClientGetStorageAccountResponse{}, err
	}
	return result, nil
}

// NewGetStorageAccountsPager - List storage accounts managed by the specified key vault. This operation requires the storage/list
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// options - ClientGetStorageAccountsOptions contains the optional parameters for the Client.GetStorageAccounts method.
func (client *Client) NewGetStorageAccountsPager(vaultBaseURL string, options *ClientGetStorageAccountsOptions) *runtime.Pager[ClientGetStorageAccountsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetStorageAccountsResponse]{
		More: func(page ClientGetStorageAccountsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetStorageAccountsResponse) (ClientGetStorageAccountsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.getStorageAccountsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientGetStorageAccountsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientGetStorageAccountsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientGetStorageAccountsResponse{}, runtime.NewResponseError(resp)
			}
			return client.getStorageAccountsHandleResponse(resp)
		},
	})
}

// getStorageAccountsCreateRequest creates the GetStorageAccounts request.
func (client *Client) getStorageAccountsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetStorageAccountsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStorageAccountsHandleResponse handles the GetStorageAccounts response.
func (client *Client) getStorageAccountsHandleResponse(resp *http.Response) (ClientGetStorageAccountsResponse, error) {
	result := ClientGetStorageAccountsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageListResult); err != nil {
		return ClientGetStorageAccountsResponse{}, err
	}
	return result, nil
}

// ImportCertificate - Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate
// to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM
// file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// parameters - The parameters to import the certificate.
// options - ClientImportCertificateOptions contains the optional parameters for the Client.ImportCertificate method.
func (client *Client) ImportCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *ClientImportCertificateOptions) (ClientImportCertificateResponse, error) {
	req, err := client.importCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return ClientImportCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientImportCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientImportCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.importCertificateHandleResponse(resp)
}

// importCertificateCreateRequest creates the ImportCertificate request.
func (client *Client) importCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *ClientImportCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/import"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// importCertificateHandleResponse handles the ImportCertificate response.
func (client *Client) importCertificateHandleResponse(resp *http.Response) (ClientImportCertificateResponse, error) {
	result := ClientImportCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return ClientImportCertificateResponse{}, err
	}
	return result, nil
}

// ImportKey - The import key operation may be used to import any key type into an Azure Key Vault. If the named key already
// exists, Azure Key Vault creates a new version of the key. This operation requires the
// keys/import permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - Name for the imported key.
// parameters - The parameters to import a key.
// options - ClientImportKeyOptions contains the optional parameters for the Client.ImportKey method.
func (client *Client) ImportKey(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyImportParameters, options *ClientImportKeyOptions) (ClientImportKeyResponse, error) {
	req, err := client.importKeyCreateRequest(ctx, vaultBaseURL, keyName, parameters, options)
	if err != nil {
		return ClientImportKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientImportKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientImportKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.importKeyHandleResponse(resp)
}

// importKeyCreateRequest creates the ImportKey request.
func (client *Client) importKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyImportParameters, options *ClientImportKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// importKeyHandleResponse handles the ImportKey response.
func (client *Client) importKeyHandleResponse(resp *http.Response) (ClientImportKeyResponse, error) {
	result := ClientImportKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return ClientImportKeyResponse{}, err
	}
	return result, nil
}

// MergeCertificate - The MergeCertificate operation performs the merging of a certificate or certificate chain with a key
// pair currently available in the service. This operation requires the certificates/create
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// parameters - The parameters to merge certificate.
// options - ClientMergeCertificateOptions contains the optional parameters for the Client.MergeCertificate method.
func (client *Client) MergeCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *ClientMergeCertificateOptions) (ClientMergeCertificateResponse, error) {
	req, err := client.mergeCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return ClientMergeCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientMergeCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ClientMergeCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.mergeCertificateHandleResponse(resp)
}

// mergeCertificateCreateRequest creates the MergeCertificate request.
func (client *Client) mergeCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *ClientMergeCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending/merge"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// mergeCertificateHandleResponse handles the MergeCertificate response.
func (client *Client) mergeCertificateHandleResponse(resp *http.Response) (ClientMergeCertificateResponse, error) {
	result := ClientMergeCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return ClientMergeCertificateResponse{}, err
	}
	return result, nil
}

// PurgeDeletedCertificate - The PurgeDeletedCertificate operation performs an irreversible deletion of the specified certificate,
// without possibility for recovery. The operation is not available if the recovery level does not
// specify 'Purgeable'. This operation requires the certificate/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate
// options - ClientPurgeDeletedCertificateOptions contains the optional parameters for the Client.PurgeDeletedCertificate
// method.
func (client *Client) PurgeDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientPurgeDeletedCertificateOptions) (ClientPurgeDeletedCertificateResponse, error) {
	req, err := client.purgeDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientPurgeDeletedCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientPurgeDeletedCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return ClientPurgeDeletedCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return ClientPurgeDeletedCertificateResponse{}, nil
}

// purgeDeletedCertificateCreateRequest creates the PurgeDeletedCertificate request.
func (client *Client) purgeDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientPurgeDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PurgeDeletedKey - The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can
// be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault.
// This operation requires the keys/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key
// options - ClientPurgeDeletedKeyOptions contains the optional parameters for the Client.PurgeDeletedKey method.
func (client *Client) PurgeDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientPurgeDeletedKeyOptions) (ClientPurgeDeletedKeyResponse, error) {
	req, err := client.purgeDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return ClientPurgeDeletedKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientPurgeDeletedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return ClientPurgeDeletedKeyResponse{}, runtime.NewResponseError(resp)
	}
	return ClientPurgeDeletedKeyResponse{}, nil
}

// purgeDeletedKeyCreateRequest creates the PurgeDeletedKey request.
func (client *Client) purgeDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientPurgeDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PurgeDeletedSecret - The purge deleted secret operation removes the secret permanently, without the possibility of recovery.
// This operation can only be enabled on a soft-delete enabled vault. This operation requires the
// secrets/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// options - ClientPurgeDeletedSecretOptions contains the optional parameters for the Client.PurgeDeletedSecret method.
func (client *Client) PurgeDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientPurgeDeletedSecretOptions) (ClientPurgeDeletedSecretResponse, error) {
	req, err := client.purgeDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return ClientPurgeDeletedSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientPurgeDeletedSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return ClientPurgeDeletedSecretResponse{}, runtime.NewResponseError(resp)
	}
	return ClientPurgeDeletedSecretResponse{}, nil
}

// purgeDeletedSecretCreateRequest creates the PurgeDeletedSecret request.
func (client *Client) purgeDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientPurgeDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PurgeDeletedStorageAccount - The purge deleted storage account operation removes the secret permanently, without the possibility
// of recovery. This operation can only be performed on a soft-delete enabled vault. This operation
// requires the storage/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientPurgeDeletedStorageAccountOptions contains the optional parameters for the Client.PurgeDeletedStorageAccount
// method.
func (client *Client) PurgeDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientPurgeDeletedStorageAccountOptions) (ClientPurgeDeletedStorageAccountResponse, error) {
	req, err := client.purgeDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return ClientPurgeDeletedStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientPurgeDeletedStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return ClientPurgeDeletedStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return ClientPurgeDeletedStorageAccountResponse{}, nil
}

// purgeDeletedStorageAccountCreateRequest creates the PurgeDeletedStorageAccount request.
func (client *Client) purgeDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientPurgeDeletedStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RecoverDeletedCertificate - The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The
// operation is applicable in vaults enabled for soft-delete, and must be issued during the retention interval
// (available in the deleted certificate's attributes). This operation requires the certificates/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the deleted certificate
// options - ClientRecoverDeletedCertificateOptions contains the optional parameters for the Client.RecoverDeletedCertificate
// method.
func (client *Client) RecoverDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientRecoverDeletedCertificateOptions) (ClientRecoverDeletedCertificateResponse, error) {
	req, err := client.recoverDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return ClientRecoverDeletedCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRecoverDeletedCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRecoverDeletedCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.recoverDeletedCertificateHandleResponse(resp)
}

// recoverDeletedCertificateCreateRequest creates the RecoverDeletedCertificate request.
func (client *Client) recoverDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientRecoverDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}/recover"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedCertificateHandleResponse handles the RecoverDeletedCertificate response.
func (client *Client) recoverDeletedCertificateHandleResponse(resp *http.Response) (ClientRecoverDeletedCertificateResponse, error) {
	result := ClientRecoverDeletedCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return ClientRecoverDeletedCertificateResponse{}, err
	}
	return result, nil
}

// RecoverDeletedKey - The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It
// recovers the deleted key back to its latest version under /keys. An attempt to recover an non-deleted
// key will return an error. Consider this the inverse of the delete operation on soft-delete enabled vaults. This operation
// requires the keys/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the deleted key.
// options - ClientRecoverDeletedKeyOptions contains the optional parameters for the Client.RecoverDeletedKey method.
func (client *Client) RecoverDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientRecoverDeletedKeyOptions) (ClientRecoverDeletedKeyResponse, error) {
	req, err := client.recoverDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return ClientRecoverDeletedKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRecoverDeletedKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRecoverDeletedKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.recoverDeletedKeyHandleResponse(resp)
}

// recoverDeletedKeyCreateRequest creates the RecoverDeletedKey request.
func (client *Client) recoverDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientRecoverDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}/recover"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedKeyHandleResponse handles the RecoverDeletedKey response.
func (client *Client) recoverDeletedKeyHandleResponse(resp *http.Response) (ClientRecoverDeletedKeyResponse, error) {
	result := ClientRecoverDeletedKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return ClientRecoverDeletedKeyResponse{}, err
	}
	return result, nil
}

// RecoverDeletedSasDefinition - Recovers the deleted SAS definition for the specified storage account. This operation can
// only be performed on a soft-delete enabled vault. This operation requires the storage/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// sasDefinitionName - The name of the SAS definition.
// options - ClientRecoverDeletedSasDefinitionOptions contains the optional parameters for the Client.RecoverDeletedSasDefinition
// method.
func (client *Client) RecoverDeletedSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientRecoverDeletedSasDefinitionOptions) (ClientRecoverDeletedSasDefinitionResponse, error) {
	req, err := client.recoverDeletedSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return ClientRecoverDeletedSasDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRecoverDeletedSasDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRecoverDeletedSasDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.recoverDeletedSasDefinitionHandleResponse(resp)
}

// recoverDeletedSasDefinitionCreateRequest creates the RecoverDeletedSasDefinition request.
func (client *Client) recoverDeletedSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientRecoverDeletedSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedSasDefinitionHandleResponse handles the RecoverDeletedSasDefinition response.
func (client *Client) recoverDeletedSasDefinitionHandleResponse(resp *http.Response) (ClientRecoverDeletedSasDefinitionResponse, error) {
	result := ClientRecoverDeletedSasDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		return ClientRecoverDeletedSasDefinitionResponse{}, err
	}
	return result, nil
}

// RecoverDeletedSecret - Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete
// enabled vault. This operation requires the secrets/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the deleted secret.
// options - ClientRecoverDeletedSecretOptions contains the optional parameters for the Client.RecoverDeletedSecret method.
func (client *Client) RecoverDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientRecoverDeletedSecretOptions) (ClientRecoverDeletedSecretResponse, error) {
	req, err := client.recoverDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return ClientRecoverDeletedSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRecoverDeletedSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRecoverDeletedSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.recoverDeletedSecretHandleResponse(resp)
}

// recoverDeletedSecretCreateRequest creates the RecoverDeletedSecret request.
func (client *Client) recoverDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientRecoverDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}/recover"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedSecretHandleResponse handles the RecoverDeletedSecret response.
func (client *Client) recoverDeletedSecretHandleResponse(resp *http.Response) (ClientRecoverDeletedSecretResponse, error) {
	result := ClientRecoverDeletedSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return ClientRecoverDeletedSecretResponse{}, err
	}
	return result, nil
}

// RecoverDeletedStorageAccount - Recovers the deleted storage account in the specified vault. This operation can only be
// performed on a soft-delete enabled vault. This operation requires the storage/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// options - ClientRecoverDeletedStorageAccountOptions contains the optional parameters for the Client.RecoverDeletedStorageAccount
// method.
func (client *Client) RecoverDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientRecoverDeletedStorageAccountOptions) (ClientRecoverDeletedStorageAccountResponse, error) {
	req, err := client.recoverDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return ClientRecoverDeletedStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRecoverDeletedStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRecoverDeletedStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.recoverDeletedStorageAccountHandleResponse(resp)
}

// recoverDeletedStorageAccountCreateRequest creates the RecoverDeletedStorageAccount request.
func (client *Client) recoverDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientRecoverDeletedStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/recover"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedStorageAccountHandleResponse handles the RecoverDeletedStorageAccount response.
func (client *Client) recoverDeletedStorageAccountHandleResponse(resp *http.Response) (ClientRecoverDeletedStorageAccountResponse, error) {
	result := ClientRecoverDeletedStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		return ClientRecoverDeletedStorageAccountResponse{}, err
	}
	return result, nil
}

// RegenerateStorageAccountKey - Regenerates the specified key value for the given storage account. This operation requires
// the storage/regeneratekey permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// parameters - The parameters to regenerate storage account key.
// options - ClientRegenerateStorageAccountKeyOptions contains the optional parameters for the Client.RegenerateStorageAccountKey
// method.
func (client *Client) RegenerateStorageAccountKey(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountRegenerteKeyParameters, options *ClientRegenerateStorageAccountKeyOptions) (ClientRegenerateStorageAccountKeyResponse, error) {
	req, err := client.regenerateStorageAccountKeyCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return ClientRegenerateStorageAccountKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRegenerateStorageAccountKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRegenerateStorageAccountKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.regenerateStorageAccountKeyHandleResponse(resp)
}

// regenerateStorageAccountKeyCreateRequest creates the RegenerateStorageAccountKey request.
func (client *Client) regenerateStorageAccountKeyCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountRegenerteKeyParameters, options *ClientRegenerateStorageAccountKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/regeneratekey"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// regenerateStorageAccountKeyHandleResponse handles the RegenerateStorageAccountKey response.
func (client *Client) regenerateStorageAccountKeyHandleResponse(resp *http.Response) (ClientRegenerateStorageAccountKeyResponse, error) {
	result := ClientRegenerateStorageAccountKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		return ClientRegenerateStorageAccountKeyResponse{}, err
	}
	return result, nil
}

// RestoreCertificate - Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// parameters - The parameters to restore the certificate.
// options - ClientRestoreCertificateOptions contains the optional parameters for the Client.RestoreCertificate method.
func (client *Client) RestoreCertificate(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *ClientRestoreCertificateOptions) (ClientRestoreCertificateResponse, error) {
	req, err := client.restoreCertificateCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return ClientRestoreCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRestoreCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRestoreCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.restoreCertificateHandleResponse(resp)
}

// restoreCertificateCreateRequest creates the RestoreCertificate request.
func (client *Client) restoreCertificateCreateRequest(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *ClientRestoreCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreCertificateHandleResponse handles the RestoreCertificate response.
func (client *Client) restoreCertificateHandleResponse(resp *http.Response) (ClientRestoreCertificateResponse, error) {
	result := ClientRestoreCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return ClientRestoreCertificateResponse{}, err
	}
	return result, nil
}

// RestoreKey - Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes
// and access control policies. The RESTORE operation may be used to import a previously backed
// up key. Individual versions of a key cannot be restored. The key is restored in its entirety with the same key name as
// it had when it was backed up. If the key name is not available in the target Key
// Vault, the RESTORE operation will be rejected. While the key name is retained during restore, the final key identifier
// will change if the key is restored to a different vault. Restore will restore all
// versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key Vault
// must be owned by the same Microsoft Azure Subscription as the source Key Vault
// The user must have RESTORE permission in the target Key Vault. This operation requires the keys/restore permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// parameters - The parameters to restore the key.
// options - ClientRestoreKeyOptions contains the optional parameters for the Client.RestoreKey method.
func (client *Client) RestoreKey(ctx context.Context, vaultBaseURL string, parameters KeyRestoreParameters, options *ClientRestoreKeyOptions) (ClientRestoreKeyResponse, error) {
	req, err := client.restoreKeyCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return ClientRestoreKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRestoreKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRestoreKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.restoreKeyHandleResponse(resp)
}

// restoreKeyCreateRequest creates the RestoreKey request.
func (client *Client) restoreKeyCreateRequest(ctx context.Context, vaultBaseURL string, parameters KeyRestoreParameters, options *ClientRestoreKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreKeyHandleResponse handles the RestoreKey response.
func (client *Client) restoreKeyHandleResponse(resp *http.Response) (ClientRestoreKeyResponse, error) {
	result := ClientRestoreKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return ClientRestoreKeyResponse{}, err
	}
	return result, nil
}

// RestoreSecret - Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// parameters - The parameters to restore the secret.
// options - ClientRestoreSecretOptions contains the optional parameters for the Client.RestoreSecret method.
func (client *Client) RestoreSecret(ctx context.Context, vaultBaseURL string, parameters SecretRestoreParameters, options *ClientRestoreSecretOptions) (ClientRestoreSecretResponse, error) {
	req, err := client.restoreSecretCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return ClientRestoreSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRestoreSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRestoreSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.restoreSecretHandleResponse(resp)
}

// restoreSecretCreateRequest creates the RestoreSecret request.
func (client *Client) restoreSecretCreateRequest(ctx context.Context, vaultBaseURL string, parameters SecretRestoreParameters, options *ClientRestoreSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreSecretHandleResponse handles the RestoreSecret response.
func (client *Client) restoreSecretHandleResponse(resp *http.Response) (ClientRestoreSecretResponse, error) {
	result := ClientRestoreSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return ClientRestoreSecretResponse{}, err
	}
	return result, nil
}

// RestoreStatus - Returns the status of restore operation
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// jobID - The Job Id returned part of the restore operation
// options - ClientRestoreStatusOptions contains the optional parameters for the Client.RestoreStatus method.
func (client *Client) RestoreStatus(ctx context.Context, vaultBaseURL string, jobID string, options *ClientRestoreStatusOptions) (ClientRestoreStatusResponse, error) {
	req, err := client.restoreStatusCreateRequest(ctx, vaultBaseURL, jobID, options)
	if err != nil {
		return ClientRestoreStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRestoreStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRestoreStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.restoreStatusHandleResponse(resp)
}

// restoreStatusCreateRequest creates the RestoreStatus request.
func (client *Client) restoreStatusCreateRequest(ctx context.Context, vaultBaseURL string, jobID string, options *ClientRestoreStatusOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/restore/{jobId}/pending"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// restoreStatusHandleResponse handles the RestoreStatus response.
func (client *Client) restoreStatusHandleResponse(resp *http.Response) (ClientRestoreStatusResponse, error) {
	result := ClientRestoreStatusResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreOperation); err != nil {
		return ClientRestoreStatusResponse{}, err
	}
	return result, nil
}

// RestoreStorageAccount - Restores a backed up storage account to a vault. This operation requires the storage/restore permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// parameters - The parameters to restore the storage account.
// options - ClientRestoreStorageAccountOptions contains the optional parameters for the Client.RestoreStorageAccount method.
func (client *Client) RestoreStorageAccount(ctx context.Context, vaultBaseURL string, parameters StorageRestoreParameters, options *ClientRestoreStorageAccountOptions) (ClientRestoreStorageAccountResponse, error) {
	req, err := client.restoreStorageAccountCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return ClientRestoreStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRestoreStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientRestoreStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.restoreStorageAccountHandleResponse(resp)
}

// restoreStorageAccountCreateRequest creates the RestoreStorageAccount request.
func (client *Client) restoreStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, parameters StorageRestoreParameters, options *ClientRestoreStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreStorageAccountHandleResponse handles the RestoreStorageAccount response.
func (client *Client) restoreStorageAccountHandleResponse(resp *http.Response) (ClientRestoreStorageAccountResponse, error) {
	result := ClientRestoreStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		return ClientRestoreStorageAccountResponse{}, err
	}
	return result, nil
}

// BeginSelectiveKeyRestoreOperation - Restores all key versions of a given key using user supplied SAS token pointing to
// a previously stored Azure Blob storage backup folder
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key to be restored from the user supplied backup
// restoreBlobDetails - The Azure blob SAS token pointing to a folder where the previous successful full backup was stored
// options - ClientBeginSelectiveKeyRestoreOperationOptions contains the optional parameters for the Client.BeginSelectiveKeyRestoreOperation
// method.
func (client *Client) BeginSelectiveKeyRestoreOperation(ctx context.Context, vaultBaseURL string, keyName string, restoreBlobDetails SelectiveKeyRestoreOperationParameters, options *ClientBeginSelectiveKeyRestoreOperationOptions) (*runtime.Poller[ClientSelectiveKeyRestoreOperationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.selectiveKeyRestoreOperation(ctx, vaultBaseURL, keyName, restoreBlobDetails, options)
		if err != nil {
			return nil, err
		}
		return runtime.NewPoller(resp, client.pl, &runtime.NewPollerOptions[ClientSelectiveKeyRestoreOperationResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
		})
	} else {
		return runtime.NewPollerFromResumeToken[ClientSelectiveKeyRestoreOperationResponse](options.ResumeToken, client.pl, nil)
	}
}

// SelectiveKeyRestoreOperation - Restores all key versions of a given key using user supplied SAS token pointing to a previously
// stored Azure Blob storage backup folder
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
func (client *Client) selectiveKeyRestoreOperation(ctx context.Context, vaultBaseURL string, keyName string, restoreBlobDetails SelectiveKeyRestoreOperationParameters, options *ClientBeginSelectiveKeyRestoreOperationOptions) (*http.Response, error) {
	req, err := client.selectiveKeyRestoreOperationCreateRequest(ctx, vaultBaseURL, keyName, restoreBlobDetails, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// selectiveKeyRestoreOperationCreateRequest creates the SelectiveKeyRestoreOperation request.
func (client *Client) selectiveKeyRestoreOperationCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, restoreBlobDetails SelectiveKeyRestoreOperationParameters, options *ClientBeginSelectiveKeyRestoreOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{keyName}/restore"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, restoreBlobDetails)
}

// SetCertificateContacts - Sets the certificate contacts for the specified key vault. This operation requires the certificates/managecontacts
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// contacts - The contacts for the key vault certificate.
// options - ClientSetCertificateContactsOptions contains the optional parameters for the Client.SetCertificateContacts method.
func (client *Client) SetCertificateContacts(ctx context.Context, vaultBaseURL string, contacts Contacts, options *ClientSetCertificateContactsOptions) (ClientSetCertificateContactsResponse, error) {
	req, err := client.setCertificateContactsCreateRequest(ctx, vaultBaseURL, contacts, options)
	if err != nil {
		return ClientSetCertificateContactsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientSetCertificateContactsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientSetCertificateContactsResponse{}, runtime.NewResponseError(resp)
	}
	return client.setCertificateContactsHandleResponse(resp)
}

// setCertificateContactsCreateRequest creates the SetCertificateContacts request.
func (client *Client) setCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, contacts Contacts, options *ClientSetCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, contacts)
}

// setCertificateContactsHandleResponse handles the SetCertificateContacts response.
func (client *Client) setCertificateContactsHandleResponse(resp *http.Response) (ClientSetCertificateContactsResponse, error) {
	result := ClientSetCertificateContactsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		return ClientSetCertificateContactsResponse{}, err
	}
	return result, nil
}

// SetCertificateIssuer - The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation
// requires the certificates/setissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// issuerName - The name of the issuer.
// parameter - Certificate issuer set parameter.
// options - ClientSetCertificateIssuerOptions contains the optional parameters for the Client.SetCertificateIssuer method.
func (client *Client) SetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *ClientSetCertificateIssuerOptions) (ClientSetCertificateIssuerResponse, error) {
	req, err := client.setCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return ClientSetCertificateIssuerResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientSetCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientSetCertificateIssuerResponse{}, runtime.NewResponseError(resp)
	}
	return client.setCertificateIssuerHandleResponse(resp)
}

// setCertificateIssuerCreateRequest creates the SetCertificateIssuer request.
func (client *Client) setCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *ClientSetCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameter)
}

// setCertificateIssuerHandleResponse handles the SetCertificateIssuer response.
func (client *Client) setCertificateIssuerHandleResponse(resp *http.Response) (ClientSetCertificateIssuerResponse, error) {
	result := ClientSetCertificateIssuerResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return ClientSetCertificateIssuerResponse{}, err
	}
	return result, nil
}

// SetSasDefinition - Creates or updates a new SAS definition for the specified storage account. This operation requires the
// storage/setsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// sasDefinitionName - The name of the SAS definition.
// parameters - The parameters to create a SAS definition.
// options - ClientSetSasDefinitionOptions contains the optional parameters for the Client.SetSasDefinition method.
func (client *Client) SetSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionCreateParameters, options *ClientSetSasDefinitionOptions) (ClientSetSasDefinitionResponse, error) {
	req, err := client.setSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, parameters, options)
	if err != nil {
		return ClientSetSasDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientSetSasDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientSetSasDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.setSasDefinitionHandleResponse(resp)
}

// setSasDefinitionCreateRequest creates the SetSasDefinition request.
func (client *Client) setSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionCreateParameters, options *ClientSetSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// setSasDefinitionHandleResponse handles the SetSasDefinition response.
func (client *Client) setSasDefinitionHandleResponse(resp *http.Response) (ClientSetSasDefinitionResponse, error) {
	result := ClientSetSasDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		return ClientSetSasDefinitionResponse{}, err
	}
	return result, nil
}

// SetSecret - The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault
// creates a new version of that secret. This operation requires the secrets/set permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// parameters - The parameters for setting the secret.
// options - ClientSetSecretOptions contains the optional parameters for the Client.SetSecret method.
func (client *Client) SetSecret(ctx context.Context, vaultBaseURL string, secretName string, parameters SecretSetParameters, options *ClientSetSecretOptions) (ClientSetSecretResponse, error) {
	req, err := client.setSecretCreateRequest(ctx, vaultBaseURL, secretName, parameters, options)
	if err != nil {
		return ClientSetSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientSetSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientSetSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.setSecretHandleResponse(resp)
}

// setSecretCreateRequest creates the SetSecret request.
func (client *Client) setSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, parameters SecretSetParameters, options *ClientSetSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// setSecretHandleResponse handles the SetSecret response.
func (client *Client) setSecretHandleResponse(resp *http.Response) (ClientSetSecretResponse, error) {
	result := ClientSetSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return ClientSetSecretResponse{}, err
	}
	return result, nil
}

// SetStorageAccount - Creates or updates a new storage account. This operation requires the storage/set permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// parameters - The parameters to create a storage account.
// options - ClientSetStorageAccountOptions contains the optional parameters for the Client.SetStorageAccount method.
func (client *Client) SetStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountCreateParameters, options *ClientSetStorageAccountOptions) (ClientSetStorageAccountResponse, error) {
	req, err := client.setStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return ClientSetStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientSetStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientSetStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.setStorageAccountHandleResponse(resp)
}

// setStorageAccountCreateRequest creates the SetStorageAccount request.
func (client *Client) setStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountCreateParameters, options *ClientSetStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// setStorageAccountHandleResponse handles the SetStorageAccount response.
func (client *Client) setStorageAccountHandleResponse(resp *http.Response) (ClientSetStorageAccountResponse, error) {
	result := ClientSetStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		return ClientSetStorageAccountResponse{}, err
	}
	return result, nil
}

// Sign - The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation
// uses the private portion of the key. This operation requires the keys/sign permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// keyVersion - The version of the key.
// parameters - The parameters for the signing operation.
// options - ClientSignOptions contains the optional parameters for the Client.Sign method.
func (client *Client) Sign(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeySignParameters, options *ClientSignOptions) (ClientSignResponse, error) {
	req, err := client.signCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientSignResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientSignResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientSignResponse{}, runtime.NewResponseError(resp)
	}
	return client.signHandleResponse(resp)
}

// signCreateRequest creates the Sign request.
func (client *Client) signCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeySignParameters, options *ClientSignOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/sign"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// signHandleResponse handles the Sign response.
func (client *Client) signHandleResponse(resp *http.Response) (ClientSignResponse, error) {
	result := ClientSignResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return ClientSignResponse{}, err
	}
	return result, nil
}

// UnwrapKey - The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation
// is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and
// symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/unwrapKey
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// keyVersion - The version of the key.
// parameters - The parameters for the key operation.
// options - ClientUnwrapKeyOptions contains the optional parameters for the Client.UnwrapKey method.
func (client *Client) UnwrapKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientUnwrapKeyOptions) (ClientUnwrapKeyResponse, error) {
	req, err := client.unwrapKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientUnwrapKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUnwrapKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUnwrapKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.unwrapKeyHandleResponse(resp)
}

// unwrapKeyCreateRequest creates the UnwrapKey request.
func (client *Client) unwrapKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientUnwrapKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/unwrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// unwrapKeyHandleResponse handles the UnwrapKey response.
func (client *Client) unwrapKeyHandleResponse(resp *http.Response) (ClientUnwrapKeyResponse, error) {
	result := ClientUnwrapKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return ClientUnwrapKeyResponse{}, err
	}
	return result, nil
}

// UpdateCertificate - The UpdateCertificate operation applies the specified update on the given certificate; the only elements
// updated are the certificate's attributes. This operation requires the certificates/update
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate in the given key vault.
// certificateVersion - The version of the certificate.
// parameters - The parameters for certificate update.
// options - ClientUpdateCertificateOptions contains the optional parameters for the Client.UpdateCertificate method.
func (client *Client) UpdateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *ClientUpdateCertificateOptions) (ClientUpdateCertificateResponse, error) {
	req, err := client.updateCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, parameters, options)
	if err != nil {
		return ClientUpdateCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateCertificateResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateCertificateHandleResponse(resp)
}

// updateCertificateCreateRequest creates the UpdateCertificate request.
func (client *Client) updateCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *ClientUpdateCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateCertificateHandleResponse handles the UpdateCertificate response.
func (client *Client) updateCertificateHandleResponse(resp *http.Response) (ClientUpdateCertificateResponse, error) {
	result := ClientUpdateCertificateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		return ClientUpdateCertificateResponse{}, err
	}
	return result, nil
}

// UpdateCertificateIssuer - The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
// entity. This operation requires the certificates/setissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// issuerName - The name of the issuer.
// parameter - Certificate issuer update parameter.
// options - ClientUpdateCertificateIssuerOptions contains the optional parameters for the Client.UpdateCertificateIssuer
// method.
func (client *Client) UpdateCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *ClientUpdateCertificateIssuerOptions) (ClientUpdateCertificateIssuerResponse, error) {
	req, err := client.updateCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return ClientUpdateCertificateIssuerResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateCertificateIssuerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateCertificateIssuerResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateCertificateIssuerHandleResponse(resp)
}

// updateCertificateIssuerCreateRequest creates the UpdateCertificateIssuer request.
func (client *Client) updateCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *ClientUpdateCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameter)
}

// updateCertificateIssuerHandleResponse handles the UpdateCertificateIssuer response.
func (client *Client) updateCertificateIssuerHandleResponse(resp *http.Response) (ClientUpdateCertificateIssuerResponse, error) {
	result := ClientUpdateCertificateIssuerResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		return ClientUpdateCertificateIssuerResponse{}, err
	}
	return result, nil
}

// UpdateCertificateOperation - Updates a certificate creation operation that is already in progress. This operation requires
// the certificates/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate.
// certificateOperation - The certificate operation response.
// options - ClientUpdateCertificateOperationOptions contains the optional parameters for the Client.UpdateCertificateOperation
// method.
func (client *Client) UpdateCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *ClientUpdateCertificateOperationOptions) (ClientUpdateCertificateOperationResponse, error) {
	req, err := client.updateCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, certificateOperation, options)
	if err != nil {
		return ClientUpdateCertificateOperationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateCertificateOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateCertificateOperationResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateCertificateOperationHandleResponse(resp)
}

// updateCertificateOperationCreateRequest creates the UpdateCertificateOperation request.
func (client *Client) updateCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *ClientUpdateCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, certificateOperation)
}

// updateCertificateOperationHandleResponse handles the UpdateCertificateOperation response.
func (client *Client) updateCertificateOperationHandleResponse(resp *http.Response) (ClientUpdateCertificateOperationResponse, error) {
	result := ClientUpdateCertificateOperationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		return ClientUpdateCertificateOperationResponse{}, err
	}
	return result, nil
}

// UpdateCertificatePolicy - Set specified members in the certificate policy. Leave others as null. This operation requires
// the certificates/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// certificateName - The name of the certificate in the given vault.
// certificatePolicy - The policy for the certificate.
// options - ClientUpdateCertificatePolicyOptions contains the optional parameters for the Client.UpdateCertificatePolicy
// method.
func (client *Client) UpdateCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *ClientUpdateCertificatePolicyOptions) (ClientUpdateCertificatePolicyResponse, error) {
	req, err := client.updateCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, certificatePolicy, options)
	if err != nil {
		return ClientUpdateCertificatePolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateCertificatePolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateCertificatePolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateCertificatePolicyHandleResponse(resp)
}

// updateCertificatePolicyCreateRequest creates the UpdateCertificatePolicy request.
func (client *Client) updateCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *ClientUpdateCertificatePolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, certificatePolicy)
}

// updateCertificatePolicyHandleResponse handles the UpdateCertificatePolicy response.
func (client *Client) updateCertificatePolicyHandleResponse(resp *http.Response) (ClientUpdateCertificatePolicyResponse, error) {
	result := ClientUpdateCertificatePolicyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CertificatePolicy); err != nil {
		return ClientUpdateCertificatePolicyResponse{}, err
	}
	return result, nil
}

// UpdateKey - In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material
// of a key itself cannot be changed. This operation requires the keys/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of key to update.
// keyVersion - The version of the key to update.
// parameters - The parameters of the key to update.
// options - ClientUpdateKeyOptions contains the optional parameters for the Client.UpdateKey method.
func (client *Client) UpdateKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyUpdateParameters, options *ClientUpdateKeyOptions) (ClientUpdateKeyResponse, error) {
	req, err := client.updateKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientUpdateKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateKeyHandleResponse(resp)
}

// updateKeyCreateRequest creates the UpdateKey request.
func (client *Client) updateKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyUpdateParameters, options *ClientUpdateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateKeyHandleResponse handles the UpdateKey response.
func (client *Client) updateKeyHandleResponse(resp *http.Response) (ClientUpdateKeyResponse, error) {
	result := ClientUpdateKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		return ClientUpdateKeyResponse{}, err
	}
	return result, nil
}

// UpdateSasDefinition - Updates the specified attributes associated with the given SAS definition. This operation requires
// the storage/setsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// sasDefinitionName - The name of the SAS definition.
// parameters - The parameters to update a SAS definition.
// options - ClientUpdateSasDefinitionOptions contains the optional parameters for the Client.UpdateSasDefinition method.
func (client *Client) UpdateSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionUpdateParameters, options *ClientUpdateSasDefinitionOptions) (ClientUpdateSasDefinitionResponse, error) {
	req, err := client.updateSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, parameters, options)
	if err != nil {
		return ClientUpdateSasDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateSasDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateSasDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSasDefinitionHandleResponse(resp)
}

// updateSasDefinitionCreateRequest creates the UpdateSasDefinition request.
func (client *Client) updateSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionUpdateParameters, options *ClientUpdateSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateSasDefinitionHandleResponse handles the UpdateSasDefinition response.
func (client *Client) updateSasDefinitionHandleResponse(resp *http.Response) (ClientUpdateSasDefinitionResponse, error) {
	result := ClientUpdateSasDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		return ClientUpdateSasDefinitionResponse{}, err
	}
	return result, nil
}

// UpdateSecret - The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not
// specified in the request are left unchanged. The value of a secret itself cannot be changed.
// This operation requires the secrets/set permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// secretName - The name of the secret.
// secretVersion - The version of the secret.
// parameters - The parameters for update secret operation.
// options - ClientUpdateSecretOptions contains the optional parameters for the Client.UpdateSecret method.
func (client *Client) UpdateSecret(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, parameters SecretUpdateParameters, options *ClientUpdateSecretOptions) (ClientUpdateSecretResponse, error) {
	req, err := client.updateSecretCreateRequest(ctx, vaultBaseURL, secretName, secretVersion, parameters, options)
	if err != nil {
		return ClientUpdateSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateSecretResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSecretHandleResponse(resp)
}

// updateSecretCreateRequest creates the UpdateSecret request.
func (client *Client) updateSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, parameters SecretUpdateParameters, options *ClientUpdateSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/{secret-version}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-version}", url.PathEscape(secretVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateSecretHandleResponse handles the UpdateSecret response.
func (client *Client) updateSecretHandleResponse(resp *http.Response) (ClientUpdateSecretResponse, error) {
	result := ClientUpdateSecretResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		return ClientUpdateSecretResponse{}, err
	}
	return result, nil
}

// UpdateStorageAccount - Updates the specified attributes associated with the given storage account. This operation requires
// the storage/set/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// storageAccountName - The name of the storage account.
// parameters - The parameters to update a storage account.
// options - ClientUpdateStorageAccountOptions contains the optional parameters for the Client.UpdateStorageAccount method.
func (client *Client) UpdateStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountUpdateParameters, options *ClientUpdateStorageAccountOptions) (ClientUpdateStorageAccountResponse, error) {
	req, err := client.updateStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return ClientUpdateStorageAccountResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateStorageAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientUpdateStorageAccountResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateStorageAccountHandleResponse(resp)
}

// updateStorageAccountCreateRequest creates the UpdateStorageAccount request.
func (client *Client) updateStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountUpdateParameters, options *ClientUpdateStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateStorageAccountHandleResponse handles the UpdateStorageAccount response.
func (client *Client) updateStorageAccountHandleResponse(resp *http.Response) (ClientUpdateStorageAccountResponse, error) {
	result := ClientUpdateStorageAccountResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		return ClientUpdateStorageAccountResponse{}, err
	}
	return result, nil
}

// Verify - The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary
// for asymmetric keys stored in Azure Key Vault since signature verification can be
// performed using the public portion of the key but this operation is supported as a convenience for callers that only have
// a key-reference and not the public portion of the key. This operation requires
// the keys/verify permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// keyVersion - The version of the key.
// parameters - The parameters for verify operations.
// options - ClientVerifyOptions contains the optional parameters for the Client.Verify method.
func (client *Client) Verify(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyVerifyParameters, options *ClientVerifyOptions) (ClientVerifyResponse, error) {
	req, err := client.verifyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientVerifyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientVerifyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientVerifyResponse{}, runtime.NewResponseError(resp)
	}
	return client.verifyHandleResponse(resp)
}

// verifyCreateRequest creates the Verify request.
func (client *Client) verifyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyVerifyParameters, options *ClientVerifyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/verify"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// verifyHandleResponse handles the Verify response.
func (client *Client) verifyHandleResponse(resp *http.Response) (ClientVerifyResponse, error) {
	result := ClientVerifyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyVerifyResult); err != nil {
		return ClientVerifyResponse{}, err
	}
	return result, nil
}

// WrapKey - The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been
// stored in an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric
// keys stored in Azure Key Vault since protection with an asymmetric key can be performed using the public portion of the
// key. This operation is supported for asymmetric keys as a convenience for
// callers that have a key-reference but do not have access to the public key material. This operation requires the keys/wrapKey
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.2
// vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
// keyName - The name of the key.
// keyVersion - The version of the key.
// parameters - The parameters for wrap operation.
// options - ClientWrapKeyOptions contains the optional parameters for the Client.WrapKey method.
func (client *Client) WrapKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientWrapKeyOptions) (ClientWrapKeyResponse, error) {
	req, err := client.wrapKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return ClientWrapKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientWrapKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientWrapKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.wrapKeyHandleResponse(resp)
}

// wrapKeyCreateRequest creates the WrapKey request.
func (client *Client) wrapKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientWrapKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/wrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// wrapKeyHandleResponse handles the WrapKey response.
func (client *Client) wrapKeyHandleResponse(resp *http.Response) (ClientWrapKeyResponse, error) {
	result := ClientWrapKeyResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		return ClientWrapKeyResponse{}, err
	}
	return result, nil
}
