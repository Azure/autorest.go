// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azkeyvault

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// KeyVaultClient contains the methods for the KeyVaultClient group.
// Don't use this type directly, use NewKeyVaultClient() instead.
type KeyVaultClient struct {
	con *Connection
}

// NewKeyVaultClient creates a new instance of KeyVaultClient with the specified values.
func NewKeyVaultClient(con *Connection) *KeyVaultClient {
	return &KeyVaultClient{con: con}
}

// BackupCertificate - Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded.
// This operation requires the certificates/backup permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BackupCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientBackupCertificateOptions) (BackupCertificateResultResponse, error) {
	req, err := client.backupCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return BackupCertificateResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupCertificateResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupCertificateResultResponse{}, client.backupCertificateHandleError(resp)
	}
	return client.backupCertificateHandleResponse(resp)
}

// backupCertificateCreateRequest creates the BackupCertificate request.
func (client *KeyVaultClient) backupCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientBackupCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/backup"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// backupCertificateHandleResponse handles the BackupCertificate response.
func (client *KeyVaultClient) backupCertificateHandleResponse(resp *azcore.Response) (BackupCertificateResultResponse, error) {
	var val *BackupCertificateResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupCertificateResultResponse{}, err
	}
	return BackupCertificateResultResponse{RawResponse: resp.Response, BackupCertificateResult: val}, nil
}

// backupCertificateHandleError handles the BackupCertificate error response.
func (client *KeyVaultClient) backupCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BackupKey - The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does NOT return key material in
// a form that can be used outside the Azure Key Vault system,
// the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this operation is to allow a client
// to GENERATE a key in one Azure Key Vault
// instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP operation may be used to export, in protected form, any
// key type from Azure Key Vault. Individual
// versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that a BACKUP from one geographical
// area cannot be restored to another
// geographical area. For example, a backup from the US geographical area cannot be restored in an EU geographical area. This operation requires the key/backup
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BackupKey(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientBackupKeyOptions) (BackupKeyResultResponse, error) {
	req, err := client.backupKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return BackupKeyResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupKeyResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupKeyResultResponse{}, client.backupKeyHandleError(resp)
	}
	return client.backupKeyHandleResponse(resp)
}

// backupKeyCreateRequest creates the BackupKey request.
func (client *KeyVaultClient) backupKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientBackupKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/backup"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// backupKeyHandleResponse handles the BackupKey response.
func (client *KeyVaultClient) backupKeyHandleResponse(resp *azcore.Response) (BackupKeyResultResponse, error) {
	var val *BackupKeyResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupKeyResultResponse{}, err
	}
	return BackupKeyResultResponse{RawResponse: resp.Response, BackupKeyResult: val}, nil
}

// backupKeyHandleError handles the BackupKey error response.
func (client *KeyVaultClient) backupKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BackupSecret - Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will be downloaded. This operation
// requires the secrets/backup permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BackupSecret(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientBackupSecretOptions) (BackupSecretResultResponse, error) {
	req, err := client.backupSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return BackupSecretResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupSecretResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupSecretResultResponse{}, client.backupSecretHandleError(resp)
	}
	return client.backupSecretHandleResponse(resp)
}

// backupSecretCreateRequest creates the BackupSecret request.
func (client *KeyVaultClient) backupSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientBackupSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/backup"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// backupSecretHandleResponse handles the BackupSecret response.
func (client *KeyVaultClient) backupSecretHandleResponse(resp *azcore.Response) (BackupSecretResultResponse, error) {
	var val *BackupSecretResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupSecretResultResponse{}, err
	}
	return BackupSecretResultResponse{RawResponse: resp.Response, BackupSecretResult: val}, nil
}

// backupSecretHandleError handles the BackupSecret error response.
func (client *KeyVaultClient) backupSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BackupStorageAccount - Requests that a backup of the specified storage account be downloaded to the client. This operation requires the storage/backup
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BackupStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientBackupStorageAccountOptions) (BackupStorageResultResponse, error) {
	req, err := client.backupStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return BackupStorageResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BackupStorageResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BackupStorageResultResponse{}, client.backupStorageAccountHandleError(resp)
	}
	return client.backupStorageAccountHandleResponse(resp)
}

// backupStorageAccountCreateRequest creates the BackupStorageAccount request.
func (client *KeyVaultClient) backupStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientBackupStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/backup"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// backupStorageAccountHandleResponse handles the BackupStorageAccount response.
func (client *KeyVaultClient) backupStorageAccountHandleResponse(resp *azcore.Response) (BackupStorageResultResponse, error) {
	var val *BackupStorageResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BackupStorageResultResponse{}, err
	}
	return BackupStorageResultResponse{RawResponse: resp.Response, BackupStorageResult: val}, nil
}

// backupStorageAccountHandleError handles the BackupStorageAccount error response.
func (client *KeyVaultClient) backupStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateCertificate - If this is the first version, the certificate resource is created. This operation requires the certificates/create permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) CreateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *KeyVaultClientCreateCertificateOptions) (CertificateOperationResponse, error) {
	req, err := client.createCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return CertificateOperationResponse{}, client.createCertificateHandleError(resp)
	}
	return client.createCertificateHandleResponse(resp)
}

// createCertificateCreateRequest creates the CreateCertificate request.
func (client *KeyVaultClient) createCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *KeyVaultClientCreateCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/create"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createCertificateHandleResponse handles the CreateCertificate response.
func (client *KeyVaultClient) createCertificateHandleResponse(resp *azcore.Response) (CertificateOperationResponse, error) {
	var val *CertificateOperation
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateOperationResponse{}, err
	}
	return CertificateOperationResponse{RawResponse: resp.Response, CertificateOperation: val}, nil
}

// createCertificateHandleError handles the CreateCertificate error response.
func (client *KeyVaultClient) createCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CreateKey - The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists, Azure Key Vault creates
// a new version of the key. It requires the keys/create
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) CreateKey(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyCreateParameters, options *KeyVaultClientCreateKeyOptions) (KeyBundleResponse, error) {
	req, err := client.createKeyCreateRequest(ctx, vaultBaseURL, keyName, parameters, options)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyBundleResponse{}, client.createKeyHandleError(resp)
	}
	return client.createKeyHandleResponse(resp)
}

// createKeyCreateRequest creates the CreateKey request.
func (client *KeyVaultClient) createKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyCreateParameters, options *KeyVaultClientCreateKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/create"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createKeyHandleResponse handles the CreateKey response.
func (client *KeyVaultClient) createKeyHandleResponse(resp *azcore.Response) (KeyBundleResponse, error) {
	var val *KeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyBundleResponse{}, err
	}
	return KeyBundleResponse{RawResponse: resp.Response, KeyBundle: val}, nil
}

// createKeyHandleError handles the CreateKey error response.
func (client *KeyVaultClient) createKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Decrypt - The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified algorithm. This operation is
// the reverse of the ENCRYPT operation; only a single block of
// data may be decrypted, the size of this block is dependent on the target key and the algorithm to be used. The DECRYPT operation applies to asymmetric
// and symmetric keys stored in Azure Key Vault
// since it uses the private portion of the key. This operation requires the keys/decrypt permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) Decrypt(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientDecryptOptions) (KeyOperationResultResponse, error) {
	req, err := client.decryptCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyOperationResultResponse{}, client.decryptHandleError(resp)
	}
	return client.decryptHandleResponse(resp)
}

// decryptCreateRequest creates the Decrypt request.
func (client *KeyVaultClient) decryptCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientDecryptOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/decrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// decryptHandleResponse handles the Decrypt response.
func (client *KeyVaultClient) decryptHandleResponse(resp *azcore.Response) (KeyOperationResultResponse, error) {
	var val *KeyOperationResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyOperationResultResponse{}, err
	}
	return KeyOperationResultResponse{RawResponse: resp.Response, KeyOperationResult: val}, nil
}

// decryptHandleError handles the Decrypt error response.
func (client *KeyVaultClient) decryptHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteCertificate - Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot be used to remove individual
// versions of a certificate object. This operation requires the
// certificates/delete permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOptions) (DeletedCertificateBundleResponse, error) {
	req, err := client.deleteCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return DeletedCertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedCertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedCertificateBundleResponse{}, client.deleteCertificateHandleError(resp)
	}
	return client.deleteCertificateHandleResponse(resp)
}

// deleteCertificateCreateRequest creates the DeleteCertificate request.
func (client *KeyVaultClient) deleteCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateHandleResponse handles the DeleteCertificate response.
func (client *KeyVaultClient) deleteCertificateHandleResponse(resp *azcore.Response) (DeletedCertificateBundleResponse, error) {
	var val *DeletedCertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedCertificateBundleResponse{}, err
	}
	return DeletedCertificateBundleResponse{RawResponse: resp.Response, DeletedCertificateBundle: val}, nil
}

// deleteCertificateHandleError handles the DeleteCertificate error response.
func (client *KeyVaultClient) deleteCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteCertificateContacts - Deletes the certificate contacts for a specified key vault certificate. This operation requires the certificates/managecontacts
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificateContacts(ctx context.Context, vaultBaseURL string, options *KeyVaultClientDeleteCertificateContactsOptions) (ContactsResponse, error) {
	req, err := client.deleteCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return ContactsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ContactsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ContactsResponse{}, client.deleteCertificateContactsHandleError(resp)
	}
	return client.deleteCertificateContactsHandleResponse(resp)
}

// deleteCertificateContactsCreateRequest creates the DeleteCertificateContacts request.
func (client *KeyVaultClient) deleteCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientDeleteCertificateContactsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateContactsHandleResponse handles the DeleteCertificateContacts response.
func (client *KeyVaultClient) deleteCertificateContactsHandleResponse(resp *azcore.Response) (ContactsResponse, error) {
	var val *Contacts
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContactsResponse{}, err
	}
	return ContactsResponse{RawResponse: resp.Response, Contacts: val}, nil
}

// deleteCertificateContactsHandleError handles the DeleteCertificateContacts error response.
func (client *KeyVaultClient) deleteCertificateContactsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteCertificateIssuer - The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from the vault. This operation requires
// the certificates/manageissuers/deleteissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientDeleteCertificateIssuerOptions) (IssuerBundleResponse, error) {
	req, err := client.deleteCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IssuerBundleResponse{}, client.deleteCertificateIssuerHandleError(resp)
	}
	return client.deleteCertificateIssuerHandleResponse(resp)
}

// deleteCertificateIssuerCreateRequest creates the DeleteCertificateIssuer request.
func (client *KeyVaultClient) deleteCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientDeleteCertificateIssuerOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateIssuerHandleResponse handles the DeleteCertificateIssuer response.
func (client *KeyVaultClient) deleteCertificateIssuerHandleResponse(resp *azcore.Response) (IssuerBundleResponse, error) {
	var val *IssuerBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IssuerBundleResponse{}, err
	}
	return IssuerBundleResponse{RawResponse: resp.Response, IssuerBundle: val}, nil
}

// deleteCertificateIssuerHandleError handles the DeleteCertificateIssuer error response.
func (client *KeyVaultClient) deleteCertificateIssuerHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteCertificateOperation - Deletes the creation operation for a specified certificate that is in the process of being created. The certificate is no
// longer created. This operation requires the certificates/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOperationOptions) (CertificateOperationResponse, error) {
	req, err := client.deleteCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateOperationResponse{}, client.deleteCertificateOperationHandleError(resp)
	}
	return client.deleteCertificateOperationHandleResponse(resp)
}

// deleteCertificateOperationCreateRequest creates the DeleteCertificateOperation request.
func (client *KeyVaultClient) deleteCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientDeleteCertificateOperationOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteCertificateOperationHandleResponse handles the DeleteCertificateOperation response.
func (client *KeyVaultClient) deleteCertificateOperationHandleResponse(resp *azcore.Response) (CertificateOperationResponse, error) {
	var val *CertificateOperation
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateOperationResponse{}, err
	}
	return CertificateOperationResponse{RawResponse: resp.Response, CertificateOperation: val}, nil
}

// deleteCertificateOperationHandleError handles the DeleteCertificateOperation error response.
func (client *KeyVaultClient) deleteCertificateOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteKey - The delete key operation cannot be used to remove individual versions of a key. This operation removes the cryptographic material associated
// with the key, which means the key is not usable for
// Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteKey(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientDeleteKeyOptions) (DeletedKeyBundleResponse, error) {
	req, err := client.deleteKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return DeletedKeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedKeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedKeyBundleResponse{}, client.deleteKeyHandleError(resp)
	}
	return client.deleteKeyHandleResponse(resp)
}

// deleteKeyCreateRequest creates the DeleteKey request.
func (client *KeyVaultClient) deleteKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientDeleteKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteKeyHandleResponse handles the DeleteKey response.
func (client *KeyVaultClient) deleteKeyHandleResponse(resp *azcore.Response) (DeletedKeyBundleResponse, error) {
	var val *DeletedKeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedKeyBundleResponse{}, err
	}
	return DeletedKeyBundleResponse{RawResponse: resp.Response, DeletedKeyBundle: val}, nil
}

// deleteKeyHandleError handles the DeleteKey error response.
func (client *KeyVaultClient) deleteKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteSasDefinition - Deletes a SAS definition from a specified storage account. This operation requires the storage/deletesas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientDeleteSasDefinitionOptions) (DeletedSasDefinitionBundleResponse, error) {
	req, err := client.deleteSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return DeletedSasDefinitionBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedSasDefinitionBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedSasDefinitionBundleResponse{}, client.deleteSasDefinitionHandleError(resp)
	}
	return client.deleteSasDefinitionHandleResponse(resp)
}

// deleteSasDefinitionCreateRequest creates the DeleteSasDefinition request.
func (client *KeyVaultClient) deleteSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientDeleteSasDefinitionOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSasDefinitionHandleResponse handles the DeleteSasDefinition response.
func (client *KeyVaultClient) deleteSasDefinitionHandleResponse(resp *azcore.Response) (DeletedSasDefinitionBundleResponse, error) {
	var val *DeletedSasDefinitionBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedSasDefinitionBundleResponse{}, err
	}
	return DeletedSasDefinitionBundleResponse{RawResponse: resp.Response, DeletedSasDefinitionBundle: val}, nil
}

// deleteSasDefinitionHandleError handles the DeleteSasDefinition error response.
func (client *KeyVaultClient) deleteSasDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteSecret - The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual version of a secret. This
// operation requires the secrets/delete permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteSecret(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientDeleteSecretOptions) (DeletedSecretBundleResponse, error) {
	req, err := client.deleteSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return DeletedSecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedSecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedSecretBundleResponse{}, client.deleteSecretHandleError(resp)
	}
	return client.deleteSecretHandleResponse(resp)
}

// deleteSecretCreateRequest creates the DeleteSecret request.
func (client *KeyVaultClient) deleteSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientDeleteSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSecretHandleResponse handles the DeleteSecret response.
func (client *KeyVaultClient) deleteSecretHandleResponse(resp *azcore.Response) (DeletedSecretBundleResponse, error) {
	var val *DeletedSecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedSecretBundleResponse{}, err
	}
	return DeletedSecretBundleResponse{RawResponse: resp.Response, DeletedSecretBundle: val}, nil
}

// deleteSecretHandleError handles the DeleteSecret error response.
func (client *KeyVaultClient) deleteSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteStorageAccount - Deletes a storage account. This operation requires the storage/delete permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) DeleteStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientDeleteStorageAccountOptions) (DeletedStorageBundleResponse, error) {
	req, err := client.deleteStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return DeletedStorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedStorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedStorageBundleResponse{}, client.deleteStorageAccountHandleError(resp)
	}
	return client.deleteStorageAccountHandleResponse(resp)
}

// deleteStorageAccountCreateRequest creates the DeleteStorageAccount request.
func (client *KeyVaultClient) deleteStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientDeleteStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStorageAccountHandleResponse handles the DeleteStorageAccount response.
func (client *KeyVaultClient) deleteStorageAccountHandleResponse(resp *azcore.Response) (DeletedStorageBundleResponse, error) {
	var val *DeletedStorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedStorageBundleResponse{}, err
	}
	return DeletedStorageBundleResponse{RawResponse: resp.Response, DeletedStorageBundle: val}, nil
}

// deleteStorageAccountHandleError handles the DeleteStorageAccount error response.
func (client *KeyVaultClient) deleteStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Encrypt - The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure Key Vault. Note that the ENCRYPT
// operation only supports a single block of data, the size
// of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT operation is only strictly necessary for symmetric keys
// stored in Azure Key Vault since protection with an
// asymmetric key can be performed using public portion of the key. This operation is supported for asymmetric keys as a convenience for callers that have
// a key-reference but do not have access to the
// public key material. This operation requires the keys/encrypt permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) Encrypt(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientEncryptOptions) (KeyOperationResultResponse, error) {
	req, err := client.encryptCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyOperationResultResponse{}, client.encryptHandleError(resp)
	}
	return client.encryptHandleResponse(resp)
}

// encryptCreateRequest creates the Encrypt request.
func (client *KeyVaultClient) encryptCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientEncryptOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/encrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// encryptHandleResponse handles the Encrypt response.
func (client *KeyVaultClient) encryptHandleResponse(resp *azcore.Response) (KeyOperationResultResponse, error) {
	var val *KeyOperationResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyOperationResultResponse{}, err
	}
	return KeyOperationResultResponse{RawResponse: resp.Response, KeyOperationResult: val}, nil
}

// encryptHandleError handles the Encrypt error response.
func (client *KeyVaultClient) encryptHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginFullBackup - Creates a full backup using a user-provided SAS token to an Azure blob storage container.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BeginFullBackup(ctx context.Context, vaultBaseURL string, options *KeyVaultClientBeginFullBackupOptions) (FullBackupOperationPollerResponse, error) {
	resp, err := client.fullBackup(ctx, vaultBaseURL, options)
	if err != nil {
		return FullBackupOperationPollerResponse{}, err
	}
	result := FullBackupOperationPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("KeyVaultClient.FullBackup", resp, client.con.Pipeline(), client.fullBackupHandleError)
	if err != nil {
		return FullBackupOperationPollerResponse{}, err
	}
	poller := &fullBackupOperationPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (FullBackupOperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeFullBackup creates a new FullBackupOperationPoller from the specified resume token.
// token - The value must come from a previous call to FullBackupOperationPoller.ResumeToken().
func (client *KeyVaultClient) ResumeFullBackup(ctx context.Context, token string) (FullBackupOperationPollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("KeyVaultClient.FullBackup", token, client.con.Pipeline(), client.fullBackupHandleError)
	if err != nil {
		return FullBackupOperationPollerResponse{}, err
	}
	poller := &fullBackupOperationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return FullBackupOperationPollerResponse{}, err
	}
	result := FullBackupOperationPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (FullBackupOperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// FullBackup - Creates a full backup using a user-provided SAS token to an Azure blob storage container.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) fullBackup(ctx context.Context, vaultBaseURL string, options *KeyVaultClientBeginFullBackupOptions) (*azcore.Response, error) {
	req, err := client.fullBackupCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.fullBackupHandleError(resp)
	}
	return resp, nil
}

// fullBackupCreateRequest creates the FullBackup request.
func (client *KeyVaultClient) fullBackupCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientBeginFullBackupOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/backup"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	if options != nil && options.AzureStorageBlobContainerURI != nil {
		return req, req.MarshalAsJSON(*options.AzureStorageBlobContainerURI)
	}
	return req, nil
}

// fullBackupHandleError handles the FullBackup error response.
func (client *KeyVaultClient) fullBackupHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// FullBackupStatus - Returns the status of full backup operation
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) FullBackupStatus(ctx context.Context, vaultBaseURL string, jobID string, options *KeyVaultClientFullBackupStatusOptions) (FullBackupOperationResponse, error) {
	req, err := client.fullBackupStatusCreateRequest(ctx, vaultBaseURL, jobID, options)
	if err != nil {
		return FullBackupOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FullBackupOperationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FullBackupOperationResponse{}, client.fullBackupStatusHandleError(resp)
	}
	return client.fullBackupStatusHandleResponse(resp)
}

// fullBackupStatusCreateRequest creates the FullBackupStatus request.
func (client *KeyVaultClient) fullBackupStatusCreateRequest(ctx context.Context, vaultBaseURL string, jobID string, options *KeyVaultClientFullBackupStatusOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/backup/{jobId}/pending"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// fullBackupStatusHandleResponse handles the FullBackupStatus response.
func (client *KeyVaultClient) fullBackupStatusHandleResponse(resp *azcore.Response) (FullBackupOperationResponse, error) {
	var val *FullBackupOperation
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FullBackupOperationResponse{}, err
	}
	return FullBackupOperationResponse{RawResponse: resp.Response, FullBackupOperation: val}, nil
}

// fullBackupStatusHandleError handles the FullBackupStatus error response.
func (client *KeyVaultClient) fullBackupStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginFullRestoreOperation - Restores all key materials using the SAS token pointing to a previously stored Azure Blob storage backup folder
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BeginFullRestoreOperation(ctx context.Context, vaultBaseURL string, options *KeyVaultClientBeginFullRestoreOperationOptions) (RestoreOperationPollerResponse, error) {
	resp, err := client.fullRestoreOperation(ctx, vaultBaseURL, options)
	if err != nil {
		return RestoreOperationPollerResponse{}, err
	}
	result := RestoreOperationPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("KeyVaultClient.FullRestoreOperation", resp, client.con.Pipeline(), client.fullRestoreOperationHandleError)
	if err != nil {
		return RestoreOperationPollerResponse{}, err
	}
	poller := &restoreOperationPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RestoreOperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeFullRestoreOperation creates a new RestoreOperationPoller from the specified resume token.
// token - The value must come from a previous call to RestoreOperationPoller.ResumeToken().
func (client *KeyVaultClient) ResumeFullRestoreOperation(ctx context.Context, token string) (RestoreOperationPollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("KeyVaultClient.FullRestoreOperation", token, client.con.Pipeline(), client.fullRestoreOperationHandleError)
	if err != nil {
		return RestoreOperationPollerResponse{}, err
	}
	poller := &restoreOperationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RestoreOperationPollerResponse{}, err
	}
	result := RestoreOperationPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RestoreOperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// FullRestoreOperation - Restores all key materials using the SAS token pointing to a previously stored Azure Blob storage backup folder
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) fullRestoreOperation(ctx context.Context, vaultBaseURL string, options *KeyVaultClientBeginFullRestoreOperationOptions) (*azcore.Response, error) {
	req, err := client.fullRestoreOperationCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.fullRestoreOperationHandleError(resp)
	}
	return resp, nil
}

// fullRestoreOperationCreateRequest creates the FullRestoreOperation request.
func (client *KeyVaultClient) fullRestoreOperationCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientBeginFullRestoreOperationOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/restore"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	if options != nil && options.RestoreBlobDetails != nil {
		return req, req.MarshalAsJSON(*options.RestoreBlobDetails)
	}
	return req, nil
}

// fullRestoreOperationHandleError handles the FullRestoreOperation error response.
func (client *KeyVaultClient) fullRestoreOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificate - Gets information about a specific certificate. This operation requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *KeyVaultClientGetCertificateOptions) (CertificateBundleResponse, error) {
	req, err := client.getCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, options)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateBundleResponse{}, client.getCertificateHandleError(resp)
	}
	return client.getCertificateHandleResponse(resp)
}

// getCertificateCreateRequest creates the GetCertificate request.
func (client *KeyVaultClient) getCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *KeyVaultClientGetCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateHandleResponse handles the GetCertificate response.
func (client *KeyVaultClient) getCertificateHandleResponse(resp *azcore.Response) (CertificateBundleResponse, error) {
	var val *CertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateBundleResponse{}, err
	}
	return CertificateBundleResponse{RawResponse: resp.Response, CertificateBundle: val}, nil
}

// getCertificateHandleError handles the GetCertificate error response.
func (client *KeyVaultClient) getCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificateContacts - The GetCertificateContacts operation returns the set of certificate contact resources in the specified key vault. This operation
// requires the certificates/managecontacts permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateContacts(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificateContactsOptions) (ContactsResponse, error) {
	req, err := client.getCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return ContactsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ContactsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ContactsResponse{}, client.getCertificateContactsHandleError(resp)
	}
	return client.getCertificateContactsHandleResponse(resp)
}

// getCertificateContactsCreateRequest creates the GetCertificateContacts request.
func (client *KeyVaultClient) getCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificateContactsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateContactsHandleResponse handles the GetCertificateContacts response.
func (client *KeyVaultClient) getCertificateContactsHandleResponse(resp *azcore.Response) (ContactsResponse, error) {
	var val *Contacts
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContactsResponse{}, err
	}
	return ContactsResponse{RawResponse: resp.Response, Contacts: val}, nil
}

// getCertificateContactsHandleError handles the GetCertificateContacts error response.
func (client *KeyVaultClient) getCertificateContactsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificateIssuer - The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified key vault. This operation
// requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientGetCertificateIssuerOptions) (IssuerBundleResponse, error) {
	req, err := client.getCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IssuerBundleResponse{}, client.getCertificateIssuerHandleError(resp)
	}
	return client.getCertificateIssuerHandleResponse(resp)
}

// getCertificateIssuerCreateRequest creates the GetCertificateIssuer request.
func (client *KeyVaultClient) getCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *KeyVaultClientGetCertificateIssuerOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateIssuerHandleResponse handles the GetCertificateIssuer response.
func (client *KeyVaultClient) getCertificateIssuerHandleResponse(resp *azcore.Response) (IssuerBundleResponse, error) {
	var val *IssuerBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IssuerBundleResponse{}, err
	}
	return IssuerBundleResponse{RawResponse: resp.Response, IssuerBundle: val}, nil
}

// getCertificateIssuerHandleError handles the GetCertificateIssuer error response.
func (client *KeyVaultClient) getCertificateIssuerHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificateIssuers - The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified key vault. This operation
// requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateIssuers(vaultBaseURL string, options *KeyVaultClientGetCertificateIssuersOptions) CertificateIssuerListResultPager {
	return &certificateIssuerListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getCertificateIssuersCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getCertificateIssuersHandleResponse,
		errorer:   client.getCertificateIssuersHandleError,
		advancer: func(ctx context.Context, resp CertificateIssuerListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.CertificateIssuerListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getCertificateIssuersCreateRequest creates the GetCertificateIssuers request.
func (client *KeyVaultClient) getCertificateIssuersCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificateIssuersOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateIssuersHandleResponse handles the GetCertificateIssuers response.
func (client *KeyVaultClient) getCertificateIssuersHandleResponse(resp *azcore.Response) (CertificateIssuerListResultResponse, error) {
	var val *CertificateIssuerListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateIssuerListResultResponse{}, err
	}
	return CertificateIssuerListResultResponse{RawResponse: resp.Response, CertificateIssuerListResult: val}, nil
}

// getCertificateIssuersHandleError handles the GetCertificateIssuers error response.
func (client *KeyVaultClient) getCertificateIssuersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificateOperation - Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateOperationOptions) (CertificateOperationResponse, error) {
	req, err := client.getCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateOperationResponse{}, client.getCertificateOperationHandleError(resp)
	}
	return client.getCertificateOperationHandleResponse(resp)
}

// getCertificateOperationCreateRequest creates the GetCertificateOperation request.
func (client *KeyVaultClient) getCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateOperationOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateOperationHandleResponse handles the GetCertificateOperation response.
func (client *KeyVaultClient) getCertificateOperationHandleResponse(resp *azcore.Response) (CertificateOperationResponse, error) {
	var val *CertificateOperation
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateOperationResponse{}, err
	}
	return CertificateOperationResponse{RawResponse: resp.Response, CertificateOperation: val}, nil
}

// getCertificateOperationHandleError handles the GetCertificateOperation error response.
func (client *KeyVaultClient) getCertificateOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificatePolicy - The GetCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation
// requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificatePolicyOptions) (CertificatePolicyResponse, error) {
	req, err := client.getCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return CertificatePolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificatePolicyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificatePolicyResponse{}, client.getCertificatePolicyHandleError(resp)
	}
	return client.getCertificatePolicyHandleResponse(resp)
}

// getCertificatePolicyCreateRequest creates the GetCertificatePolicy request.
func (client *KeyVaultClient) getCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificatePolicyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificatePolicyHandleResponse handles the GetCertificatePolicy response.
func (client *KeyVaultClient) getCertificatePolicyHandleResponse(resp *azcore.Response) (CertificatePolicyResponse, error) {
	var val *CertificatePolicy
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificatePolicyResponse{}, err
	}
	return CertificatePolicyResponse{RawResponse: resp.Response, CertificatePolicy: val}, nil
}

// getCertificatePolicyHandleError handles the GetCertificatePolicy error response.
func (client *KeyVaultClient) getCertificatePolicyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificateVersions - The GetCertificateVersions operation returns the versions of a certificate in the specified key vault. This operation requires
// the certificates/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificateVersions(vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateVersionsOptions) CertificateListResultPager {
	return &certificateListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getCertificateVersionsCreateRequest(ctx, vaultBaseURL, certificateName, options)
		},
		responder: client.getCertificateVersionsHandleResponse,
		errorer:   client.getCertificateVersionsHandleError,
		advancer: func(ctx context.Context, resp CertificateListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.CertificateListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getCertificateVersionsCreateRequest creates the GetCertificateVersions request.
func (client *KeyVaultClient) getCertificateVersionsCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetCertificateVersionsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/versions"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificateVersionsHandleResponse handles the GetCertificateVersions response.
func (client *KeyVaultClient) getCertificateVersionsHandleResponse(resp *azcore.Response) (CertificateListResultResponse, error) {
	var val *CertificateListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateListResultResponse{}, err
	}
	return CertificateListResultResponse{RawResponse: resp.Response, CertificateListResult: val}, nil
}

// getCertificateVersionsHandleError handles the GetCertificateVersions error response.
func (client *KeyVaultClient) getCertificateVersionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCertificates - The GetCertificates operation returns the set of certificates resources in the specified key vault. This operation requires the certificates/list
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetCertificates(vaultBaseURL string, options *KeyVaultClientGetCertificatesOptions) CertificateListResultPager {
	return &certificateListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getCertificatesCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getCertificatesHandleResponse,
		errorer:   client.getCertificatesHandleError,
		advancer: func(ctx context.Context, resp CertificateListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.CertificateListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getCertificatesCreateRequest creates the GetCertificates request.
func (client *KeyVaultClient) getCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetCertificatesOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCertificatesHandleResponse handles the GetCertificates response.
func (client *KeyVaultClient) getCertificatesHandleResponse(resp *azcore.Response) (CertificateListResultResponse, error) {
	var val *CertificateListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateListResultResponse{}, err
	}
	return CertificateListResultResponse{RawResponse: resp.Response, CertificateListResult: val}, nil
}

// getCertificatesHandleError handles the GetCertificates error response.
func (client *KeyVaultClient) getCertificatesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedCertificate - The GetDeletedCertificate operation retrieves the deleted certificate information plus its attributes, such as retention interval,
// scheduled permanent deletion and the current deletion recovery level.
// This operation requires the certificates/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetDeletedCertificateOptions) (DeletedCertificateBundleResponse, error) {
	req, err := client.getDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return DeletedCertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedCertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedCertificateBundleResponse{}, client.getDeletedCertificateHandleError(resp)
	}
	return client.getDeletedCertificateHandleResponse(resp)
}

// getDeletedCertificateCreateRequest creates the GetDeletedCertificate request.
func (client *KeyVaultClient) getDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientGetDeletedCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedCertificateHandleResponse handles the GetDeletedCertificate response.
func (client *KeyVaultClient) getDeletedCertificateHandleResponse(resp *azcore.Response) (DeletedCertificateBundleResponse, error) {
	var val *DeletedCertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedCertificateBundleResponse{}, err
	}
	return DeletedCertificateBundleResponse{RawResponse: resp.Response, DeletedCertificateBundle: val}, nil
}

// getDeletedCertificateHandleError handles the GetDeletedCertificate error response.
func (client *KeyVaultClient) getDeletedCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedCertificates - The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a deleted state and ready
// for recovery or purging. This operation includes deletion-specific
// information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedCertificates(vaultBaseURL string, options *KeyVaultClientGetDeletedCertificatesOptions) DeletedCertificateListResultPager {
	return &deletedCertificateListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getDeletedCertificatesCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getDeletedCertificatesHandleResponse,
		errorer:   client.getDeletedCertificatesHandleError,
		advancer: func(ctx context.Context, resp DeletedCertificateListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeletedCertificateListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getDeletedCertificatesCreateRequest creates the GetDeletedCertificates request.
func (client *KeyVaultClient) getDeletedCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetDeletedCertificatesOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedCertificatesHandleResponse handles the GetDeletedCertificates response.
func (client *KeyVaultClient) getDeletedCertificatesHandleResponse(resp *azcore.Response) (DeletedCertificateListResultResponse, error) {
	var val *DeletedCertificateListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedCertificateListResultResponse{}, err
	}
	return DeletedCertificateListResultResponse{RawResponse: resp.Response, DeletedCertificateListResult: val}, nil
}

// getDeletedCertificatesHandleError handles the GetDeletedCertificates error response.
func (client *KeyVaultClient) getDeletedCertificatesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedKey - The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any vault, it will
// return an error if invoked on a non soft-delete enabled vault. This
// operation requires the keys/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientGetDeletedKeyOptions) (DeletedKeyBundleResponse, error) {
	req, err := client.getDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return DeletedKeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedKeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedKeyBundleResponse{}, client.getDeletedKeyHandleError(resp)
	}
	return client.getDeletedKeyHandleResponse(resp)
}

// getDeletedKeyCreateRequest creates the GetDeletedKey request.
func (client *KeyVaultClient) getDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientGetDeletedKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedKeyHandleResponse handles the GetDeletedKey response.
func (client *KeyVaultClient) getDeletedKeyHandleResponse(resp *azcore.Response) (DeletedKeyBundleResponse, error) {
	var val *DeletedKeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedKeyBundleResponse{}, err
	}
	return DeletedKeyBundleResponse{RawResponse: resp.Response, DeletedKeyBundle: val}, nil
}

// getDeletedKeyHandleError handles the GetDeletedKey error response.
func (client *KeyVaultClient) getDeletedKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedKeys - Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a deleted key. This operation
// includes deletion-specific information. The Get Deleted Keys
// operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on any vault, it will return an error if invoked on a
// non soft-delete enabled vault. This operation
// requires the keys/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedKeys(vaultBaseURL string, options *KeyVaultClientGetDeletedKeysOptions) DeletedKeyListResultPager {
	return &deletedKeyListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getDeletedKeysCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getDeletedKeysHandleResponse,
		errorer:   client.getDeletedKeysHandleError,
		advancer: func(ctx context.Context, resp DeletedKeyListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeletedKeyListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getDeletedKeysCreateRequest creates the GetDeletedKeys request.
func (client *KeyVaultClient) getDeletedKeysCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetDeletedKeysOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedKeysHandleResponse handles the GetDeletedKeys response.
func (client *KeyVaultClient) getDeletedKeysHandleResponse(resp *azcore.Response) (DeletedKeyListResultResponse, error) {
	var val *DeletedKeyListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedKeyListResultResponse{}, err
	}
	return DeletedKeyListResultResponse{RawResponse: resp.Response, DeletedKeyListResult: val}, nil
}

// getDeletedKeysHandleError handles the GetDeletedKeys error response.
func (client *KeyVaultClient) getDeletedKeysHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedSasDefinition - The Get Deleted SAS Definition operation returns the specified deleted SAS definition along with its attributes. This operation
// requires the storage/getsas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientGetDeletedSasDefinitionOptions) (DeletedSasDefinitionBundleResponse, error) {
	req, err := client.getDeletedSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return DeletedSasDefinitionBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedSasDefinitionBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedSasDefinitionBundleResponse{}, client.getDeletedSasDefinitionHandleError(resp)
	}
	return client.getDeletedSasDefinitionHandleResponse(resp)
}

// getDeletedSasDefinitionCreateRequest creates the GetDeletedSasDefinition request.
func (client *KeyVaultClient) getDeletedSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientGetDeletedSasDefinitionOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedSasDefinitionHandleResponse handles the GetDeletedSasDefinition response.
func (client *KeyVaultClient) getDeletedSasDefinitionHandleResponse(resp *azcore.Response) (DeletedSasDefinitionBundleResponse, error) {
	var val *DeletedSasDefinitionBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedSasDefinitionBundleResponse{}, err
	}
	return DeletedSasDefinitionBundleResponse{RawResponse: resp.Response, DeletedSasDefinitionBundle: val}, nil
}

// getDeletedSasDefinitionHandleError handles the GetDeletedSasDefinition error response.
func (client *KeyVaultClient) getDeletedSasDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedSasDefinitions - The Get Deleted Sas Definitions operation returns the SAS definitions that have been deleted for a vault enabled for soft-delete.
// This operation requires the storage/listsas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedSasDefinitions(vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetDeletedSasDefinitionsOptions) DeletedSasDefinitionListResultPager {
	return &deletedSasDefinitionListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getDeletedSasDefinitionsCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
		},
		responder: client.getDeletedSasDefinitionsHandleResponse,
		errorer:   client.getDeletedSasDefinitionsHandleError,
		advancer: func(ctx context.Context, resp DeletedSasDefinitionListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeletedSasDefinitionListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getDeletedSasDefinitionsCreateRequest creates the GetDeletedSasDefinitions request.
func (client *KeyVaultClient) getDeletedSasDefinitionsCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetDeletedSasDefinitionsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedSasDefinitionsHandleResponse handles the GetDeletedSasDefinitions response.
func (client *KeyVaultClient) getDeletedSasDefinitionsHandleResponse(resp *azcore.Response) (DeletedSasDefinitionListResultResponse, error) {
	var val *DeletedSasDefinitionListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedSasDefinitionListResultResponse{}, err
	}
	return DeletedSasDefinitionListResultResponse{RawResponse: resp.Response, DeletedSasDefinitionListResult: val}, nil
}

// getDeletedSasDefinitionsHandleError handles the GetDeletedSasDefinitions error response.
func (client *KeyVaultClient) getDeletedSasDefinitionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedSecret - The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This operation requires the secrets/get
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientGetDeletedSecretOptions) (DeletedSecretBundleResponse, error) {
	req, err := client.getDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return DeletedSecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedSecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedSecretBundleResponse{}, client.getDeletedSecretHandleError(resp)
	}
	return client.getDeletedSecretHandleResponse(resp)
}

// getDeletedSecretCreateRequest creates the GetDeletedSecret request.
func (client *KeyVaultClient) getDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientGetDeletedSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedSecretHandleResponse handles the GetDeletedSecret response.
func (client *KeyVaultClient) getDeletedSecretHandleResponse(resp *azcore.Response) (DeletedSecretBundleResponse, error) {
	var val *DeletedSecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedSecretBundleResponse{}, err
	}
	return DeletedSecretBundleResponse{RawResponse: resp.Response, DeletedSecretBundle: val}, nil
}

// getDeletedSecretHandleError handles the GetDeletedSecret error response.
func (client *KeyVaultClient) getDeletedSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedSecrets - The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled for soft-delete. This operation
// requires the secrets/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedSecrets(vaultBaseURL string, options *KeyVaultClientGetDeletedSecretsOptions) DeletedSecretListResultPager {
	return &deletedSecretListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getDeletedSecretsCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getDeletedSecretsHandleResponse,
		errorer:   client.getDeletedSecretsHandleError,
		advancer: func(ctx context.Context, resp DeletedSecretListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeletedSecretListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getDeletedSecretsCreateRequest creates the GetDeletedSecrets request.
func (client *KeyVaultClient) getDeletedSecretsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetDeletedSecretsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedSecretsHandleResponse handles the GetDeletedSecrets response.
func (client *KeyVaultClient) getDeletedSecretsHandleResponse(resp *azcore.Response) (DeletedSecretListResultResponse, error) {
	var val *DeletedSecretListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedSecretListResultResponse{}, err
	}
	return DeletedSecretListResultResponse{RawResponse: resp.Response, DeletedSecretListResult: val}, nil
}

// getDeletedSecretsHandleError handles the GetDeletedSecrets error response.
func (client *KeyVaultClient) getDeletedSecretsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedStorageAccount - The Get Deleted Storage Account operation returns the specified deleted storage account along with its attributes. This operation
// requires the storage/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetDeletedStorageAccountOptions) (DeletedStorageBundleResponse, error) {
	req, err := client.getDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return DeletedStorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeletedStorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeletedStorageBundleResponse{}, client.getDeletedStorageAccountHandleError(resp)
	}
	return client.getDeletedStorageAccountHandleResponse(resp)
}

// getDeletedStorageAccountCreateRequest creates the GetDeletedStorageAccount request.
func (client *KeyVaultClient) getDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetDeletedStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedStorageAccountHandleResponse handles the GetDeletedStorageAccount response.
func (client *KeyVaultClient) getDeletedStorageAccountHandleResponse(resp *azcore.Response) (DeletedStorageBundleResponse, error) {
	var val *DeletedStorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedStorageBundleResponse{}, err
	}
	return DeletedStorageBundleResponse{RawResponse: resp.Response, DeletedStorageBundle: val}, nil
}

// getDeletedStorageAccountHandleError handles the GetDeletedStorageAccount error response.
func (client *KeyVaultClient) getDeletedStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDeletedStorageAccounts - The Get Deleted Storage Accounts operation returns the storage accounts that have been deleted for a vault enabled for soft-delete.
// This operation requires the storage/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetDeletedStorageAccounts(vaultBaseURL string, options *KeyVaultClientGetDeletedStorageAccountsOptions) DeletedStorageListResultPager {
	return &deletedStorageListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getDeletedStorageAccountsCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getDeletedStorageAccountsHandleResponse,
		errorer:   client.getDeletedStorageAccountsHandleError,
		advancer: func(ctx context.Context, resp DeletedStorageListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeletedStorageListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getDeletedStorageAccountsCreateRequest creates the GetDeletedStorageAccounts request.
func (client *KeyVaultClient) getDeletedStorageAccountsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetDeletedStorageAccountsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDeletedStorageAccountsHandleResponse handles the GetDeletedStorageAccounts response.
func (client *KeyVaultClient) getDeletedStorageAccountsHandleResponse(resp *azcore.Response) (DeletedStorageListResultResponse, error) {
	var val *DeletedStorageListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeletedStorageListResultResponse{}, err
	}
	return DeletedStorageListResultResponse{RawResponse: resp.Response, DeletedStorageListResult: val}, nil
}

// getDeletedStorageAccountsHandleError handles the GetDeletedStorageAccounts error response.
func (client *KeyVaultClient) getDeletedStorageAccountsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetKey - The get key operation is applicable to all key types. If the requested key is symmetric, then no key material is released in the response. This
// operation requires the keys/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, options *KeyVaultClientGetKeyOptions) (KeyBundleResponse, error) {
	req, err := client.getKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, options)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyBundleResponse{}, client.getKeyHandleError(resp)
	}
	return client.getKeyHandleResponse(resp)
}

// getKeyCreateRequest creates the GetKey request.
func (client *KeyVaultClient) getKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, options *KeyVaultClientGetKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getKeyHandleResponse handles the GetKey response.
func (client *KeyVaultClient) getKeyHandleResponse(resp *azcore.Response) (KeyBundleResponse, error) {
	var val *KeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyBundleResponse{}, err
	}
	return KeyBundleResponse{RawResponse: resp.Response, KeyBundle: val}, nil
}

// getKeyHandleError handles the GetKey error response.
func (client *KeyVaultClient) getKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetKeyVersions - The full key identifier, attributes, and tags are provided in the response. This operation requires the keys/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetKeyVersions(vaultBaseURL string, keyName string, options *KeyVaultClientGetKeyVersionsOptions) KeyListResultPager {
	return &keyListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getKeyVersionsCreateRequest(ctx, vaultBaseURL, keyName, options)
		},
		responder: client.getKeyVersionsHandleResponse,
		errorer:   client.getKeyVersionsHandleError,
		advancer: func(ctx context.Context, resp KeyListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.KeyListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getKeyVersionsCreateRequest creates the GetKeyVersions request.
func (client *KeyVaultClient) getKeyVersionsCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientGetKeyVersionsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/versions"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getKeyVersionsHandleResponse handles the GetKeyVersions response.
func (client *KeyVaultClient) getKeyVersionsHandleResponse(resp *azcore.Response) (KeyListResultResponse, error) {
	var val *KeyListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyListResultResponse{}, err
	}
	return KeyListResultResponse{RawResponse: resp.Response, KeyListResult: val}, nil
}

// getKeyVersionsHandleError handles the GetKeyVersions error response.
func (client *KeyVaultClient) getKeyVersionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetKeys - Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part of a stored key. The LIST operation is
// applicable to all key types, however only the base key
// identifier, attributes, and tags are provided in the response. Individual versions of a key are not listed in the response. This operation requires the
// keys/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetKeys(vaultBaseURL string, options *KeyVaultClientGetKeysOptions) KeyListResultPager {
	return &keyListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getKeysCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getKeysHandleResponse,
		errorer:   client.getKeysHandleError,
		advancer: func(ctx context.Context, resp KeyListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.KeyListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getKeysCreateRequest creates the GetKeys request.
func (client *KeyVaultClient) getKeysCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetKeysOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getKeysHandleResponse handles the GetKeys response.
func (client *KeyVaultClient) getKeysHandleResponse(resp *azcore.Response) (KeyListResultResponse, error) {
	var val *KeyListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyListResultResponse{}, err
	}
	return KeyListResultResponse{RawResponse: resp.Response, KeyListResult: val}, nil
}

// getKeysHandleError handles the GetKeys error response.
func (client *KeyVaultClient) getKeysHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSasDefinition - Gets information about a SAS definition for the specified storage account. This operation requires the storage/getsas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientGetSasDefinitionOptions) (SasDefinitionBundleResponse, error) {
	req, err := client.getSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SasDefinitionBundleResponse{}, client.getSasDefinitionHandleError(resp)
	}
	return client.getSasDefinitionHandleResponse(resp)
}

// getSasDefinitionCreateRequest creates the GetSasDefinition request.
func (client *KeyVaultClient) getSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientGetSasDefinitionOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSasDefinitionHandleResponse handles the GetSasDefinition response.
func (client *KeyVaultClient) getSasDefinitionHandleResponse(resp *azcore.Response) (SasDefinitionBundleResponse, error) {
	var val *SasDefinitionBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	return SasDefinitionBundleResponse{RawResponse: resp.Response, SasDefinitionBundle: val}, nil
}

// getSasDefinitionHandleError handles the GetSasDefinition error response.
func (client *KeyVaultClient) getSasDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSasDefinitions - List storage SAS definitions for the given storage account. This operation requires the storage/listsas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetSasDefinitions(vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetSasDefinitionsOptions) SasDefinitionListResultPager {
	return &sasDefinitionListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSasDefinitionsCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
		},
		responder: client.getSasDefinitionsHandleResponse,
		errorer:   client.getSasDefinitionsHandleError,
		advancer: func(ctx context.Context, resp SasDefinitionListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SasDefinitionListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSasDefinitionsCreateRequest creates the GetSasDefinitions request.
func (client *KeyVaultClient) getSasDefinitionsCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetSasDefinitionsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSasDefinitionsHandleResponse handles the GetSasDefinitions response.
func (client *KeyVaultClient) getSasDefinitionsHandleResponse(resp *azcore.Response) (SasDefinitionListResultResponse, error) {
	var val *SasDefinitionListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SasDefinitionListResultResponse{}, err
	}
	return SasDefinitionListResultResponse{RawResponse: resp.Response, SasDefinitionListResult: val}, nil
}

// getSasDefinitionsHandleError handles the GetSasDefinitions error response.
func (client *KeyVaultClient) getSasDefinitionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSecret - The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetSecret(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, options *KeyVaultClientGetSecretOptions) (SecretBundleResponse, error) {
	req, err := client.getSecretCreateRequest(ctx, vaultBaseURL, secretName, secretVersion, options)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SecretBundleResponse{}, client.getSecretHandleError(resp)
	}
	return client.getSecretHandleResponse(resp)
}

// getSecretCreateRequest creates the GetSecret request.
func (client *KeyVaultClient) getSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, options *KeyVaultClientGetSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/{secret-version}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-version}", url.PathEscape(secretVersion))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSecretHandleResponse handles the GetSecret response.
func (client *KeyVaultClient) getSecretHandleResponse(resp *azcore.Response) (SecretBundleResponse, error) {
	var val *SecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretBundleResponse{}, err
	}
	return SecretBundleResponse{RawResponse: resp.Response, SecretBundle: val}, nil
}

// getSecretHandleError handles the GetSecret error response.
func (client *KeyVaultClient) getSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSecretVersions - The full secret identifier and attributes are provided in the response. No values are returned for the secrets. This operations requires
// the secrets/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetSecretVersions(vaultBaseURL string, secretName string, options *KeyVaultClientGetSecretVersionsOptions) SecretListResultPager {
	return &secretListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSecretVersionsCreateRequest(ctx, vaultBaseURL, secretName, options)
		},
		responder: client.getSecretVersionsHandleResponse,
		errorer:   client.getSecretVersionsHandleError,
		advancer: func(ctx context.Context, resp SecretListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SecretListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSecretVersionsCreateRequest creates the GetSecretVersions request.
func (client *KeyVaultClient) getSecretVersionsCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientGetSecretVersionsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/versions"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSecretVersionsHandleResponse handles the GetSecretVersions response.
func (client *KeyVaultClient) getSecretVersionsHandleResponse(resp *azcore.Response) (SecretListResultResponse, error) {
	var val *SecretListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretListResultResponse{}, err
	}
	return SecretListResultResponse{RawResponse: resp.Response, SecretListResult: val}, nil
}

// getSecretVersionsHandleError handles the GetSecretVersions error response.
func (client *KeyVaultClient) getSecretVersionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSecrets - The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier and its attributes are provided in
// the response. Individual secret versions are not listed in the
// response. This operation requires the secrets/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetSecrets(vaultBaseURL string, options *KeyVaultClientGetSecretsOptions) SecretListResultPager {
	return &secretListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSecretsCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getSecretsHandleResponse,
		errorer:   client.getSecretsHandleError,
		advancer: func(ctx context.Context, resp SecretListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.SecretListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSecretsCreateRequest creates the GetSecrets request.
func (client *KeyVaultClient) getSecretsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetSecretsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSecretsHandleResponse handles the GetSecrets response.
func (client *KeyVaultClient) getSecretsHandleResponse(resp *azcore.Response) (SecretListResultResponse, error) {
	var val *SecretListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretListResultResponse{}, err
	}
	return SecretListResultResponse{RawResponse: resp.Response, SecretListResult: val}, nil
}

// getSecretsHandleError handles the GetSecrets error response.
func (client *KeyVaultClient) getSecretsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetStorageAccount - Gets information about a specified storage account. This operation requires the storage/get permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetStorageAccountOptions) (StorageBundleResponse, error) {
	req, err := client.getStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageBundleResponse{}, client.getStorageAccountHandleError(resp)
	}
	return client.getStorageAccountHandleResponse(resp)
}

// getStorageAccountCreateRequest creates the GetStorageAccount request.
func (client *KeyVaultClient) getStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientGetStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getStorageAccountHandleResponse handles the GetStorageAccount response.
func (client *KeyVaultClient) getStorageAccountHandleResponse(resp *azcore.Response) (StorageBundleResponse, error) {
	var val *StorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageBundleResponse{}, err
	}
	return StorageBundleResponse{RawResponse: resp.Response, StorageBundle: val}, nil
}

// getStorageAccountHandleError handles the GetStorageAccount error response.
func (client *KeyVaultClient) getStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetStorageAccounts - List storage accounts managed by the specified key vault. This operation requires the storage/list permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) GetStorageAccounts(vaultBaseURL string, options *KeyVaultClientGetStorageAccountsOptions) StorageListResultPager {
	return &storageListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getStorageAccountsCreateRequest(ctx, vaultBaseURL, options)
		},
		responder: client.getStorageAccountsHandleResponse,
		errorer:   client.getStorageAccountsHandleError,
		advancer: func(ctx context.Context, resp StorageListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.StorageListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getStorageAccountsCreateRequest creates the GetStorageAccounts request.
func (client *KeyVaultClient) getStorageAccountsCreateRequest(ctx context.Context, vaultBaseURL string, options *KeyVaultClientGetStorageAccountsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getStorageAccountsHandleResponse handles the GetStorageAccounts response.
func (client *KeyVaultClient) getStorageAccountsHandleResponse(resp *azcore.Response) (StorageListResultResponse, error) {
	var val *StorageListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageListResultResponse{}, err
	}
	return StorageListResultResponse{RawResponse: resp.Response, StorageListResult: val}, nil
}

// getStorageAccountsHandleError handles the GetStorageAccounts error response.
func (client *KeyVaultClient) getStorageAccountsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ImportCertificate - Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either
// PFX or PEM format. If the certificate is in PEM format the PEM
// file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) ImportCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *KeyVaultClientImportCertificateOptions) (CertificateBundleResponse, error) {
	req, err := client.importCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateBundleResponse{}, client.importCertificateHandleError(resp)
	}
	return client.importCertificateHandleResponse(resp)
}

// importCertificateCreateRequest creates the ImportCertificate request.
func (client *KeyVaultClient) importCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *KeyVaultClientImportCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/import"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// importCertificateHandleResponse handles the ImportCertificate response.
func (client *KeyVaultClient) importCertificateHandleResponse(resp *azcore.Response) (CertificateBundleResponse, error) {
	var val *CertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateBundleResponse{}, err
	}
	return CertificateBundleResponse{RawResponse: resp.Response, CertificateBundle: val}, nil
}

// importCertificateHandleError handles the ImportCertificate error response.
func (client *KeyVaultClient) importCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ImportKey - The import key operation may be used to import any key type into an Azure Key Vault. If the named key already exists, Azure Key Vault creates
// a new version of the key. This operation requires the
// keys/import permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) ImportKey(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyImportParameters, options *KeyVaultClientImportKeyOptions) (KeyBundleResponse, error) {
	req, err := client.importKeyCreateRequest(ctx, vaultBaseURL, keyName, parameters, options)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyBundleResponse{}, client.importKeyHandleError(resp)
	}
	return client.importKeyHandleResponse(resp)
}

// importKeyCreateRequest creates the ImportKey request.
func (client *KeyVaultClient) importKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyImportParameters, options *KeyVaultClientImportKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// importKeyHandleResponse handles the ImportKey response.
func (client *KeyVaultClient) importKeyHandleResponse(resp *azcore.Response) (KeyBundleResponse, error) {
	var val *KeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyBundleResponse{}, err
	}
	return KeyBundleResponse{RawResponse: resp.Response, KeyBundle: val}, nil
}

// importKeyHandleError handles the ImportKey error response.
func (client *KeyVaultClient) importKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// MergeCertificate - The MergeCertificate operation performs the merging of a certificate or certificate chain with a key pair currently available in the
// service. This operation requires the certificates/create
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) MergeCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *KeyVaultClientMergeCertificateOptions) (CertificateBundleResponse, error) {
	req, err := client.mergeCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return CertificateBundleResponse{}, client.mergeCertificateHandleError(resp)
	}
	return client.mergeCertificateHandleResponse(resp)
}

// mergeCertificateCreateRequest creates the MergeCertificate request.
func (client *KeyVaultClient) mergeCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *KeyVaultClientMergeCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending/merge"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// mergeCertificateHandleResponse handles the MergeCertificate response.
func (client *KeyVaultClient) mergeCertificateHandleResponse(resp *azcore.Response) (CertificateBundleResponse, error) {
	var val *CertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateBundleResponse{}, err
	}
	return CertificateBundleResponse{RawResponse: resp.Response, CertificateBundle: val}, nil
}

// mergeCertificateHandleError handles the MergeCertificate error response.
func (client *KeyVaultClient) mergeCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PurgeDeletedCertificate - The PurgeDeletedCertificate operation performs an irreversible deletion of the specified certificate, without possibility for
// recovery. The operation is not available if the recovery level does not
// specify 'Purgeable'. This operation requires the certificate/purge permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) PurgeDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientPurgeDeletedCertificateOptions) (*http.Response, error) {
	req, err := client.purgeDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.purgeDeletedCertificateHandleError(resp)
	}
	return resp.Response, nil
}

// purgeDeletedCertificateCreateRequest creates the PurgeDeletedCertificate request.
func (client *KeyVaultClient) purgeDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientPurgeDeletedCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// purgeDeletedCertificateHandleError handles the PurgeDeletedCertificate error response.
func (client *KeyVaultClient) purgeDeletedCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PurgeDeletedKey - The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be invoked on any vault, it will
// return an error if invoked on a non soft-delete enabled vault.
// This operation requires the keys/purge permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) PurgeDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientPurgeDeletedKeyOptions) (*http.Response, error) {
	req, err := client.purgeDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.purgeDeletedKeyHandleError(resp)
	}
	return resp.Response, nil
}

// purgeDeletedKeyCreateRequest creates the PurgeDeletedKey request.
func (client *KeyVaultClient) purgeDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientPurgeDeletedKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// purgeDeletedKeyHandleError handles the PurgeDeletedKey error response.
func (client *KeyVaultClient) purgeDeletedKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PurgeDeletedSecret - The purge deleted secret operation removes the secret permanently, without the possibility of recovery. This operation can only
// be enabled on a soft-delete enabled vault. This operation requires the
// secrets/purge permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) PurgeDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientPurgeDeletedSecretOptions) (*http.Response, error) {
	req, err := client.purgeDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.purgeDeletedSecretHandleError(resp)
	}
	return resp.Response, nil
}

// purgeDeletedSecretCreateRequest creates the PurgeDeletedSecret request.
func (client *KeyVaultClient) purgeDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientPurgeDeletedSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// purgeDeletedSecretHandleError handles the PurgeDeletedSecret error response.
func (client *KeyVaultClient) purgeDeletedSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PurgeDeletedStorageAccount - The purge deleted storage account operation removes the secret permanently, without the possibility of recovery. This operation
// can only be performed on a soft-delete enabled vault. This operation
// requires the storage/purge permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) PurgeDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientPurgeDeletedStorageAccountOptions) (*http.Response, error) {
	req, err := client.purgeDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.purgeDeletedStorageAccountHandleError(resp)
	}
	return resp.Response, nil
}

// purgeDeletedStorageAccountCreateRequest creates the PurgeDeletedStorageAccount request.
func (client *KeyVaultClient) purgeDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientPurgeDeletedStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// purgeDeletedStorageAccountHandleError handles the PurgeDeletedStorageAccount error response.
func (client *KeyVaultClient) purgeDeletedStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverDeletedCertificate - The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The operation is applicable in vaults
// enabled for soft-delete, and must be issued during the retention interval
// (available in the deleted certificate's attributes). This operation requires the certificates/recover permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RecoverDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientRecoverDeletedCertificateOptions) (CertificateBundleResponse, error) {
	req, err := client.recoverDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateBundleResponse{}, client.recoverDeletedCertificateHandleError(resp)
	}
	return client.recoverDeletedCertificateHandleResponse(resp)
}

// recoverDeletedCertificateCreateRequest creates the RecoverDeletedCertificate request.
func (client *KeyVaultClient) recoverDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *KeyVaultClientRecoverDeletedCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}/recover"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverDeletedCertificateHandleResponse handles the RecoverDeletedCertificate response.
func (client *KeyVaultClient) recoverDeletedCertificateHandleResponse(resp *azcore.Response) (CertificateBundleResponse, error) {
	var val *CertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateBundleResponse{}, err
	}
	return CertificateBundleResponse{RawResponse: resp.Response, CertificateBundle: val}, nil
}

// recoverDeletedCertificateHandleError handles the RecoverDeletedCertificate error response.
func (client *KeyVaultClient) recoverDeletedCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverDeletedKey - The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It recovers the deleted key back
// to its latest version under /keys. An attempt to recover an non-deleted
// key will return an error. Consider this the inverse of the delete operation on soft-delete enabled vaults. This operation requires the keys/recover permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RecoverDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientRecoverDeletedKeyOptions) (KeyBundleResponse, error) {
	req, err := client.recoverDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyBundleResponse{}, client.recoverDeletedKeyHandleError(resp)
	}
	return client.recoverDeletedKeyHandleResponse(resp)
}

// recoverDeletedKeyCreateRequest creates the RecoverDeletedKey request.
func (client *KeyVaultClient) recoverDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientRecoverDeletedKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}/recover"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverDeletedKeyHandleResponse handles the RecoverDeletedKey response.
func (client *KeyVaultClient) recoverDeletedKeyHandleResponse(resp *azcore.Response) (KeyBundleResponse, error) {
	var val *KeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyBundleResponse{}, err
	}
	return KeyBundleResponse{RawResponse: resp.Response, KeyBundle: val}, nil
}

// recoverDeletedKeyHandleError handles the RecoverDeletedKey error response.
func (client *KeyVaultClient) recoverDeletedKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverDeletedSasDefinition - Recovers the deleted SAS definition for the specified storage account. This operation can only be performed on a soft-delete
// enabled vault. This operation requires the storage/recover permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RecoverDeletedSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientRecoverDeletedSasDefinitionOptions) (SasDefinitionBundleResponse, error) {
	req, err := client.recoverDeletedSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SasDefinitionBundleResponse{}, client.recoverDeletedSasDefinitionHandleError(resp)
	}
	return client.recoverDeletedSasDefinitionHandleResponse(resp)
}

// recoverDeletedSasDefinitionCreateRequest creates the RecoverDeletedSasDefinition request.
func (client *KeyVaultClient) recoverDeletedSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *KeyVaultClientRecoverDeletedSasDefinitionOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverDeletedSasDefinitionHandleResponse handles the RecoverDeletedSasDefinition response.
func (client *KeyVaultClient) recoverDeletedSasDefinitionHandleResponse(resp *azcore.Response) (SasDefinitionBundleResponse, error) {
	var val *SasDefinitionBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	return SasDefinitionBundleResponse{RawResponse: resp.Response, SasDefinitionBundle: val}, nil
}

// recoverDeletedSasDefinitionHandleError handles the RecoverDeletedSasDefinition error response.
func (client *KeyVaultClient) recoverDeletedSasDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverDeletedSecret - Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete enabled vault. This
// operation requires the secrets/recover permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RecoverDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientRecoverDeletedSecretOptions) (SecretBundleResponse, error) {
	req, err := client.recoverDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SecretBundleResponse{}, client.recoverDeletedSecretHandleError(resp)
	}
	return client.recoverDeletedSecretHandleResponse(resp)
}

// recoverDeletedSecretCreateRequest creates the RecoverDeletedSecret request.
func (client *KeyVaultClient) recoverDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *KeyVaultClientRecoverDeletedSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}/recover"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverDeletedSecretHandleResponse handles the RecoverDeletedSecret response.
func (client *KeyVaultClient) recoverDeletedSecretHandleResponse(resp *azcore.Response) (SecretBundleResponse, error) {
	var val *SecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretBundleResponse{}, err
	}
	return SecretBundleResponse{RawResponse: resp.Response, SecretBundle: val}, nil
}

// recoverDeletedSecretHandleError handles the RecoverDeletedSecret error response.
func (client *KeyVaultClient) recoverDeletedSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RecoverDeletedStorageAccount - Recovers the deleted storage account in the specified vault. This operation can only be performed on a soft-delete enabled
// vault. This operation requires the storage/recover permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RecoverDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientRecoverDeletedStorageAccountOptions) (StorageBundleResponse, error) {
	req, err := client.recoverDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageBundleResponse{}, client.recoverDeletedStorageAccountHandleError(resp)
	}
	return client.recoverDeletedStorageAccountHandleResponse(resp)
}

// recoverDeletedStorageAccountCreateRequest creates the RecoverDeletedStorageAccount request.
func (client *KeyVaultClient) recoverDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *KeyVaultClientRecoverDeletedStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/recover"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// recoverDeletedStorageAccountHandleResponse handles the RecoverDeletedStorageAccount response.
func (client *KeyVaultClient) recoverDeletedStorageAccountHandleResponse(resp *azcore.Response) (StorageBundleResponse, error) {
	var val *StorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageBundleResponse{}, err
	}
	return StorageBundleResponse{RawResponse: resp.Response, StorageBundle: val}, nil
}

// recoverDeletedStorageAccountHandleError handles the RecoverDeletedStorageAccount error response.
func (client *KeyVaultClient) recoverDeletedStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RegenerateStorageAccountKey - Regenerates the specified key value for the given storage account. This operation requires the storage/regeneratekey permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RegenerateStorageAccountKey(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountRegenerteKeyParameters, options *KeyVaultClientRegenerateStorageAccountKeyOptions) (StorageBundleResponse, error) {
	req, err := client.regenerateStorageAccountKeyCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageBundleResponse{}, client.regenerateStorageAccountKeyHandleError(resp)
	}
	return client.regenerateStorageAccountKeyHandleResponse(resp)
}

// regenerateStorageAccountKeyCreateRequest creates the RegenerateStorageAccountKey request.
func (client *KeyVaultClient) regenerateStorageAccountKeyCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountRegenerteKeyParameters, options *KeyVaultClientRegenerateStorageAccountKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/regeneratekey"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// regenerateStorageAccountKeyHandleResponse handles the RegenerateStorageAccountKey response.
func (client *KeyVaultClient) regenerateStorageAccountKeyHandleResponse(resp *azcore.Response) (StorageBundleResponse, error) {
	var val *StorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageBundleResponse{}, err
	}
	return StorageBundleResponse{RawResponse: resp.Response, StorageBundle: val}, nil
}

// regenerateStorageAccountKeyHandleError handles the RegenerateStorageAccountKey error response.
func (client *KeyVaultClient) regenerateStorageAccountKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RestoreCertificate - Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RestoreCertificate(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *KeyVaultClientRestoreCertificateOptions) (CertificateBundleResponse, error) {
	req, err := client.restoreCertificateCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateBundleResponse{}, client.restoreCertificateHandleError(resp)
	}
	return client.restoreCertificateHandleResponse(resp)
}

// restoreCertificateCreateRequest creates the RestoreCertificate request.
func (client *KeyVaultClient) restoreCertificateCreateRequest(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *KeyVaultClientRestoreCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/restore"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// restoreCertificateHandleResponse handles the RestoreCertificate response.
func (client *KeyVaultClient) restoreCertificateHandleResponse(resp *azcore.Response) (CertificateBundleResponse, error) {
	var val *CertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateBundleResponse{}, err
	}
	return CertificateBundleResponse{RawResponse: resp.Response, CertificateBundle: val}, nil
}

// restoreCertificateHandleError handles the RestoreCertificate error response.
func (client *KeyVaultClient) restoreCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RestoreKey - Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes and access control policies.
// The RESTORE operation may be used to import a previously backed
// up key. Individual versions of a key cannot be restored. The key is restored in its entirety with the same key name as it had when it was backed up.
// If the key name is not available in the target Key
// Vault, the RESTORE operation will be rejected. While the key name is retained during restore, the final key identifier will change if the key is restored
// to a different vault. Restore will restore all
// versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key Vault must be owned by the same Microsoft
// Azure Subscription as the source Key Vault
// The user must have RESTORE permission in the target Key Vault. This operation requires the keys/restore permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RestoreKey(ctx context.Context, vaultBaseURL string, parameters KeyRestoreParameters, options *KeyVaultClientRestoreKeyOptions) (KeyBundleResponse, error) {
	req, err := client.restoreKeyCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyBundleResponse{}, client.restoreKeyHandleError(resp)
	}
	return client.restoreKeyHandleResponse(resp)
}

// restoreKeyCreateRequest creates the RestoreKey request.
func (client *KeyVaultClient) restoreKeyCreateRequest(ctx context.Context, vaultBaseURL string, parameters KeyRestoreParameters, options *KeyVaultClientRestoreKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/restore"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// restoreKeyHandleResponse handles the RestoreKey response.
func (client *KeyVaultClient) restoreKeyHandleResponse(resp *azcore.Response) (KeyBundleResponse, error) {
	var val *KeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyBundleResponse{}, err
	}
	return KeyBundleResponse{RawResponse: resp.Response, KeyBundle: val}, nil
}

// restoreKeyHandleError handles the RestoreKey error response.
func (client *KeyVaultClient) restoreKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RestoreSecret - Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RestoreSecret(ctx context.Context, vaultBaseURL string, parameters SecretRestoreParameters, options *KeyVaultClientRestoreSecretOptions) (SecretBundleResponse, error) {
	req, err := client.restoreSecretCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SecretBundleResponse{}, client.restoreSecretHandleError(resp)
	}
	return client.restoreSecretHandleResponse(resp)
}

// restoreSecretCreateRequest creates the RestoreSecret request.
func (client *KeyVaultClient) restoreSecretCreateRequest(ctx context.Context, vaultBaseURL string, parameters SecretRestoreParameters, options *KeyVaultClientRestoreSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/restore"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// restoreSecretHandleResponse handles the RestoreSecret response.
func (client *KeyVaultClient) restoreSecretHandleResponse(resp *azcore.Response) (SecretBundleResponse, error) {
	var val *SecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretBundleResponse{}, err
	}
	return SecretBundleResponse{RawResponse: resp.Response, SecretBundle: val}, nil
}

// restoreSecretHandleError handles the RestoreSecret error response.
func (client *KeyVaultClient) restoreSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RestoreStatus - Returns the status of restore operation
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RestoreStatus(ctx context.Context, vaultBaseURL string, jobID string, options *KeyVaultClientRestoreStatusOptions) (RestoreOperationResponse, error) {
	req, err := client.restoreStatusCreateRequest(ctx, vaultBaseURL, jobID, options)
	if err != nil {
		return RestoreOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RestoreOperationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RestoreOperationResponse{}, client.restoreStatusHandleError(resp)
	}
	return client.restoreStatusHandleResponse(resp)
}

// restoreStatusCreateRequest creates the RestoreStatus request.
func (client *KeyVaultClient) restoreStatusCreateRequest(ctx context.Context, vaultBaseURL string, jobID string, options *KeyVaultClientRestoreStatusOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/restore/{jobId}/pending"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// restoreStatusHandleResponse handles the RestoreStatus response.
func (client *KeyVaultClient) restoreStatusHandleResponse(resp *azcore.Response) (RestoreOperationResponse, error) {
	var val *RestoreOperation
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RestoreOperationResponse{}, err
	}
	return RestoreOperationResponse{RawResponse: resp.Response, RestoreOperation: val}, nil
}

// restoreStatusHandleError handles the RestoreStatus error response.
func (client *KeyVaultClient) restoreStatusHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// RestoreStorageAccount - Restores a backed up storage account to a vault. This operation requires the storage/restore permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) RestoreStorageAccount(ctx context.Context, vaultBaseURL string, parameters StorageRestoreParameters, options *KeyVaultClientRestoreStorageAccountOptions) (StorageBundleResponse, error) {
	req, err := client.restoreStorageAccountCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageBundleResponse{}, client.restoreStorageAccountHandleError(resp)
	}
	return client.restoreStorageAccountHandleResponse(resp)
}

// restoreStorageAccountCreateRequest creates the RestoreStorageAccount request.
func (client *KeyVaultClient) restoreStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, parameters StorageRestoreParameters, options *KeyVaultClientRestoreStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/restore"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// restoreStorageAccountHandleResponse handles the RestoreStorageAccount response.
func (client *KeyVaultClient) restoreStorageAccountHandleResponse(resp *azcore.Response) (StorageBundleResponse, error) {
	var val *StorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageBundleResponse{}, err
	}
	return StorageBundleResponse{RawResponse: resp.Response, StorageBundle: val}, nil
}

// restoreStorageAccountHandleError handles the RestoreStorageAccount error response.
func (client *KeyVaultClient) restoreStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginSelectiveKeyRestoreOperation - Restores all key versions of a given key using user supplied SAS token pointing to a previously stored Azure Blob
// storage backup folder
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) BeginSelectiveKeyRestoreOperation(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientBeginSelectiveKeyRestoreOperationOptions) (SelectiveKeyRestoreOperationPollerResponse, error) {
	resp, err := client.selectiveKeyRestoreOperation(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return SelectiveKeyRestoreOperationPollerResponse{}, err
	}
	result := SelectiveKeyRestoreOperationPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("KeyVaultClient.SelectiveKeyRestoreOperation", resp, client.con.Pipeline(), client.selectiveKeyRestoreOperationHandleError)
	if err != nil {
		return SelectiveKeyRestoreOperationPollerResponse{}, err
	}
	poller := &selectiveKeyRestoreOperationPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SelectiveKeyRestoreOperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeSelectiveKeyRestoreOperation creates a new SelectiveKeyRestoreOperationPoller from the specified resume token.
// token - The value must come from a previous call to SelectiveKeyRestoreOperationPoller.ResumeToken().
func (client *KeyVaultClient) ResumeSelectiveKeyRestoreOperation(ctx context.Context, token string) (SelectiveKeyRestoreOperationPollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("KeyVaultClient.SelectiveKeyRestoreOperation", token, client.con.Pipeline(), client.selectiveKeyRestoreOperationHandleError)
	if err != nil {
		return SelectiveKeyRestoreOperationPollerResponse{}, err
	}
	poller := &selectiveKeyRestoreOperationPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SelectiveKeyRestoreOperationPollerResponse{}, err
	}
	result := SelectiveKeyRestoreOperationPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SelectiveKeyRestoreOperationResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// SelectiveKeyRestoreOperation - Restores all key versions of a given key using user supplied SAS token pointing to a previously stored Azure Blob storage
// backup folder
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) selectiveKeyRestoreOperation(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientBeginSelectiveKeyRestoreOperationOptions) (*azcore.Response, error) {
	req, err := client.selectiveKeyRestoreOperationCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.selectiveKeyRestoreOperationHandleError(resp)
	}
	return resp, nil
}

// selectiveKeyRestoreOperationCreateRequest creates the SelectiveKeyRestoreOperation request.
func (client *KeyVaultClient) selectiveKeyRestoreOperationCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *KeyVaultClientBeginSelectiveKeyRestoreOperationOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{keyName}/restore"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	if options != nil && options.RestoreBlobDetails != nil {
		return req, req.MarshalAsJSON(*options.RestoreBlobDetails)
	}
	return req, nil
}

// selectiveKeyRestoreOperationHandleError handles the SelectiveKeyRestoreOperation error response.
func (client *KeyVaultClient) selectiveKeyRestoreOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SetCertificateContacts - Sets the certificate contacts for the specified key vault. This operation requires the certificates/managecontacts permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetCertificateContacts(ctx context.Context, vaultBaseURL string, contacts Contacts, options *KeyVaultClientSetCertificateContactsOptions) (ContactsResponse, error) {
	req, err := client.setCertificateContactsCreateRequest(ctx, vaultBaseURL, contacts, options)
	if err != nil {
		return ContactsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ContactsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ContactsResponse{}, client.setCertificateContactsHandleError(resp)
	}
	return client.setCertificateContactsHandleResponse(resp)
}

// setCertificateContactsCreateRequest creates the SetCertificateContacts request.
func (client *KeyVaultClient) setCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, contacts Contacts, options *KeyVaultClientSetCertificateContactsOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(contacts)
}

// setCertificateContactsHandleResponse handles the SetCertificateContacts response.
func (client *KeyVaultClient) setCertificateContactsHandleResponse(resp *azcore.Response) (ContactsResponse, error) {
	var val *Contacts
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ContactsResponse{}, err
	}
	return ContactsResponse{RawResponse: resp.Response, Contacts: val}, nil
}

// setCertificateContactsHandleError handles the SetCertificateContacts error response.
func (client *KeyVaultClient) setCertificateContactsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SetCertificateIssuer - The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation requires the certificates/setissuers
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *KeyVaultClientSetCertificateIssuerOptions) (IssuerBundleResponse, error) {
	req, err := client.setCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IssuerBundleResponse{}, client.setCertificateIssuerHandleError(resp)
	}
	return client.setCertificateIssuerHandleResponse(resp)
}

// setCertificateIssuerCreateRequest creates the SetCertificateIssuer request.
func (client *KeyVaultClient) setCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *KeyVaultClientSetCertificateIssuerOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameter)
}

// setCertificateIssuerHandleResponse handles the SetCertificateIssuer response.
func (client *KeyVaultClient) setCertificateIssuerHandleResponse(resp *azcore.Response) (IssuerBundleResponse, error) {
	var val *IssuerBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IssuerBundleResponse{}, err
	}
	return IssuerBundleResponse{RawResponse: resp.Response, IssuerBundle: val}, nil
}

// setCertificateIssuerHandleError handles the SetCertificateIssuer error response.
func (client *KeyVaultClient) setCertificateIssuerHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SetSasDefinition - Creates or updates a new SAS definition for the specified storage account. This operation requires the storage/setsas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionCreateParameters, options *KeyVaultClientSetSasDefinitionOptions) (SasDefinitionBundleResponse, error) {
	req, err := client.setSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, parameters, options)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SasDefinitionBundleResponse{}, client.setSasDefinitionHandleError(resp)
	}
	return client.setSasDefinitionHandleResponse(resp)
}

// setSasDefinitionCreateRequest creates the SetSasDefinition request.
func (client *KeyVaultClient) setSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionCreateParameters, options *KeyVaultClientSetSasDefinitionOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// setSasDefinitionHandleResponse handles the SetSasDefinition response.
func (client *KeyVaultClient) setSasDefinitionHandleResponse(resp *azcore.Response) (SasDefinitionBundleResponse, error) {
	var val *SasDefinitionBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	return SasDefinitionBundleResponse{RawResponse: resp.Response, SasDefinitionBundle: val}, nil
}

// setSasDefinitionHandleError handles the SetSasDefinition error response.
func (client *KeyVaultClient) setSasDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SetSecret - The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault creates a new version of that
// secret. This operation requires the secrets/set permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetSecret(ctx context.Context, vaultBaseURL string, secretName string, parameters SecretSetParameters, options *KeyVaultClientSetSecretOptions) (SecretBundleResponse, error) {
	req, err := client.setSecretCreateRequest(ctx, vaultBaseURL, secretName, parameters, options)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SecretBundleResponse{}, client.setSecretHandleError(resp)
	}
	return client.setSecretHandleResponse(resp)
}

// setSecretCreateRequest creates the SetSecret request.
func (client *KeyVaultClient) setSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, parameters SecretSetParameters, options *KeyVaultClientSetSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// setSecretHandleResponse handles the SetSecret response.
func (client *KeyVaultClient) setSecretHandleResponse(resp *azcore.Response) (SecretBundleResponse, error) {
	var val *SecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretBundleResponse{}, err
	}
	return SecretBundleResponse{RawResponse: resp.Response, SecretBundle: val}, nil
}

// setSecretHandleError handles the SetSecret error response.
func (client *KeyVaultClient) setSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SetStorageAccount - Creates or updates a new storage account. This operation requires the storage/set permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) SetStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountCreateParameters, options *KeyVaultClientSetStorageAccountOptions) (StorageBundleResponse, error) {
	req, err := client.setStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageBundleResponse{}, client.setStorageAccountHandleError(resp)
	}
	return client.setStorageAccountHandleResponse(resp)
}

// setStorageAccountCreateRequest creates the SetStorageAccount request.
func (client *KeyVaultClient) setStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountCreateParameters, options *KeyVaultClientSetStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// setStorageAccountHandleResponse handles the SetStorageAccount response.
func (client *KeyVaultClient) setStorageAccountHandleResponse(resp *azcore.Response) (StorageBundleResponse, error) {
	var val *StorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageBundleResponse{}, err
	}
	return StorageBundleResponse{RawResponse: resp.Response, StorageBundle: val}, nil
}

// setStorageAccountHandleError handles the SetStorageAccount error response.
func (client *KeyVaultClient) setStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Sign - The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation uses the private portion of the
// key. This operation requires the keys/sign permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) Sign(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeySignParameters, options *KeyVaultClientSignOptions) (KeyOperationResultResponse, error) {
	req, err := client.signCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyOperationResultResponse{}, client.signHandleError(resp)
	}
	return client.signHandleResponse(resp)
}

// signCreateRequest creates the Sign request.
func (client *KeyVaultClient) signCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeySignParameters, options *KeyVaultClientSignOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/sign"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// signHandleResponse handles the Sign response.
func (client *KeyVaultClient) signHandleResponse(resp *azcore.Response) (KeyOperationResultResponse, error) {
	var val *KeyOperationResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyOperationResultResponse{}, err
	}
	return KeyOperationResultResponse{RawResponse: resp.Response, KeyOperationResult: val}, nil
}

// signHandleError handles the Sign error response.
func (client *KeyVaultClient) signHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UnwrapKey - The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation is the reverse of the WRAP
// operation. The UNWRAP operation applies to asymmetric and
// symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/unwrapKey permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UnwrapKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientUnwrapKeyOptions) (KeyOperationResultResponse, error) {
	req, err := client.unwrapKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyOperationResultResponse{}, client.unwrapKeyHandleError(resp)
	}
	return client.unwrapKeyHandleResponse(resp)
}

// unwrapKeyCreateRequest creates the UnwrapKey request.
func (client *KeyVaultClient) unwrapKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientUnwrapKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/unwrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// unwrapKeyHandleResponse handles the UnwrapKey response.
func (client *KeyVaultClient) unwrapKeyHandleResponse(resp *azcore.Response) (KeyOperationResultResponse, error) {
	var val *KeyOperationResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyOperationResultResponse{}, err
	}
	return KeyOperationResultResponse{RawResponse: resp.Response, KeyOperationResult: val}, nil
}

// unwrapKeyHandleError handles the UnwrapKey error response.
func (client *KeyVaultClient) unwrapKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateCertificate - The UpdateCertificate operation applies the specified update on the given certificate; the only elements updated are the certificate's
// attributes. This operation requires the certificates/update
// permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *KeyVaultClientUpdateCertificateOptions) (CertificateBundleResponse, error) {
	req, err := client.updateCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, parameters, options)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateBundleResponse{}, client.updateCertificateHandleError(resp)
	}
	return client.updateCertificateHandleResponse(resp)
}

// updateCertificateCreateRequest creates the UpdateCertificate request.
func (client *KeyVaultClient) updateCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *KeyVaultClientUpdateCertificateOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// updateCertificateHandleResponse handles the UpdateCertificate response.
func (client *KeyVaultClient) updateCertificateHandleResponse(resp *azcore.Response) (CertificateBundleResponse, error) {
	var val *CertificateBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateBundleResponse{}, err
	}
	return CertificateBundleResponse{RawResponse: resp.Response, CertificateBundle: val}, nil
}

// updateCertificateHandleError handles the UpdateCertificate error response.
func (client *KeyVaultClient) updateCertificateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateCertificateIssuer - The UpdateCertificateIssuer operation performs an update on the specified certificate issuer entity. This operation requires
// the certificates/setissuers permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *KeyVaultClientUpdateCertificateIssuerOptions) (IssuerBundleResponse, error) {
	req, err := client.updateCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return IssuerBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return IssuerBundleResponse{}, client.updateCertificateIssuerHandleError(resp)
	}
	return client.updateCertificateIssuerHandleResponse(resp)
}

// updateCertificateIssuerCreateRequest creates the UpdateCertificateIssuer request.
func (client *KeyVaultClient) updateCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *KeyVaultClientUpdateCertificateIssuerOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameter)
}

// updateCertificateIssuerHandleResponse handles the UpdateCertificateIssuer response.
func (client *KeyVaultClient) updateCertificateIssuerHandleResponse(resp *azcore.Response) (IssuerBundleResponse, error) {
	var val *IssuerBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return IssuerBundleResponse{}, err
	}
	return IssuerBundleResponse{RawResponse: resp.Response, IssuerBundle: val}, nil
}

// updateCertificateIssuerHandleError handles the UpdateCertificateIssuer error response.
func (client *KeyVaultClient) updateCertificateIssuerHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateCertificateOperation - Updates a certificate creation operation that is already in progress. This operation requires the certificates/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *KeyVaultClientUpdateCertificateOperationOptions) (CertificateOperationResponse, error) {
	req, err := client.updateCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, certificateOperation, options)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificateOperationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificateOperationResponse{}, client.updateCertificateOperationHandleError(resp)
	}
	return client.updateCertificateOperationHandleResponse(resp)
}

// updateCertificateOperationCreateRequest creates the UpdateCertificateOperation request.
func (client *KeyVaultClient) updateCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *KeyVaultClientUpdateCertificateOperationOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(certificateOperation)
}

// updateCertificateOperationHandleResponse handles the UpdateCertificateOperation response.
func (client *KeyVaultClient) updateCertificateOperationHandleResponse(resp *azcore.Response) (CertificateOperationResponse, error) {
	var val *CertificateOperation
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificateOperationResponse{}, err
	}
	return CertificateOperationResponse{RawResponse: resp.Response, CertificateOperation: val}, nil
}

// updateCertificateOperationHandleError handles the UpdateCertificateOperation error response.
func (client *KeyVaultClient) updateCertificateOperationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateCertificatePolicy - Set specified members in the certificate policy. Leave others as null. This operation requires the certificates/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *KeyVaultClientUpdateCertificatePolicyOptions) (CertificatePolicyResponse, error) {
	req, err := client.updateCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, certificatePolicy, options)
	if err != nil {
		return CertificatePolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CertificatePolicyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CertificatePolicyResponse{}, client.updateCertificatePolicyHandleError(resp)
	}
	return client.updateCertificatePolicyHandleResponse(resp)
}

// updateCertificatePolicyCreateRequest creates the UpdateCertificatePolicy request.
func (client *KeyVaultClient) updateCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *KeyVaultClientUpdateCertificatePolicyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(certificatePolicy)
}

// updateCertificatePolicyHandleResponse handles the UpdateCertificatePolicy response.
func (client *KeyVaultClient) updateCertificatePolicyHandleResponse(resp *azcore.Response) (CertificatePolicyResponse, error) {
	var val *CertificatePolicy
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CertificatePolicyResponse{}, err
	}
	return CertificatePolicyResponse{RawResponse: resp.Response, CertificatePolicy: val}, nil
}

// updateCertificatePolicyHandleError handles the UpdateCertificatePolicy error response.
func (client *KeyVaultClient) updateCertificatePolicyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateKey - In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material of a key itself cannot
// be changed. This operation requires the keys/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyUpdateParameters, options *KeyVaultClientUpdateKeyOptions) (KeyBundleResponse, error) {
	req, err := client.updateKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyBundleResponse{}, client.updateKeyHandleError(resp)
	}
	return client.updateKeyHandleResponse(resp)
}

// updateKeyCreateRequest creates the UpdateKey request.
func (client *KeyVaultClient) updateKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyUpdateParameters, options *KeyVaultClientUpdateKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// updateKeyHandleResponse handles the UpdateKey response.
func (client *KeyVaultClient) updateKeyHandleResponse(resp *azcore.Response) (KeyBundleResponse, error) {
	var val *KeyBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyBundleResponse{}, err
	}
	return KeyBundleResponse{RawResponse: resp.Response, KeyBundle: val}, nil
}

// updateKeyHandleError handles the UpdateKey error response.
func (client *KeyVaultClient) updateKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSasDefinition - Updates the specified attributes associated with the given SAS definition. This operation requires the storage/setsas permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionUpdateParameters, options *KeyVaultClientUpdateSasDefinitionOptions) (SasDefinitionBundleResponse, error) {
	req, err := client.updateSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, parameters, options)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SasDefinitionBundleResponse{}, client.updateSasDefinitionHandleError(resp)
	}
	return client.updateSasDefinitionHandleResponse(resp)
}

// updateSasDefinitionCreateRequest creates the UpdateSasDefinition request.
func (client *KeyVaultClient) updateSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionUpdateParameters, options *KeyVaultClientUpdateSasDefinitionOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// updateSasDefinitionHandleResponse handles the UpdateSasDefinition response.
func (client *KeyVaultClient) updateSasDefinitionHandleResponse(resp *azcore.Response) (SasDefinitionBundleResponse, error) {
	var val *SasDefinitionBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SasDefinitionBundleResponse{}, err
	}
	return SasDefinitionBundleResponse{RawResponse: resp.Response, SasDefinitionBundle: val}, nil
}

// updateSasDefinitionHandleError handles the UpdateSasDefinition error response.
func (client *KeyVaultClient) updateSasDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateSecret - The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not specified in the request are left
// unchanged. The value of a secret itself cannot be changed.
// This operation requires the secrets/set permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateSecret(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, parameters SecretUpdateParameters, options *KeyVaultClientUpdateSecretOptions) (SecretBundleResponse, error) {
	req, err := client.updateSecretCreateRequest(ctx, vaultBaseURL, secretName, secretVersion, parameters, options)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SecretBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SecretBundleResponse{}, client.updateSecretHandleError(resp)
	}
	return client.updateSecretHandleResponse(resp)
}

// updateSecretCreateRequest creates the UpdateSecret request.
func (client *KeyVaultClient) updateSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, parameters SecretUpdateParameters, options *KeyVaultClientUpdateSecretOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/{secret-version}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-version}", url.PathEscape(secretVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// updateSecretHandleResponse handles the UpdateSecret response.
func (client *KeyVaultClient) updateSecretHandleResponse(resp *azcore.Response) (SecretBundleResponse, error) {
	var val *SecretBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SecretBundleResponse{}, err
	}
	return SecretBundleResponse{RawResponse: resp.Response, SecretBundle: val}, nil
}

// updateSecretHandleError handles the UpdateSecret error response.
func (client *KeyVaultClient) updateSecretHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateStorageAccount - Updates the specified attributes associated with the given storage account. This operation requires the storage/set/update permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) UpdateStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountUpdateParameters, options *KeyVaultClientUpdateStorageAccountOptions) (StorageBundleResponse, error) {
	req, err := client.updateStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageBundleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageBundleResponse{}, client.updateStorageAccountHandleError(resp)
	}
	return client.updateStorageAccountHandleResponse(resp)
}

// updateStorageAccountCreateRequest creates the UpdateStorageAccount request.
func (client *KeyVaultClient) updateStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountUpdateParameters, options *KeyVaultClientUpdateStorageAccountOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// updateStorageAccountHandleResponse handles the UpdateStorageAccount response.
func (client *KeyVaultClient) updateStorageAccountHandleResponse(resp *azcore.Response) (StorageBundleResponse, error) {
	var val *StorageBundle
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StorageBundleResponse{}, err
	}
	return StorageBundleResponse{RawResponse: resp.Response, StorageBundle: val}, nil
}

// updateStorageAccountHandleError handles the UpdateStorageAccount error response.
func (client *KeyVaultClient) updateStorageAccountHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Verify - The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary for asymmetric keys stored
// in Azure Key Vault since signature verification can be
// performed using the public portion of the key but this operation is supported as a convenience for callers that only have a key-reference and not the
// public portion of the key. This operation requires
// the keys/verify permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) Verify(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyVerifyParameters, options *KeyVaultClientVerifyOptions) (KeyVerifyResultResponse, error) {
	req, err := client.verifyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyVerifyResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyVerifyResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyVerifyResultResponse{}, client.verifyHandleError(resp)
	}
	return client.verifyHandleResponse(resp)
}

// verifyCreateRequest creates the Verify request.
func (client *KeyVaultClient) verifyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyVerifyParameters, options *KeyVaultClientVerifyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/verify"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// verifyHandleResponse handles the Verify response.
func (client *KeyVaultClient) verifyHandleResponse(resp *azcore.Response) (KeyVerifyResultResponse, error) {
	var val *KeyVerifyResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyVerifyResultResponse{}, err
	}
	return KeyVerifyResultResponse{RawResponse: resp.Response, KeyVerifyResult: val}, nil
}

// verifyHandleError handles the Verify error response.
func (client *KeyVaultClient) verifyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// WrapKey - The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been stored in an Azure Key Vault.
// The WRAP operation is only strictly necessary for symmetric
// keys stored in Azure Key Vault since protection with an asymmetric key can be performed using the public portion of the key. This operation is supported
// for asymmetric keys as a convenience for
// callers that have a key-reference but do not have access to the public key material. This operation requires the keys/wrapKey permission.
// If the operation fails it returns the *KeyVaultError error type.
func (client *KeyVaultClient) WrapKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientWrapKeyOptions) (KeyOperationResultResponse, error) {
	req, err := client.wrapKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return KeyOperationResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return KeyOperationResultResponse{}, client.wrapKeyHandleError(resp)
	}
	return client.wrapKeyHandleResponse(resp)
}

// wrapKeyCreateRequest creates the WrapKey request.
func (client *KeyVaultClient) wrapKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *KeyVaultClientWrapKeyOptions) (*azcore.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/wrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "7.2")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// wrapKeyHandleResponse handles the WrapKey response.
func (client *KeyVaultClient) wrapKeyHandleResponse(resp *azcore.Response) (KeyOperationResultResponse, error) {
	var val *KeyOperationResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return KeyOperationResultResponse{}, err
	}
	return KeyOperationResultResponse{RawResponse: resp.Response, KeyOperationResult: val}, nil
}

// wrapKeyHandleError handles the WrapKey error response.
func (client *KeyVaultClient) wrapKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := KeyVaultError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
