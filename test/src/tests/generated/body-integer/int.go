package integergroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"github.com/Azure/go-autorest/autorest/date"
	"io/ioutil"
	"net/http"
)

// IntClient is the test Infrastructure for AutoRest
type IntClient struct {
	ManagementClient
}

// NewIntClient creates an instance of the IntClient client.
func NewIntClient(p pipeline.Pipeline) IntClient {
	return IntClient{NewManagementClient(p)}
}

// GetInvalid get invalid Int value
func (client IntClient) GetInvalid(ctx context.Context) (*GetInvalidResponse, error) {
	req, err := client.getInvalidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getInvalidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetInvalidResponse), err
}

// getInvalidPreparer prepares the GetInvalid request.
func (client IntClient) getInvalidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/invalid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getInvalidResponder handles the response to the GetInvalid request.
func (client IntClient) getInvalidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetInvalidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetInvalidUnixTime get invalid Unix time value
func (client IntClient) GetInvalidUnixTime(ctx context.Context) (*GetInvalidUnixTimeResponse, error) {
	req, err := client.getInvalidUnixTimePreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getInvalidUnixTimeResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetInvalidUnixTimeResponse), err
}

// getInvalidUnixTimePreparer prepares the GetInvalidUnixTime request.
func (client IntClient) getInvalidUnixTimePreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/invalidunixtime"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getInvalidUnixTimeResponder handles the response to the GetInvalidUnixTime request.
func (client IntClient) getInvalidUnixTimeResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetInvalidUnixTimeResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetNull get null Int value
func (client IntClient) GetNull(ctx context.Context) (*GetNullResponse, error) {
	req, err := client.getNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetNullResponse), err
}

// getNullPreparer prepares the GetNull request.
func (client IntClient) getNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/null"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getNullResponder handles the response to the GetNull request.
func (client IntClient) getNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetNullUnixTime get null Unix time value
func (client IntClient) GetNullUnixTime(ctx context.Context) (*GetNullUnixTimeResponse, error) {
	req, err := client.getNullUnixTimePreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getNullUnixTimeResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetNullUnixTimeResponse), err
}

// getNullUnixTimePreparer prepares the GetNullUnixTime request.
func (client IntClient) getNullUnixTimePreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/nullunixtime"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getNullUnixTimeResponder handles the response to the GetNullUnixTime request.
func (client IntClient) getNullUnixTimeResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetNullUnixTimeResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetOverflowInt32 get overflow Int32 value
func (client IntClient) GetOverflowInt32(ctx context.Context) (*GetOverflowInt32Response, error) {
	req, err := client.getOverflowInt32Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getOverflowInt32Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetOverflowInt32Response), err
}

// getOverflowInt32Preparer prepares the GetOverflowInt32 request.
func (client IntClient) getOverflowInt32Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/overflowint32"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getOverflowInt32Responder handles the response to the GetOverflowInt32 request.
func (client IntClient) getOverflowInt32Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetOverflowInt32Response{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetOverflowInt64 get overflow Int64 value
func (client IntClient) GetOverflowInt64(ctx context.Context) (*GetOverflowInt64Response, error) {
	req, err := client.getOverflowInt64Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getOverflowInt64Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetOverflowInt64Response), err
}

// getOverflowInt64Preparer prepares the GetOverflowInt64 request.
func (client IntClient) getOverflowInt64Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/overflowint64"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getOverflowInt64Responder handles the response to the GetOverflowInt64 request.
func (client IntClient) getOverflowInt64Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetOverflowInt64Response{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetUnderflowInt32 get underflow Int32 value
func (client IntClient) GetUnderflowInt32(ctx context.Context) (*GetUnderflowInt32Response, error) {
	req, err := client.getUnderflowInt32Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getUnderflowInt32Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetUnderflowInt32Response), err
}

// getUnderflowInt32Preparer prepares the GetUnderflowInt32 request.
func (client IntClient) getUnderflowInt32Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/underflowint32"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getUnderflowInt32Responder handles the response to the GetUnderflowInt32 request.
func (client IntClient) getUnderflowInt32Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetUnderflowInt32Response{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetUnderflowInt64 get underflow Int64 value
func (client IntClient) GetUnderflowInt64(ctx context.Context) (*GetUnderflowInt64Response, error) {
	req, err := client.getUnderflowInt64Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getUnderflowInt64Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetUnderflowInt64Response), err
}

// getUnderflowInt64Preparer prepares the GetUnderflowInt64 request.
func (client IntClient) getUnderflowInt64Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/underflowint64"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getUnderflowInt64Responder handles the response to the GetUnderflowInt64 request.
func (client IntClient) getUnderflowInt64Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetUnderflowInt64Response{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetUnixTime get datetime encoded as Unix time value
func (client IntClient) GetUnixTime(ctx context.Context) (*GetUnixTimeResponse, error) {
	req, err := client.getUnixTimePreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getUnixTimeResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetUnixTimeResponse), err
}

// getUnixTimePreparer prepares the GetUnixTime request.
func (client IntClient) getUnixTimePreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/unixtime"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getUnixTimeResponder handles the response to the GetUnixTime request.
func (client IntClient) getUnixTimeResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetUnixTimeResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// PutMax32 put max int32 value
//
func (client IntClient) PutMax32(ctx context.Context, intBody int32) (*http.Response, error) {
	req, err := client.putMax32Preparer(intBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putMax32Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putMax32Preparer prepares the PutMax32 request.
func (client IntClient) putMax32Preparer(intBody int32) (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/max/32"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(intBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putMax32Responder handles the response to the PutMax32 request.
func (client IntClient) putMax32Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// PutMax64 put max int64 value
//
func (client IntClient) PutMax64(ctx context.Context, intBody int64) (*http.Response, error) {
	req, err := client.putMax64Preparer(intBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putMax64Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putMax64Preparer prepares the PutMax64 request.
func (client IntClient) putMax64Preparer(intBody int64) (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/max/64"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(intBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putMax64Responder handles the response to the PutMax64 request.
func (client IntClient) putMax64Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// PutMin32 put min int32 value
//
func (client IntClient) PutMin32(ctx context.Context, intBody int32) (*http.Response, error) {
	req, err := client.putMin32Preparer(intBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putMin32Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putMin32Preparer prepares the PutMin32 request.
func (client IntClient) putMin32Preparer(intBody int32) (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/min/32"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(intBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putMin32Responder handles the response to the PutMin32 request.
func (client IntClient) putMin32Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// PutMin64 put min int64 value
//
func (client IntClient) PutMin64(ctx context.Context, intBody int64) (*http.Response, error) {
	req, err := client.putMin64Preparer(intBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putMin64Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putMin64Preparer prepares the PutMin64 request.
func (client IntClient) putMin64Preparer(intBody int64) (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/min/64"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(intBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putMin64Responder handles the response to the PutMin64 request.
func (client IntClient) putMin64Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// PutUnixTimeDate put datetime encoded as Unix time
//
func (client IntClient) PutUnixTimeDate(ctx context.Context, intBody date.UnixTime) (*http.Response, error) {
	req, err := client.putUnixTimeDatePreparer(intBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putUnixTimeDateResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putUnixTimeDatePreparer prepares the PutUnixTimeDate request.
func (client IntClient) putUnixTimeDatePreparer(intBody date.UnixTime) (pipeline.Request, error) {
	u := client.url
	u.Path = "/int/unixtime"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(intBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putUnixTimeDateResponder handles the response to the PutUnixTimeDate request.
func (client IntClient) putUnixTimeDateResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}
