package headergroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// HeaderClient is the test Infrastructure for AutoRest
type HeaderClient struct {
	BaseClient
}

// NewHeaderClient creates an instance of the HeaderClient client.
func NewHeaderClient() HeaderClient {
	return NewHeaderClientWithBaseURI(DefaultBaseURI)
}

// NewHeaderClientWithBaseURI creates an instance of the HeaderClient client.
func NewHeaderClientWithBaseURI(baseURI string) HeaderClient {
	return HeaderClient{NewWithBaseURI(baseURI)}
}

// CustomRequestID send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
func (client HeaderClient) CustomRequestID(ctx context.Context) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.CustomRequestID")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.CustomRequestIDPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "CustomRequestID", nil, "Failure preparing request")
		return
	}

	resp, err := client.CustomRequestIDSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "CustomRequestID", resp, "Failure sending request")
		return
	}

	result, err = client.CustomRequestIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "CustomRequestID", resp, "Failure responding to request")
	}

	return
}

// CustomRequestIDPreparer prepares the CustomRequestID request.
func (client HeaderClient) CustomRequestIDPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/custom/x-ms-client-request-id/9C4D50EE-2D56-4CD3-8152-34347DC9F2B0"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CustomRequestIDSender sends the CustomRequestID request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) CustomRequestIDSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CustomRequestIDResponder handles the response to the CustomRequestID request. The method always
// closes the http.Response Body.
func (client HeaderClient) CustomRequestIDResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamBool send a post request with header values "scenario": "true", "value": true or "scenario": "false", "value":
// false
// Parameters:
// scenario - send a post request with header values "scenario": "true" or "false"
// value - send a post request with header values true or false
func (client HeaderClient) ParamBool(ctx context.Context, scenario string, value bool) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamBool")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamBoolPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamBool", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamBoolSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamBool", resp, "Failure sending request")
		return
	}

	result, err = client.ParamBoolResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamBool", resp, "Failure responding to request")
	}

	return
}

// ParamBoolPreparer prepares the ParamBool request.
func (client HeaderClient) ParamBoolPreparer(ctx context.Context, scenario string, value bool) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/bool"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamBoolSender sends the ParamBool request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamBoolSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamBoolResponder handles the response to the ParamBool request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamBoolResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamByte send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
// Parameters:
// scenario - send a post request with header values "scenario": "valid"
// value - send a post request with header values "啊齄丂狛狜隣郎隣兀﨩"
func (client HeaderClient) ParamByte(ctx context.Context, scenario string, value []byte) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamByte")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	if err := validation.Validate([]validation.Validation{
		{TargetValue: value,
			Constraints: []validation.Constraint{{Target: "value", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("headergroup.HeaderClient", "ParamByte", err.Error())
	}

	req, err := client.ParamBytePreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamByte", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamByteSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamByte", resp, "Failure sending request")
		return
	}

	result, err = client.ParamByteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamByte", resp, "Failure responding to request")
	}

	return
}

// ParamBytePreparer prepares the ParamByte request.
func (client HeaderClient) ParamBytePreparer(ctx context.Context, scenario string, value []byte) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/byte"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamByteSender sends the ParamByte request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamByteSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamByteResponder handles the response to the ParamByte request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamByteResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamDate send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario": "min",
// "value": "0001-01-01"
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "min"
// value - send a post request with header values "2010-01-01" or "0001-01-01"
func (client HeaderClient) ParamDate(ctx context.Context, scenario string, value date.Date) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamDate")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamDatePreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDate", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamDateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDate", resp, "Failure sending request")
		return
	}

	result, err = client.ParamDateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDate", resp, "Failure responding to request")
	}

	return
}

// ParamDatePreparer prepares the ParamDate request.
func (client HeaderClient) ParamDatePreparer(ctx context.Context, scenario string, value date.Date) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/date"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamDateSender sends the ParamDate request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamDateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamDateResponder handles the response to the ParamDate request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamDateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamDatetime send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or
// "scenario": "min", "value": "0001-01-01T00:00:00Z"
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "min"
// value - send a post request with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
func (client HeaderClient) ParamDatetime(ctx context.Context, scenario string, value date.Time) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamDatetime")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamDatetimePreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDatetime", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamDatetimeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDatetime", resp, "Failure sending request")
		return
	}

	result, err = client.ParamDatetimeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDatetime", resp, "Failure responding to request")
	}

	return
}

// ParamDatetimePreparer prepares the ParamDatetime request.
func (client HeaderClient) ParamDatetimePreparer(ctx context.Context, scenario string, value date.Time) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/datetime"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamDatetimeSender sends the ParamDatetime request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamDatetimeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamDatetimeResponder handles the response to the ParamDatetime request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamDatetimeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamDatetimeRfc1123 send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56
// GMT" or "scenario": "min", "value": "Mon, 01 Jan 0001 00:00:00 GMT"
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "min"
// value - send a post request with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00
// GMT"
func (client HeaderClient) ParamDatetimeRfc1123(ctx context.Context, scenario string, value *date.TimeRFC1123) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamDatetimeRfc1123")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamDatetimeRfc1123Preparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDatetimeRfc1123", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamDatetimeRfc1123Sender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDatetimeRfc1123", resp, "Failure sending request")
		return
	}

	result, err = client.ParamDatetimeRfc1123Responder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDatetimeRfc1123", resp, "Failure responding to request")
	}

	return
}

// ParamDatetimeRfc1123Preparer prepares the ParamDatetimeRfc1123 request.
func (client HeaderClient) ParamDatetimeRfc1123Preparer(ctx context.Context, scenario string, value *date.TimeRFC1123) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/datetimerfc1123"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	if value != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("value", autorest.String(value)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamDatetimeRfc1123Sender sends the ParamDatetimeRfc1123 request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamDatetimeRfc1123Sender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamDatetimeRfc1123Responder handles the response to the ParamDatetimeRfc1123 request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamDatetimeRfc1123Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamDouble send a post request with header values "scenario": "positive", "value": 7e120 or "scenario": "negative",
// "value": -3.0
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
// value - send a post request with header values 7e120 or -3.0
func (client HeaderClient) ParamDouble(ctx context.Context, scenario string, value float64) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamDouble")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamDoublePreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDouble", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamDoubleSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDouble", resp, "Failure sending request")
		return
	}

	result, err = client.ParamDoubleResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDouble", resp, "Failure responding to request")
	}

	return
}

// ParamDoublePreparer prepares the ParamDouble request.
func (client HeaderClient) ParamDoublePreparer(ctx context.Context, scenario string, value float64) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/double"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamDoubleSender sends the ParamDouble request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamDoubleSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamDoubleResponder handles the response to the ParamDouble request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamDoubleResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamDuration send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
// Parameters:
// scenario - send a post request with header values "scenario": "valid"
// value - send a post request with header values "P123DT22H14M12.011S"
func (client HeaderClient) ParamDuration(ctx context.Context, scenario string, value string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamDuration")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamDurationPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDuration", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamDurationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDuration", resp, "Failure sending request")
		return
	}

	result, err = client.ParamDurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamDuration", resp, "Failure responding to request")
	}

	return
}

// ParamDurationPreparer prepares the ParamDuration request.
func (client HeaderClient) ParamDurationPreparer(ctx context.Context, scenario string, value string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/duration"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamDurationSender sends the ParamDuration request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamDurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamDurationResponder handles the response to the ParamDuration request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamDurationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamEnum send a post request with header values "scenario": "valid", "value": "GREY" or "scenario": "null",
// "value": null
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "null" or "empty"
// value - send a post request with header values 'GREY'
func (client HeaderClient) ParamEnum(ctx context.Context, scenario string, value GreyscaleColors) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamEnum")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamEnumPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamEnum", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamEnumSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamEnum", resp, "Failure sending request")
		return
	}

	result, err = client.ParamEnumResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamEnum", resp, "Failure responding to request")
	}

	return
}

// ParamEnumPreparer prepares the ParamEnum request.
func (client HeaderClient) ParamEnumPreparer(ctx context.Context, scenario string, value GreyscaleColors) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/enum"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	if len(string(value)) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("value", autorest.String(value)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamEnumSender sends the ParamEnum request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamEnumSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamEnumResponder handles the response to the ParamEnum request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamEnumResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamExistingKey send a post request with header value "User-Agent": "overwrite"
// Parameters:
// userAgent - send a post request with header value "User-Agent": "overwrite"
func (client HeaderClient) ParamExistingKey(ctx context.Context, userAgent string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamExistingKey")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamExistingKeyPreparer(ctx, userAgent)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamExistingKey", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamExistingKeySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamExistingKey", resp, "Failure sending request")
		return
	}

	result, err = client.ParamExistingKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamExistingKey", resp, "Failure responding to request")
	}

	return
}

// ParamExistingKeyPreparer prepares the ParamExistingKey request.
func (client HeaderClient) ParamExistingKeyPreparer(ctx context.Context, userAgent string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/existingkey"),
		autorest.WithHeader("User-Agent", autorest.String(userAgent)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamExistingKeySender sends the ParamExistingKey request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamExistingKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamExistingKeyResponder handles the response to the ParamExistingKey request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamExistingKeyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamFloat send a post request with header values "scenario": "positive", "value": 0.07 or "scenario": "negative",
// "value": -3.0
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
// value - send a post request with header values 0.07 or -3.0
func (client HeaderClient) ParamFloat(ctx context.Context, scenario string, value float64) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamFloat")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamFloatPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamFloat", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamFloatSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamFloat", resp, "Failure sending request")
		return
	}

	result, err = client.ParamFloatResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamFloat", resp, "Failure responding to request")
	}

	return
}

// ParamFloatPreparer prepares the ParamFloat request.
func (client HeaderClient) ParamFloatPreparer(ctx context.Context, scenario string, value float64) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/float"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamFloatSender sends the ParamFloat request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamFloatSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamFloatResponder handles the response to the ParamFloat request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamFloatResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamInteger send a post request with header values "scenario": "positive", "value": 1 or "scenario": "negative",
// "value": -2
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
// value - send a post request with header values 1 or -2
func (client HeaderClient) ParamInteger(ctx context.Context, scenario string, value int32) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamInteger")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamIntegerPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamInteger", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamIntegerSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamInteger", resp, "Failure sending request")
		return
	}

	result, err = client.ParamIntegerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamInteger", resp, "Failure responding to request")
	}

	return
}

// ParamIntegerPreparer prepares the ParamInteger request.
func (client HeaderClient) ParamIntegerPreparer(ctx context.Context, scenario string, value int32) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/integer"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamIntegerSender sends the ParamInteger request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamIntegerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamIntegerResponder handles the response to the ParamInteger request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamIntegerResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamLong send a post request with header values "scenario": "positive", "value": 105 or "scenario": "negative",
// "value": -2
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
// value - send a post request with header values 105 or -2
func (client HeaderClient) ParamLong(ctx context.Context, scenario string, value int64) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamLong")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamLongPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamLong", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamLongSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamLong", resp, "Failure sending request")
		return
	}

	result, err = client.ParamLongResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamLong", resp, "Failure responding to request")
	}

	return
}

// ParamLongPreparer prepares the ParamLong request.
func (client HeaderClient) ParamLongPreparer(ctx context.Context, scenario string, value int64) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/long"),
		autorest.WithHeader("scenario", autorest.String(scenario)),
		autorest.WithHeader("value", autorest.String(value)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamLongSender sends the ParamLong request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamLongSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamLongResponder handles the response to the ParamLong request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamLongResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamProtectedKey send a post request with header value "Content-Type": "text/html"
// Parameters:
// contentType - send a post request with header value "Content-Type": "text/html"
func (client HeaderClient) ParamProtectedKey(ctx context.Context, contentType string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamProtectedKey")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamProtectedKeyPreparer(ctx, contentType)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamProtectedKey", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamProtectedKeySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamProtectedKey", resp, "Failure sending request")
		return
	}

	result, err = client.ParamProtectedKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamProtectedKey", resp, "Failure responding to request")
	}

	return
}

// ParamProtectedKeyPreparer prepares the ParamProtectedKey request.
func (client HeaderClient) ParamProtectedKeyPreparer(ctx context.Context, contentType string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/protectedkey"),
		autorest.WithHeader("Content-Type", autorest.String(contentType)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamProtectedKeySender sends the ParamProtectedKey request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamProtectedKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamProtectedKeyResponder handles the response to the ParamProtectedKey request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamProtectedKeyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ParamString send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps over the
// lazy dog" or "scenario": "null", "value": null or "scenario": "empty", "value": ""
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "null" or "empty"
// value - send a post request with header values "The quick brown fox jumps over the lazy dog" or null or ""
func (client HeaderClient) ParamString(ctx context.Context, scenario string, value string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ParamString")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ParamStringPreparer(ctx, scenario, value)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamString", nil, "Failure preparing request")
		return
	}

	resp, err := client.ParamStringSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamString", resp, "Failure sending request")
		return
	}

	result, err = client.ParamStringResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ParamString", resp, "Failure responding to request")
	}

	return
}

// ParamStringPreparer prepares the ParamString request.
func (client HeaderClient) ParamStringPreparer(ctx context.Context, scenario string, value string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/param/prim/string"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	if len(value) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("value", autorest.String(value)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ParamStringSender sends the ParamString request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ParamStringSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ParamStringResponder handles the response to the ParamString request. The method always
// closes the http.Response Body.
func (client HeaderClient) ParamStringResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseBool get a response with header value "value": true or false
// Parameters:
// scenario - send a post request with header values "scenario": "true" or "false"
func (client HeaderClient) ResponseBool(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseBool")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseBoolPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseBool", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseBoolSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseBool", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseBoolResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseBool", resp, "Failure responding to request")
	}

	return
}

// ResponseBoolPreparer prepares the ResponseBool request.
func (client HeaderClient) ResponseBoolPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/bool"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseBoolSender sends the ResponseBool request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseBoolSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseBoolResponder handles the response to the ResponseBool request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseBoolResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseByte get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
// Parameters:
// scenario - send a post request with header values "scenario": "valid"
func (client HeaderClient) ResponseByte(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseByte")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseBytePreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseByte", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseByteSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseByte", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseByteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseByte", resp, "Failure responding to request")
	}

	return
}

// ResponseBytePreparer prepares the ResponseByte request.
func (client HeaderClient) ResponseBytePreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/byte"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseByteSender sends the ResponseByte request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseByteSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseByteResponder handles the response to the ResponseByte request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseByteResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseDate get a response with header values "2010-01-01" or "0001-01-01"
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "min"
func (client HeaderClient) ResponseDate(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseDate")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseDatePreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDate", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseDateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDate", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseDateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDate", resp, "Failure responding to request")
	}

	return
}

// ResponseDatePreparer prepares the ResponseDate request.
func (client HeaderClient) ResponseDatePreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/date"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseDateSender sends the ResponseDate request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseDateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseDateResponder handles the response to the ResponseDate request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseDateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseDatetime get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "min"
func (client HeaderClient) ResponseDatetime(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseDatetime")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseDatetimePreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDatetime", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseDatetimeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDatetime", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseDatetimeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDatetime", resp, "Failure responding to request")
	}

	return
}

// ResponseDatetimePreparer prepares the ResponseDatetime request.
func (client HeaderClient) ResponseDatetimePreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/datetime"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseDatetimeSender sends the ResponseDatetime request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseDatetimeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseDatetimeResponder handles the response to the ResponseDatetime request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseDatetimeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseDatetimeRfc1123 get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001
// 00:00:00 GMT"
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "min"
func (client HeaderClient) ResponseDatetimeRfc1123(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseDatetimeRfc1123")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseDatetimeRfc1123Preparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDatetimeRfc1123", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseDatetimeRfc1123Sender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDatetimeRfc1123", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseDatetimeRfc1123Responder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDatetimeRfc1123", resp, "Failure responding to request")
	}

	return
}

// ResponseDatetimeRfc1123Preparer prepares the ResponseDatetimeRfc1123 request.
func (client HeaderClient) ResponseDatetimeRfc1123Preparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/datetimerfc1123"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseDatetimeRfc1123Sender sends the ResponseDatetimeRfc1123 request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseDatetimeRfc1123Sender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseDatetimeRfc1123Responder handles the response to the ResponseDatetimeRfc1123 request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseDatetimeRfc1123Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseDouble get a response with header value "value": 7e120 or -3.0
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
func (client HeaderClient) ResponseDouble(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseDouble")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseDoublePreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDouble", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseDoubleSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDouble", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseDoubleResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDouble", resp, "Failure responding to request")
	}

	return
}

// ResponseDoublePreparer prepares the ResponseDouble request.
func (client HeaderClient) ResponseDoublePreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/double"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseDoubleSender sends the ResponseDouble request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseDoubleSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseDoubleResponder handles the response to the ResponseDouble request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseDoubleResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseDuration get a response with header values "P123DT22H14M12.011S"
// Parameters:
// scenario - send a post request with header values "scenario": "valid"
func (client HeaderClient) ResponseDuration(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseDuration")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseDurationPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDuration", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseDurationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDuration", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseDurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseDuration", resp, "Failure responding to request")
	}

	return
}

// ResponseDurationPreparer prepares the ResponseDuration request.
func (client HeaderClient) ResponseDurationPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/duration"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseDurationSender sends the ResponseDuration request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseDurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseDurationResponder handles the response to the ResponseDuration request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseDurationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseEnum get a response with header values "GREY" or null
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "null" or "empty"
func (client HeaderClient) ResponseEnum(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseEnum")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseEnumPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseEnum", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseEnumSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseEnum", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseEnumResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseEnum", resp, "Failure responding to request")
	}

	return
}

// ResponseEnumPreparer prepares the ResponseEnum request.
func (client HeaderClient) ResponseEnumPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/enum"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseEnumSender sends the ResponseEnum request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseEnumSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseEnumResponder handles the response to the ResponseEnum request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseEnumResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseExistingKey get a response with header value "User-Agent": "overwrite"
func (client HeaderClient) ResponseExistingKey(ctx context.Context) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseExistingKey")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseExistingKeyPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseExistingKey", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseExistingKeySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseExistingKey", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseExistingKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseExistingKey", resp, "Failure responding to request")
	}

	return
}

// ResponseExistingKeyPreparer prepares the ResponseExistingKey request.
func (client HeaderClient) ResponseExistingKeyPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/existingkey"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseExistingKeySender sends the ResponseExistingKey request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseExistingKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseExistingKeyResponder handles the response to the ResponseExistingKey request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseExistingKeyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseFloat get a response with header value "value": 0.07 or -3.0
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
func (client HeaderClient) ResponseFloat(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseFloat")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseFloatPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseFloat", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseFloatSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseFloat", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseFloatResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseFloat", resp, "Failure responding to request")
	}

	return
}

// ResponseFloatPreparer prepares the ResponseFloat request.
func (client HeaderClient) ResponseFloatPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/float"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseFloatSender sends the ResponseFloat request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseFloatSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseFloatResponder handles the response to the ResponseFloat request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseFloatResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseInteger get a response with header value "value": 1 or -2
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
func (client HeaderClient) ResponseInteger(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseInteger")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseIntegerPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseInteger", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseIntegerSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseInteger", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseIntegerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseInteger", resp, "Failure responding to request")
	}

	return
}

// ResponseIntegerPreparer prepares the ResponseInteger request.
func (client HeaderClient) ResponseIntegerPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/integer"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseIntegerSender sends the ResponseInteger request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseIntegerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseIntegerResponder handles the response to the ResponseInteger request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseIntegerResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseLong get a response with header value "value": 105 or -2
// Parameters:
// scenario - send a post request with header values "scenario": "positive" or "negative"
func (client HeaderClient) ResponseLong(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseLong")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseLongPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseLong", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseLongSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseLong", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseLongResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseLong", resp, "Failure responding to request")
	}

	return
}

// ResponseLongPreparer prepares the ResponseLong request.
func (client HeaderClient) ResponseLongPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/long"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseLongSender sends the ResponseLong request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseLongSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseLongResponder handles the response to the ResponseLong request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseLongResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseProtectedKey get a response with header value "Content-Type": "text/html"
func (client HeaderClient) ResponseProtectedKey(ctx context.Context) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseProtectedKey")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseProtectedKeyPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseProtectedKey", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseProtectedKeySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseProtectedKey", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseProtectedKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseProtectedKey", resp, "Failure responding to request")
	}

	return
}

// ResponseProtectedKeyPreparer prepares the ResponseProtectedKey request.
func (client HeaderClient) ResponseProtectedKeyPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/protectedkey"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseProtectedKeySender sends the ResponseProtectedKey request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseProtectedKeySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseProtectedKeyResponder handles the response to the ResponseProtectedKey request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseProtectedKeyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResponseString get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
// Parameters:
// scenario - send a post request with header values "scenario": "valid" or "null" or "empty"
func (client HeaderClient) ResponseString(ctx context.Context, scenario string) (result autorest.Response, err error) {
	ctx = tracing.StartSpan(ctx, "generated/header/HeaderClient.ResponseString")
	defer func() {
		sc := -1
		if result.Response != nil {
			sc = result.StatusCode
		}
		tracing.EndSpan(ctx, sc, err)
	}()
	req, err := client.ResponseStringPreparer(ctx, scenario)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseString", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResponseStringSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseString", resp, "Failure sending request")
		return
	}

	result, err = client.ResponseStringResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "headergroup.HeaderClient", "ResponseString", resp, "Failure responding to request")
	}

	return
}

// ResponseStringPreparer prepares the ResponseString request.
func (client HeaderClient) ResponseStringPreparer(ctx context.Context, scenario string) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/header/response/prim/string"),
		autorest.WithHeader("scenario", autorest.String(scenario)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResponseStringSender sends the ResponseString request. The method will close the
// http.Response Body if it receives an error.
func (client HeaderClient) ResponseStringSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ResponseStringResponder handles the response to the ResponseString request. The method always
// closes the http.Response Body.
func (client HeaderClient) ResponseStringResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
