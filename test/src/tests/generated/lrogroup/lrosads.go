package lrogroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// LROSADsClient is the long-running Operation for AutoRest
type LROSADsClient struct {
	BaseClient
}

// NewLROSADsClient creates an instance of the LROSADsClient client.
func NewLROSADsClient() LROSADsClient {
	return NewLROSADsClientWithBaseURI(DefaultBaseURI)
}

// NewLROSADsClientWithBaseURI creates an instance of the LROSADsClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewLROSADsClientWithBaseURI(baseURI string) LROSADsClient {
	return LROSADsClient{NewWithBaseURI(baseURI)}
}

// Delete202NonRetry400 long running delete request, service returns a 202 with a location header
func (client LROSADsClient) Delete202NonRetry400(ctx context.Context) (result LROSADsDelete202NonRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Delete202NonRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Delete202NonRetry400Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Delete202NonRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete202NonRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Delete202NonRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// Delete202NonRetry400Preparer prepares the Delete202NonRetry400 request.
func (client LROSADsClient) Delete202NonRetry400Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/delete/202/retry/400"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Delete202NonRetry400Sender sends the Delete202NonRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Delete202NonRetry400Sender(req *http.Request) (future LROSADsDelete202NonRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Delete202NonRetry400Responder handles the response to the Delete202NonRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Delete202NonRetry400Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Delete202RetryInvalidHeader long running delete request, service returns a 202 to the initial request receing a
// reponse with an invalid 'Location' and 'Retry-After' headers
func (client LROSADsClient) Delete202RetryInvalidHeader(ctx context.Context) (result LROSADsDelete202RetryInvalidHeaderFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Delete202RetryInvalidHeader")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Delete202RetryInvalidHeaderPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Delete202RetryInvalidHeader", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete202RetryInvalidHeaderSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Delete202RetryInvalidHeader", result.Response(), "Failure sending request")
		return
	}

	return
}

// Delete202RetryInvalidHeaderPreparer prepares the Delete202RetryInvalidHeader request.
func (client LROSADsClient) Delete202RetryInvalidHeaderPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/delete/202/retry/invalidheader"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Delete202RetryInvalidHeaderSender sends the Delete202RetryInvalidHeader request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Delete202RetryInvalidHeaderSender(req *http.Request) (future LROSADsDelete202RetryInvalidHeaderFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Delete202RetryInvalidHeaderResponder handles the response to the Delete202RetryInvalidHeader request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Delete202RetryInvalidHeaderResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Delete204Succeeded long running delete request, service returns a 204 to the initial request, indicating success.
func (client LROSADsClient) Delete204Succeeded(ctx context.Context) (result LROSADsDelete204SucceededFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Delete204Succeeded")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Delete204SucceededPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Delete204Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete204SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Delete204Succeeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// Delete204SucceededPreparer prepares the Delete204Succeeded request.
func (client LROSADsClient) Delete204SucceededPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/delete/204/nolocation"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Delete204SucceededSender sends the Delete204Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Delete204SucceededSender(req *http.Request) (future LROSADsDelete204SucceededFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Delete204SucceededResponder handles the response to the Delete204Succeeded request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Delete204SucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRelativeRetry400 long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROSADsClient) DeleteAsyncRelativeRetry400(ctx context.Context) (result LROSADsDeleteAsyncRelativeRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.DeleteAsyncRelativeRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteAsyncRelativeRetry400Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRelativeRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRelativeRetry400Preparer prepares the DeleteAsyncRelativeRetry400 request.
func (client LROSADsClient) DeleteAsyncRelativeRetry400Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/deleteasync/retry/400"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRelativeRetry400Sender sends the DeleteAsyncRelativeRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) DeleteAsyncRelativeRetry400Sender(req *http.Request) (future LROSADsDeleteAsyncRelativeRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// DeleteAsyncRelativeRetry400Responder handles the response to the DeleteAsyncRelativeRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) DeleteAsyncRelativeRetry400Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRelativeRetryInvalidHeader long running delete request, service returns a 202 to the initial request. The
// endpoint indicated in the Azure-AsyncOperation header is invalid
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidHeader(ctx context.Context) (result LROSADsDeleteAsyncRelativeRetryInvalidHeaderFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.DeleteAsyncRelativeRetryInvalidHeader")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteAsyncRelativeRetryInvalidHeaderPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetryInvalidHeader", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRelativeRetryInvalidHeaderSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetryInvalidHeader", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRelativeRetryInvalidHeaderPreparer prepares the DeleteAsyncRelativeRetryInvalidHeader request.
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidHeaderPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/deleteasync/retry/invalidheader"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRelativeRetryInvalidHeaderSender sends the DeleteAsyncRelativeRetryInvalidHeader request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidHeaderSender(req *http.Request) (future LROSADsDeleteAsyncRelativeRetryInvalidHeaderFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// DeleteAsyncRelativeRetryInvalidHeaderResponder handles the response to the DeleteAsyncRelativeRetryInvalidHeader request. The method always
// closes the http.Response Body.
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidHeaderResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRelativeRetryInvalidJSONPolling long running delete request, service returns a 202 to the initial
// request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context) (result LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.DeleteAsyncRelativeRetryInvalidJSONPolling")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteAsyncRelativeRetryInvalidJSONPollingPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetryInvalidJSONPolling", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRelativeRetryInvalidJSONPollingSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetryInvalidJSONPolling", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRelativeRetryInvalidJSONPollingPreparer prepares the DeleteAsyncRelativeRetryInvalidJSONPolling request.
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidJSONPollingPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/deleteasync/retry/invalidjsonpolling"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRelativeRetryInvalidJSONPollingSender sends the DeleteAsyncRelativeRetryInvalidJSONPolling request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidJSONPollingSender(req *http.Request) (future LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// DeleteAsyncRelativeRetryInvalidJSONPollingResponder handles the response to the DeleteAsyncRelativeRetryInvalidJSONPolling request. The method always
// closes the http.Response Body.
func (client LROSADsClient) DeleteAsyncRelativeRetryInvalidJSONPollingResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRelativeRetryNoStatus long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROSADsClient) DeleteAsyncRelativeRetryNoStatus(ctx context.Context) (result LROSADsDeleteAsyncRelativeRetryNoStatusFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.DeleteAsyncRelativeRetryNoStatus")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteAsyncRelativeRetryNoStatusPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetryNoStatus", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRelativeRetryNoStatusSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteAsyncRelativeRetryNoStatus", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRelativeRetryNoStatusPreparer prepares the DeleteAsyncRelativeRetryNoStatus request.
func (client LROSADsClient) DeleteAsyncRelativeRetryNoStatusPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/deleteasync/retry/nostatus"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRelativeRetryNoStatusSender sends the DeleteAsyncRelativeRetryNoStatus request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) DeleteAsyncRelativeRetryNoStatusSender(req *http.Request) (future LROSADsDeleteAsyncRelativeRetryNoStatusFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// DeleteAsyncRelativeRetryNoStatusResponder handles the response to the DeleteAsyncRelativeRetryNoStatus request. The method always
// closes the http.Response Body.
func (client LROSADsClient) DeleteAsyncRelativeRetryNoStatusResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteNonRetry400 long running delete request, service returns a 400 with an error body
func (client LROSADsClient) DeleteNonRetry400(ctx context.Context) (result LROSADsDeleteNonRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.DeleteNonRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteNonRetry400Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteNonRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteNonRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "DeleteNonRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteNonRetry400Preparer prepares the DeleteNonRetry400 request.
func (client LROSADsClient) DeleteNonRetry400Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/delete/400"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteNonRetry400Sender sends the DeleteNonRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) DeleteNonRetry400Sender(req *http.Request) (future LROSADsDeleteNonRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// DeleteNonRetry400Responder handles the response to the DeleteNonRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) DeleteNonRetry400Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Post202NoLocation long running post request, service returns a 202 to the initial request, without a location
// header.
// Parameters:
// product - product to put
func (client LROSADsClient) Post202NoLocation(ctx context.Context, product *Product) (result LROSADsPost202NoLocationFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Post202NoLocation")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Post202NoLocationPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Post202NoLocation", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202NoLocationSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Post202NoLocation", result.Response(), "Failure sending request")
		return
	}

	return
}

// Post202NoLocationPreparer prepares the Post202NoLocation request.
func (client LROSADsClient) Post202NoLocationPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/post/202/nolocation"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Post202NoLocationSender sends the Post202NoLocation request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Post202NoLocationSender(req *http.Request) (future LROSADsPost202NoLocationFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Post202NoLocationResponder handles the response to the Post202NoLocation request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Post202NoLocationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Post202NonRetry400 long running post request, service returns a 202 with a location header
// Parameters:
// product - product to put
func (client LROSADsClient) Post202NonRetry400(ctx context.Context, product *Product) (result LROSADsPost202NonRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Post202NonRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Post202NonRetry400Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Post202NonRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202NonRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Post202NonRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// Post202NonRetry400Preparer prepares the Post202NonRetry400 request.
func (client LROSADsClient) Post202NonRetry400Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/post/202/retry/400"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Post202NonRetry400Sender sends the Post202NonRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Post202NonRetry400Sender(req *http.Request) (future LROSADsPost202NonRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Post202NonRetry400Responder handles the response to the Post202NonRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Post202NonRetry400Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Post202RetryInvalidHeader long running post request, service returns a 202 to the initial request, with invalid
// 'Location' and 'Retry-After' headers.
// Parameters:
// product - product to put
func (client LROSADsClient) Post202RetryInvalidHeader(ctx context.Context, product *Product) (result LROSADsPost202RetryInvalidHeaderFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Post202RetryInvalidHeader")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Post202RetryInvalidHeaderPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Post202RetryInvalidHeader", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202RetryInvalidHeaderSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Post202RetryInvalidHeader", result.Response(), "Failure sending request")
		return
	}

	return
}

// Post202RetryInvalidHeaderPreparer prepares the Post202RetryInvalidHeader request.
func (client LROSADsClient) Post202RetryInvalidHeaderPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/post/202/retry/invalidheader"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Post202RetryInvalidHeaderSender sends the Post202RetryInvalidHeader request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Post202RetryInvalidHeaderSender(req *http.Request) (future LROSADsPost202RetryInvalidHeaderFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Post202RetryInvalidHeaderResponder handles the response to the Post202RetryInvalidHeader request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Post202RetryInvalidHeaderResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRelativeRetry400 long running post request, service returns a 202 to the initial request Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PostAsyncRelativeRetry400(ctx context.Context, product *Product) (result LROSADsPostAsyncRelativeRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PostAsyncRelativeRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PostAsyncRelativeRetry400Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRelativeRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRelativeRetry400Preparer prepares the PostAsyncRelativeRetry400 request.
func (client LROSADsClient) PostAsyncRelativeRetry400Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/postasync/retry/400"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRelativeRetry400Sender sends the PostAsyncRelativeRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PostAsyncRelativeRetry400Sender(req *http.Request) (future LROSADsPostAsyncRelativeRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PostAsyncRelativeRetry400Responder handles the response to the PostAsyncRelativeRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PostAsyncRelativeRetry400Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRelativeRetryInvalidHeader long running post request, service returns a 202 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
// invalid.
// Parameters:
// product - product to put
func (client LROSADsClient) PostAsyncRelativeRetryInvalidHeader(ctx context.Context, product *Product) (result LROSADsPostAsyncRelativeRetryInvalidHeaderFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PostAsyncRelativeRetryInvalidHeader")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PostAsyncRelativeRetryInvalidHeaderPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetryInvalidHeader", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRelativeRetryInvalidHeaderSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetryInvalidHeader", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRelativeRetryInvalidHeaderPreparer prepares the PostAsyncRelativeRetryInvalidHeader request.
func (client LROSADsClient) PostAsyncRelativeRetryInvalidHeaderPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/postasync/retry/invalidheader"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRelativeRetryInvalidHeaderSender sends the PostAsyncRelativeRetryInvalidHeader request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PostAsyncRelativeRetryInvalidHeaderSender(req *http.Request) (future LROSADsPostAsyncRelativeRetryInvalidHeaderFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PostAsyncRelativeRetryInvalidHeaderResponder handles the response to the PostAsyncRelativeRetryInvalidHeader request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PostAsyncRelativeRetryInvalidHeaderResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRelativeRetryInvalidJSONPolling long running post request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation
// header for operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PostAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, product *Product) (result LROSADsPostAsyncRelativeRetryInvalidJSONPollingFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PostAsyncRelativeRetryInvalidJSONPolling")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PostAsyncRelativeRetryInvalidJSONPollingPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetryInvalidJSONPolling", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRelativeRetryInvalidJSONPollingSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetryInvalidJSONPolling", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRelativeRetryInvalidJSONPollingPreparer prepares the PostAsyncRelativeRetryInvalidJSONPolling request.
func (client LROSADsClient) PostAsyncRelativeRetryInvalidJSONPollingPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/postasync/retry/invalidjsonpolling"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRelativeRetryInvalidJSONPollingSender sends the PostAsyncRelativeRetryInvalidJSONPolling request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PostAsyncRelativeRetryInvalidJSONPollingSender(req *http.Request) (future LROSADsPostAsyncRelativeRetryInvalidJSONPollingFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PostAsyncRelativeRetryInvalidJSONPollingResponder handles the response to the PostAsyncRelativeRetryInvalidJSONPolling request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PostAsyncRelativeRetryInvalidJSONPollingResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRelativeRetryNoPayload long running post request, service returns a 202 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PostAsyncRelativeRetryNoPayload(ctx context.Context, product *Product) (result LROSADsPostAsyncRelativeRetryNoPayloadFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PostAsyncRelativeRetryNoPayload")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PostAsyncRelativeRetryNoPayloadPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetryNoPayload", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRelativeRetryNoPayloadSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostAsyncRelativeRetryNoPayload", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRelativeRetryNoPayloadPreparer prepares the PostAsyncRelativeRetryNoPayload request.
func (client LROSADsClient) PostAsyncRelativeRetryNoPayloadPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/postasync/retry/nopayload"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRelativeRetryNoPayloadSender sends the PostAsyncRelativeRetryNoPayload request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PostAsyncRelativeRetryNoPayloadSender(req *http.Request) (future LROSADsPostAsyncRelativeRetryNoPayloadFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PostAsyncRelativeRetryNoPayloadResponder handles the response to the PostAsyncRelativeRetryNoPayload request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PostAsyncRelativeRetryNoPayloadResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostNonRetry400 long running post request, service returns a 400 with no error body
// Parameters:
// product - product to put
func (client LROSADsClient) PostNonRetry400(ctx context.Context, product *Product) (result LROSADsPostNonRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PostNonRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PostNonRetry400Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostNonRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.PostNonRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PostNonRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostNonRetry400Preparer prepares the PostNonRetry400 request.
func (client LROSADsClient) PostNonRetry400Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/post/400"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostNonRetry400Sender sends the PostNonRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PostNonRetry400Sender(req *http.Request) (future LROSADsPostNonRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PostNonRetry400Responder handles the response to the PostNonRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PostNonRetry400Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Put200InvalidJSON long running put request, service returns a 200 to the initial request, with an entity that is not
// a valid json
// Parameters:
// product - product to put
func (client LROSADsClient) Put200InvalidJSON(ctx context.Context, product *Product) (result LROSADsPut200InvalidJSONFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.Put200InvalidJSON")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Put200InvalidJSONPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Put200InvalidJSON", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200InvalidJSONSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "Put200InvalidJSON", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put200InvalidJSONPreparer prepares the Put200InvalidJSON request.
func (client LROSADsClient) Put200InvalidJSONPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/put/200/invalidjson"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put200InvalidJSONSender sends the Put200InvalidJSON request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) Put200InvalidJSONSender(req *http.Request) (future LROSADsPut200InvalidJSONFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// Put200InvalidJSONResponder handles the response to the Put200InvalidJSON request. The method always
// closes the http.Response Body.
func (client LROSADsClient) Put200InvalidJSONResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRelativeRetry400 long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PutAsyncRelativeRetry400(ctx context.Context, product *Product) (result LROSADsPutAsyncRelativeRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutAsyncRelativeRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutAsyncRelativeRetry400Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRelativeRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRelativeRetry400Preparer prepares the PutAsyncRelativeRetry400 request.
func (client LROSADsClient) PutAsyncRelativeRetry400Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/putasync/retry/400"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRelativeRetry400Sender sends the PutAsyncRelativeRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutAsyncRelativeRetry400Sender(req *http.Request) (future LROSADsPutAsyncRelativeRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutAsyncRelativeRetry400Responder handles the response to the PutAsyncRelativeRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutAsyncRelativeRetry400Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRelativeRetryInvalidHeader long running put request, service returns a 200 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is
// invalid.
// Parameters:
// product - product to put
func (client LROSADsClient) PutAsyncRelativeRetryInvalidHeader(ctx context.Context, product *Product) (result LROSADsPutAsyncRelativeRetryInvalidHeaderFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutAsyncRelativeRetryInvalidHeader")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutAsyncRelativeRetryInvalidHeaderPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryInvalidHeader", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRelativeRetryInvalidHeaderSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryInvalidHeader", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRelativeRetryInvalidHeaderPreparer prepares the PutAsyncRelativeRetryInvalidHeader request.
func (client LROSADsClient) PutAsyncRelativeRetryInvalidHeaderPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/putasync/retry/invalidheader"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRelativeRetryInvalidHeaderSender sends the PutAsyncRelativeRetryInvalidHeader request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutAsyncRelativeRetryInvalidHeaderSender(req *http.Request) (future LROSADsPutAsyncRelativeRetryInvalidHeaderFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutAsyncRelativeRetryInvalidHeaderResponder handles the response to the PutAsyncRelativeRetryInvalidHeader request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutAsyncRelativeRetryInvalidHeaderResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRelativeRetryInvalidJSONPolling long running put request, service returns a 200 to the initial request, with
// an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PutAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, product *Product) (result LROSADsPutAsyncRelativeRetryInvalidJSONPollingFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutAsyncRelativeRetryInvalidJSONPolling")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutAsyncRelativeRetryInvalidJSONPollingPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryInvalidJSONPolling", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRelativeRetryInvalidJSONPollingSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryInvalidJSONPolling", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRelativeRetryInvalidJSONPollingPreparer prepares the PutAsyncRelativeRetryInvalidJSONPolling request.
func (client LROSADsClient) PutAsyncRelativeRetryInvalidJSONPollingPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/putasync/retry/invalidjsonpolling"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRelativeRetryInvalidJSONPollingSender sends the PutAsyncRelativeRetryInvalidJSONPolling request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutAsyncRelativeRetryInvalidJSONPollingSender(req *http.Request) (future LROSADsPutAsyncRelativeRetryInvalidJSONPollingFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutAsyncRelativeRetryInvalidJSONPollingResponder handles the response to the PutAsyncRelativeRetryInvalidJSONPolling request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutAsyncRelativeRetryInvalidJSONPollingResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRelativeRetryNoStatus long running put request, service returns a 200 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PutAsyncRelativeRetryNoStatus(ctx context.Context, product *Product) (result LROSADsPutAsyncRelativeRetryNoStatusFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutAsyncRelativeRetryNoStatus")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutAsyncRelativeRetryNoStatusPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryNoStatus", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRelativeRetryNoStatusSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryNoStatus", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRelativeRetryNoStatusPreparer prepares the PutAsyncRelativeRetryNoStatus request.
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/putasync/retry/nostatus"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRelativeRetryNoStatusSender sends the PutAsyncRelativeRetryNoStatus request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusSender(req *http.Request) (future LROSADsPutAsyncRelativeRetryNoStatusFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutAsyncRelativeRetryNoStatusResponder handles the response to the PutAsyncRelativeRetryNoStatus request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRelativeRetryNoStatusPayload long running put request, service returns a 200 to the initial request, with an
// entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header
// for operation status
// Parameters:
// product - product to put
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusPayload(ctx context.Context, product *Product) (result LROSADsPutAsyncRelativeRetryNoStatusPayloadFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutAsyncRelativeRetryNoStatusPayload")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutAsyncRelativeRetryNoStatusPayloadPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryNoStatusPayload", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRelativeRetryNoStatusPayloadSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutAsyncRelativeRetryNoStatusPayload", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRelativeRetryNoStatusPayloadPreparer prepares the PutAsyncRelativeRetryNoStatusPayload request.
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusPayloadPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/putasync/retry/nostatuspayload"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRelativeRetryNoStatusPayloadSender sends the PutAsyncRelativeRetryNoStatusPayload request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusPayloadSender(req *http.Request) (future LROSADsPutAsyncRelativeRetryNoStatusPayloadFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutAsyncRelativeRetryNoStatusPayloadResponder handles the response to the PutAsyncRelativeRetryNoStatusPayload request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutAsyncRelativeRetryNoStatusPayloadResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutError201NoProvisioningStatePayload long running put request, service returns a 201 to the initial request with no
// payload
// Parameters:
// product - product to put
func (client LROSADsClient) PutError201NoProvisioningStatePayload(ctx context.Context, product *Product) (result LROSADsPutError201NoProvisioningStatePayloadFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutError201NoProvisioningStatePayload")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutError201NoProvisioningStatePayloadPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutError201NoProvisioningStatePayload", nil, "Failure preparing request")
		return
	}

	result, err = client.PutError201NoProvisioningStatePayloadSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutError201NoProvisioningStatePayload", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutError201NoProvisioningStatePayloadPreparer prepares the PutError201NoProvisioningStatePayload request.
func (client LROSADsClient) PutError201NoProvisioningStatePayloadPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/error/put/201/noprovisioningstatepayload"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutError201NoProvisioningStatePayloadSender sends the PutError201NoProvisioningStatePayload request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutError201NoProvisioningStatePayloadSender(req *http.Request) (future LROSADsPutError201NoProvisioningStatePayloadFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutError201NoProvisioningStatePayloadResponder handles the response to the PutError201NoProvisioningStatePayload request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutError201NoProvisioningStatePayloadResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNonRetry201Creating400 long running put request, service returns a Product with 'ProvisioningState' = 'Creating'
// and 201 response code
// Parameters:
// product - product to put
func (client LROSADsClient) PutNonRetry201Creating400(ctx context.Context, product *Product) (result LROSADsPutNonRetry201Creating400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutNonRetry201Creating400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutNonRetry201Creating400Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutNonRetry201Creating400", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNonRetry201Creating400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutNonRetry201Creating400", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutNonRetry201Creating400Preparer prepares the PutNonRetry201Creating400 request.
func (client LROSADsClient) PutNonRetry201Creating400Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/put/201/creating/400"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutNonRetry201Creating400Sender sends the PutNonRetry201Creating400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutNonRetry201Creating400Sender(req *http.Request) (future LROSADsPutNonRetry201Creating400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutNonRetry201Creating400Responder handles the response to the PutNonRetry201Creating400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutNonRetry201Creating400Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNonRetry201Creating400InvalidJSON long running put request, service returns a Product with 'ProvisioningState' =
// 'Creating' and 201 response code
// Parameters:
// product - product to put
func (client LROSADsClient) PutNonRetry201Creating400InvalidJSON(ctx context.Context, product *Product) (result LROSADsPutNonRetry201Creating400InvalidJSONFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutNonRetry201Creating400InvalidJSON")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutNonRetry201Creating400InvalidJSONPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutNonRetry201Creating400InvalidJSON", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNonRetry201Creating400InvalidJSONSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutNonRetry201Creating400InvalidJSON", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutNonRetry201Creating400InvalidJSONPreparer prepares the PutNonRetry201Creating400InvalidJSON request.
func (client LROSADsClient) PutNonRetry201Creating400InvalidJSONPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/put/201/creating/400/invalidjson"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutNonRetry201Creating400InvalidJSONSender sends the PutNonRetry201Creating400InvalidJSON request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutNonRetry201Creating400InvalidJSONSender(req *http.Request) (future LROSADsPutNonRetry201Creating400InvalidJSONFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutNonRetry201Creating400InvalidJSONResponder handles the response to the PutNonRetry201Creating400InvalidJSON request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutNonRetry201Creating400InvalidJSONResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNonRetry400 long running put request, service returns a 400 to the initial request
// Parameters:
// product - product to put
func (client LROSADsClient) PutNonRetry400(ctx context.Context, product *Product) (result LROSADsPutNonRetry400Future, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LROSADsClient.PutNonRetry400")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.PutNonRetry400Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutNonRetry400", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNonRetry400Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROSADsClient", "PutNonRetry400", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutNonRetry400Preparer prepares the PutNonRetry400 request.
func (client LROSADsClient) PutNonRetry400Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/nonretryerror/put/400"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutNonRetry400Sender sends the PutNonRetry400 request. The method will close the
// http.Response Body if it receives an error.
func (client LROSADsClient) PutNonRetry400Sender(req *http.Request) (future LROSADsPutNonRetry400Future, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// PutNonRetry400Responder handles the response to the PutNonRetry400 request. The method always
// closes the http.Response Body.
func (client LROSADsClient) PutNonRetry400Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
