package lrogroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"net/http"
)

// LROsClient is the long-running Operation for AutoRest
type LROsClient struct {
	BaseClient
}

// NewLROsClient creates an instance of the LROsClient client.
func NewLROsClient() LROsClient {
	return NewLROsClientWithBaseURI(DefaultBaseURI)
}

// NewLROsClientWithBaseURI creates an instance of the LROsClient client.
func NewLROsClientWithBaseURI(baseURI string) LROsClient {
	return LROsClient{NewWithBaseURI(baseURI)}
}

// Delete202NoRetry204 long running delete request, service returns a 202 to the initial request. Polls return this
// value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client LROsClient) Delete202NoRetry204(ctx context.Context) (result LROsDelete202NoRetry204Future, err error) {
	req, err := client.Delete202NoRetry204Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202NoRetry204", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete202NoRetry204Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202NoRetry204", result.Response(), "Failure sending request")
		return
	}

	return
}

// Delete202NoRetry204Preparer prepares the Delete202NoRetry204 request.
func (client LROsClient) Delete202NoRetry204Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/202/noretry/204"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Delete202NoRetry204Sender sends the Delete202NoRetry204 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Delete202NoRetry204Sender(req *http.Request) (future LROsDelete202NoRetry204Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Delete202NoRetry204Responder handles the response to the Delete202NoRetry204 request. The method always
// closes the http.Response Body.
func (client LROsClient) Delete202NoRetry204Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete202Retry200 long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client LROsClient) Delete202Retry200(ctx context.Context) (result LROsDelete202Retry200Future, err error) {
	req, err := client.Delete202Retry200Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202Retry200", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete202Retry200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202Retry200", result.Response(), "Failure sending request")
		return
	}

	return
}

// Delete202Retry200Preparer prepares the Delete202Retry200 request.
func (client LROsClient) Delete202Retry200Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/202/retry/200"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Delete202Retry200Sender sends the Delete202Retry200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Delete202Retry200Sender(req *http.Request) (future LROsDelete202Retry200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Delete202Retry200Responder handles the response to the Delete202Retry200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Delete202Retry200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete204Succeeded long running delete succeeds and returns right away
func (client LROsClient) Delete204Succeeded(ctx context.Context) (result LROsDelete204SucceededFuture, err error) {
	req, err := client.Delete204SucceededPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete204Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete204SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete204Succeeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// Delete204SucceededPreparer prepares the Delete204Succeeded request.
func (client LROsClient) Delete204SucceededPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/204/succeeded"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Delete204SucceededSender sends the Delete204Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Delete204SucceededSender(req *http.Request) (future LROsDelete204SucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Delete204SucceededResponder handles the response to the Delete204Succeeded request. The method always
// closes the http.Response Body.
func (client LROsClient) Delete204SucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncNoHeaderInRetry long running delete request, service returns an Azure-AsyncOperation header in the
// initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
func (client LROsClient) DeleteAsyncNoHeaderInRetry(ctx context.Context) (result LROsDeleteAsyncNoHeaderInRetryFuture, err error) {
	req, err := client.DeleteAsyncNoHeaderInRetryPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoHeaderInRetry", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncNoHeaderInRetryPreparer prepares the DeleteAsyncNoHeaderInRetry request.
func (client LROsClient) DeleteAsyncNoHeaderInRetryPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/noheader/202/204"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncNoHeaderInRetrySender sends the DeleteAsyncNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncNoHeaderInRetrySender(req *http.Request) (future LROsDeleteAsyncNoHeaderInRetryFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteAsyncNoHeaderInRetryResponder handles the response to the DeleteAsyncNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncNoHeaderInRetryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncNoRetrySucceeded long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncNoRetrySucceeded(ctx context.Context) (result LROsDeleteAsyncNoRetrySucceededFuture, err error) {
	req, err := client.DeleteAsyncNoRetrySucceededPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncNoRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoRetrySucceeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncNoRetrySucceededPreparer prepares the DeleteAsyncNoRetrySucceeded request.
func (client LROsClient) DeleteAsyncNoRetrySucceededPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/noretry/succeeded"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncNoRetrySucceededSender sends the DeleteAsyncNoRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncNoRetrySucceededSender(req *http.Request) (future LROsDeleteAsyncNoRetrySucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteAsyncNoRetrySucceededResponder handles the response to the DeleteAsyncNoRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncNoRetrySucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRetrycanceled long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncRetrycanceled(ctx context.Context) (result LROsDeleteAsyncRetrycanceledFuture, err error) {
	req, err := client.DeleteAsyncRetrycanceledPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrycanceled", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRetrycanceledSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrycanceled", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRetrycanceledPreparer prepares the DeleteAsyncRetrycanceled request.
func (client LROsClient) DeleteAsyncRetrycanceledPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/retry/canceled"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRetrycanceledSender sends the DeleteAsyncRetrycanceled request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncRetrycanceledSender(req *http.Request) (future LROsDeleteAsyncRetrycanceledFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteAsyncRetrycanceledResponder handles the response to the DeleteAsyncRetrycanceled request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncRetrycanceledResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRetryFailed long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncRetryFailed(ctx context.Context) (result LROsDeleteAsyncRetryFailedFuture, err error) {
	req, err := client.DeleteAsyncRetryFailedPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetryFailed", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRetryFailedSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetryFailed", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRetryFailedPreparer prepares the DeleteAsyncRetryFailed request.
func (client LROsClient) DeleteAsyncRetryFailedPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/retry/failed"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRetryFailedSender sends the DeleteAsyncRetryFailed request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncRetryFailedSender(req *http.Request) (future LROsDeleteAsyncRetryFailedFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteAsyncRetryFailedResponder handles the response to the DeleteAsyncRetryFailed request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncRetryFailedResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRetrySucceeded long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncRetrySucceeded(ctx context.Context) (result LROsDeleteAsyncRetrySucceededFuture, err error) {
	req, err := client.DeleteAsyncRetrySucceededPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrySucceeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteAsyncRetrySucceededPreparer prepares the DeleteAsyncRetrySucceeded request.
func (client LROsClient) DeleteAsyncRetrySucceededPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/retry/succeeded"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAsyncRetrySucceededSender sends the DeleteAsyncRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncRetrySucceededSender(req *http.Request) (future LROsDeleteAsyncRetrySucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteAsyncRetrySucceededResponder handles the response to the DeleteAsyncRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncRetrySucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteNoHeaderInRetry long running delete request, service returns a location header in the initial request.
// Subsequent calls to operation status do not contain location header.
func (client LROsClient) DeleteNoHeaderInRetry(ctx context.Context) (result LROsDeleteNoHeaderInRetryFuture, err error) {
	req, err := client.DeleteNoHeaderInRetryPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteNoHeaderInRetry", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteNoHeaderInRetryPreparer prepares the DeleteNoHeaderInRetry request.
func (client LROsClient) DeleteNoHeaderInRetryPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/noheader"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteNoHeaderInRetrySender sends the DeleteNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteNoHeaderInRetrySender(req *http.Request) (future LROsDeleteNoHeaderInRetryFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteNoHeaderInRetryResponder handles the response to the DeleteNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteNoHeaderInRetryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteProvisioning202Accepted200Succeeded long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Succeeded’
func (client LROsClient) DeleteProvisioning202Accepted200Succeeded(ctx context.Context) (result LROsDeleteProvisioning202Accepted200SucceededFuture, err error) {
	req, err := client.DeleteProvisioning202Accepted200SucceededPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Accepted200Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteProvisioning202Accepted200SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Accepted200Succeeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteProvisioning202Accepted200SucceededPreparer prepares the DeleteProvisioning202Accepted200Succeeded request.
func (client LROsClient) DeleteProvisioning202Accepted200SucceededPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/provisioning/202/accepted/200/succeeded"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteProvisioning202Accepted200SucceededSender sends the DeleteProvisioning202Accepted200Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteProvisioning202Accepted200SucceededSender(req *http.Request) (future LROsDeleteProvisioning202Accepted200SucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteProvisioning202Accepted200SucceededResponder handles the response to the DeleteProvisioning202Accepted200Succeeded request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteProvisioning202Accepted200SucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteProvisioning202Deletingcanceled200 long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Canceled’
func (client LROsClient) DeleteProvisioning202Deletingcanceled200(ctx context.Context) (result LROsDeleteProvisioning202Deletingcanceled200Future, err error) {
	req, err := client.DeleteProvisioning202Deletingcanceled200Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Deletingcanceled200", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteProvisioning202Deletingcanceled200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Deletingcanceled200", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteProvisioning202Deletingcanceled200Preparer prepares the DeleteProvisioning202Deletingcanceled200 request.
func (client LROsClient) DeleteProvisioning202Deletingcanceled200Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/provisioning/202/deleting/200/canceled"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteProvisioning202Deletingcanceled200Sender sends the DeleteProvisioning202Deletingcanceled200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteProvisioning202Deletingcanceled200Sender(req *http.Request) (future LROsDeleteProvisioning202Deletingcanceled200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteProvisioning202Deletingcanceled200Responder handles the response to the DeleteProvisioning202Deletingcanceled200 request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteProvisioning202Deletingcanceled200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteProvisioning202DeletingFailed200 long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Failed’
func (client LROsClient) DeleteProvisioning202DeletingFailed200(ctx context.Context) (result LROsDeleteProvisioning202DeletingFailed200Future, err error) {
	req, err := client.DeleteProvisioning202DeletingFailed200Preparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202DeletingFailed200", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteProvisioning202DeletingFailed200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202DeletingFailed200", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteProvisioning202DeletingFailed200Preparer prepares the DeleteProvisioning202DeletingFailed200 request.
func (client LROsClient) DeleteProvisioning202DeletingFailed200Preparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/provisioning/202/deleting/200/failed"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteProvisioning202DeletingFailed200Sender sends the DeleteProvisioning202DeletingFailed200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteProvisioning202DeletingFailed200Sender(req *http.Request) (future LROsDeleteProvisioning202DeletingFailed200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteProvisioning202DeletingFailed200Responder handles the response to the DeleteProvisioning202DeletingFailed200 request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteProvisioning202DeletingFailed200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Post200WithPayload long running post request, service returns a 202 to the initial request, with 'Location' header.
// Poll returns a 200 with a response body after success.
func (client LROsClient) Post200WithPayload(ctx context.Context) (result LROsPost200WithPayloadFuture, err error) {
	req, err := client.Post200WithPayloadPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post200WithPayload", nil, "Failure preparing request")
		return
	}

	result, err = client.Post200WithPayloadSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post200WithPayload", result.Response(), "Failure sending request")
		return
	}

	return
}

// Post200WithPayloadPreparer prepares the Post200WithPayload request.
func (client LROsClient) Post200WithPayloadPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/post/payload/200"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Post200WithPayloadSender sends the Post200WithPayload request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Post200WithPayloadSender(req *http.Request) (future LROsPost200WithPayloadFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Post200WithPayloadResponder handles the response to the Post200WithPayload request. The method always
// closes the http.Response Body.
func (client LROsClient) Post200WithPayloadResponder(resp *http.Response) (result Sku, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Post202NoRetry204 long running post request, service returns a 202 to the initial request, with 'Location' header,
// 204 with noresponse body after success
// Parameters:
// product - product to put
func (client LROsClient) Post202NoRetry204(ctx context.Context, product *Product) (result LROsPost202NoRetry204Future, err error) {
	req, err := client.Post202NoRetry204Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202NoRetry204", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202NoRetry204Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202NoRetry204", result.Response(), "Failure sending request")
		return
	}

	return
}

// Post202NoRetry204Preparer prepares the Post202NoRetry204 request.
func (client LROsClient) Post202NoRetry204Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/post/202/noretry/204"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Post202NoRetry204Sender sends the Post202NoRetry204 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Post202NoRetry204Sender(req *http.Request) (future LROsPost202NoRetry204Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Post202NoRetry204Responder handles the response to the Post202NoRetry204 request. The method always
// closes the http.Response Body.
func (client LROsClient) Post202NoRetry204Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Post202Retry200 long running post request, service returns a 202 to the initial request, with 'Location' and
// 'Retry-After' headers, Polls return a 200 with a response body after success
// Parameters:
// product - product to put
func (client LROsClient) Post202Retry200(ctx context.Context, product *Product) (result LROsPost202Retry200Future, err error) {
	req, err := client.Post202Retry200Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202Retry200", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202Retry200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202Retry200", result.Response(), "Failure sending request")
		return
	}

	return
}

// Post202Retry200Preparer prepares the Post202Retry200 request.
func (client LROsClient) Post202Retry200Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/post/202/retry/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Post202Retry200Sender sends the Post202Retry200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Post202Retry200Sender(req *http.Request) (future LROsPost202Retry200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Post202Retry200Responder handles the response to the Post202Retry200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Post202Retry200Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncNoRetrySucceeded long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
// Parameters:
// product - product to put
func (client LROsClient) PostAsyncNoRetrySucceeded(ctx context.Context, product *Product) (result LROsPostAsyncNoRetrySucceededFuture, err error) {
	req, err := client.PostAsyncNoRetrySucceededPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncNoRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncNoRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncNoRetrySucceeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncNoRetrySucceededPreparer prepares the PostAsyncNoRetrySucceeded request.
func (client LROsClient) PostAsyncNoRetrySucceededPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/noretry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncNoRetrySucceededSender sends the PostAsyncNoRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncNoRetrySucceededSender(req *http.Request) (future LROsPostAsyncNoRetrySucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PostAsyncNoRetrySucceededResponder handles the response to the PostAsyncNoRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncNoRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PostAsyncRetrycanceled long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PostAsyncRetrycanceled(ctx context.Context, product *Product) (result LROsPostAsyncRetrycanceledFuture, err error) {
	req, err := client.PostAsyncRetrycanceledPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrycanceled", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRetrycanceledSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrycanceled", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRetrycanceledPreparer prepares the PostAsyncRetrycanceled request.
func (client LROsClient) PostAsyncRetrycanceledPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/retry/canceled"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRetrycanceledSender sends the PostAsyncRetrycanceled request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncRetrycanceledSender(req *http.Request) (future LROsPostAsyncRetrycanceledFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PostAsyncRetrycanceledResponder handles the response to the PostAsyncRetrycanceled request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncRetrycanceledResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRetryFailed long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PostAsyncRetryFailed(ctx context.Context, product *Product) (result LROsPostAsyncRetryFailedFuture, err error) {
	req, err := client.PostAsyncRetryFailedPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetryFailed", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRetryFailedSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetryFailed", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRetryFailedPreparer prepares the PostAsyncRetryFailed request.
func (client LROsClient) PostAsyncRetryFailedPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/retry/failed"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRetryFailedSender sends the PostAsyncRetryFailed request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncRetryFailedSender(req *http.Request) (future LROsPostAsyncRetryFailedFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PostAsyncRetryFailedResponder handles the response to the PostAsyncRetryFailed request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncRetryFailedResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRetrySucceeded long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PostAsyncRetrySucceeded(ctx context.Context, product *Product) (result LROsPostAsyncRetrySucceededFuture, err error) {
	req, err := client.PostAsyncRetrySucceededPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrySucceeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// PostAsyncRetrySucceededPreparer prepares the PostAsyncRetrySucceeded request.
func (client LROsClient) PostAsyncRetrySucceededPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/retry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PostAsyncRetrySucceededSender sends the PostAsyncRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncRetrySucceededSender(req *http.Request) (future LROsPostAsyncRetrySucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PostAsyncRetrySucceededResponder handles the response to the PostAsyncRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200Acceptedcanceled200 long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
// Parameters:
// product - product to put
func (client LROsClient) Put200Acceptedcanceled200(ctx context.Context, product *Product) (result LROsPut200Acceptedcanceled200Future, err error) {
	req, err := client.Put200Acceptedcanceled200Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Acceptedcanceled200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200Acceptedcanceled200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Acceptedcanceled200", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put200Acceptedcanceled200Preparer prepares the Put200Acceptedcanceled200 request.
func (client LROsClient) Put200Acceptedcanceled200Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/accepted/canceled/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put200Acceptedcanceled200Sender sends the Put200Acceptedcanceled200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200Acceptedcanceled200Sender(req *http.Request) (future LROsPut200Acceptedcanceled200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put200Acceptedcanceled200Responder handles the response to the Put200Acceptedcanceled200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200Acceptedcanceled200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200Succeeded long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
// Parameters:
// product - product to put
func (client LROsClient) Put200Succeeded(ctx context.Context, product *Product) (result LROsPut200SucceededFuture, err error) {
	req, err := client.Put200SucceededPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Succeeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put200SucceededPreparer prepares the Put200Succeeded request.
func (client LROsClient) Put200SucceededPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put200SucceededSender sends the Put200Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200SucceededSender(req *http.Request) (future LROsPut200SucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put200SucceededResponder handles the response to the Put200Succeeded request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200SucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200SucceededNoState long running put request, service returns a 200 to the initial request, with an entity that
// does not contain ProvisioningState=’Succeeded’.
// Parameters:
// product - product to put
func (client LROsClient) Put200SucceededNoState(ctx context.Context, product *Product) (result LROsPut200SucceededNoStateFuture, err error) {
	req, err := client.Put200SucceededNoStatePreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200SucceededNoState", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200SucceededNoStateSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200SucceededNoState", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put200SucceededNoStatePreparer prepares the Put200SucceededNoState request.
func (client LROsClient) Put200SucceededNoStatePreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/succeeded/nostate"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put200SucceededNoStateSender sends the Put200SucceededNoState request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200SucceededNoStateSender(req *http.Request) (future LROsPut200SucceededNoStateFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put200SucceededNoStateResponder handles the response to the Put200SucceededNoState request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200SucceededNoStateResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200UpdatingSucceeded204 long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// Parameters:
// product - product to put
func (client LROsClient) Put200UpdatingSucceeded204(ctx context.Context, product *Product) (result LROsPut200UpdatingSucceeded204Future, err error) {
	req, err := client.Put200UpdatingSucceeded204Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200UpdatingSucceeded204", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200UpdatingSucceeded204Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200UpdatingSucceeded204", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put200UpdatingSucceeded204Preparer prepares the Put200UpdatingSucceeded204 request.
func (client LROsClient) Put200UpdatingSucceeded204Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/updating/succeeded/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put200UpdatingSucceeded204Sender sends the Put200UpdatingSucceeded204 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200UpdatingSucceeded204Sender(req *http.Request) (future LROsPut200UpdatingSucceeded204Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put200UpdatingSucceeded204Responder handles the response to the Put200UpdatingSucceeded204 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200UpdatingSucceeded204Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put201CreatingFailed200 long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
// Parameters:
// product - product to put
func (client LROsClient) Put201CreatingFailed200(ctx context.Context, product *Product) (result LROsPut201CreatingFailed200Future, err error) {
	req, err := client.Put201CreatingFailed200Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingFailed200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put201CreatingFailed200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingFailed200", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put201CreatingFailed200Preparer prepares the Put201CreatingFailed200 request.
func (client LROsClient) Put201CreatingFailed200Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/201/created/failed/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put201CreatingFailed200Sender sends the Put201CreatingFailed200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put201CreatingFailed200Sender(req *http.Request) (future LROsPut201CreatingFailed200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put201CreatingFailed200Responder handles the response to the Put201CreatingFailed200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put201CreatingFailed200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put201CreatingSucceeded200 long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
// Parameters:
// product - product to put
func (client LROsClient) Put201CreatingSucceeded200(ctx context.Context, product *Product) (result LROsPut201CreatingSucceeded200Future, err error) {
	req, err := client.Put201CreatingSucceeded200Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingSucceeded200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put201CreatingSucceeded200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingSucceeded200", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put201CreatingSucceeded200Preparer prepares the Put201CreatingSucceeded200 request.
func (client LROsClient) Put201CreatingSucceeded200Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/201/creating/succeeded/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put201CreatingSucceeded200Sender sends the Put201CreatingSucceeded200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put201CreatingSucceeded200Sender(req *http.Request) (future LROsPut201CreatingSucceeded200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put201CreatingSucceeded200Responder handles the response to the Put201CreatingSucceeded200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put201CreatingSucceeded200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put202Retry200 long running put request, service returns a 202 to the initial request, with a location header that
// points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
// Parameters:
// product - product to put
func (client LROsClient) Put202Retry200(ctx context.Context, product *Product) (result LROsPut202Retry200Future, err error) {
	req, err := client.Put202Retry200Preparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put202Retry200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put202Retry200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put202Retry200", result.Response(), "Failure sending request")
		return
	}

	return
}

// Put202Retry200Preparer prepares the Put202Retry200 request.
func (client LROsClient) Put202Retry200Preparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/202/retry/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Put202Retry200Sender sends the Put202Retry200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put202Retry200Sender(req *http.Request) (future LROsPut202Retry200Future, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// Put202Retry200Responder handles the response to the Put202Retry200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put202Retry200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNoHeaderInRetry long running put request, service returns a 202 to the initial request with
// Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
// Parameters:
// product - product to put
func (client LROsClient) PutAsyncNoHeaderInRetry(ctx context.Context, product *Product) (result LROsPutAsyncNoHeaderInRetryFuture, err error) {
	req, err := client.PutAsyncNoHeaderInRetryPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoHeaderInRetry", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncNoHeaderInRetryPreparer prepares the PutAsyncNoHeaderInRetry request.
func (client LROsClient) PutAsyncNoHeaderInRetryPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/noheader/201/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncNoHeaderInRetrySender sends the PutAsyncNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNoHeaderInRetrySender(req *http.Request) (future LROsPutAsyncNoHeaderInRetryFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncNoHeaderInRetryResponder handles the response to the PutAsyncNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNoHeaderInRetryResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNonResource long running put request with non resource.
// Parameters:
// sku - sku to put
func (client LROsClient) PutAsyncNonResource(ctx context.Context, sku *Sku) (result LROsPutAsyncNonResourceFuture, err error) {
	req, err := client.PutAsyncNonResourcePreparer(ctx, sku)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNonResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNonResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNonResource", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncNonResourcePreparer prepares the PutAsyncNonResource request.
func (client LROsClient) PutAsyncNonResourcePreparer(ctx context.Context, sku *Sku) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putnonresourceasync/202/200"))
	if sku != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(sku))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncNonResourceSender sends the PutAsyncNonResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNonResourceSender(req *http.Request) (future LROsPutAsyncNonResourceFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncNonResourceResponder handles the response to the PutAsyncNonResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNonResourceResponder(resp *http.Response) (result Sku, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNoRetrycanceled long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PutAsyncNoRetrycanceled(ctx context.Context, product *Product) (result LROsPutAsyncNoRetrycanceledFuture, err error) {
	req, err := client.PutAsyncNoRetrycanceledPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrycanceled", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNoRetrycanceledSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrycanceled", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncNoRetrycanceledPreparer prepares the PutAsyncNoRetrycanceled request.
func (client LROsClient) PutAsyncNoRetrycanceledPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/noretry/canceled"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncNoRetrycanceledSender sends the PutAsyncNoRetrycanceled request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNoRetrycanceledSender(req *http.Request) (future LROsPutAsyncNoRetrycanceledFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncNoRetrycanceledResponder handles the response to the PutAsyncNoRetrycanceled request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNoRetrycanceledResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNoRetrySucceeded long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PutAsyncNoRetrySucceeded(ctx context.Context, product *Product) (result LROsPutAsyncNoRetrySucceededFuture, err error) {
	req, err := client.PutAsyncNoRetrySucceededPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNoRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrySucceeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncNoRetrySucceededPreparer prepares the PutAsyncNoRetrySucceeded request.
func (client LROsClient) PutAsyncNoRetrySucceededPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/noretry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncNoRetrySucceededSender sends the PutAsyncNoRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNoRetrySucceededSender(req *http.Request) (future LROsPutAsyncNoRetrySucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncNoRetrySucceededResponder handles the response to the PutAsyncNoRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNoRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRetryFailed long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PutAsyncRetryFailed(ctx context.Context, product *Product) (result LROsPutAsyncRetryFailedFuture, err error) {
	req, err := client.PutAsyncRetryFailedPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetryFailed", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRetryFailedSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetryFailed", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRetryFailedPreparer prepares the PutAsyncRetryFailed request.
func (client LROsClient) PutAsyncRetryFailedPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/retry/failed"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRetryFailedSender sends the PutAsyncRetryFailed request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncRetryFailedSender(req *http.Request) (future LROsPutAsyncRetryFailedFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncRetryFailedResponder handles the response to the PutAsyncRetryFailed request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncRetryFailedResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRetrySucceeded long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
// Parameters:
// product - product to put
func (client LROsClient) PutAsyncRetrySucceeded(ctx context.Context, product *Product) (result LROsPutAsyncRetrySucceededFuture, err error) {
	req, err := client.PutAsyncRetrySucceededPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetrySucceeded", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncRetrySucceededPreparer prepares the PutAsyncRetrySucceeded request.
func (client LROsClient) PutAsyncRetrySucceededPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/retry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncRetrySucceededSender sends the PutAsyncRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncRetrySucceededSender(req *http.Request) (future LROsPutAsyncRetrySucceededFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncRetrySucceededResponder handles the response to the PutAsyncRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncSubResource long running put request with sub resource.
// Parameters:
// product - sub Product to put
func (client LROsClient) PutAsyncSubResource(ctx context.Context, product *SubProduct) (result LROsPutAsyncSubResourceFuture, err error) {
	req, err := client.PutAsyncSubResourcePreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncSubResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncSubResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncSubResource", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutAsyncSubResourcePreparer prepares the PutAsyncSubResource request.
func (client LROsClient) PutAsyncSubResourcePreparer(ctx context.Context, product *SubProduct) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putsubresourceasync/202/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutAsyncSubResourceSender sends the PutAsyncSubResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncSubResourceSender(req *http.Request) (future LROsPutAsyncSubResourceFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutAsyncSubResourceResponder handles the response to the PutAsyncSubResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncSubResourceResponder(resp *http.Response) (result SubProduct, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNoHeaderInRetry long running put request, service returns a 202 to the initial request with location header.
// Subsequent calls to operation status do not contain location header.
// Parameters:
// product - product to put
func (client LROsClient) PutNoHeaderInRetry(ctx context.Context, product *Product) (result LROsPutNoHeaderInRetryFuture, err error) {
	req, err := client.PutNoHeaderInRetryPreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNoHeaderInRetry", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutNoHeaderInRetryPreparer prepares the PutNoHeaderInRetry request.
func (client LROsClient) PutNoHeaderInRetryPreparer(ctx context.Context, product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/noheader/202/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutNoHeaderInRetrySender sends the PutNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutNoHeaderInRetrySender(req *http.Request) (future LROsPutNoHeaderInRetryFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutNoHeaderInRetryResponder handles the response to the PutNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) PutNoHeaderInRetryResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNonResource long running put request with non resource.
// Parameters:
// sku - sku to put
func (client LROsClient) PutNonResource(ctx context.Context, sku *Sku) (result LROsPutNonResourceFuture, err error) {
	req, err := client.PutNonResourcePreparer(ctx, sku)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNonResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNonResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNonResource", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutNonResourcePreparer prepares the PutNonResource request.
func (client LROsClient) PutNonResourcePreparer(ctx context.Context, sku *Sku) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putnonresource/202/200"))
	if sku != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(sku))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutNonResourceSender sends the PutNonResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutNonResourceSender(req *http.Request) (future LROsPutNonResourceFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutNonResourceResponder handles the response to the PutNonResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutNonResourceResponder(resp *http.Response) (result Sku, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutSubResource long running put request with sub resource.
// Parameters:
// product - sub Product to put
func (client LROsClient) PutSubResource(ctx context.Context, product *SubProduct) (result LROsPutSubResourceFuture, err error) {
	req, err := client.PutSubResourcePreparer(ctx, product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutSubResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutSubResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutSubResource", result.Response(), "Failure sending request")
		return
	}

	return
}

// PutSubResourcePreparer prepares the PutSubResource request.
func (client LROsClient) PutSubResourcePreparer(ctx context.Context, product *SubProduct) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putsubresource/202/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutSubResourceSender sends the PutSubResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutSubResourceSender(req *http.Request) (future LROsPutSubResourceFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	err = autorest.Respond(resp, azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// PutSubResourceResponder handles the response to the PutSubResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutSubResourceResponder(resp *http.Response) (result SubProduct, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
