package lrogroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"net/http"
)

// LROsClient is the long-running Operation for AutoRest
type LROsClient struct {
	ManagementClient
}

// NewLROsClient creates an instance of the LROsClient client.
func NewLROsClient() LROsClient {
	return NewLROsClientWithBaseURI(DefaultBaseURI)
}

// NewLROsClientWithBaseURI creates an instance of the LROsClient client.
func NewLROsClientWithBaseURI(baseURI string) LROsClient {
	return LROsClient{NewWithBaseURI(baseURI)}
}

// Delete202NoRetry204 long running delete request, service returns a 202 to the initial request. Polls return this
// value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client LROsClient) Delete202NoRetry204() (result LROsDelete202NoRetry204Future, err error) {
	req, err := client.Delete202NoRetry204Preparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202NoRetry204", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete202NoRetry204Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202NoRetry204", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Delete202NoRetry204Preparer prepares the Delete202NoRetry204 request.
func (client LROsClient) Delete202NoRetry204Preparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/202/noretry/204"))
	return preparer.Prepare(&http.Request{})
}

// Delete202NoRetry204Sender sends the Delete202NoRetry204 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Delete202NoRetry204Sender(req *http.Request) (LROsDelete202NoRetry204Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDelete202NoRetry204Future{Future: future}
	return f, err
}

// Delete202NoRetry204Responder handles the response to the Delete202NoRetry204 request. The method always
// closes the http.Response Body.
func (client LROsClient) Delete202NoRetry204Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete202Retry200 long running delete request, service returns a 202 to the initial request. Polls return this value
// until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client LROsClient) Delete202Retry200() (result LROsDelete202Retry200Future, err error) {
	req, err := client.Delete202Retry200Preparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202Retry200", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete202Retry200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete202Retry200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Delete202Retry200Preparer prepares the Delete202Retry200 request.
func (client LROsClient) Delete202Retry200Preparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/202/retry/200"))
	return preparer.Prepare(&http.Request{})
}

// Delete202Retry200Sender sends the Delete202Retry200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Delete202Retry200Sender(req *http.Request) (LROsDelete202Retry200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDelete202Retry200Future{Future: future}
	return f, err
}

// Delete202Retry200Responder handles the response to the Delete202Retry200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Delete202Retry200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete204Succeeded long running delete succeeds and returns right away
func (client LROsClient) Delete204Succeeded() (result LROsDelete204SucceededFuture, err error) {
	req, err := client.Delete204SucceededPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete204Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.Delete204SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Delete204Succeeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Delete204SucceededPreparer prepares the Delete204Succeeded request.
func (client LROsClient) Delete204SucceededPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/204/succeeded"))
	return preparer.Prepare(&http.Request{})
}

// Delete204SucceededSender sends the Delete204Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Delete204SucceededSender(req *http.Request) (LROsDelete204SucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDelete204SucceededFuture{Future: future}
	return f, err
}

// Delete204SucceededResponder handles the response to the Delete204Succeeded request. The method always
// closes the http.Response Body.
func (client LROsClient) Delete204SucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncNoHeaderInRetry long running delete request, service returns an Azure-AsyncOperation header in the
// initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
func (client LROsClient) DeleteAsyncNoHeaderInRetry() (result LROsDeleteAsyncNoHeaderInRetryFuture, err error) {
	req, err := client.DeleteAsyncNoHeaderInRetryPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoHeaderInRetry", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteAsyncNoHeaderInRetryPreparer prepares the DeleteAsyncNoHeaderInRetry request.
func (client LROsClient) DeleteAsyncNoHeaderInRetryPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/noheader/202/204"))
	return preparer.Prepare(&http.Request{})
}

// DeleteAsyncNoHeaderInRetrySender sends the DeleteAsyncNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncNoHeaderInRetrySender(req *http.Request) (LROsDeleteAsyncNoHeaderInRetryFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteAsyncNoHeaderInRetryFuture{Future: future}
	return f, err
}

// DeleteAsyncNoHeaderInRetryResponder handles the response to the DeleteAsyncNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncNoHeaderInRetryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncNoRetrySucceeded long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncNoRetrySucceeded() (result LROsDeleteAsyncNoRetrySucceededFuture, err error) {
	req, err := client.DeleteAsyncNoRetrySucceededPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncNoRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncNoRetrySucceeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteAsyncNoRetrySucceededPreparer prepares the DeleteAsyncNoRetrySucceeded request.
func (client LROsClient) DeleteAsyncNoRetrySucceededPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/noretry/succeeded"))
	return preparer.Prepare(&http.Request{})
}

// DeleteAsyncNoRetrySucceededSender sends the DeleteAsyncNoRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncNoRetrySucceededSender(req *http.Request) (LROsDeleteAsyncNoRetrySucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteAsyncNoRetrySucceededFuture{Future: future}
	return f, err
}

// DeleteAsyncNoRetrySucceededResponder handles the response to the DeleteAsyncNoRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncNoRetrySucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRetrycanceled long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncRetrycanceled() (result LROsDeleteAsyncRetrycanceledFuture, err error) {
	req, err := client.DeleteAsyncRetrycanceledPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrycanceled", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRetrycanceledSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrycanceled", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteAsyncRetrycanceledPreparer prepares the DeleteAsyncRetrycanceled request.
func (client LROsClient) DeleteAsyncRetrycanceledPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/retry/canceled"))
	return preparer.Prepare(&http.Request{})
}

// DeleteAsyncRetrycanceledSender sends the DeleteAsyncRetrycanceled request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncRetrycanceledSender(req *http.Request) (LROsDeleteAsyncRetrycanceledFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteAsyncRetrycanceledFuture{Future: future}
	return f, err
}

// DeleteAsyncRetrycanceledResponder handles the response to the DeleteAsyncRetrycanceled request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncRetrycanceledResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRetryFailed long running delete request, service returns a 202 to the initial request. Poll the endpoint
// indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncRetryFailed() (result LROsDeleteAsyncRetryFailedFuture, err error) {
	req, err := client.DeleteAsyncRetryFailedPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetryFailed", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRetryFailedSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetryFailed", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteAsyncRetryFailedPreparer prepares the DeleteAsyncRetryFailed request.
func (client LROsClient) DeleteAsyncRetryFailedPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/retry/failed"))
	return preparer.Prepare(&http.Request{})
}

// DeleteAsyncRetryFailedSender sends the DeleteAsyncRetryFailed request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncRetryFailedSender(req *http.Request) (LROsDeleteAsyncRetryFailedFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteAsyncRetryFailedFuture{Future: future}
	return f, err
}

// DeleteAsyncRetryFailedResponder handles the response to the DeleteAsyncRetryFailed request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncRetryFailedResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteAsyncRetrySucceeded long running delete request, service returns a 202 to the initial request. Poll the
// endpoint indicated in the Azure-AsyncOperation header for operation status
func (client LROsClient) DeleteAsyncRetrySucceeded() (result LROsDeleteAsyncRetrySucceededFuture, err error) {
	req, err := client.DeleteAsyncRetrySucceededPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteAsyncRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteAsyncRetrySucceeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteAsyncRetrySucceededPreparer prepares the DeleteAsyncRetrySucceeded request.
func (client LROsClient) DeleteAsyncRetrySucceededPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/deleteasync/retry/succeeded"))
	return preparer.Prepare(&http.Request{})
}

// DeleteAsyncRetrySucceededSender sends the DeleteAsyncRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteAsyncRetrySucceededSender(req *http.Request) (LROsDeleteAsyncRetrySucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteAsyncRetrySucceededFuture{Future: future}
	return f, err
}

// DeleteAsyncRetrySucceededResponder handles the response to the DeleteAsyncRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteAsyncRetrySucceededResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteNoHeaderInRetry long running delete request, service returns a location header in the initial request.
// Subsequent calls to operation status do not contain location header.
func (client LROsClient) DeleteNoHeaderInRetry() (result LROsDeleteNoHeaderInRetryFuture, err error) {
	req, err := client.DeleteNoHeaderInRetryPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteNoHeaderInRetry", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteNoHeaderInRetryPreparer prepares the DeleteNoHeaderInRetry request.
func (client LROsClient) DeleteNoHeaderInRetryPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/noheader"))
	return preparer.Prepare(&http.Request{})
}

// DeleteNoHeaderInRetrySender sends the DeleteNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteNoHeaderInRetrySender(req *http.Request) (LROsDeleteNoHeaderInRetryFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteNoHeaderInRetryFuture{Future: future}
	return f, err
}

// DeleteNoHeaderInRetryResponder handles the response to the DeleteNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteNoHeaderInRetryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteProvisioning202Accepted200Succeeded long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Succeeded’
func (client LROsClient) DeleteProvisioning202Accepted200Succeeded() (result LROsDeleteProvisioning202Accepted200SucceededFuture, err error) {
	req, err := client.DeleteProvisioning202Accepted200SucceededPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Accepted200Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteProvisioning202Accepted200SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Accepted200Succeeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteProvisioning202Accepted200SucceededPreparer prepares the DeleteProvisioning202Accepted200Succeeded request.
func (client LROsClient) DeleteProvisioning202Accepted200SucceededPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/provisioning/202/accepted/200/succeeded"))
	return preparer.Prepare(&http.Request{})
}

// DeleteProvisioning202Accepted200SucceededSender sends the DeleteProvisioning202Accepted200Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteProvisioning202Accepted200SucceededSender(req *http.Request) (LROsDeleteProvisioning202Accepted200SucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteProvisioning202Accepted200SucceededFuture{Future: future}
	return f, err
}

// DeleteProvisioning202Accepted200SucceededResponder handles the response to the DeleteProvisioning202Accepted200Succeeded request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteProvisioning202Accepted200SucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteProvisioning202Deletingcanceled200 long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Canceled’
func (client LROsClient) DeleteProvisioning202Deletingcanceled200() (result LROsDeleteProvisioning202Deletingcanceled200Future, err error) {
	req, err := client.DeleteProvisioning202Deletingcanceled200Preparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Deletingcanceled200", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteProvisioning202Deletingcanceled200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202Deletingcanceled200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteProvisioning202Deletingcanceled200Preparer prepares the DeleteProvisioning202Deletingcanceled200 request.
func (client LROsClient) DeleteProvisioning202Deletingcanceled200Preparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/provisioning/202/deleting/200/canceled"))
	return preparer.Prepare(&http.Request{})
}

// DeleteProvisioning202Deletingcanceled200Sender sends the DeleteProvisioning202Deletingcanceled200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteProvisioning202Deletingcanceled200Sender(req *http.Request) (LROsDeleteProvisioning202Deletingcanceled200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteProvisioning202Deletingcanceled200Future{Future: future}
	return f, err
}

// DeleteProvisioning202Deletingcanceled200Responder handles the response to the DeleteProvisioning202Deletingcanceled200 request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteProvisioning202Deletingcanceled200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteProvisioning202DeletingFailed200 long running delete request, service returns a 202 to the initial request,
// with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a
// ‘200’ with ProvisioningState=’Failed’
func (client LROsClient) DeleteProvisioning202DeletingFailed200() (result LROsDeleteProvisioning202DeletingFailed200Future, err error) {
	req, err := client.DeleteProvisioning202DeletingFailed200Preparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202DeletingFailed200", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteProvisioning202DeletingFailed200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "DeleteProvisioning202DeletingFailed200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// DeleteProvisioning202DeletingFailed200Preparer prepares the DeleteProvisioning202DeletingFailed200 request.
func (client LROsClient) DeleteProvisioning202DeletingFailed200Preparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/delete/provisioning/202/deleting/200/failed"))
	return preparer.Prepare(&http.Request{})
}

// DeleteProvisioning202DeletingFailed200Sender sends the DeleteProvisioning202DeletingFailed200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) DeleteProvisioning202DeletingFailed200Sender(req *http.Request) (LROsDeleteProvisioning202DeletingFailed200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsDeleteProvisioning202DeletingFailed200Future{Future: future}
	return f, err
}

// DeleteProvisioning202DeletingFailed200Responder handles the response to the DeleteProvisioning202DeletingFailed200 request. The method always
// closes the http.Response Body.
func (client LROsClient) DeleteProvisioning202DeletingFailed200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Post200WithPayload long running post request, service returns a 202 to the initial request, with 'Location' header.
// Poll returns a 200 with a response body after success.
func (client LROsClient) Post200WithPayload() (result LROsPost200WithPayloadFuture, err error) {
	req, err := client.Post200WithPayloadPreparer()
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post200WithPayload", nil, "Failure preparing request")
		return
	}

	result, err = client.Post200WithPayloadSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post200WithPayload", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Post200WithPayloadPreparer prepares the Post200WithPayload request.
func (client LROsClient) Post200WithPayloadPreparer() (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/post/payload/200"))
	return preparer.Prepare(&http.Request{})
}

// Post200WithPayloadSender sends the Post200WithPayload request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Post200WithPayloadSender(req *http.Request) (LROsPost200WithPayloadFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPost200WithPayloadFuture{Future: future}
	return f, err
}

// Post200WithPayloadResponder handles the response to the Post200WithPayload request. The method always
// closes the http.Response Body.
func (client LROsClient) Post200WithPayloadResponder(resp *http.Response) (result Sku, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusAccepted, http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Post202NoRetry204 long running post request, service returns a 202 to the initial request, with 'Location' header,
// 204 with noresponse body after success
//
// product is product to put
func (client LROsClient) Post202NoRetry204(product *Product) (result LROsPost202NoRetry204Future, err error) {
	req, err := client.Post202NoRetry204Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202NoRetry204", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202NoRetry204Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202NoRetry204", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Post202NoRetry204Preparer prepares the Post202NoRetry204 request.
func (client LROsClient) Post202NoRetry204Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/post/202/noretry/204"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Post202NoRetry204Sender sends the Post202NoRetry204 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Post202NoRetry204Sender(req *http.Request) (LROsPost202NoRetry204Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPost202NoRetry204Future{Future: future}
	return f, err
}

// Post202NoRetry204Responder handles the response to the Post202NoRetry204 request. The method always
// closes the http.Response Body.
func (client LROsClient) Post202NoRetry204Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Post202Retry200 long running post request, service returns a 202 to the initial request, with 'Location' and
// 'Retry-After' headers, Polls return a 200 with a response body after success
//
// product is product to put
func (client LROsClient) Post202Retry200(product *Product) (result LROsPost202Retry200Future, err error) {
	req, err := client.Post202Retry200Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202Retry200", nil, "Failure preparing request")
		return
	}

	result, err = client.Post202Retry200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Post202Retry200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Post202Retry200Preparer prepares the Post202Retry200 request.
func (client LROsClient) Post202Retry200Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/post/202/retry/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Post202Retry200Sender sends the Post202Retry200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Post202Retry200Sender(req *http.Request) (LROsPost202Retry200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPost202Retry200Future{Future: future}
	return f, err
}

// Post202Retry200Responder handles the response to the Post202Retry200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Post202Retry200Responder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncNoRetrySucceeded long running post request, service returns a 202 to the initial request, with an entity
// that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for
// operation status
//
// product is product to put
func (client LROsClient) PostAsyncNoRetrySucceeded(product *Product) (result LROsPostAsyncNoRetrySucceededFuture, err error) {
	req, err := client.PostAsyncNoRetrySucceededPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncNoRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncNoRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncNoRetrySucceeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PostAsyncNoRetrySucceededPreparer prepares the PostAsyncNoRetrySucceeded request.
func (client LROsClient) PostAsyncNoRetrySucceededPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/noretry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PostAsyncNoRetrySucceededSender sends the PostAsyncNoRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncNoRetrySucceededSender(req *http.Request) (LROsPostAsyncNoRetrySucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPostAsyncNoRetrySucceededFuture{Future: future}
	return f, err
}

// PostAsyncNoRetrySucceededResponder handles the response to the PostAsyncNoRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncNoRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusAccepted, http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PostAsyncRetrycanceled long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PostAsyncRetrycanceled(product *Product) (result LROsPostAsyncRetrycanceledFuture, err error) {
	req, err := client.PostAsyncRetrycanceledPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrycanceled", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRetrycanceledSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrycanceled", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PostAsyncRetrycanceledPreparer prepares the PostAsyncRetrycanceled request.
func (client LROsClient) PostAsyncRetrycanceledPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/retry/canceled"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PostAsyncRetrycanceledSender sends the PostAsyncRetrycanceled request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncRetrycanceledSender(req *http.Request) (LROsPostAsyncRetrycanceledFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPostAsyncRetrycanceledFuture{Future: future}
	return f, err
}

// PostAsyncRetrycanceledResponder handles the response to the PostAsyncRetrycanceled request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncRetrycanceledResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRetryFailed long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PostAsyncRetryFailed(product *Product) (result LROsPostAsyncRetryFailedFuture, err error) {
	req, err := client.PostAsyncRetryFailedPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetryFailed", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRetryFailedSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetryFailed", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PostAsyncRetryFailedPreparer prepares the PostAsyncRetryFailed request.
func (client LROsClient) PostAsyncRetryFailedPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/retry/failed"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PostAsyncRetryFailedSender sends the PostAsyncRetryFailed request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncRetryFailedSender(req *http.Request) (LROsPostAsyncRetryFailedFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPostAsyncRetryFailedFuture{Future: future}
	return f, err
}

// PostAsyncRetryFailedResponder handles the response to the PostAsyncRetryFailed request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncRetryFailedResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// PostAsyncRetrySucceeded long running post request, service returns a 202 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PostAsyncRetrySucceeded(product *Product) (result LROsPostAsyncRetrySucceededFuture, err error) {
	req, err := client.PostAsyncRetrySucceededPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PostAsyncRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PostAsyncRetrySucceeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PostAsyncRetrySucceededPreparer prepares the PostAsyncRetrySucceeded request.
func (client LROsClient) PostAsyncRetrySucceededPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/postasync/retry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PostAsyncRetrySucceededSender sends the PostAsyncRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PostAsyncRetrySucceededSender(req *http.Request) (LROsPostAsyncRetrySucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPostAsyncRetrySucceededFuture{Future: future}
	return f, err
}

// PostAsyncRetrySucceededResponder handles the response to the PostAsyncRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PostAsyncRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusAccepted, http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200Acceptedcanceled200 long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Canceled’
//
// product is product to put
func (client LROsClient) Put200Acceptedcanceled200(product *Product) (result LROsPut200Acceptedcanceled200Future, err error) {
	req, err := client.Put200Acceptedcanceled200Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Acceptedcanceled200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200Acceptedcanceled200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Acceptedcanceled200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put200Acceptedcanceled200Preparer prepares the Put200Acceptedcanceled200 request.
func (client LROsClient) Put200Acceptedcanceled200Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/accepted/canceled/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put200Acceptedcanceled200Sender sends the Put200Acceptedcanceled200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200Acceptedcanceled200Sender(req *http.Request) (LROsPut200Acceptedcanceled200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut200Acceptedcanceled200Future{Future: future}
	return f, err
}

// Put200Acceptedcanceled200Responder handles the response to the Put200Acceptedcanceled200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200Acceptedcanceled200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200Succeeded long running put request, service returns a 200 to the initial request, with an entity that contains
// ProvisioningState=’Succeeded’.
//
// product is product to put
func (client LROsClient) Put200Succeeded(product *Product) (result LROsPut200SucceededFuture, err error) {
	req, err := client.Put200SucceededPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Succeeded", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200SucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200Succeeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put200SucceededPreparer prepares the Put200Succeeded request.
func (client LROsClient) Put200SucceededPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put200SucceededSender sends the Put200Succeeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200SucceededSender(req *http.Request) (LROsPut200SucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut200SucceededFuture{Future: future}
	return f, err
}

// Put200SucceededResponder handles the response to the Put200Succeeded request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200SucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200SucceededNoState long running put request, service returns a 200 to the initial request, with an entity that
// does not contain ProvisioningState=’Succeeded’.
//
// product is product to put
func (client LROsClient) Put200SucceededNoState(product *Product) (result LROsPut200SucceededNoStateFuture, err error) {
	req, err := client.Put200SucceededNoStatePreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200SucceededNoState", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200SucceededNoStateSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200SucceededNoState", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put200SucceededNoStatePreparer prepares the Put200SucceededNoState request.
func (client LROsClient) Put200SucceededNoStatePreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/succeeded/nostate"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put200SucceededNoStateSender sends the Put200SucceededNoState request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200SucceededNoStateSender(req *http.Request) (LROsPut200SucceededNoStateFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut200SucceededNoStateFuture{Future: future}
	return f, err
}

// Put200SucceededNoStateResponder handles the response to the Put200SucceededNoState request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200SucceededNoStateResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put200UpdatingSucceeded204 long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
//
// product is product to put
func (client LROsClient) Put200UpdatingSucceeded204(product *Product) (result LROsPut200UpdatingSucceeded204Future, err error) {
	req, err := client.Put200UpdatingSucceeded204Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200UpdatingSucceeded204", nil, "Failure preparing request")
		return
	}

	result, err = client.Put200UpdatingSucceeded204Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put200UpdatingSucceeded204", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put200UpdatingSucceeded204Preparer prepares the Put200UpdatingSucceeded204 request.
func (client LROsClient) Put200UpdatingSucceeded204Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/200/updating/succeeded/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put200UpdatingSucceeded204Sender sends the Put200UpdatingSucceeded204 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put200UpdatingSucceeded204Sender(req *http.Request) (LROsPut200UpdatingSucceeded204Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut200UpdatingSucceeded204Future{Future: future}
	return f, err
}

// Put200UpdatingSucceeded204Responder handles the response to the Put200UpdatingSucceeded204 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put200UpdatingSucceeded204Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put201CreatingFailed200 long running put request, service returns a 201 to the initial request, with an entity that
// contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Failed’
//
// product is product to put
func (client LROsClient) Put201CreatingFailed200(product *Product) (result LROsPut201CreatingFailed200Future, err error) {
	req, err := client.Put201CreatingFailed200Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingFailed200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put201CreatingFailed200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingFailed200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put201CreatingFailed200Preparer prepares the Put201CreatingFailed200 request.
func (client LROsClient) Put201CreatingFailed200Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/201/created/failed/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put201CreatingFailed200Sender sends the Put201CreatingFailed200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put201CreatingFailed200Sender(req *http.Request) (LROsPut201CreatingFailed200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut201CreatingFailed200Future{Future: future}
	return f, err
}

// Put201CreatingFailed200Responder handles the response to the Put201CreatingFailed200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put201CreatingFailed200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put201CreatingSucceeded200 long running put request, service returns a 201 to the initial request, with an entity
// that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with
// ProvisioningState=’Succeeded’
//
// product is product to put
func (client LROsClient) Put201CreatingSucceeded200(product *Product) (result LROsPut201CreatingSucceeded200Future, err error) {
	req, err := client.Put201CreatingSucceeded200Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingSucceeded200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put201CreatingSucceeded200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put201CreatingSucceeded200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put201CreatingSucceeded200Preparer prepares the Put201CreatingSucceeded200 request.
func (client LROsClient) Put201CreatingSucceeded200Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/201/creating/succeeded/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put201CreatingSucceeded200Sender sends the Put201CreatingSucceeded200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put201CreatingSucceeded200Sender(req *http.Request) (LROsPut201CreatingSucceeded200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut201CreatingSucceeded200Future{Future: future}
	return f, err
}

// Put201CreatingSucceeded200Responder handles the response to the Put201CreatingSucceeded200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put201CreatingSucceeded200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Put202Retry200 long running put request, service returns a 202 to the initial request, with a location header that
// points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
//
// product is product to put
func (client LROsClient) Put202Retry200(product *Product) (result LROsPut202Retry200Future, err error) {
	req, err := client.Put202Retry200Preparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put202Retry200", nil, "Failure preparing request")
		return
	}

	result, err = client.Put202Retry200Sender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "Put202Retry200", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// Put202Retry200Preparer prepares the Put202Retry200 request.
func (client LROsClient) Put202Retry200Preparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/202/retry/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// Put202Retry200Sender sends the Put202Retry200 request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) Put202Retry200Sender(req *http.Request) (LROsPut202Retry200Future, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPut202Retry200Future{Future: future}
	return f, err
}

// Put202Retry200Responder handles the response to the Put202Retry200 request. The method always
// closes the http.Response Body.
func (client LROsClient) Put202Retry200Responder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNoHeaderInRetry long running put request, service returns a 202 to the initial request with
// Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
//
// product is product to put
func (client LROsClient) PutAsyncNoHeaderInRetry(product *Product) (result LROsPutAsyncNoHeaderInRetryFuture, err error) {
	req, err := client.PutAsyncNoHeaderInRetryPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoHeaderInRetry", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncNoHeaderInRetryPreparer prepares the PutAsyncNoHeaderInRetry request.
func (client LROsClient) PutAsyncNoHeaderInRetryPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/noheader/201/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncNoHeaderInRetrySender sends the PutAsyncNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNoHeaderInRetrySender(req *http.Request) (LROsPutAsyncNoHeaderInRetryFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncNoHeaderInRetryFuture{Future: future}
	return f, err
}

// PutAsyncNoHeaderInRetryResponder handles the response to the PutAsyncNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNoHeaderInRetryResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNonResource long running put request with non resource.
//
// sku is sku to put
func (client LROsClient) PutAsyncNonResource(sku *Sku) (result LROsPutAsyncNonResourceFuture, err error) {
	req, err := client.PutAsyncNonResourcePreparer(sku)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNonResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNonResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNonResource", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncNonResourcePreparer prepares the PutAsyncNonResource request.
func (client LROsClient) PutAsyncNonResourcePreparer(sku *Sku) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putnonresourceasync/202/200"))
	if sku != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(sku))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncNonResourceSender sends the PutAsyncNonResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNonResourceSender(req *http.Request) (LROsPutAsyncNonResourceFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncNonResourceFuture{Future: future}
	return f, err
}

// PutAsyncNonResourceResponder handles the response to the PutAsyncNonResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNonResourceResponder(resp *http.Response) (result Sku, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNoRetrycanceled long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PutAsyncNoRetrycanceled(product *Product) (result LROsPutAsyncNoRetrycanceledFuture, err error) {
	req, err := client.PutAsyncNoRetrycanceledPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrycanceled", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNoRetrycanceledSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrycanceled", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncNoRetrycanceledPreparer prepares the PutAsyncNoRetrycanceled request.
func (client LROsClient) PutAsyncNoRetrycanceledPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/noretry/canceled"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncNoRetrycanceledSender sends the PutAsyncNoRetrycanceled request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNoRetrycanceledSender(req *http.Request) (LROsPutAsyncNoRetrycanceledFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncNoRetrycanceledFuture{Future: future}
	return f, err
}

// PutAsyncNoRetrycanceledResponder handles the response to the PutAsyncNoRetrycanceled request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNoRetrycanceledResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncNoRetrySucceeded long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PutAsyncNoRetrySucceeded(product *Product) (result LROsPutAsyncNoRetrySucceededFuture, err error) {
	req, err := client.PutAsyncNoRetrySucceededPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncNoRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncNoRetrySucceeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncNoRetrySucceededPreparer prepares the PutAsyncNoRetrySucceeded request.
func (client LROsClient) PutAsyncNoRetrySucceededPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/noretry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncNoRetrySucceededSender sends the PutAsyncNoRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncNoRetrySucceededSender(req *http.Request) (LROsPutAsyncNoRetrySucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncNoRetrySucceededFuture{Future: future}
	return f, err
}

// PutAsyncNoRetrySucceededResponder handles the response to the PutAsyncNoRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncNoRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRetryFailed long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PutAsyncRetryFailed(product *Product) (result LROsPutAsyncRetryFailedFuture, err error) {
	req, err := client.PutAsyncRetryFailedPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetryFailed", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRetryFailedSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetryFailed", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncRetryFailedPreparer prepares the PutAsyncRetryFailed request.
func (client LROsClient) PutAsyncRetryFailedPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/retry/failed"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncRetryFailedSender sends the PutAsyncRetryFailed request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncRetryFailedSender(req *http.Request) (LROsPutAsyncRetryFailedFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncRetryFailedFuture{Future: future}
	return f, err
}

// PutAsyncRetryFailedResponder handles the response to the PutAsyncRetryFailed request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncRetryFailedResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncRetrySucceeded long running put request, service returns a 200 to the initial request, with an entity that
// contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
// status
//
// product is product to put
func (client LROsClient) PutAsyncRetrySucceeded(product *Product) (result LROsPutAsyncRetrySucceededFuture, err error) {
	req, err := client.PutAsyncRetrySucceededPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetrySucceeded", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncRetrySucceededSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncRetrySucceeded", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncRetrySucceededPreparer prepares the PutAsyncRetrySucceeded request.
func (client LROsClient) PutAsyncRetrySucceededPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putasync/retry/succeeded"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncRetrySucceededSender sends the PutAsyncRetrySucceeded request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncRetrySucceededSender(req *http.Request) (LROsPutAsyncRetrySucceededFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncRetrySucceededFuture{Future: future}
	return f, err
}

// PutAsyncRetrySucceededResponder handles the response to the PutAsyncRetrySucceeded request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncRetrySucceededResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutAsyncSubResource long running put request with sub resource.
//
// product is sub Product to put
func (client LROsClient) PutAsyncSubResource(product *SubProduct) (result LROsPutAsyncSubResourceFuture, err error) {
	req, err := client.PutAsyncSubResourcePreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncSubResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutAsyncSubResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutAsyncSubResource", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutAsyncSubResourcePreparer prepares the PutAsyncSubResource request.
func (client LROsClient) PutAsyncSubResourcePreparer(product *SubProduct) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putsubresourceasync/202/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutAsyncSubResourceSender sends the PutAsyncSubResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutAsyncSubResourceSender(req *http.Request) (LROsPutAsyncSubResourceFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutAsyncSubResourceFuture{Future: future}
	return f, err
}

// PutAsyncSubResourceResponder handles the response to the PutAsyncSubResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutAsyncSubResourceResponder(resp *http.Response) (result SubProduct, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNoHeaderInRetry long running put request, service returns a 202 to the initial request with location header.
// Subsequent calls to operation status do not contain location header.
//
// product is product to put
func (client LROsClient) PutNoHeaderInRetry(product *Product) (result LROsPutNoHeaderInRetryFuture, err error) {
	req, err := client.PutNoHeaderInRetryPreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNoHeaderInRetry", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNoHeaderInRetrySender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNoHeaderInRetry", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutNoHeaderInRetryPreparer prepares the PutNoHeaderInRetry request.
func (client LROsClient) PutNoHeaderInRetryPreparer(product *Product) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/put/noheader/202/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutNoHeaderInRetrySender sends the PutNoHeaderInRetry request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutNoHeaderInRetrySender(req *http.Request) (LROsPutNoHeaderInRetryFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutNoHeaderInRetryFuture{Future: future}
	return f, err
}

// PutNoHeaderInRetryResponder handles the response to the PutNoHeaderInRetry request. The method always
// closes the http.Response Body.
func (client LROsClient) PutNoHeaderInRetryResponder(resp *http.Response) (result Product, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutNonResource long running put request with non resource.
//
// sku is sku to put
func (client LROsClient) PutNonResource(sku *Sku) (result LROsPutNonResourceFuture, err error) {
	req, err := client.PutNonResourcePreparer(sku)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNonResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutNonResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutNonResource", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutNonResourcePreparer prepares the PutNonResource request.
func (client LROsClient) PutNonResourcePreparer(sku *Sku) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putnonresource/202/200"))
	if sku != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(sku))
	}
	return preparer.Prepare(&http.Request{})
}

// PutNonResourceSender sends the PutNonResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutNonResourceSender(req *http.Request) (LROsPutNonResourceFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutNonResourceFuture{Future: future}
	return f, err
}

// PutNonResourceResponder handles the response to the PutNonResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutNonResourceResponder(resp *http.Response) (result Sku, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutSubResource long running put request with sub resource.
//
// product is sub Product to put
func (client LROsClient) PutSubResource(product *SubProduct) (result LROsPutSubResourceFuture, err error) {
	req, err := client.PutSubResourcePreparer(product)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutSubResource", nil, "Failure preparing request")
		return
	}

	result, err = client.PutSubResourceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "lrogroup.LROsClient", "PutSubResource", nil, "Failure sending request'result.Response()'")
		return
	}

	return
}

// PutSubResourcePreparer prepares the PutSubResource request.
func (client LROsClient) PutSubResourcePreparer(product *SubProduct) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/lro/putsubresource/202/200"))
	if product != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(product))
	}
	return preparer.Prepare(&http.Request{})
}

// PutSubResourceSender sends the PutSubResource request. The method will close the
// http.Response Body if it receives an error.
func (client LROsClient) PutSubResourceSender(req *http.Request) (LROsPutSubResourceFuture, error) {
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	future := azure.NewFuture(req)
	_, err := future.Done(sender)
	f := LROsPutSubResourceFuture{Future: future}
	return f, err
}

// PutSubResourceResponder handles the response to the PutSubResource request. The method always
// closes the http.Response Body.
func (client LROsClient) PutSubResourceResponder(resp *http.Response) (result SubProduct, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
