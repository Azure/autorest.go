package lrogroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"net/http"
)

// ProvisioningStateValues enumerates the values for provisioning state values.
type ProvisioningStateValues string

const (
	// Accepted specifies the accepted state for provisioning state values.
	Accepted ProvisioningStateValues = "Accepted"
	// Canceled specifies the canceled state for provisioning state values.
	Canceled ProvisioningStateValues = "canceled"
	// Created specifies the created state for provisioning state values.
	Created ProvisioningStateValues = "Created"
	// Creating specifies the creating state for provisioning state values.
	Creating ProvisioningStateValues = "Creating"
	// Deleted specifies the deleted state for provisioning state values.
	Deleted ProvisioningStateValues = "Deleted"
	// Deleting specifies the deleting state for provisioning state values.
	Deleting ProvisioningStateValues = "Deleting"
	// Failed specifies the failed state for provisioning state values.
	Failed ProvisioningStateValues = "Failed"
	// OK specifies the ok state for provisioning state values.
	OK ProvisioningStateValues = "OK"
	// Succeeded specifies the succeeded state for provisioning state values.
	Succeeded ProvisioningStateValues = "Succeeded"
	// Updated specifies the updated state for provisioning state values.
	Updated ProvisioningStateValues = "Updated"
	// Updating specifies the updating state for provisioning state values.
	Updating ProvisioningStateValues = "Updating"
)

// ProvisioningStateValues1 enumerates the values for provisioning state values 1.
type ProvisioningStateValues1 string

const (
	// ProvisioningStateValues1Accepted specifies the provisioning state values 1 accepted state for provisioning state
	// values 1.
	ProvisioningStateValues1Accepted ProvisioningStateValues1 = "Accepted"
	// ProvisioningStateValues1Canceled specifies the provisioning state values 1 canceled state for provisioning state
	// values 1.
	ProvisioningStateValues1Canceled ProvisioningStateValues1 = "canceled"
	// ProvisioningStateValues1Created specifies the provisioning state values 1 created state for provisioning state
	// values 1.
	ProvisioningStateValues1Created ProvisioningStateValues1 = "Created"
	// ProvisioningStateValues1Creating specifies the provisioning state values 1 creating state for provisioning state
	// values 1.
	ProvisioningStateValues1Creating ProvisioningStateValues1 = "Creating"
	// ProvisioningStateValues1Deleted specifies the provisioning state values 1 deleted state for provisioning state
	// values 1.
	ProvisioningStateValues1Deleted ProvisioningStateValues1 = "Deleted"
	// ProvisioningStateValues1Deleting specifies the provisioning state values 1 deleting state for provisioning state
	// values 1.
	ProvisioningStateValues1Deleting ProvisioningStateValues1 = "Deleting"
	// ProvisioningStateValues1Failed specifies the provisioning state values 1 failed state for provisioning state values
	// 1.
	ProvisioningStateValues1Failed ProvisioningStateValues1 = "Failed"
	// ProvisioningStateValues1OK specifies the provisioning state values 1ok state for provisioning state values 1.
	ProvisioningStateValues1OK ProvisioningStateValues1 = "OK"
	// ProvisioningStateValues1Succeeded specifies the provisioning state values 1 succeeded state for provisioning state
	// values 1.
	ProvisioningStateValues1Succeeded ProvisioningStateValues1 = "Succeeded"
	// ProvisioningStateValues1Updated specifies the provisioning state values 1 updated state for provisioning state
	// values 1.
	ProvisioningStateValues1Updated ProvisioningStateValues1 = "Updated"
	// ProvisioningStateValues1Updating specifies the provisioning state values 1 updating state for provisioning state
	// values 1.
	ProvisioningStateValues1Updating ProvisioningStateValues1 = "Updating"
)

// Status enumerates the values for status.
type Status string

const (
	// StatusAccepted specifies the status accepted state for status.
	StatusAccepted Status = "Accepted"
	// StatusCanceled specifies the status canceled state for status.
	StatusCanceled Status = "canceled"
	// StatusCreated specifies the status created state for status.
	StatusCreated Status = "Created"
	// StatusCreating specifies the status creating state for status.
	StatusCreating Status = "Creating"
	// StatusDeleted specifies the status deleted state for status.
	StatusDeleted Status = "Deleted"
	// StatusDeleting specifies the status deleting state for status.
	StatusDeleting Status = "Deleting"
	// StatusFailed specifies the status failed state for status.
	StatusFailed Status = "Failed"
	// StatusOK specifies the status ok state for status.
	StatusOK Status = "OK"
	// StatusSucceeded specifies the status succeeded state for status.
	StatusSucceeded Status = "Succeeded"
	// StatusUpdated specifies the status updated state for status.
	StatusUpdated Status = "Updated"
	// StatusUpdating specifies the status updating state for status.
	StatusUpdating Status = "Updating"
)

// CloudError
type CloudError struct {
	Status  *int32  `json:"status,omitempty"`
	Message *string `json:"message,omitempty"`
}

// LRORetrysDelete202Retry200Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LRORetrysDelete202Retry200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysDelete202Retry200Future) Result(client LRORetrysClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LRORetrysDelete202Retry200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete202Retry200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Delete202Retry200Responder(resp)
}

// LRORetrysDeleteAsyncRelativeRetrySucceededFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LRORetrysDeleteAsyncRelativeRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysDeleteAsyncRelativeRetrySucceededFuture) Result(client LRORetrysClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LRORetrysDeleteAsyncRelativeRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRelativeRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRelativeRetrySucceededResponder(resp)
}

// LRORetrysDeleteProvisioning202Accepted200SucceededFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type LRORetrysDeleteProvisioning202Accepted200SucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysDeleteProvisioning202Accepted200SucceededFuture) Result(client LRORetrysClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LRORetrysDeleteProvisioning202Accepted200SucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteProvisioning202Accepted200SucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.DeleteProvisioning202Accepted200SucceededResponder(resp)
}

// LRORetrysPost202Retry200Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LRORetrysPost202Retry200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysPost202Retry200Future) Result(client LRORetrysClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LRORetrysPost202Retry200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202Retry200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Post202Retry200Responder(resp)
}

// LRORetrysPostAsyncRelativeRetrySucceededFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LRORetrysPostAsyncRelativeRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysPostAsyncRelativeRetrySucceededFuture) Result(client LRORetrysClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LRORetrysPostAsyncRelativeRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRelativeRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRelativeRetrySucceededResponder(resp)
}

// LRORetrysPut201CreatingSucceeded200Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LRORetrysPut201CreatingSucceeded200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysPut201CreatingSucceeded200Future) Result(client LRORetrysClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LRORetrysPut201CreatingSucceeded200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put201CreatingSucceeded200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put201CreatingSucceeded200Responder(resp)
}

// LRORetrysPutAsyncRelativeRetrySucceededFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LRORetrysPutAsyncRelativeRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LRORetrysPutAsyncRelativeRetrySucceededFuture) Result(client LRORetrysClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LRORetrysPutAsyncRelativeRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRelativeRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRelativeRetrySucceededResponder(resp)
}

// LROSADsDelete202NonRetry400Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsDelete202NonRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDelete202NonRetry400Future) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDelete202NonRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete202NonRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Delete202NonRetry400Responder(resp)
}

// LROSADsDelete202RetryInvalidHeaderFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsDelete202RetryInvalidHeaderFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDelete202RetryInvalidHeaderFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDelete202RetryInvalidHeaderFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete202RetryInvalidHeaderResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Delete202RetryInvalidHeaderResponder(resp)
}

// LROSADsDelete204SucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsDelete204SucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDelete204SucceededFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDelete204SucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete204SucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Delete204SucceededResponder(resp)
}

// LROSADsDeleteAsyncRelativeRetry400Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsDeleteAsyncRelativeRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDeleteAsyncRelativeRetry400Future) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDeleteAsyncRelativeRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRelativeRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRelativeRetry400Responder(resp)
}

// LROSADsDeleteAsyncRelativeRetryInvalidHeaderFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsDeleteAsyncRelativeRetryInvalidHeaderFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDeleteAsyncRelativeRetryInvalidHeaderFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDeleteAsyncRelativeRetryInvalidHeaderFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRelativeRetryInvalidHeaderResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRelativeRetryInvalidHeaderResponder(resp)
}

// LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDeleteAsyncRelativeRetryInvalidJSONPollingFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRelativeRetryInvalidJSONPollingResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRelativeRetryInvalidJSONPollingResponder(resp)
}

// LROSADsDeleteAsyncRelativeRetryNoStatusFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsDeleteAsyncRelativeRetryNoStatusFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDeleteAsyncRelativeRetryNoStatusFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDeleteAsyncRelativeRetryNoStatusFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRelativeRetryNoStatusResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRelativeRetryNoStatusResponder(resp)
}

// LROSADsDeleteNonRetry400Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROSADsDeleteNonRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsDeleteNonRetry400Future) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsDeleteNonRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteNonRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteNonRetry400Responder(resp)
}

// LROSADsPost202NoLocationFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROSADsPost202NoLocationFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPost202NoLocationFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPost202NoLocationFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202NoLocationResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Post202NoLocationResponder(resp)
}

// LROSADsPost202NonRetry400Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsPost202NonRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPost202NonRetry400Future) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPost202NonRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202NonRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Post202NonRetry400Responder(resp)
}

// LROSADsPost202RetryInvalidHeaderFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsPost202RetryInvalidHeaderFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPost202RetryInvalidHeaderFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPost202RetryInvalidHeaderFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202RetryInvalidHeaderResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Post202RetryInvalidHeaderResponder(resp)
}

// LROSADsPostAsyncRelativeRetry400Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsPostAsyncRelativeRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPostAsyncRelativeRetry400Future) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPostAsyncRelativeRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRelativeRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRelativeRetry400Responder(resp)
}

// LROSADsPostAsyncRelativeRetryInvalidHeaderFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPostAsyncRelativeRetryInvalidHeaderFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPostAsyncRelativeRetryInvalidHeaderFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPostAsyncRelativeRetryInvalidHeaderFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRelativeRetryInvalidHeaderResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRelativeRetryInvalidHeaderResponder(resp)
}

// LROSADsPostAsyncRelativeRetryInvalidJSONPollingFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPostAsyncRelativeRetryInvalidJSONPollingFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPostAsyncRelativeRetryInvalidJSONPollingFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPostAsyncRelativeRetryInvalidJSONPollingFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRelativeRetryInvalidJSONPollingResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRelativeRetryInvalidJSONPollingResponder(resp)
}

// LROSADsPostAsyncRelativeRetryNoPayloadFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPostAsyncRelativeRetryNoPayloadFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPostAsyncRelativeRetryNoPayloadFuture) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPostAsyncRelativeRetryNoPayloadFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRelativeRetryNoPayloadResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRelativeRetryNoPayloadResponder(resp)
}

// LROSADsPostNonRetry400Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROSADsPostNonRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPostNonRetry400Future) Result(client LROSADsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROSADsPostNonRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostNonRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostNonRetry400Responder(resp)
}

// LROSADsPut200InvalidJSONFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROSADsPut200InvalidJSONFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPut200InvalidJSONFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPut200InvalidJSONFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put200InvalidJSONResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put200InvalidJSONResponder(resp)
}

// LROSADsPutAsyncRelativeRetry400Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsPutAsyncRelativeRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutAsyncRelativeRetry400Future) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutAsyncRelativeRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRelativeRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRelativeRetry400Responder(resp)
}

// LROSADsPutAsyncRelativeRetryInvalidHeaderFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPutAsyncRelativeRetryInvalidHeaderFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutAsyncRelativeRetryInvalidHeaderFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutAsyncRelativeRetryInvalidHeaderFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRelativeRetryInvalidHeaderResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRelativeRetryInvalidHeaderResponder(resp)
}

// LROSADsPutAsyncRelativeRetryInvalidJSONPollingFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPutAsyncRelativeRetryInvalidJSONPollingFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutAsyncRelativeRetryInvalidJSONPollingFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutAsyncRelativeRetryInvalidJSONPollingFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRelativeRetryInvalidJSONPollingResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRelativeRetryInvalidJSONPollingResponder(resp)
}

// LROSADsPutAsyncRelativeRetryNoStatusFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPutAsyncRelativeRetryNoStatusFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutAsyncRelativeRetryNoStatusFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutAsyncRelativeRetryNoStatusFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRelativeRetryNoStatusResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRelativeRetryNoStatusResponder(resp)
}

// LROSADsPutAsyncRelativeRetryNoStatusPayloadFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPutAsyncRelativeRetryNoStatusPayloadFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutAsyncRelativeRetryNoStatusPayloadFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutAsyncRelativeRetryNoStatusPayloadFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRelativeRetryNoStatusPayloadResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRelativeRetryNoStatusPayloadResponder(resp)
}

// LROSADsPutError201NoProvisioningStatePayloadFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPutError201NoProvisioningStatePayloadFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutError201NoProvisioningStatePayloadFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutError201NoProvisioningStatePayloadFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutError201NoProvisioningStatePayloadResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutError201NoProvisioningStatePayloadResponder(resp)
}

// LROSADsPutNonRetry201Creating400Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROSADsPutNonRetry201Creating400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutNonRetry201Creating400Future) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutNonRetry201Creating400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutNonRetry201Creating400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutNonRetry201Creating400Responder(resp)
}

// LROSADsPutNonRetry201Creating400InvalidJSONFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROSADsPutNonRetry201Creating400InvalidJSONFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutNonRetry201Creating400InvalidJSONFuture) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutNonRetry201Creating400InvalidJSONFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutNonRetry201Creating400InvalidJSONResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutNonRetry201Creating400InvalidJSONResponder(resp)
}

// LROSADsPutNonRetry400Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROSADsPutNonRetry400Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROSADsPutNonRetry400Future) Result(client LROSADsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROSADsPutNonRetry400Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutNonRetry400Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutNonRetry400Responder(resp)
}

// LROsCustomHeaderPost202Retry200Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsCustomHeaderPost202Retry200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsCustomHeaderPost202Retry200Future) Result(client LROsCustomHeaderClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsCustomHeaderPost202Retry200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202Retry200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Post202Retry200Responder(resp)
}

// LROsCustomHeaderPostAsyncRetrySucceededFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROsCustomHeaderPostAsyncRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsCustomHeaderPostAsyncRetrySucceededFuture) Result(client LROsCustomHeaderClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsCustomHeaderPostAsyncRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRetrySucceededResponder(resp)
}

// LROsCustomHeaderPut201CreatingSucceeded200Future an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROsCustomHeaderPut201CreatingSucceeded200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsCustomHeaderPut201CreatingSucceeded200Future) Result(client LROsCustomHeaderClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsCustomHeaderPut201CreatingSucceeded200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put201CreatingSucceeded200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put201CreatingSucceeded200Responder(resp)
}

// LROsCustomHeaderPutAsyncRetrySucceededFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROsCustomHeaderPutAsyncRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsCustomHeaderPutAsyncRetrySucceededFuture) Result(client LROsCustomHeaderClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsCustomHeaderPutAsyncRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRetrySucceededResponder(resp)
}

// LROsDelete202NoRetry204Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsDelete202NoRetry204Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDelete202NoRetry204Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsDelete202NoRetry204Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete202NoRetry204Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Delete202NoRetry204Responder(resp)
}

// LROsDelete202Retry200Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsDelete202Retry200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDelete202Retry200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsDelete202Retry200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete202Retry200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Delete202Retry200Responder(resp)
}

// LROsDelete204SucceededFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsDelete204SucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDelete204SucceededFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDelete204SucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Delete204SucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Delete204SucceededResponder(resp)
}

// LROsDeleteAsyncNoHeaderInRetryFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsDeleteAsyncNoHeaderInRetryFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteAsyncNoHeaderInRetryFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDeleteAsyncNoHeaderInRetryFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncNoHeaderInRetryResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncNoHeaderInRetryResponder(resp)
}

// LROsDeleteAsyncNoRetrySucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsDeleteAsyncNoRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteAsyncNoRetrySucceededFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDeleteAsyncNoRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncNoRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncNoRetrySucceededResponder(resp)
}

// LROsDeleteAsyncRetrycanceledFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsDeleteAsyncRetrycanceledFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteAsyncRetrycanceledFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDeleteAsyncRetrycanceledFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRetrycanceledResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRetrycanceledResponder(resp)
}

// LROsDeleteAsyncRetryFailedFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsDeleteAsyncRetryFailedFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteAsyncRetryFailedFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDeleteAsyncRetryFailedFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRetryFailedResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRetryFailedResponder(resp)
}

// LROsDeleteAsyncRetrySucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsDeleteAsyncRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteAsyncRetrySucceededFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDeleteAsyncRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteAsyncRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteAsyncRetrySucceededResponder(resp)
}

// LROsDeleteNoHeaderInRetryFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsDeleteNoHeaderInRetryFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteNoHeaderInRetryFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsDeleteNoHeaderInRetryFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteNoHeaderInRetryResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.DeleteNoHeaderInRetryResponder(resp)
}

// LROsDeleteProvisioning202Accepted200SucceededFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROsDeleteProvisioning202Accepted200SucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteProvisioning202Accepted200SucceededFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsDeleteProvisioning202Accepted200SucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteProvisioning202Accepted200SucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.DeleteProvisioning202Accepted200SucceededResponder(resp)
}

// LROsDeleteProvisioning202Deletingcanceled200Future an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROsDeleteProvisioning202Deletingcanceled200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteProvisioning202Deletingcanceled200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsDeleteProvisioning202Deletingcanceled200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteProvisioning202Deletingcanceled200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.DeleteProvisioning202Deletingcanceled200Responder(resp)
}

// LROsDeleteProvisioning202DeletingFailed200Future an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LROsDeleteProvisioning202DeletingFailed200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsDeleteProvisioning202DeletingFailed200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsDeleteProvisioning202DeletingFailed200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.DeleteProvisioning202DeletingFailed200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.DeleteProvisioning202DeletingFailed200Responder(resp)
}

// LROsPost200WithPayloadFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPost200WithPayloadFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPost200WithPayloadFuture) Result(client LROsClient) (Sku, error) {
	done, err := future.Done(client)
	if err != nil {
		return Sku{}, err
	}
	if !done {
		return Sku{}, autorest.NewError("lrogroup.LROsPost200WithPayloadFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post200WithPayloadResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Sku{}, err
	}
	return client.Post200WithPayloadResponder(resp)
}

// LROsPost202NoRetry204Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPost202NoRetry204Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPost202NoRetry204Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPost202NoRetry204Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202NoRetry204Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Post202NoRetry204Responder(resp)
}

// LROsPost202Retry200Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPost202Retry200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPost202Retry200Future) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsPost202Retry200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Post202Retry200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.Post202Retry200Responder(resp)
}

// LROsPostAsyncNoRetrySucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPostAsyncNoRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPostAsyncNoRetrySucceededFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPostAsyncNoRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncNoRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PostAsyncNoRetrySucceededResponder(resp)
}

// LROsPostAsyncRetrycanceledFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPostAsyncRetrycanceledFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPostAsyncRetrycanceledFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsPostAsyncRetrycanceledFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRetrycanceledResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRetrycanceledResponder(resp)
}

// LROsPostAsyncRetryFailedFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPostAsyncRetryFailedFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPostAsyncRetryFailedFuture) Result(client LROsClient) (autorest.Response, error) {
	done, err := future.Done(client)
	if err != nil {
		return autorest.Response{}, err
	}
	if !done {
		return autorest.Response{}, autorest.NewError("lrogroup.LROsPostAsyncRetryFailedFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRetryFailedResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return autorest.Response{}, err
	}
	return client.PostAsyncRetryFailedResponder(resp)
}

// LROsPostAsyncRetrySucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPostAsyncRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPostAsyncRetrySucceededFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPostAsyncRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PostAsyncRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PostAsyncRetrySucceededResponder(resp)
}

// LROsPut200Acceptedcanceled200Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPut200Acceptedcanceled200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut200Acceptedcanceled200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut200Acceptedcanceled200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put200Acceptedcanceled200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put200Acceptedcanceled200Responder(resp)
}

// LROsPut200SucceededFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPut200SucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut200SucceededFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut200SucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put200SucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put200SucceededResponder(resp)
}

// LROsPut200SucceededNoStateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPut200SucceededNoStateFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut200SucceededNoStateFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut200SucceededNoStateFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put200SucceededNoStateResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put200SucceededNoStateResponder(resp)
}

// LROsPut200UpdatingSucceeded204Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPut200UpdatingSucceeded204Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut200UpdatingSucceeded204Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut200UpdatingSucceeded204Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put200UpdatingSucceeded204Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put200UpdatingSucceeded204Responder(resp)
}

// LROsPut201CreatingFailed200Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPut201CreatingFailed200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut201CreatingFailed200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut201CreatingFailed200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put201CreatingFailed200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put201CreatingFailed200Responder(resp)
}

// LROsPut201CreatingSucceeded200Future an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPut201CreatingSucceeded200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut201CreatingSucceeded200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut201CreatingSucceeded200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put201CreatingSucceeded200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put201CreatingSucceeded200Responder(resp)
}

// LROsPut202Retry200Future an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPut202Retry200Future struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPut202Retry200Future) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPut202Retry200Future", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.Put202Retry200Responder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.Put202Retry200Responder(resp)
}

// LROsPutAsyncNoHeaderInRetryFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPutAsyncNoHeaderInRetryFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncNoHeaderInRetryFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPutAsyncNoHeaderInRetryFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncNoHeaderInRetryResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncNoHeaderInRetryResponder(resp)
}

// LROsPutAsyncNonResourceFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPutAsyncNonResourceFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncNonResourceFuture) Result(client LROsClient) (Sku, error) {
	done, err := future.Done(client)
	if err != nil {
		return Sku{}, err
	}
	if !done {
		return Sku{}, autorest.NewError("lrogroup.LROsPutAsyncNonResourceFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncNonResourceResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Sku{}, err
	}
	return client.PutAsyncNonResourceResponder(resp)
}

// LROsPutAsyncNoRetrycanceledFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPutAsyncNoRetrycanceledFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncNoRetrycanceledFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPutAsyncNoRetrycanceledFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncNoRetrycanceledResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncNoRetrycanceledResponder(resp)
}

// LROsPutAsyncNoRetrySucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPutAsyncNoRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncNoRetrySucceededFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPutAsyncNoRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncNoRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncNoRetrySucceededResponder(resp)
}

// LROsPutAsyncRetryFailedFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPutAsyncRetryFailedFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncRetryFailedFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPutAsyncRetryFailedFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRetryFailedResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRetryFailedResponder(resp)
}

// LROsPutAsyncRetrySucceededFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type LROsPutAsyncRetrySucceededFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncRetrySucceededFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPutAsyncRetrySucceededFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncRetrySucceededResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutAsyncRetrySucceededResponder(resp)
}

// LROsPutAsyncSubResourceFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPutAsyncSubResourceFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutAsyncSubResourceFuture) Result(client LROsClient) (SubProduct, error) {
	done, err := future.Done(client)
	if err != nil {
		return SubProduct{}, err
	}
	if !done {
		return SubProduct{}, autorest.NewError("lrogroup.LROsPutAsyncSubResourceFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutAsyncSubResourceResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return SubProduct{}, err
	}
	return client.PutAsyncSubResourceResponder(resp)
}

// LROsPutNoHeaderInRetryFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPutNoHeaderInRetryFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutNoHeaderInRetryFuture) Result(client LROsClient) (Product, error) {
	done, err := future.Done(client)
	if err != nil {
		return Product{}, err
	}
	if !done {
		return Product{}, autorest.NewError("lrogroup.LROsPutNoHeaderInRetryFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutNoHeaderInRetryResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Product{}, err
	}
	return client.PutNoHeaderInRetryResponder(resp)
}

// LROsPutNonResourceFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPutNonResourceFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutNonResourceFuture) Result(client LROsClient) (Sku, error) {
	done, err := future.Done(client)
	if err != nil {
		return Sku{}, err
	}
	if !done {
		return Sku{}, autorest.NewError("lrogroup.LROsPutNonResourceFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutNonResourceResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return Sku{}, err
	}
	return client.PutNonResourceResponder(resp)
}

// LROsPutSubResourceFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type LROsPutSubResourceFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future LROsPutSubResourceFuture) Result(client LROsClient) (SubProduct, error) {
	done, err := future.Done(client)
	if err != nil {
		return SubProduct{}, err
	}
	if !done {
		return SubProduct{}, autorest.NewError("lrogroup.LROsPutSubResourceFuture", "Result", "asynchronous operation has not completed")
	}
	if future.PollingMethod() == azure.PollingLocation {
		return client.PutSubResourceResponder(future.Response())
	}
	resp, err := autorest.SendWithSender(client, autorest.ChangeToGet(future.req),
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return SubProduct{}, err
	}
	return client.PutSubResourceResponder(resp)
}

// OperationResult
type OperationResult struct {
	Status Status                `json:"status,omitempty"`
	Error  *OperationResultError `json:"error,omitempty"`
}

// OperationResultError
type OperationResultError struct {
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Product
type Product struct {
	autorest.Response  `json:"-"`
	ID                 *string             `json:"id,omitempty"`
	Type               *string             `json:"type,omitempty"`
	Tags               *map[string]*string `json:"tags,omitempty"`
	Location           *string             `json:"location,omitempty"`
	Name               *string             `json:"name,omitempty"`
	*ProductProperties `json:"properties,omitempty"`
}

// ProductProperties
type ProductProperties struct {
	ProvisioningState       *string                 `json:"provisioningState,omitempty"`
	ProvisioningStateValues ProvisioningStateValues `json:"provisioningStateValues,omitempty"`
}

// Resource
type Resource struct {
	ID       *string             `json:"id,omitempty"`
	Type     *string             `json:"type,omitempty"`
	Tags     *map[string]*string `json:"tags,omitempty"`
	Location *string             `json:"location,omitempty"`
	Name     *string             `json:"name,omitempty"`
}

// Sku
type Sku struct {
	autorest.Response `json:"-"`
	Name              *string `json:"name,omitempty"`
	ID                *string `json:"id,omitempty"`
}

// SubProduct
type SubProduct struct {
	autorest.Response     `json:"-"`
	ID                    *string `json:"id,omitempty"`
	*SubProductProperties `json:"properties,omitempty"`
}

// SubProductProperties
type SubProductProperties struct {
	ProvisioningState       *string                 `json:"provisioningState,omitempty"`
	ProvisioningStateValues ProvisioningStateValues `json:"provisioningStateValues,omitempty"`
}

// SubResource
type SubResource struct {
	ID *string `json:"id,omitempty"`
}
