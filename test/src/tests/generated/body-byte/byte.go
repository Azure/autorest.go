package bytegroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io/ioutil"
	"net/http"
)

// ByteClient is the test Infrastructure for AutoRest Swagger BAT
type ByteClient struct {
	ManagementClient
}

// NewByteClient creates an instance of the ByteClient client.
func NewByteClient(p pipeline.Pipeline) ByteClient {
	return ByteClient{NewManagementClient(p)}
}

// GetEmpty get empty byte value ''
func (client ByteClient) GetEmpty(ctx context.Context) (*GetEmptyResponse, error) {
	req, err := client.getEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetEmptyResponse), err
}

// getEmptyPreparer prepares the GetEmpty request.
func (client ByteClient) getEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/byte/empty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getEmptyResponder handles the response to the GetEmpty request.
func (client ByteClient) getEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetInvalid get invalid byte value ':::SWAGGER::::'
func (client ByteClient) GetInvalid(ctx context.Context) (*GetInvalidResponse, error) {
	req, err := client.getInvalidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getInvalidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetInvalidResponse), err
}

// getInvalidPreparer prepares the GetInvalid request.
func (client ByteClient) getInvalidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/byte/invalid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getInvalidResponder handles the response to the GetInvalid request.
func (client ByteClient) getInvalidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetInvalidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetNonASCII get non-ascii byte string hex(FF FE FD FC FB FA F9 F8 F7 F6)
func (client ByteClient) GetNonASCII(ctx context.Context) (*GetNonASCIIResponse, error) {
	req, err := client.getNonASCIIPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getNonASCIIResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetNonASCIIResponse), err
}

// getNonASCIIPreparer prepares the GetNonASCII request.
func (client ByteClient) getNonASCIIPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/byte/nonAscii"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getNonASCIIResponder handles the response to the GetNonASCII request.
func (client ByteClient) getNonASCIIResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetNonASCIIResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetNull get null byte value
func (client ByteClient) GetNull(ctx context.Context) (*GetNullResponse, error) {
	req, err := client.getNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetNullResponse), err
}

// getNullPreparer prepares the GetNull request.
func (client ByteClient) getNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/byte/null"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getNullResponder handles the response to the GetNull request.
func (client ByteClient) getNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, &result.Value)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// PutNonASCII put non-ascii byte string hex(FF FE FD FC FB FA F9 F8 F7 F6)
//
// byteBody is base64-encoded non-ascii byte string hex(FF FE FD FC FB FA F9 F8 F7 F6)
func (client ByteClient) PutNonASCII(ctx context.Context, byteBody []byte) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: byteBody,
			constraints: []constraint{{target: "byteBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putNonASCIIPreparer(byteBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putNonASCIIResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putNonASCIIPreparer prepares the PutNonASCII request.
func (client ByteClient) putNonASCIIPreparer(byteBody []byte) (pipeline.Request, error) {
	u := client.url
	u.Path = "/byte/nonAscii"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(byteBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putNonASCIIResponder handles the response to the PutNonASCII request.
func (client ByteClient) putNonASCIIResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	resp.Response().Body.Close()
	return resp, err
}
