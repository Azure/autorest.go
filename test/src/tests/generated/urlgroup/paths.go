package urlgroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// PathsClient is the test Infrastructure for AutoRest
type PathsClient struct {
	BaseClient
}

// NewPathsClient creates an instance of the PathsClient client.
func NewPathsClient(globalStringPath string, globalStringQuery string) PathsClient {
	return NewPathsClientWithBaseURI(DefaultBaseURI, globalStringPath, globalStringQuery)
}

// NewPathsClientWithBaseURI creates an instance of the PathsClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewPathsClientWithBaseURI(baseURI string, globalStringPath string, globalStringQuery string) PathsClient {
	return PathsClient{NewWithBaseURI(baseURI, globalStringPath, globalStringQuery)}
}

// ArrayCsvInPath get an array of string ['ArrayPath1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array
// format
// Parameters:
// arrayPath - an array of string ['ArrayPath1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array
// format
func (client PathsClient) ArrayCsvInPath(ctx context.Context, arrayPath []string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.ArrayCsvInPath")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: arrayPath,
			Constraints: []validation.Constraint{{Target: "arrayPath", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("urlgroup.PathsClient", "ArrayCsvInPath", err.Error())
	}

	req, err := client.ArrayCsvInPathPreparer(ctx, arrayPath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ArrayCsvInPath", nil, "Failure preparing request")
		return
	}

	resp, err := client.ArrayCsvInPathSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ArrayCsvInPath", resp, "Failure sending request")
		return
	}

	result, err = client.ArrayCsvInPathResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ArrayCsvInPath", resp, "Failure responding to request")
	}

	return
}

// ArrayCsvInPathPreparer prepares the ArrayCsvInPath request.
func (client PathsClient) ArrayCsvInPathPreparer(ctx context.Context, arrayPath []string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"arrayPath": autorest.Encode("path", arrayPath, ","),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/array/ArrayPath1%2cbegin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend%2c%2c/{arrayPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ArrayCsvInPathSender sends the ArrayCsvInPath request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) ArrayCsvInPathSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ArrayCsvInPathResponder handles the response to the ArrayCsvInPath request. The method always
// closes the http.Response Body.
func (client PathsClient) ArrayCsvInPathResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Base64URL get 'lorem' encoded value as 'bG9yZW0' (base64url)
// Parameters:
// base64URLPath - base64url encoded value
func (client PathsClient) Base64URL(ctx context.Context, base64URLPath string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.Base64URL")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.Base64URLPreparer(ctx, base64URLPath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "Base64URL", nil, "Failure preparing request")
		return
	}

	resp, err := client.Base64URLSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "Base64URL", resp, "Failure sending request")
		return
	}

	result, err = client.Base64URLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "Base64URL", resp, "Failure responding to request")
	}

	return
}

// Base64URLPreparer prepares the Base64URL request.
func (client PathsClient) Base64URLPreparer(ctx context.Context, base64URLPath string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"base64UrlPath": autorest.Encode("path", base64URLPath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/string/bG9yZW0/{base64UrlPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Base64URLSender sends the Base64URL request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) Base64URLSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Base64URLResponder handles the response to the Base64URL request. The method always
// closes the http.Response Body.
func (client PathsClient) Base64URLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ByteEmpty get '' as byte array
func (client PathsClient) ByteEmpty(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.ByteEmpty")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.ByteEmptyPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteEmpty", nil, "Failure preparing request")
		return
	}

	resp, err := client.ByteEmptySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteEmpty", resp, "Failure sending request")
		return
	}

	result, err = client.ByteEmptyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteEmpty", resp, "Failure responding to request")
	}

	return
}

// ByteEmptyPreparer prepares the ByteEmpty request.
func (client PathsClient) ByteEmptyPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"bytePath": autorest.Encode("path", []byte("")),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/byte/empty/{bytePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ByteEmptySender sends the ByteEmpty request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) ByteEmptySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ByteEmptyResponder handles the response to the ByteEmpty request. The method always
// closes the http.Response Body.
func (client PathsClient) ByteEmptyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ByteMultiByte get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
// Parameters:
// bytePath - '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
func (client PathsClient) ByteMultiByte(ctx context.Context, bytePath []byte) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.ByteMultiByte")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: bytePath,
			Constraints: []validation.Constraint{{Target: "bytePath", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("urlgroup.PathsClient", "ByteMultiByte", err.Error())
	}

	req, err := client.ByteMultiBytePreparer(ctx, bytePath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteMultiByte", nil, "Failure preparing request")
		return
	}

	resp, err := client.ByteMultiByteSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteMultiByte", resp, "Failure sending request")
		return
	}

	result, err = client.ByteMultiByteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteMultiByte", resp, "Failure responding to request")
	}

	return
}

// ByteMultiBytePreparer prepares the ByteMultiByte request.
func (client PathsClient) ByteMultiBytePreparer(ctx context.Context, bytePath []byte) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"bytePath": autorest.Encode("path", bytePath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/byte/multibyte/{bytePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ByteMultiByteSender sends the ByteMultiByte request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) ByteMultiByteSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ByteMultiByteResponder handles the response to the ByteMultiByte request. The method always
// closes the http.Response Body.
func (client PathsClient) ByteMultiByteResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ByteNull get null as byte array (should throw)
// Parameters:
// bytePath - null as byte array (should throw)
func (client PathsClient) ByteNull(ctx context.Context, bytePath []byte) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.ByteNull")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: bytePath,
			Constraints: []validation.Constraint{{Target: "bytePath", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("urlgroup.PathsClient", "ByteNull", err.Error())
	}

	req, err := client.ByteNullPreparer(ctx, bytePath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteNull", nil, "Failure preparing request")
		return
	}

	resp, err := client.ByteNullSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteNull", resp, "Failure sending request")
		return
	}

	result, err = client.ByteNullResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "ByteNull", resp, "Failure responding to request")
	}

	return
}

// ByteNullPreparer prepares the ByteNull request.
func (client PathsClient) ByteNullPreparer(ctx context.Context, bytePath []byte) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"bytePath": autorest.Encode("path", bytePath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/byte/null/{bytePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ByteNullSender sends the ByteNull request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) ByteNullSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ByteNullResponder handles the response to the ByteNull request. The method always
// closes the http.Response Body.
func (client PathsClient) ByteNullResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DateNull get null as date - this should throw or be unusable on the client side, depending on date representation
// Parameters:
// datePath - null as date (should throw)
func (client PathsClient) DateNull(ctx context.Context, datePath date.Date) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.DateNull")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DateNullPreparer(ctx, datePath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateNull", nil, "Failure preparing request")
		return
	}

	resp, err := client.DateNullSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateNull", resp, "Failure sending request")
		return
	}

	result, err = client.DateNullResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateNull", resp, "Failure responding to request")
	}

	return
}

// DateNullPreparer prepares the DateNull request.
func (client PathsClient) DateNullPreparer(ctx context.Context, datePath date.Date) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"datePath": autorest.Encode("path", datePath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/date/null/{datePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DateNullSender sends the DateNull request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) DateNullSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DateNullResponder handles the response to the DateNull request. The method always
// closes the http.Response Body.
func (client PathsClient) DateNullResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DateTimeNull get null as date-time, should be disallowed or throw depending on representation of date-time
// Parameters:
// dateTimePath - null as date-time
func (client PathsClient) DateTimeNull(ctx context.Context, dateTimePath date.Time) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.DateTimeNull")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DateTimeNullPreparer(ctx, dateTimePath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateTimeNull", nil, "Failure preparing request")
		return
	}

	resp, err := client.DateTimeNullSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateTimeNull", resp, "Failure sending request")
		return
	}

	result, err = client.DateTimeNullResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateTimeNull", resp, "Failure responding to request")
	}

	return
}

// DateTimeNullPreparer prepares the DateTimeNull request.
func (client PathsClient) DateTimeNullPreparer(ctx context.Context, dateTimePath date.Time) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"dateTimePath": autorest.Encode("path", dateTimePath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/datetime/null/{dateTimePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DateTimeNullSender sends the DateTimeNull request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) DateTimeNullSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DateTimeNullResponder handles the response to the DateTimeNull request. The method always
// closes the http.Response Body.
func (client PathsClient) DateTimeNullResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DateTimeValid get '2012-01-01T01:01:01Z' as date-time
func (client PathsClient) DateTimeValid(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.DateTimeValid")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DateTimeValidPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateTimeValid", nil, "Failure preparing request")
		return
	}

	resp, err := client.DateTimeValidSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateTimeValid", resp, "Failure sending request")
		return
	}

	result, err = client.DateTimeValidResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateTimeValid", resp, "Failure responding to request")
	}

	return
}

// DateTimeValidPreparer prepares the DateTimeValid request.
func (client PathsClient) DateTimeValidPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"dateTimePath": autorest.Encode("path", "2012-01-01T01:01:01Z"),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/datetime/2012-01-01T01%3A01%3A01Z/{dateTimePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DateTimeValidSender sends the DateTimeValid request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) DateTimeValidSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DateTimeValidResponder handles the response to the DateTimeValid request. The method always
// closes the http.Response Body.
func (client PathsClient) DateTimeValidResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DateValid get '2012-01-01' as date
func (client PathsClient) DateValid(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.DateValid")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DateValidPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateValid", nil, "Failure preparing request")
		return
	}

	resp, err := client.DateValidSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateValid", resp, "Failure sending request")
		return
	}

	result, err = client.DateValidResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DateValid", resp, "Failure responding to request")
	}

	return
}

// DateValidPreparer prepares the DateValid request.
func (client PathsClient) DateValidPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"datePath": autorest.Encode("path", "2012-01-01"),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/date/2012-01-01/{datePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DateValidSender sends the DateValid request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) DateValidSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DateValidResponder handles the response to the DateValid request. The method always
// closes the http.Response Body.
func (client PathsClient) DateValidResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DoubleDecimalNegative get '-9999999.999' numeric value
func (client PathsClient) DoubleDecimalNegative(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.DoubleDecimalNegative")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DoubleDecimalNegativePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DoubleDecimalNegative", nil, "Failure preparing request")
		return
	}

	resp, err := client.DoubleDecimalNegativeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DoubleDecimalNegative", resp, "Failure sending request")
		return
	}

	result, err = client.DoubleDecimalNegativeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DoubleDecimalNegative", resp, "Failure responding to request")
	}

	return
}

// DoubleDecimalNegativePreparer prepares the DoubleDecimalNegative request.
func (client PathsClient) DoubleDecimalNegativePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"doublePath": autorest.Encode("path", -9999999.999),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/double/-9999999.999/{doublePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DoubleDecimalNegativeSender sends the DoubleDecimalNegative request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) DoubleDecimalNegativeSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DoubleDecimalNegativeResponder handles the response to the DoubleDecimalNegative request. The method always
// closes the http.Response Body.
func (client PathsClient) DoubleDecimalNegativeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DoubleDecimalPositive get '9999999.999' numeric value
func (client PathsClient) DoubleDecimalPositive(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.DoubleDecimalPositive")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DoubleDecimalPositivePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DoubleDecimalPositive", nil, "Failure preparing request")
		return
	}

	resp, err := client.DoubleDecimalPositiveSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DoubleDecimalPositive", resp, "Failure sending request")
		return
	}

	result, err = client.DoubleDecimalPositiveResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "DoubleDecimalPositive", resp, "Failure responding to request")
	}

	return
}

// DoubleDecimalPositivePreparer prepares the DoubleDecimalPositive request.
func (client PathsClient) DoubleDecimalPositivePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"doublePath": autorest.Encode("path", 9999999.999),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/double/9999999.999/{doublePath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DoubleDecimalPositiveSender sends the DoubleDecimalPositive request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) DoubleDecimalPositiveSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DoubleDecimalPositiveResponder handles the response to the DoubleDecimalPositive request. The method always
// closes the http.Response Body.
func (client PathsClient) DoubleDecimalPositiveResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// EnumNull get null (should throw on the client before the request is sent on wire)
// Parameters:
// enumPath - send null should throw
func (client PathsClient) EnumNull(ctx context.Context, enumPath URIColor) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.EnumNull")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.EnumNullPreparer(ctx, enumPath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "EnumNull", nil, "Failure preparing request")
		return
	}

	resp, err := client.EnumNullSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "EnumNull", resp, "Failure sending request")
		return
	}

	result, err = client.EnumNullResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "EnumNull", resp, "Failure responding to request")
	}

	return
}

// EnumNullPreparer prepares the EnumNull request.
func (client PathsClient) EnumNullPreparer(ctx context.Context, enumPath URIColor) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"enumPath": autorest.Encode("path", enumPath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/string/null/{enumPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// EnumNullSender sends the EnumNull request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) EnumNullSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// EnumNullResponder handles the response to the EnumNull request. The method always
// closes the http.Response Body.
func (client PathsClient) EnumNullResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest),
		autorest.ByClosing())
	result.Response = resp
	return
}

// EnumValid get using uri with 'green color' in path parameter
// Parameters:
// enumPath - send the value green
func (client PathsClient) EnumValid(ctx context.Context, enumPath URIColor) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.EnumValid")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.EnumValidPreparer(ctx, enumPath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "EnumValid", nil, "Failure preparing request")
		return
	}

	resp, err := client.EnumValidSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "EnumValid", resp, "Failure sending request")
		return
	}

	result, err = client.EnumValidResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "EnumValid", resp, "Failure responding to request")
	}

	return
}

// EnumValidPreparer prepares the EnumValid request.
func (client PathsClient) EnumValidPreparer(ctx context.Context, enumPath URIColor) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"enumPath": autorest.Encode("path", enumPath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/enum/green%20color/{enumPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// EnumValidSender sends the EnumValid request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) EnumValidSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// EnumValidResponder handles the response to the EnumValid request. The method always
// closes the http.Response Body.
func (client PathsClient) EnumValidResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// FloatScientificNegative get '-1.034E-20' numeric value
func (client PathsClient) FloatScientificNegative(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.FloatScientificNegative")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.FloatScientificNegativePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "FloatScientificNegative", nil, "Failure preparing request")
		return
	}

	resp, err := client.FloatScientificNegativeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "FloatScientificNegative", resp, "Failure sending request")
		return
	}

	result, err = client.FloatScientificNegativeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "FloatScientificNegative", resp, "Failure responding to request")
	}

	return
}

// FloatScientificNegativePreparer prepares the FloatScientificNegative request.
func (client PathsClient) FloatScientificNegativePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"floatPath": autorest.Encode("path", -1.034E-20),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/float/-1.034E-20/{floatPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// FloatScientificNegativeSender sends the FloatScientificNegative request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) FloatScientificNegativeSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// FloatScientificNegativeResponder handles the response to the FloatScientificNegative request. The method always
// closes the http.Response Body.
func (client PathsClient) FloatScientificNegativeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// FloatScientificPositive get '1.034E+20' numeric value
func (client PathsClient) FloatScientificPositive(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.FloatScientificPositive")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.FloatScientificPositivePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "FloatScientificPositive", nil, "Failure preparing request")
		return
	}

	resp, err := client.FloatScientificPositiveSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "FloatScientificPositive", resp, "Failure sending request")
		return
	}

	result, err = client.FloatScientificPositiveResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "FloatScientificPositive", resp, "Failure responding to request")
	}

	return
}

// FloatScientificPositivePreparer prepares the FloatScientificPositive request.
func (client PathsClient) FloatScientificPositivePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"floatPath": autorest.Encode("path", 1.034E+20),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/float/1.034E+20/{floatPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// FloatScientificPositiveSender sends the FloatScientificPositive request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) FloatScientificPositiveSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// FloatScientificPositiveResponder handles the response to the FloatScientificPositive request. The method always
// closes the http.Response Body.
func (client PathsClient) FloatScientificPositiveResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetBooleanFalse get false Boolean value on path
func (client PathsClient) GetBooleanFalse(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.GetBooleanFalse")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBooleanFalsePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetBooleanFalse", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBooleanFalseSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetBooleanFalse", resp, "Failure sending request")
		return
	}

	result, err = client.GetBooleanFalseResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetBooleanFalse", resp, "Failure responding to request")
	}

	return
}

// GetBooleanFalsePreparer prepares the GetBooleanFalse request.
func (client PathsClient) GetBooleanFalsePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"boolPath": autorest.Encode("path", false),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/bool/false/{boolPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBooleanFalseSender sends the GetBooleanFalse request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) GetBooleanFalseSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBooleanFalseResponder handles the response to the GetBooleanFalse request. The method always
// closes the http.Response Body.
func (client PathsClient) GetBooleanFalseResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetBooleanTrue get true Boolean value on path
func (client PathsClient) GetBooleanTrue(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.GetBooleanTrue")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetBooleanTruePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetBooleanTrue", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBooleanTrueSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetBooleanTrue", resp, "Failure sending request")
		return
	}

	result, err = client.GetBooleanTrueResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetBooleanTrue", resp, "Failure responding to request")
	}

	return
}

// GetBooleanTruePreparer prepares the GetBooleanTrue request.
func (client PathsClient) GetBooleanTruePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"boolPath": autorest.Encode("path", true),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/bool/true/{boolPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBooleanTrueSender sends the GetBooleanTrue request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) GetBooleanTrueSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetBooleanTrueResponder handles the response to the GetBooleanTrue request. The method always
// closes the http.Response Body.
func (client PathsClient) GetBooleanTrueResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetIntNegativeOneMillion get '-1000000' integer value
func (client PathsClient) GetIntNegativeOneMillion(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.GetIntNegativeOneMillion")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetIntNegativeOneMillionPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetIntNegativeOneMillion", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetIntNegativeOneMillionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetIntNegativeOneMillion", resp, "Failure sending request")
		return
	}

	result, err = client.GetIntNegativeOneMillionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetIntNegativeOneMillion", resp, "Failure responding to request")
	}

	return
}

// GetIntNegativeOneMillionPreparer prepares the GetIntNegativeOneMillion request.
func (client PathsClient) GetIntNegativeOneMillionPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"intPath": autorest.Encode("path", -1000000),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/int/-1000000/{intPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetIntNegativeOneMillionSender sends the GetIntNegativeOneMillion request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) GetIntNegativeOneMillionSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetIntNegativeOneMillionResponder handles the response to the GetIntNegativeOneMillion request. The method always
// closes the http.Response Body.
func (client PathsClient) GetIntNegativeOneMillionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetIntOneMillion get '1000000' integer value
func (client PathsClient) GetIntOneMillion(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.GetIntOneMillion")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetIntOneMillionPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetIntOneMillion", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetIntOneMillionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetIntOneMillion", resp, "Failure sending request")
		return
	}

	result, err = client.GetIntOneMillionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetIntOneMillion", resp, "Failure responding to request")
	}

	return
}

// GetIntOneMillionPreparer prepares the GetIntOneMillion request.
func (client PathsClient) GetIntOneMillionPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"intPath": autorest.Encode("path", 1000000),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/int/1000000/{intPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetIntOneMillionSender sends the GetIntOneMillion request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) GetIntOneMillionSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetIntOneMillionResponder handles the response to the GetIntOneMillion request. The method always
// closes the http.Response Body.
func (client PathsClient) GetIntOneMillionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetNegativeTenBillion get '-10000000000' 64 bit integer value
func (client PathsClient) GetNegativeTenBillion(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.GetNegativeTenBillion")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetNegativeTenBillionPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetNegativeTenBillion", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNegativeTenBillionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetNegativeTenBillion", resp, "Failure sending request")
		return
	}

	result, err = client.GetNegativeTenBillionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetNegativeTenBillion", resp, "Failure responding to request")
	}

	return
}

// GetNegativeTenBillionPreparer prepares the GetNegativeTenBillion request.
func (client PathsClient) GetNegativeTenBillionPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"longPath": autorest.Encode("path", -10000000000),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/long/-10000000000/{longPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNegativeTenBillionSender sends the GetNegativeTenBillion request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) GetNegativeTenBillionSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNegativeTenBillionResponder handles the response to the GetNegativeTenBillion request. The method always
// closes the http.Response Body.
func (client PathsClient) GetNegativeTenBillionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetTenBillion get '10000000000' 64 bit integer value
func (client PathsClient) GetTenBillion(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.GetTenBillion")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTenBillionPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetTenBillion", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTenBillionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetTenBillion", resp, "Failure sending request")
		return
	}

	result, err = client.GetTenBillionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "GetTenBillion", resp, "Failure responding to request")
	}

	return
}

// GetTenBillionPreparer prepares the GetTenBillion request.
func (client PathsClient) GetTenBillionPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"longPath": autorest.Encode("path", 10000000000),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/long/10000000000/{longPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTenBillionSender sends the GetTenBillion request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) GetTenBillionSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTenBillionResponder handles the response to the GetTenBillion request. The method always
// closes the http.Response Body.
func (client PathsClient) GetTenBillionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StringEmpty get ''
func (client PathsClient) StringEmpty(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.StringEmpty")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.StringEmptyPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringEmpty", nil, "Failure preparing request")
		return
	}

	resp, err := client.StringEmptySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringEmpty", resp, "Failure sending request")
		return
	}

	result, err = client.StringEmptyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringEmpty", resp, "Failure responding to request")
	}

	return
}

// StringEmptyPreparer prepares the StringEmpty request.
func (client PathsClient) StringEmptyPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"stringPath": autorest.Encode("path", ""),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/string/empty/{stringPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StringEmptySender sends the StringEmpty request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) StringEmptySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StringEmptyResponder handles the response to the StringEmpty request. The method always
// closes the http.Response Body.
func (client PathsClient) StringEmptyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StringNull get null (should throw)
// Parameters:
// stringPath - null string value
func (client PathsClient) StringNull(ctx context.Context, stringPath string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.StringNull")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.StringNullPreparer(ctx, stringPath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringNull", nil, "Failure preparing request")
		return
	}

	resp, err := client.StringNullSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringNull", resp, "Failure sending request")
		return
	}

	result, err = client.StringNullResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringNull", resp, "Failure responding to request")
	}

	return
}

// StringNullPreparer prepares the StringNull request.
func (client PathsClient) StringNullPreparer(ctx context.Context, stringPath string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"stringPath": autorest.Encode("path", stringPath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/string/null/{stringPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StringNullSender sends the StringNull request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) StringNullSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StringNullResponder handles the response to the StringNull request. The method always
// closes the http.Response Body.
func (client PathsClient) StringNullResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StringUnicode get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
func (client PathsClient) StringUnicode(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.StringUnicode")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.StringUnicodePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringUnicode", nil, "Failure preparing request")
		return
	}

	resp, err := client.StringUnicodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringUnicode", resp, "Failure sending request")
		return
	}

	result, err = client.StringUnicodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringUnicode", resp, "Failure responding to request")
	}

	return
}

// StringUnicodePreparer prepares the StringUnicode request.
func (client PathsClient) StringUnicodePreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"stringPath": autorest.Encode("path", "啊齄丂狛狜隣郎隣兀﨩"),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/string/unicode/{stringPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StringUnicodeSender sends the StringUnicode request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) StringUnicodeSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StringUnicodeResponder handles the response to the StringUnicode request. The method always
// closes the http.Response Body.
func (client PathsClient) StringUnicodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StringURLEncoded get 'begin!*'();:@ &=+$,/?#[]end
func (client PathsClient) StringURLEncoded(ctx context.Context) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.StringURLEncoded")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.StringURLEncodedPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringURLEncoded", nil, "Failure preparing request")
		return
	}

	resp, err := client.StringURLEncodedSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringURLEncoded", resp, "Failure sending request")
		return
	}

	result, err = client.StringURLEncodedResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "StringURLEncoded", resp, "Failure responding to request")
	}

	return
}

// StringURLEncodedPreparer prepares the StringURLEncoded request.
func (client PathsClient) StringURLEncodedPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"stringPath": autorest.Encode("path", "begin!*'();:@ &=+$,/?#[]end"),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend/{stringPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StringURLEncodedSender sends the StringURLEncoded request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) StringURLEncodedSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// StringURLEncodedResponder handles the response to the StringURLEncoded request. The method always
// closes the http.Response Body.
func (client PathsClient) StringURLEncodedResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// UnixTimeURL get the date 2016-04-13 encoded value as '1460505600' (Unix time)
// Parameters:
// unixTimeURLPath - unix time encoded value
func (client PathsClient) UnixTimeURL(ctx context.Context, unixTimeURLPath date.UnixTime) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PathsClient.UnixTimeURL")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UnixTimeURLPreparer(ctx, unixTimeURLPath)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "UnixTimeURL", nil, "Failure preparing request")
		return
	}

	resp, err := client.UnixTimeURLSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "UnixTimeURL", resp, "Failure sending request")
		return
	}

	result, err = client.UnixTimeURLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "urlgroup.PathsClient", "UnixTimeURL", resp, "Failure responding to request")
	}

	return
}

// UnixTimeURLPreparer prepares the UnixTimeURL request.
func (client PathsClient) UnixTimeURLPreparer(ctx context.Context, unixTimeURLPath date.UnixTime) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"unixTimeUrlPath": autorest.Encode("path", unixTimeURLPath),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paths/int/1460505600/{unixTimeUrlPath}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UnixTimeURLSender sends the UnixTimeURL request. The method will close the
// http.Response Body if it receives an error.
func (client PathsClient) UnixTimeURLSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UnixTimeURLResponder handles the response to the UnixTimeURL request. The method always
// closes the http.Response Body.
func (client PathsClient) UnixTimeURLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
