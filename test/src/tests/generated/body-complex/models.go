package complexgroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
)

// CMYKColors enumerates the values for cmyk colors.
type CMYKColors string

const (
	// BlacK ...
	BlacK CMYKColors = "blacK"
	// Cyan ...
	Cyan CMYKColors = "cyan"
	// Magenta ...
	Magenta CMYKColors = "Magenta"
	// YELLOW ...
	YELLOW CMYKColors = "YELLOW"
)

// Fishtype enumerates the values for fishtype.
type Fishtype string

const (
	// FishtypeCookiecuttershark ...
	FishtypeCookiecuttershark Fishtype = "cookiecuttershark"
	// FishtypeFish ...
	FishtypeFish Fishtype = "Fish"
	// FishtypeGoblin ...
	FishtypeGoblin Fishtype = "goblin"
	// FishtypeSalmon ...
	FishtypeSalmon Fishtype = "salmon"
	// FishtypeSawshark ...
	FishtypeSawshark Fishtype = "sawshark"
	// FishtypeShark ...
	FishtypeShark Fishtype = "shark"
	// FishtypeSmartSalmon ...
	FishtypeSmartSalmon Fishtype = "smart_salmon"
)

// ArrayWrapper ...
type ArrayWrapper struct {
	autorest.Response `json:"-"`
	Array             *[]string `json:"array,omitempty"`
}

// Basic ...
type Basic struct {
	autorest.Response `json:"-"`
	// ID - Basic Id
	ID *int32 `json:"id,omitempty"`
	// Name - Name property with a very long description that does not fit on a single line and a line break.
	Name *string `json:"name,omitempty"`
	// Color - Possible values include: 'Cyan', 'Magenta', 'YELLOW', 'BlacK'
	Color CMYKColors `json:"color,omitempty"`
}

// BooleanWrapper ...
type BooleanWrapper struct {
	autorest.Response `json:"-"`
	FieldTrue         *bool `json:"field_true,omitempty"`
	FieldFalse        *bool `json:"field_false,omitempty"`
}

// ByteWrapper ...
type ByteWrapper struct {
	autorest.Response `json:"-"`
	Field             *[]byte `json:"field,omitempty"`
}

// Cat ...
type Cat struct {
	ID    *int32  `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
	Hates *[]Dog  `json:"hates,omitempty"`
}

// Cookiecuttershark ...
type Cookiecuttershark struct {
	Species  *string      `json:"species,omitempty"`
	Length   *float64     `json:"length,omitempty"`
	Siblings *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype   `json:"fishtype,omitempty"`
	Age      *int32     `json:"age,omitempty"`
	Birthday *date.Time `json:"birthday,omitempty"`
}

// MarshalJSON is the custom marshaler for Cookiecuttershark.
func (c Cookiecuttershark) MarshalJSON() ([]byte, error) {
	c.Fishtype = FishtypeCookiecuttershark
	objectMap := make(map[string]interface{})
	if c.Age != nil {
		objectMap["age"] = c.Age
	}
	if c.Birthday != nil {
		objectMap["birthday"] = c.Birthday
	}
	if c.Species != nil {
		objectMap["species"] = c.Species
	}
	if c.Length != nil {
		objectMap["length"] = c.Length
	}
	if c.Siblings != nil {
		objectMap["siblings"] = c.Siblings
	}
	objectMap["fishtype"] = c.Fishtype
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsSalmon() (*Salmon, bool) {
	return nil, false
}

// AsBasicSalmon is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsBasicSalmon() (BasicSalmon, bool) {
	return nil, false
}

// AsSmartSalmon is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsSmartSalmon() (*SmartSalmon, bool) {
	return nil, false
}

// AsShark is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsShark() (*Shark, bool) {
	return nil, false
}

// AsBasicShark is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsBasicShark() (BasicShark, bool) {
	return &c, true
}

// AsSawshark is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsSawshark() (*Sawshark, bool) {
	return nil, false
}

// AsGoblinshark is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsGoblinshark() (*Goblinshark, bool) {
	return nil, false
}

// AsCookiecuttershark is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return &c, true
}

// AsFish is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsFish() (*Fish, bool) {
	return nil, false
}

// AsBasicFish is the BasicFish implementation for Cookiecuttershark.
func (c Cookiecuttershark) AsBasicFish() (BasicFish, bool) {
	return &c, true
}

// UnmarshalJSON is the custom unmarshaler for Cookiecuttershark struct.
func (c *Cookiecuttershark) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "age":
			if v != nil {
				var age int32
				err = json.Unmarshal(*v, &age)
				if err != nil {
					return err
				}
				c.Age = &age
			}
		case "birthday":
			if v != nil {
				var birthday date.Time
				err = json.Unmarshal(*v, &birthday)
				if err != nil {
					return err
				}
				c.Birthday = &birthday
			}
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				c.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				c.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				c.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				c.Fishtype = fishtype
			}
		}
	}

	return nil
}

// Datetimerfc1123Wrapper ...
type Datetimerfc1123Wrapper struct {
	autorest.Response `json:"-"`
	Field             *date.TimeRFC1123 `json:"field,omitempty"`
	Now               *date.TimeRFC1123 `json:"now,omitempty"`
}

// DatetimeWrapper ...
type DatetimeWrapper struct {
	autorest.Response `json:"-"`
	Field             *date.Time `json:"field,omitempty"`
	Now               *date.Time `json:"now,omitempty"`
}

// DateWrapper ...
type DateWrapper struct {
	autorest.Response `json:"-"`
	Field             *date.Date `json:"field,omitempty"`
	Leap              *date.Date `json:"leap,omitempty"`
}

// DictionaryWrapper ...
type DictionaryWrapper struct {
	autorest.Response `json:"-"`
	DefaultProgram    map[string]*string `json:"defaultProgram"`
}

// MarshalJSON is the custom marshaler for DictionaryWrapper.
func (d DictionaryWrapper) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DefaultProgram != nil {
		objectMap["defaultProgram"] = d.DefaultProgram
	}
	return json.Marshal(objectMap)
}

// Dog ...
type Dog struct {
	ID   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
	Food *string `json:"food,omitempty"`
}

// DoubleWrapper ...
type DoubleWrapper struct {
	autorest.Response                                                               `json:"-"`
	Field1                                                                          *float64 `json:"field1,omitempty"`
	Field56ZerosAfterTheDotAndNegativeZeroBeforeDotAndThisIsALongFieldNameOnPurpose *float64 `json:"field_56_zeros_after_the_dot_and_negative_zero_before_dot_and_this_is_a_long_field_name_on_purpose,omitempty"`
}

// DurationWrapper ...
type DurationWrapper struct {
	autorest.Response `json:"-"`
	Field             *string `json:"field,omitempty"`
}

// Error ...
type Error struct {
	Status  *int32  `json:"status,omitempty"`
	Message *string `json:"message,omitempty"`
}

// BasicFish ...
type BasicFish interface {
	AsSalmon() (*Salmon, bool)
	AsBasicSalmon() (BasicSalmon, bool)
	AsSmartSalmon() (*SmartSalmon, bool)
	AsShark() (*Shark, bool)
	AsBasicShark() (BasicShark, bool)
	AsSawshark() (*Sawshark, bool)
	AsGoblinshark() (*Goblinshark, bool)
	AsCookiecuttershark() (*Cookiecuttershark, bool)
	AsFish() (*Fish, bool)
}

// Fish ...
type Fish struct {
	autorest.Response `json:"-"`
	Species           *string      `json:"species,omitempty"`
	Length            *float64     `json:"length,omitempty"`
	Siblings          *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype `json:"fishtype,omitempty"`
}

func unmarshalBasicFish(body []byte) (BasicFish, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["fishtype"] {
	case string(FishtypeSalmon):
		var s Salmon
		err := json.Unmarshal(body, &s)
		return s, err
	case string(FishtypeSmartSalmon):
		var s SmartSalmon
		err := json.Unmarshal(body, &s)
		return s, err
	case string(FishtypeShark):
		var s Shark
		err := json.Unmarshal(body, &s)
		return s, err
	case string(FishtypeSawshark):
		var s Sawshark
		err := json.Unmarshal(body, &s)
		return s, err
	case string(FishtypeGoblin):
		var g Goblinshark
		err := json.Unmarshal(body, &g)
		return g, err
	case string(FishtypeCookiecuttershark):
		var c Cookiecuttershark
		err := json.Unmarshal(body, &c)
		return c, err
	default:
		var f Fish
		err := json.Unmarshal(body, &f)
		return f, err
	}
}
func unmarshalBasicFishArray(body []byte) ([]BasicFish, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	fArray := make([]BasicFish, len(rawMessages))

	for index, rawMessage := range rawMessages {
		f, err := unmarshalBasicFish(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return fArray, nil
}

// MarshalJSON is the custom marshaler for Fish.
func (f Fish) MarshalJSON() ([]byte, error) {
	f.Fishtype = FishtypeFish
	objectMap := make(map[string]interface{})
	if f.Species != nil {
		objectMap["species"] = f.Species
	}
	if f.Length != nil {
		objectMap["length"] = f.Length
	}
	if f.Siblings != nil {
		objectMap["siblings"] = f.Siblings
	}
	objectMap["fishtype"] = f.Fishtype
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for Fish.
func (f Fish) AsSalmon() (*Salmon, bool) {
	return nil, false
}

// AsBasicSalmon is the BasicFish implementation for Fish.
func (f Fish) AsBasicSalmon() (BasicSalmon, bool) {
	return nil, false
}

// AsSmartSalmon is the BasicFish implementation for Fish.
func (f Fish) AsSmartSalmon() (*SmartSalmon, bool) {
	return nil, false
}

// AsShark is the BasicFish implementation for Fish.
func (f Fish) AsShark() (*Shark, bool) {
	return nil, false
}

// AsBasicShark is the BasicFish implementation for Fish.
func (f Fish) AsBasicShark() (BasicShark, bool) {
	return nil, false
}

// AsSawshark is the BasicFish implementation for Fish.
func (f Fish) AsSawshark() (*Sawshark, bool) {
	return nil, false
}

// AsGoblinshark is the BasicFish implementation for Fish.
func (f Fish) AsGoblinshark() (*Goblinshark, bool) {
	return nil, false
}

// AsCookiecuttershark is the BasicFish implementation for Fish.
func (f Fish) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return nil, false
}

// AsFish is the BasicFish implementation for Fish.
func (f Fish) AsFish() (*Fish, bool) {
	return &f, true
}

// AsBasicFish is the BasicFish implementation for Fish.
func (f Fish) AsBasicFish() (BasicFish, bool) {
	return &f, true
}

// UnmarshalJSON is the custom unmarshaler for Fish struct.
func (f *Fish) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				f.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				f.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				f.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				f.Fishtype = fishtype
			}
		}
	}

	return nil
}

// FishModel ...
type FishModel struct {
	autorest.Response `json:"-"`
	Value             BasicFish `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for FishModel struct.
func (fm *FishModel) UnmarshalJSON(body []byte) error {
	f, err := unmarshalBasicFish(body)
	if err != nil {
		return err
	}
	fm.Value = f

	return nil
}

// FloatWrapper ...
type FloatWrapper struct {
	autorest.Response `json:"-"`
	Field1            *float64 `json:"field1,omitempty"`
	Field2            *float64 `json:"field2,omitempty"`
}

// Goblinshark ...
type Goblinshark struct {
	Species  *string      `json:"species,omitempty"`
	Length   *float64     `json:"length,omitempty"`
	Siblings *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype   `json:"fishtype,omitempty"`
	Age      *int32     `json:"age,omitempty"`
	Birthday *date.Time `json:"birthday,omitempty"`
	Jawsize  *int32     `json:"jawsize,omitempty"`
}

// MarshalJSON is the custom marshaler for Goblinshark.
func (g Goblinshark) MarshalJSON() ([]byte, error) {
	g.Fishtype = FishtypeGoblin
	objectMap := make(map[string]interface{})
	if g.Jawsize != nil {
		objectMap["jawsize"] = g.Jawsize
	}
	if g.Age != nil {
		objectMap["age"] = g.Age
	}
	if g.Birthday != nil {
		objectMap["birthday"] = g.Birthday
	}
	if g.Species != nil {
		objectMap["species"] = g.Species
	}
	if g.Length != nil {
		objectMap["length"] = g.Length
	}
	if g.Siblings != nil {
		objectMap["siblings"] = g.Siblings
	}
	objectMap["fishtype"] = g.Fishtype
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsSalmon() (*Salmon, bool) {
	return nil, false
}

// AsBasicSalmon is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsBasicSalmon() (BasicSalmon, bool) {
	return nil, false
}

// AsSmartSalmon is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsSmartSalmon() (*SmartSalmon, bool) {
	return nil, false
}

// AsShark is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsShark() (*Shark, bool) {
	return nil, false
}

// AsBasicShark is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsBasicShark() (BasicShark, bool) {
	return &g, true
}

// AsSawshark is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsSawshark() (*Sawshark, bool) {
	return nil, false
}

// AsGoblinshark is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsGoblinshark() (*Goblinshark, bool) {
	return &g, true
}

// AsCookiecuttershark is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return nil, false
}

// AsFish is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsFish() (*Fish, bool) {
	return nil, false
}

// AsBasicFish is the BasicFish implementation for Goblinshark.
func (g Goblinshark) AsBasicFish() (BasicFish, bool) {
	return &g, true
}

// UnmarshalJSON is the custom unmarshaler for Goblinshark struct.
func (g *Goblinshark) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "jawsize":
			if v != nil {
				var jawsize int32
				err = json.Unmarshal(*v, &jawsize)
				if err != nil {
					return err
				}
				g.Jawsize = &jawsize
			}
		case "age":
			if v != nil {
				var age int32
				err = json.Unmarshal(*v, &age)
				if err != nil {
					return err
				}
				g.Age = &age
			}
		case "birthday":
			if v != nil {
				var birthday date.Time
				err = json.Unmarshal(*v, &birthday)
				if err != nil {
					return err
				}
				g.Birthday = &birthday
			}
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				g.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				g.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				g.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				g.Fishtype = fishtype
			}
		}
	}

	return nil
}

// IntWrapper ...
type IntWrapper struct {
	autorest.Response `json:"-"`
	Field1            *int32 `json:"field1,omitempty"`
	Field2            *int32 `json:"field2,omitempty"`
}

// LongWrapper ...
type LongWrapper struct {
	autorest.Response `json:"-"`
	Field1            *int64 `json:"field1,omitempty"`
	Field2            *int64 `json:"field2,omitempty"`
}

// Pet ...
type Pet struct {
	ID   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ReadonlyObj ...
type ReadonlyObj struct {
	autorest.Response `json:"-"`
	ID                *string `json:"id,omitempty"`
	Size              *int32  `json:"size,omitempty"`
}

// BasicSalmon ...
type BasicSalmon interface {
	AsSmartSalmon() (*SmartSalmon, bool)
	AsSalmon() (*Salmon, bool)
}

// Salmon ...
type Salmon struct {
	autorest.Response `json:"-"`
	Species           *string      `json:"species,omitempty"`
	Length            *float64     `json:"length,omitempty"`
	Siblings          *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype `json:"fishtype,omitempty"`
	Location *string  `json:"location,omitempty"`
	Iswild   *bool    `json:"iswild,omitempty"`
}

func unmarshalBasicSalmon(body []byte) (BasicSalmon, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["fishtype"] {
	case string(FishtypeSmartSalmon):
		var s SmartSalmon
		err := json.Unmarshal(body, &s)
		return s, err
	default:
		var s Salmon
		err := json.Unmarshal(body, &s)
		return s, err
	}
}
func unmarshalBasicSalmonArray(body []byte) ([]BasicSalmon, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sArray := make([]BasicSalmon, len(rawMessages))

	for index, rawMessage := range rawMessages {
		s, err := unmarshalBasicSalmon(*rawMessage)
		if err != nil {
			return nil, err
		}
		sArray[index] = s
	}
	return sArray, nil
}

// MarshalJSON is the custom marshaler for Salmon.
func (s Salmon) MarshalJSON() ([]byte, error) {
	s.Fishtype = FishtypeSalmon
	objectMap := make(map[string]interface{})
	if s.Location != nil {
		objectMap["location"] = s.Location
	}
	if s.Iswild != nil {
		objectMap["iswild"] = s.Iswild
	}
	if s.Species != nil {
		objectMap["species"] = s.Species
	}
	if s.Length != nil {
		objectMap["length"] = s.Length
	}
	if s.Siblings != nil {
		objectMap["siblings"] = s.Siblings
	}
	objectMap["fishtype"] = s.Fishtype
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for Salmon.
func (s Salmon) AsSalmon() (*Salmon, bool) {
	return &s, true
}

// AsBasicSalmon is the BasicFish implementation for Salmon.
func (s Salmon) AsBasicSalmon() (BasicSalmon, bool) {
	return &s, true
}

// AsSmartSalmon is the BasicFish implementation for Salmon.
func (s Salmon) AsSmartSalmon() (*SmartSalmon, bool) {
	return nil, false
}

// AsShark is the BasicFish implementation for Salmon.
func (s Salmon) AsShark() (*Shark, bool) {
	return nil, false
}

// AsBasicShark is the BasicFish implementation for Salmon.
func (s Salmon) AsBasicShark() (BasicShark, bool) {
	return nil, false
}

// AsSawshark is the BasicFish implementation for Salmon.
func (s Salmon) AsSawshark() (*Sawshark, bool) {
	return nil, false
}

// AsGoblinshark is the BasicFish implementation for Salmon.
func (s Salmon) AsGoblinshark() (*Goblinshark, bool) {
	return nil, false
}

// AsCookiecuttershark is the BasicFish implementation for Salmon.
func (s Salmon) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return nil, false
}

// AsFish is the BasicFish implementation for Salmon.
func (s Salmon) AsFish() (*Fish, bool) {
	return nil, false
}

// AsBasicFish is the BasicFish implementation for Salmon.
func (s Salmon) AsBasicFish() (BasicFish, bool) {
	return &s, true
}

// UnmarshalJSON is the custom unmarshaler for Salmon struct.
func (s *Salmon) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				s.Location = &location
			}
		case "iswild":
			if v != nil {
				var iswild bool
				err = json.Unmarshal(*v, &iswild)
				if err != nil {
					return err
				}
				s.Iswild = &iswild
			}
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				s.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				s.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				s.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				s.Fishtype = fishtype
			}
		}
	}

	return nil
}

// SalmonModel ...
type SalmonModel struct {
	autorest.Response `json:"-"`
	Value             BasicSalmon `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for SalmonModel struct.
func (sm *SalmonModel) UnmarshalJSON(body []byte) error {
	s, err := unmarshalBasicSalmon(body)
	if err != nil {
		return err
	}
	sm.Value = s

	return nil
}

// Sawshark ...
type Sawshark struct {
	Species  *string      `json:"species,omitempty"`
	Length   *float64     `json:"length,omitempty"`
	Siblings *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype   `json:"fishtype,omitempty"`
	Age      *int32     `json:"age,omitempty"`
	Birthday *date.Time `json:"birthday,omitempty"`
	Picture  *[]byte    `json:"picture,omitempty"`
}

// MarshalJSON is the custom marshaler for Sawshark.
func (s Sawshark) MarshalJSON() ([]byte, error) {
	s.Fishtype = FishtypeSawshark
	objectMap := make(map[string]interface{})
	if s.Picture != nil {
		objectMap["picture"] = s.Picture
	}
	if s.Age != nil {
		objectMap["age"] = s.Age
	}
	if s.Birthday != nil {
		objectMap["birthday"] = s.Birthday
	}
	if s.Species != nil {
		objectMap["species"] = s.Species
	}
	if s.Length != nil {
		objectMap["length"] = s.Length
	}
	if s.Siblings != nil {
		objectMap["siblings"] = s.Siblings
	}
	objectMap["fishtype"] = s.Fishtype
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for Sawshark.
func (s Sawshark) AsSalmon() (*Salmon, bool) {
	return nil, false
}

// AsBasicSalmon is the BasicFish implementation for Sawshark.
func (s Sawshark) AsBasicSalmon() (BasicSalmon, bool) {
	return nil, false
}

// AsSmartSalmon is the BasicFish implementation for Sawshark.
func (s Sawshark) AsSmartSalmon() (*SmartSalmon, bool) {
	return nil, false
}

// AsShark is the BasicFish implementation for Sawshark.
func (s Sawshark) AsShark() (*Shark, bool) {
	return nil, false
}

// AsBasicShark is the BasicFish implementation for Sawshark.
func (s Sawshark) AsBasicShark() (BasicShark, bool) {
	return &s, true
}

// AsSawshark is the BasicFish implementation for Sawshark.
func (s Sawshark) AsSawshark() (*Sawshark, bool) {
	return &s, true
}

// AsGoblinshark is the BasicFish implementation for Sawshark.
func (s Sawshark) AsGoblinshark() (*Goblinshark, bool) {
	return nil, false
}

// AsCookiecuttershark is the BasicFish implementation for Sawshark.
func (s Sawshark) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return nil, false
}

// AsFish is the BasicFish implementation for Sawshark.
func (s Sawshark) AsFish() (*Fish, bool) {
	return nil, false
}

// AsBasicFish is the BasicFish implementation for Sawshark.
func (s Sawshark) AsBasicFish() (BasicFish, bool) {
	return &s, true
}

// UnmarshalJSON is the custom unmarshaler for Sawshark struct.
func (s *Sawshark) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "picture":
			if v != nil {
				var picture []byte
				err = json.Unmarshal(*v, &picture)
				if err != nil {
					return err
				}
				s.Picture = &picture
			}
		case "age":
			if v != nil {
				var age int32
				err = json.Unmarshal(*v, &age)
				if err != nil {
					return err
				}
				s.Age = &age
			}
		case "birthday":
			if v != nil {
				var birthday date.Time
				err = json.Unmarshal(*v, &birthday)
				if err != nil {
					return err
				}
				s.Birthday = &birthday
			}
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				s.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				s.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				s.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				s.Fishtype = fishtype
			}
		}
	}

	return nil
}

// BasicShark ...
type BasicShark interface {
	AsSawshark() (*Sawshark, bool)
	AsGoblinshark() (*Goblinshark, bool)
	AsCookiecuttershark() (*Cookiecuttershark, bool)
	AsShark() (*Shark, bool)
}

// Shark ...
type Shark struct {
	Species  *string      `json:"species,omitempty"`
	Length   *float64     `json:"length,omitempty"`
	Siblings *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype   `json:"fishtype,omitempty"`
	Age      *int32     `json:"age,omitempty"`
	Birthday *date.Time `json:"birthday,omitempty"`
}

func unmarshalBasicShark(body []byte) (BasicShark, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["fishtype"] {
	case string(FishtypeSawshark):
		var s Sawshark
		err := json.Unmarshal(body, &s)
		return s, err
	case string(FishtypeGoblin):
		var g Goblinshark
		err := json.Unmarshal(body, &g)
		return g, err
	case string(FishtypeCookiecuttershark):
		var c Cookiecuttershark
		err := json.Unmarshal(body, &c)
		return c, err
	default:
		var s Shark
		err := json.Unmarshal(body, &s)
		return s, err
	}
}
func unmarshalBasicSharkArray(body []byte) ([]BasicShark, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sArray := make([]BasicShark, len(rawMessages))

	for index, rawMessage := range rawMessages {
		s, err := unmarshalBasicShark(*rawMessage)
		if err != nil {
			return nil, err
		}
		sArray[index] = s
	}
	return sArray, nil
}

// MarshalJSON is the custom marshaler for Shark.
func (s Shark) MarshalJSON() ([]byte, error) {
	s.Fishtype = FishtypeShark
	objectMap := make(map[string]interface{})
	if s.Age != nil {
		objectMap["age"] = s.Age
	}
	if s.Birthday != nil {
		objectMap["birthday"] = s.Birthday
	}
	if s.Species != nil {
		objectMap["species"] = s.Species
	}
	if s.Length != nil {
		objectMap["length"] = s.Length
	}
	if s.Siblings != nil {
		objectMap["siblings"] = s.Siblings
	}
	objectMap["fishtype"] = s.Fishtype
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for Shark.
func (s Shark) AsSalmon() (*Salmon, bool) {
	return nil, false
}

// AsBasicSalmon is the BasicFish implementation for Shark.
func (s Shark) AsBasicSalmon() (BasicSalmon, bool) {
	return nil, false
}

// AsSmartSalmon is the BasicFish implementation for Shark.
func (s Shark) AsSmartSalmon() (*SmartSalmon, bool) {
	return nil, false
}

// AsShark is the BasicFish implementation for Shark.
func (s Shark) AsShark() (*Shark, bool) {
	return &s, true
}

// AsBasicShark is the BasicFish implementation for Shark.
func (s Shark) AsBasicShark() (BasicShark, bool) {
	return &s, true
}

// AsSawshark is the BasicFish implementation for Shark.
func (s Shark) AsSawshark() (*Sawshark, bool) {
	return nil, false
}

// AsGoblinshark is the BasicFish implementation for Shark.
func (s Shark) AsGoblinshark() (*Goblinshark, bool) {
	return nil, false
}

// AsCookiecuttershark is the BasicFish implementation for Shark.
func (s Shark) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return nil, false
}

// AsFish is the BasicFish implementation for Shark.
func (s Shark) AsFish() (*Fish, bool) {
	return nil, false
}

// AsBasicFish is the BasicFish implementation for Shark.
func (s Shark) AsBasicFish() (BasicFish, bool) {
	return &s, true
}

// UnmarshalJSON is the custom unmarshaler for Shark struct.
func (s *Shark) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "age":
			if v != nil {
				var age int32
				err = json.Unmarshal(*v, &age)
				if err != nil {
					return err
				}
				s.Age = &age
			}
		case "birthday":
			if v != nil {
				var birthday date.Time
				err = json.Unmarshal(*v, &birthday)
				if err != nil {
					return err
				}
				s.Birthday = &birthday
			}
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				s.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				s.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				s.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				s.Fishtype = fishtype
			}
		}
	}

	return nil
}

// Siamese ...
type Siamese struct {
	autorest.Response `json:"-"`
	ID                *int32  `json:"id,omitempty"`
	Name              *string `json:"name,omitempty"`
	Color             *string `json:"color,omitempty"`
	Hates             *[]Dog  `json:"hates,omitempty"`
	Breed             *string `json:"breed,omitempty"`
}

// SmartSalmon ...
type SmartSalmon struct {
	Species  *string      `json:"species,omitempty"`
	Length   *float64     `json:"length,omitempty"`
	Siblings *[]BasicFish `json:"siblings,omitempty"`
	// Fishtype - Possible values include: 'FishtypeFish', 'FishtypeSalmon', 'FishtypeSmartSalmon', 'FishtypeShark', 'FishtypeSawshark', 'FishtypeGoblin', 'FishtypeCookiecuttershark'
	Fishtype Fishtype `json:"fishtype,omitempty"`
	Location *string  `json:"location,omitempty"`
	Iswild   *bool    `json:"iswild,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	CollegeDegree        *string                `json:"college_degree,omitempty"`
}

// MarshalJSON is the custom marshaler for SmartSalmon.
func (s SmartSalmon) MarshalJSON() ([]byte, error) {
	s.Fishtype = FishtypeSmartSalmon
	objectMap := make(map[string]interface{})
	if s.CollegeDegree != nil {
		objectMap["college_degree"] = s.CollegeDegree
	}
	if s.Location != nil {
		objectMap["location"] = s.Location
	}
	if s.Iswild != nil {
		objectMap["iswild"] = s.Iswild
	}
	if s.Species != nil {
		objectMap["species"] = s.Species
	}
	if s.Length != nil {
		objectMap["length"] = s.Length
	}
	if s.Siblings != nil {
		objectMap["siblings"] = s.Siblings
	}
	objectMap["fishtype"] = s.Fishtype
	for k, v := range s.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// AsSalmon is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsSalmon() (*Salmon, bool) {
	return nil, false
}

// AsBasicSalmon is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsBasicSalmon() (BasicSalmon, bool) {
	return &s, true
}

// AsSmartSalmon is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsSmartSalmon() (*SmartSalmon, bool) {
	return &s, true
}

// AsShark is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsShark() (*Shark, bool) {
	return nil, false
}

// AsBasicShark is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsBasicShark() (BasicShark, bool) {
	return nil, false
}

// AsSawshark is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsSawshark() (*Sawshark, bool) {
	return nil, false
}

// AsGoblinshark is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsGoblinshark() (*Goblinshark, bool) {
	return nil, false
}

// AsCookiecuttershark is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsCookiecuttershark() (*Cookiecuttershark, bool) {
	return nil, false
}

// AsFish is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsFish() (*Fish, bool) {
	return nil, false
}

// AsBasicFish is the BasicFish implementation for SmartSalmon.
func (s SmartSalmon) AsBasicFish() (BasicFish, bool) {
	return &s, true
}

// UnmarshalJSON is the custom unmarshaler for SmartSalmon struct.
func (s *SmartSalmon) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if s.AdditionalProperties == nil {
					s.AdditionalProperties = make(map[string]interface{})
				}
				s.AdditionalProperties[k] = additionalProperties
			}
		case "college_degree":
			if v != nil {
				var collegeDegree string
				err = json.Unmarshal(*v, &collegeDegree)
				if err != nil {
					return err
				}
				s.CollegeDegree = &collegeDegree
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				s.Location = &location
			}
		case "iswild":
			if v != nil {
				var iswild bool
				err = json.Unmarshal(*v, &iswild)
				if err != nil {
					return err
				}
				s.Iswild = &iswild
			}
		case "species":
			if v != nil {
				var species string
				err = json.Unmarshal(*v, &species)
				if err != nil {
					return err
				}
				s.Species = &species
			}
		case "length":
			if v != nil {
				var length float64
				err = json.Unmarshal(*v, &length)
				if err != nil {
					return err
				}
				s.Length = &length
			}
		case "siblings":
			if v != nil {
				siblings, err := unmarshalBasicFishArray(*v)
				if err != nil {
					return err
				}
				s.Siblings = &siblings
			}
		case "fishtype":
			if v != nil {
				var fishtype Fishtype
				err = json.Unmarshal(*v, &fishtype)
				if err != nil {
					return err
				}
				s.Fishtype = fishtype
			}
		}
	}

	return nil
}

// StringWrapper ...
type StringWrapper struct {
	autorest.Response `json:"-"`
	Field             *string `json:"field,omitempty"`
	Empty             *string `json:"empty,omitempty"`
	Null              *string `json:"null,omitempty"`
}
