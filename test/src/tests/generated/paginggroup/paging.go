package paginggroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// PagingClient is the long-running Operation for AutoRest
type PagingClient struct {
	BaseClient
}

// NewPagingClient creates an instance of the PagingClient client.
func NewPagingClient() PagingClient {
	return NewPagingClientWithBaseURI(DefaultBaseURI)
}

// NewPagingClientWithBaseURI creates an instance of the PagingClient client using a custom endpoint.  Use this when
// interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewPagingClientWithBaseURI(baseURI string) PagingClient {
	return PagingClient{NewWithBaseURI(baseURI)}
}

// GetMultiplePages a paging operation that includes a nextLink that has 10 pages
// Parameters:
// maxresults - sets the maximum number of items to return in the response.
// timeout - sets the maximum time that the server can spend processing the request, in seconds. The default is
// 30 seconds.
func (client PagingClient) GetMultiplePages(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePages")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getMultiplePagesNextResults
	req, err := client.GetMultiplePagesPreparer(ctx, clientRequestID, maxresults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePages", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePages", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetMultiplePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePages", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesPreparer prepares the GetMultiplePages request.
func (client PagingClient) GetMultiplePagesPreparer(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple"))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if maxresults != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("maxresults", autorest.String(*maxresults)))
	}
	if timeout != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(*timeout)))
	} else {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(30)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesSender sends the GetMultiplePages request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesResponder handles the response to the GetMultiplePages request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesNextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetMultiplePagesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetMultiplePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetMultiplePagesComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesComplete(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePages")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePages(ctx, clientRequestID, maxresults, timeout)
	return
}

// GetMultiplePagesFailure a paging operation that receives a 400 on the second call
func (client PagingClient) GetMultiplePagesFailure(ctx context.Context) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFailure")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getMultiplePagesFailureNextResults
	req, err := client.GetMultiplePagesFailurePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFailure", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesFailureSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFailure", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetMultiplePagesFailureResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFailure", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesFailurePreparer prepares the GetMultiplePagesFailure request.
func (client PagingClient) GetMultiplePagesFailurePreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple/failure"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesFailureSender sends the GetMultiplePagesFailure request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesFailureSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesFailureResponder handles the response to the GetMultiplePagesFailure request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesFailureResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesFailureNextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesFailureNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesFailureNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetMultiplePagesFailureSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesFailureNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetMultiplePagesFailureResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesFailureNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetMultiplePagesFailureComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesFailureComplete(ctx context.Context) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFailure")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesFailure(ctx)
	return
}

// GetMultiplePagesFailureURI a paging operation that receives an invalid nextLink
func (client PagingClient) GetMultiplePagesFailureURI(ctx context.Context) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFailureURI")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getMultiplePagesFailureURINextResults
	req, err := client.GetMultiplePagesFailureURIPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFailureURI", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesFailureURISender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFailureURI", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetMultiplePagesFailureURIResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFailureURI", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesFailureURIPreparer prepares the GetMultiplePagesFailureURI request.
func (client PagingClient) GetMultiplePagesFailureURIPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple/failureuri"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesFailureURISender sends the GetMultiplePagesFailureURI request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesFailureURISender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesFailureURIResponder handles the response to the GetMultiplePagesFailureURI request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesFailureURIResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesFailureURINextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesFailureURINextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesFailureURINextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetMultiplePagesFailureURISender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesFailureURINextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetMultiplePagesFailureURIResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesFailureURINextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetMultiplePagesFailureURIComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesFailureURIComplete(ctx context.Context) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFailureURI")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesFailureURI(ctx)
	return
}

// GetMultiplePagesFragmentNextLink a paging operation that doesn't return a full URL, just a fragment
// Parameters:
// APIVersion - sets the api version to use.
// tenant - sets the tenant to use.
func (client PagingClient) GetMultiplePagesFragmentNextLink(ctx context.Context, APIVersion string, tenant string) (result OdataProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFragmentNextLink")
		defer func() {
			sc := -1
			if result.opr.Response.Response != nil {
				sc = result.opr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = func(ctx context.Context, lastResult OdataProductResult) (OdataProductResult, error) {
		if lastResult.OdataNextLink == nil || len(to.String(lastResult.OdataNextLink)) < 1 {
			return OdataProductResult{}, nil
		}
		return client.NextFragment(ctx, APIVersion, tenant, *lastResult.OdataNextLink)
	}
	req, err := client.GetMultiplePagesFragmentNextLinkPreparer(ctx, APIVersion, tenant)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFragmentNextLink", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesFragmentNextLinkSender(req)
	if err != nil {
		result.opr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFragmentNextLink", resp, "Failure sending request")
		return
	}

	result.opr, err = client.GetMultiplePagesFragmentNextLinkResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFragmentNextLink", resp, "Failure responding to request")
		return
	}
	if result.opr.hasNextLink() && result.opr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesFragmentNextLinkPreparer prepares the GetMultiplePagesFragmentNextLink request.
func (client PagingClient) GetMultiplePagesFragmentNextLinkPreparer(ctx context.Context, APIVersion string, tenant string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"tenant": autorest.Encode("path", tenant),
	}

	queryParameters := map[string]interface{}{
		"api_version": autorest.Encode("query", APIVersion),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paging/multiple/fragment/{tenant}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesFragmentNextLinkSender sends the GetMultiplePagesFragmentNextLink request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesFragmentNextLinkSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesFragmentNextLinkResponder handles the response to the GetMultiplePagesFragmentNextLink request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesFragmentNextLinkResponder(resp *http.Response) (result OdataProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMultiplePagesFragmentNextLinkComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesFragmentNextLinkComplete(ctx context.Context, APIVersion string, tenant string) (result OdataProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFragmentNextLink")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesFragmentNextLink(ctx, APIVersion, tenant)
	return
}

// GetMultiplePagesFragmentWithGroupingNextLink a paging operation that doesn't return a full URL, just a fragment with
// parameters grouped
// Parameters:
// APIVersion - sets the api version to use.
// tenant - sets the tenant to use.
func (client PagingClient) GetMultiplePagesFragmentWithGroupingNextLink(ctx context.Context, APIVersion string, tenant string) (result OdataProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFragmentWithGroupingNextLink")
		defer func() {
			sc := -1
			if result.opr.Response.Response != nil {
				sc = result.opr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = func(ctx context.Context, lastResult OdataProductResult) (OdataProductResult, error) {
		if lastResult.OdataNextLink == nil || len(to.String(lastResult.OdataNextLink)) < 1 {
			return OdataProductResult{}, nil
		}
		return client.NextFragmentWithGrouping(ctx, APIVersion, tenant, *lastResult.OdataNextLink)
	}
	req, err := client.GetMultiplePagesFragmentWithGroupingNextLinkPreparer(ctx, APIVersion, tenant)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFragmentWithGroupingNextLink", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesFragmentWithGroupingNextLinkSender(req)
	if err != nil {
		result.opr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFragmentWithGroupingNextLink", resp, "Failure sending request")
		return
	}

	result.opr, err = client.GetMultiplePagesFragmentWithGroupingNextLinkResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesFragmentWithGroupingNextLink", resp, "Failure responding to request")
		return
	}
	if result.opr.hasNextLink() && result.opr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesFragmentWithGroupingNextLinkPreparer prepares the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkPreparer(ctx context.Context, APIVersion string, tenant string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"tenant": autorest.Encode("path", tenant),
	}

	queryParameters := map[string]interface{}{
		"api_version": autorest.Encode("query", APIVersion),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paging/multiple/fragmentwithgrouping/{tenant}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesFragmentWithGroupingNextLinkSender sends the GetMultiplePagesFragmentWithGroupingNextLink request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesFragmentWithGroupingNextLinkResponder handles the response to the GetMultiplePagesFragmentWithGroupingNextLink request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkResponder(resp *http.Response) (result OdataProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMultiplePagesFragmentWithGroupingNextLinkComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkComplete(ctx context.Context, APIVersion string, tenant string) (result OdataProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesFragmentWithGroupingNextLink")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesFragmentWithGroupingNextLink(ctx, APIVersion, tenant)
	return
}

// GetMultiplePagesLRO a long-running paging operation that includes a nextLink that has 10 pages
// Parameters:
// maxresults - sets the maximum number of items to return in the response.
// timeout - sets the maximum time that the server can spend processing the request, in seconds. The default is
// 30 seconds.
func (client PagingClient) GetMultiplePagesLRO(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (result PagingGetMultiplePagesLROFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesLRO")
		defer func() {
			sc := -1
			if result.FutureAPI != nil && result.FutureAPI.Response() != nil {
				sc = result.FutureAPI.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetMultiplePagesLROPreparer(ctx, clientRequestID, maxresults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesLRO", nil, "Failure preparing request")
		return
	}

	result, err = client.GetMultiplePagesLROSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesLRO", result.Response(), "Failure sending request")
		return
	}

	return
}

// GetMultiplePagesLROPreparer prepares the GetMultiplePagesLRO request.
func (client PagingClient) GetMultiplePagesLROPreparer(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple/lro"))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if maxresults != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("maxresults", autorest.String(*maxresults)))
	}
	if timeout != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(*timeout)))
	} else {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(30)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesLROSender sends the GetMultiplePagesLRO request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesLROSender(req *http.Request) (future PagingGetMultiplePagesLROFuture, err error) {
	var resp *http.Response
	future.FutureAPI = &azure.Future{}
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return
	}
	var azf azure.Future
	azf, err = azure.NewFutureFromResponse(resp)
	future.FutureAPI = &azf
	future.Result = future.result
	return
}

// GetMultiplePagesLROResponder handles the response to the GetMultiplePagesLRO request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesLROResponder(resp *http.Response) (result ProductResultPage, err error) {
	result.pr, err = client.getMultiplePagesLROResponder(resp)
	result.fn = client.getMultiplePagesLRONextResults
	return
}

func (client PagingClient) getMultiplePagesLROResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesLRONextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesLRONextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesLRONextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	var resp *http.Response
	resp, err = client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesLRONextResults", resp, "Failure sending next results request")
	}
	return client.getMultiplePagesLROResponder(resp)
}

// GetMultiplePagesLROComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesLROComplete(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (result PagingGetMultiplePagesLROAllFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesLRO")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	var future PagingGetMultiplePagesLROFuture
	future, err = client.GetMultiplePagesLRO(ctx, clientRequestID, maxresults, timeout)
	result.FutureAPI = future.FutureAPI
	return
}

// GetMultiplePagesRetryFirst a paging operation that fails on the first call with 500 and then retries and then get a
// response including a nextLink that has 10 pages
func (client PagingClient) GetMultiplePagesRetryFirst(ctx context.Context) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesRetryFirst")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getMultiplePagesRetryFirstNextResults
	req, err := client.GetMultiplePagesRetryFirstPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesRetryFirst", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesRetryFirstSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesRetryFirst", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetMultiplePagesRetryFirstResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesRetryFirst", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesRetryFirstPreparer prepares the GetMultiplePagesRetryFirst request.
func (client PagingClient) GetMultiplePagesRetryFirstPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple/retryfirst"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesRetryFirstSender sends the GetMultiplePagesRetryFirst request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesRetryFirstSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesRetryFirstResponder handles the response to the GetMultiplePagesRetryFirst request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesRetryFirstResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesRetryFirstNextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesRetryFirstNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesRetryFirstNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetMultiplePagesRetryFirstSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesRetryFirstNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetMultiplePagesRetryFirstResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesRetryFirstNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetMultiplePagesRetryFirstComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesRetryFirstComplete(ctx context.Context) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesRetryFirst")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesRetryFirst(ctx)
	return
}

// GetMultiplePagesRetrySecond a paging operation that includes a nextLink that has 10 pages, of which the 2nd call
// fails first with 500. The client should retry and finish all 10 pages eventually.
func (client PagingClient) GetMultiplePagesRetrySecond(ctx context.Context) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesRetrySecond")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getMultiplePagesRetrySecondNextResults
	req, err := client.GetMultiplePagesRetrySecondPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesRetrySecond", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesRetrySecondSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesRetrySecond", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetMultiplePagesRetrySecondResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesRetrySecond", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesRetrySecondPreparer prepares the GetMultiplePagesRetrySecond request.
func (client PagingClient) GetMultiplePagesRetrySecondPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple/retrysecond"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesRetrySecondSender sends the GetMultiplePagesRetrySecond request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesRetrySecondSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesRetrySecondResponder handles the response to the GetMultiplePagesRetrySecond request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesRetrySecondResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesRetrySecondNextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesRetrySecondNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesRetrySecondNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetMultiplePagesRetrySecondSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesRetrySecondNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetMultiplePagesRetrySecondResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesRetrySecondNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetMultiplePagesRetrySecondComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesRetrySecondComplete(ctx context.Context) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesRetrySecond")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesRetrySecond(ctx)
	return
}

// GetMultiplePagesWithOffset a paging operation that includes a nextLink that has 10 pages
// Parameters:
// offset - offset of return value
// maxresults - sets the maximum number of items to return in the response.
// timeout - sets the maximum time that the server can spend processing the request, in seconds. The default is
// 30 seconds.
func (client PagingClient) GetMultiplePagesWithOffset(ctx context.Context, offset int32, clientRequestID string, maxresults *int32, timeout *int32) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesWithOffset")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getMultiplePagesWithOffsetNextResults
	req, err := client.GetMultiplePagesWithOffsetPreparer(ctx, offset, clientRequestID, maxresults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesWithOffset", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMultiplePagesWithOffsetSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesWithOffset", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetMultiplePagesWithOffsetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetMultiplePagesWithOffset", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetMultiplePagesWithOffsetPreparer prepares the GetMultiplePagesWithOffset request.
func (client PagingClient) GetMultiplePagesWithOffsetPreparer(ctx context.Context, offset int32, clientRequestID string, maxresults *int32, timeout *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"offset": autorest.Encode("path", offset),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paging/multiple/withpath/{offset}", pathParameters))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if maxresults != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("maxresults", autorest.String(*maxresults)))
	}
	if timeout != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(*timeout)))
	} else {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(30)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMultiplePagesWithOffsetSender sends the GetMultiplePagesWithOffset request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetMultiplePagesWithOffsetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetMultiplePagesWithOffsetResponder handles the response to the GetMultiplePagesWithOffset request. The method always
// closes the http.Response Body.
func (client PagingClient) GetMultiplePagesWithOffsetResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getMultiplePagesWithOffsetNextResults retrieves the next set of results, if any.
func (client PagingClient) getMultiplePagesWithOffsetNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesWithOffsetNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetMultiplePagesWithOffsetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesWithOffsetNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetMultiplePagesWithOffsetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getMultiplePagesWithOffsetNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetMultiplePagesWithOffsetComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetMultiplePagesWithOffsetComplete(ctx context.Context, offset int32, clientRequestID string, maxresults *int32, timeout *int32) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetMultiplePagesWithOffset")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetMultiplePagesWithOffset(ctx, offset, clientRequestID, maxresults, timeout)
	return
}

// GetNoItemNamePages a paging operation that must return result of the default 'value' node.
func (client PagingClient) GetNoItemNamePages(ctx context.Context) (result ProductResultValuePage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetNoItemNamePages")
		defer func() {
			sc := -1
			if result.prv.Response.Response != nil {
				sc = result.prv.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getNoItemNamePagesNextResults
	req, err := client.GetNoItemNamePagesPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetNoItemNamePages", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNoItemNamePagesSender(req)
	if err != nil {
		result.prv.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetNoItemNamePages", resp, "Failure sending request")
		return
	}

	result.prv, err = client.GetNoItemNamePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetNoItemNamePages", resp, "Failure responding to request")
		return
	}
	if result.prv.hasNextLink() && result.prv.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetNoItemNamePagesPreparer prepares the GetNoItemNamePages request.
func (client PagingClient) GetNoItemNamePagesPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/noitemname"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNoItemNamePagesSender sends the GetNoItemNamePages request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetNoItemNamePagesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNoItemNamePagesResponder handles the response to the GetNoItemNamePages request. The method always
// closes the http.Response Body.
func (client PagingClient) GetNoItemNamePagesResponder(resp *http.Response) (result ProductResultValue, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getNoItemNamePagesNextResults retrieves the next set of results, if any.
func (client PagingClient) getNoItemNamePagesNextResults(ctx context.Context, lastResults ProductResultValue) (result ProductResultValue, err error) {
	req, err := lastResults.productResultValuePreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getNoItemNamePagesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetNoItemNamePagesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getNoItemNamePagesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetNoItemNamePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getNoItemNamePagesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetNoItemNamePagesComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetNoItemNamePagesComplete(ctx context.Context) (result ProductResultValueIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetNoItemNamePages")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetNoItemNamePages(ctx)
	return
}

// GetNullNextLinkNamePages a paging operation that must ignore any kind of nextLink, and stop after page 1.
func (client PagingClient) GetNullNextLinkNamePages(ctx context.Context) (result ProductResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetNullNextLinkNamePages")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetNullNextLinkNamePagesPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetNullNextLinkNamePages", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNullNextLinkNamePagesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetNullNextLinkNamePages", resp, "Failure sending request")
		return
	}

	result, err = client.GetNullNextLinkNamePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetNullNextLinkNamePages", resp, "Failure responding to request")
		return
	}

	return
}

// GetNullNextLinkNamePagesPreparer prepares the GetNullNextLinkNamePages request.
func (client PagingClient) GetNullNextLinkNamePagesPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/nullnextlink"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNullNextLinkNamePagesSender sends the GetNullNextLinkNamePages request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetNullNextLinkNamePagesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetNullNextLinkNamePagesResponder handles the response to the GetNullNextLinkNamePages request. The method always
// closes the http.Response Body.
func (client PagingClient) GetNullNextLinkNamePagesResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetOdataMultiplePages a paging operation that includes a nextLink in odata format that has 10 pages
// Parameters:
// maxresults - sets the maximum number of items to return in the response.
// timeout - sets the maximum time that the server can spend processing the request, in seconds. The default is
// 30 seconds.
func (client PagingClient) GetOdataMultiplePages(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (result OdataProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetOdataMultiplePages")
		defer func() {
			sc := -1
			if result.opr.Response.Response != nil {
				sc = result.opr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getOdataMultiplePagesNextResults
	req, err := client.GetOdataMultiplePagesPreparer(ctx, clientRequestID, maxresults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetOdataMultiplePages", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetOdataMultiplePagesSender(req)
	if err != nil {
		result.opr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetOdataMultiplePages", resp, "Failure sending request")
		return
	}

	result.opr, err = client.GetOdataMultiplePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetOdataMultiplePages", resp, "Failure responding to request")
		return
	}
	if result.opr.hasNextLink() && result.opr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetOdataMultiplePagesPreparer prepares the GetOdataMultiplePages request.
func (client PagingClient) GetOdataMultiplePagesPreparer(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/multiple/odata"))
	if len(clientRequestID) > 0 {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("client-request-id", autorest.String(clientRequestID)))
	}
	if maxresults != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("maxresults", autorest.String(*maxresults)))
	}
	if timeout != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(*timeout)))
	} else {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithHeader("timeout", autorest.String(30)))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetOdataMultiplePagesSender sends the GetOdataMultiplePages request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetOdataMultiplePagesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetOdataMultiplePagesResponder handles the response to the GetOdataMultiplePages request. The method always
// closes the http.Response Body.
func (client PagingClient) GetOdataMultiplePagesResponder(resp *http.Response) (result OdataProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getOdataMultiplePagesNextResults retrieves the next set of results, if any.
func (client PagingClient) getOdataMultiplePagesNextResults(ctx context.Context, lastResults OdataProductResult) (result OdataProductResult, err error) {
	req, err := lastResults.odataProductResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getOdataMultiplePagesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetOdataMultiplePagesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getOdataMultiplePagesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetOdataMultiplePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getOdataMultiplePagesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetOdataMultiplePagesComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetOdataMultiplePagesComplete(ctx context.Context, clientRequestID string, maxresults *int32, timeout *int32) (result OdataProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetOdataMultiplePages")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetOdataMultiplePages(ctx, clientRequestID, maxresults, timeout)
	return
}

// GetSinglePages a paging operation that finishes on the first call without a nextlink
func (client PagingClient) GetSinglePages(ctx context.Context) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetSinglePages")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getSinglePagesNextResults
	req, err := client.GetSinglePagesPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetSinglePages", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSinglePagesSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetSinglePages", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetSinglePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetSinglePages", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetSinglePagesPreparer prepares the GetSinglePages request.
func (client PagingClient) GetSinglePagesPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/single"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSinglePagesSender sends the GetSinglePages request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetSinglePagesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSinglePagesResponder handles the response to the GetSinglePages request. The method always
// closes the http.Response Body.
func (client PagingClient) GetSinglePagesResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getSinglePagesNextResults retrieves the next set of results, if any.
func (client PagingClient) getSinglePagesNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getSinglePagesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetSinglePagesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getSinglePagesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetSinglePagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getSinglePagesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetSinglePagesComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetSinglePagesComplete(ctx context.Context) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetSinglePages")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetSinglePages(ctx)
	return
}

// GetSinglePagesFailure a paging operation that receives a 400 on the first call
func (client PagingClient) GetSinglePagesFailure(ctx context.Context) (result ProductResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetSinglePagesFailure")
		defer func() {
			sc := -1
			if result.pr.Response.Response != nil {
				sc = result.pr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.getSinglePagesFailureNextResults
	req, err := client.GetSinglePagesFailurePreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetSinglePagesFailure", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSinglePagesFailureSender(req)
	if err != nil {
		result.pr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetSinglePagesFailure", resp, "Failure sending request")
		return
	}

	result.pr, err = client.GetSinglePagesFailureResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "GetSinglePagesFailure", resp, "Failure responding to request")
		return
	}
	if result.pr.hasNextLink() && result.pr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// GetSinglePagesFailurePreparer prepares the GetSinglePagesFailure request.
func (client PagingClient) GetSinglePagesFailurePreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/paging/single/failure"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSinglePagesFailureSender sends the GetSinglePagesFailure request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) GetSinglePagesFailureSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSinglePagesFailureResponder handles the response to the GetSinglePagesFailure request. The method always
// closes the http.Response Body.
func (client PagingClient) GetSinglePagesFailureResponder(resp *http.Response) (result ProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// getSinglePagesFailureNextResults retrieves the next set of results, if any.
func (client PagingClient) getSinglePagesFailureNextResults(ctx context.Context, lastResults ProductResult) (result ProductResult, err error) {
	req, err := lastResults.productResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getSinglePagesFailureNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.GetSinglePagesFailureSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getSinglePagesFailureNextResults", resp, "Failure sending next results request")
	}
	result, err = client.GetSinglePagesFailureResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "getSinglePagesFailureNextResults", resp, "Failure responding to next results request")
	}
	return
}

// GetSinglePagesFailureComplete enumerates all values, automatically crossing page boundaries as required.
func (client PagingClient) GetSinglePagesFailureComplete(ctx context.Context) (result ProductResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.GetSinglePagesFailure")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.GetSinglePagesFailure(ctx)
	return
}

// NextFragment a paging operation that doesn't return a full URL, just a fragment
// Parameters:
// APIVersion - sets the api version to use.
// tenant - sets the tenant to use.
// nextLink - next link for list operation.
func (client PagingClient) NextFragment(ctx context.Context, APIVersion string, tenant string, nextLink string) (result OdataProductResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.NextFragment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.NextFragmentPreparer(ctx, APIVersion, tenant, nextLink)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "NextFragment", nil, "Failure preparing request")
		return
	}

	resp, err := client.NextFragmentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "NextFragment", resp, "Failure sending request")
		return
	}

	result, err = client.NextFragmentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "NextFragment", resp, "Failure responding to request")
		return
	}

	return
}

// NextFragmentPreparer prepares the NextFragment request.
func (client PagingClient) NextFragmentPreparer(ctx context.Context, APIVersion string, tenant string, nextLink string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nextLink": nextLink,
		"tenant":   autorest.Encode("path", tenant),
	}

	queryParameters := map[string]interface{}{
		"api_version": autorest.Encode("query", APIVersion),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paging/multiple/fragment/{tenant}/{nextLink}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// NextFragmentSender sends the NextFragment request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) NextFragmentSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// NextFragmentResponder handles the response to the NextFragment request. The method always
// closes the http.Response Body.
func (client PagingClient) NextFragmentResponder(resp *http.Response) (result OdataProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// NextFragmentWithGrouping a paging operation that doesn't return a full URL, just a fragment
// Parameters:
// APIVersion - sets the api version to use.
// tenant - sets the tenant to use.
// nextLink - next link for list operation.
func (client PagingClient) NextFragmentWithGrouping(ctx context.Context, APIVersion string, tenant string, nextLink string) (result OdataProductResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PagingClient.NextFragmentWithGrouping")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.NextFragmentWithGroupingPreparer(ctx, APIVersion, tenant, nextLink)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "NextFragmentWithGrouping", nil, "Failure preparing request")
		return
	}

	resp, err := client.NextFragmentWithGroupingSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "NextFragmentWithGrouping", resp, "Failure sending request")
		return
	}

	result, err = client.NextFragmentWithGroupingResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "paginggroup.PagingClient", "NextFragmentWithGrouping", resp, "Failure responding to request")
		return
	}

	return
}

// NextFragmentWithGroupingPreparer prepares the NextFragmentWithGrouping request.
func (client PagingClient) NextFragmentWithGroupingPreparer(ctx context.Context, APIVersion string, tenant string, nextLink string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nextLink": nextLink,
		"tenant":   autorest.Encode("path", tenant),
	}

	queryParameters := map[string]interface{}{
		"api_version": autorest.Encode("query", APIVersion),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// NextFragmentWithGroupingSender sends the NextFragmentWithGrouping request. The method will close the
// http.Response Body if it receives an error.
func (client PagingClient) NextFragmentWithGroupingSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// NextFragmentWithGroupingResponder handles the response to the NextFragmentWithGrouping request. The method always
// closes the http.Response Body.
func (client PagingClient) NextFragmentWithGroupingResponder(resp *http.Response) (result OdataProductResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
