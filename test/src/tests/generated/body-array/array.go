package arraygroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"github.com/Azure/azure-pipeline-go/pipeline"
	uuid "github.com/satori/go.uuid"
	"io"
	"io/ioutil"
	"net/http"
	"time"
)

// ArrayClient is the test Infrastructure for AutoRest Swagger BAT
type ArrayClient struct {
	ManagementClient
}

// NewArrayClient creates an instance of the ArrayClient client.
func NewArrayClient(p pipeline.Pipeline) ArrayClient {
	return ArrayClient{NewManagementClient(p)}
}

// GetArrayEmpty get an empty array []
func (client ArrayClient) GetArrayEmpty(ctx context.Context) (*GetArrayEmptyResponse, error) {
	req, err := client.getArrayEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getArrayEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetArrayEmptyResponse), err
}

// getArrayEmptyPreparer prepares the GetArrayEmpty request.
func (client ArrayClient) getArrayEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/array/empty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getArrayEmptyResponder handles the response to the GetArrayEmpty request.
func (client ArrayClient) getArrayEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetArrayEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetArrayItemEmpty get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
func (client ArrayClient) GetArrayItemEmpty(ctx context.Context) (*GetArrayItemEmptyResponse, error) {
	req, err := client.getArrayItemEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getArrayItemEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetArrayItemEmptyResponse), err
}

// getArrayItemEmptyPreparer prepares the GetArrayItemEmpty request.
func (client ArrayClient) getArrayItemEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/array/itemempty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getArrayItemEmptyResponder handles the response to the GetArrayItemEmpty request.
func (client ArrayClient) getArrayItemEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetArrayItemEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetArrayItemNull get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
func (client ArrayClient) GetArrayItemNull(ctx context.Context) (*GetArrayItemNullResponse, error) {
	req, err := client.getArrayItemNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getArrayItemNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetArrayItemNullResponse), err
}

// getArrayItemNullPreparer prepares the GetArrayItemNull request.
func (client ArrayClient) getArrayItemNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/array/itemnull"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getArrayItemNullResponder handles the response to the GetArrayItemNull request.
func (client ArrayClient) getArrayItemNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetArrayItemNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetArrayNull get a null array
func (client ArrayClient) GetArrayNull(ctx context.Context) (*GetArrayNullResponse, error) {
	req, err := client.getArrayNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getArrayNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetArrayNullResponse), err
}

// getArrayNullPreparer prepares the GetArrayNull request.
func (client ArrayClient) getArrayNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/array/null"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getArrayNullResponder handles the response to the GetArrayNull request.
func (client ArrayClient) getArrayNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetArrayNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetArrayValid get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
func (client ArrayClient) GetArrayValid(ctx context.Context) (*GetArrayValidResponse, error) {
	req, err := client.getArrayValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getArrayValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetArrayValidResponse), err
}

// getArrayValidPreparer prepares the GetArrayValid request.
func (client ArrayClient) getArrayValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/array/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getArrayValidResponder handles the response to the GetArrayValid request.
func (client ArrayClient) getArrayValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetArrayValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetBase64URL get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the
// items base64url encoded
func (client ArrayClient) GetBase64URL(ctx context.Context) (*GetBase64URLResponse, error) {
	req, err := client.getBase64URLPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getBase64URLResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetBase64URLResponse), err
}

// getBase64URLPreparer prepares the GetBase64URL request.
func (client ArrayClient) getBase64URLPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/base64url/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getBase64URLResponder handles the response to the GetBase64URL request.
func (client ArrayClient) getBase64URLResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetBase64URLResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetBooleanInvalidNull get boolean array value [true, null, false]
func (client ArrayClient) GetBooleanInvalidNull(ctx context.Context) (*GetBooleanInvalidNullResponse, error) {
	req, err := client.getBooleanInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getBooleanInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetBooleanInvalidNullResponse), err
}

// getBooleanInvalidNullPreparer prepares the GetBooleanInvalidNull request.
func (client ArrayClient) getBooleanInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/boolean/true.null.false"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getBooleanInvalidNullResponder handles the response to the GetBooleanInvalidNull request.
func (client ArrayClient) getBooleanInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetBooleanInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetBooleanInvalidString get boolean array value [true, 'boolean', false]
func (client ArrayClient) GetBooleanInvalidString(ctx context.Context) (*GetBooleanInvalidStringResponse, error) {
	req, err := client.getBooleanInvalidStringPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getBooleanInvalidStringResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetBooleanInvalidStringResponse), err
}

// getBooleanInvalidStringPreparer prepares the GetBooleanInvalidString request.
func (client ArrayClient) getBooleanInvalidStringPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/boolean/true.boolean.false"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getBooleanInvalidStringResponder handles the response to the GetBooleanInvalidString request.
func (client ArrayClient) getBooleanInvalidStringResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetBooleanInvalidStringResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetBooleanTfft get boolean array value [true, false, false, true]
func (client ArrayClient) GetBooleanTfft(ctx context.Context) (*GetBooleanTfftResponse, error) {
	req, err := client.getBooleanTfftPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getBooleanTfftResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetBooleanTfftResponse), err
}

// getBooleanTfftPreparer prepares the GetBooleanTfft request.
func (client ArrayClient) getBooleanTfftPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/boolean/tfft"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getBooleanTfftResponder handles the response to the GetBooleanTfft request.
func (client ArrayClient) getBooleanTfftResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetBooleanTfftResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetByteInvalidNull get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded
func (client ArrayClient) GetByteInvalidNull(ctx context.Context) (*GetByteInvalidNullResponse, error) {
	req, err := client.getByteInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getByteInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetByteInvalidNullResponse), err
}

// getByteInvalidNullPreparer prepares the GetByteInvalidNull request.
func (client ArrayClient) getByteInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/byte/invalidnull"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getByteInvalidNullResponder handles the response to the GetByteInvalidNull request.
func (client ArrayClient) getByteInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetByteInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetByteValid get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in
// base64
func (client ArrayClient) GetByteValid(ctx context.Context) (*GetByteValidResponse, error) {
	req, err := client.getByteValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getByteValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetByteValidResponse), err
}

// getByteValidPreparer prepares the GetByteValid request.
func (client ArrayClient) getByteValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/byte/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getByteValidResponder handles the response to the GetByteValid request.
func (client ArrayClient) getByteValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetByteValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetComplexEmpty get empty array of complex type []
func (client ArrayClient) GetComplexEmpty(ctx context.Context) (*GetComplexEmptyResponse, error) {
	req, err := client.getComplexEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getComplexEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetComplexEmptyResponse), err
}

// getComplexEmptyPreparer prepares the GetComplexEmpty request.
func (client ArrayClient) getComplexEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/complex/empty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getComplexEmptyResponder handles the response to the GetComplexEmpty request.
func (client ArrayClient) getComplexEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetComplexEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetComplexItemEmpty get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5,
// 'string': '6'}]
func (client ArrayClient) GetComplexItemEmpty(ctx context.Context) (*GetComplexItemEmptyResponse, error) {
	req, err := client.getComplexItemEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getComplexItemEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetComplexItemEmptyResponse), err
}

// getComplexItemEmptyPreparer prepares the GetComplexItemEmpty request.
func (client ArrayClient) getComplexItemEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/complex/itemempty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getComplexItemEmptyResponder handles the response to the GetComplexItemEmpty request.
func (client ArrayClient) getComplexItemEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetComplexItemEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetComplexItemNull get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5,
// 'string': '6'}]
func (client ArrayClient) GetComplexItemNull(ctx context.Context) (*GetComplexItemNullResponse, error) {
	req, err := client.getComplexItemNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getComplexItemNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetComplexItemNullResponse), err
}

// getComplexItemNullPreparer prepares the GetComplexItemNull request.
func (client ArrayClient) getComplexItemNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/complex/itemnull"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getComplexItemNullResponder handles the response to the GetComplexItemNull request.
func (client ArrayClient) getComplexItemNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetComplexItemNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetComplexNull get array of complex type null value
func (client ArrayClient) GetComplexNull(ctx context.Context) (*GetComplexNullResponse, error) {
	req, err := client.getComplexNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getComplexNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetComplexNullResponse), err
}

// getComplexNullPreparer prepares the GetComplexNull request.
func (client ArrayClient) getComplexNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/complex/null"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getComplexNullResponder handles the response to the GetComplexNull request.
func (client ArrayClient) getComplexNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetComplexNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetComplexValid get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'},
// {'integer': 5, 'string': '6'}]
func (client ArrayClient) GetComplexValid(ctx context.Context) (*GetComplexValidResponse, error) {
	req, err := client.getComplexValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getComplexValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetComplexValidResponse), err
}

// getComplexValidPreparer prepares the GetComplexValid request.
func (client ArrayClient) getComplexValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/complex/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getComplexValidResponder handles the response to the GetComplexValid request.
func (client ArrayClient) getComplexValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetComplexValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateInvalidChars get date array value ['2011-03-22', 'date']
func (client ArrayClient) GetDateInvalidChars(ctx context.Context) (*GetDateInvalidCharsResponse, error) {
	req, err := client.getDateInvalidCharsPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateInvalidCharsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateInvalidCharsResponse), err
}

// getDateInvalidCharsPreparer prepares the GetDateInvalidChars request.
func (client ArrayClient) getDateInvalidCharsPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date/invalidchars"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateInvalidCharsResponder handles the response to the GetDateInvalidChars request.
func (client ArrayClient) getDateInvalidCharsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateInvalidCharsResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateInvalidNull get date array value ['2012-01-01', null, '1776-07-04']
func (client ArrayClient) GetDateInvalidNull(ctx context.Context) (*GetDateInvalidNullResponse, error) {
	req, err := client.getDateInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateInvalidNullResponse), err
}

// getDateInvalidNullPreparer prepares the GetDateInvalidNull request.
func (client ArrayClient) getDateInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date/invalidnull"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateInvalidNullResponder handles the response to the GetDateInvalidNull request.
func (client ArrayClient) getDateInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateTimeInvalidChars get date array value ['2000-12-01t00:00:01z', 'date-time']
func (client ArrayClient) GetDateTimeInvalidChars(ctx context.Context) (*GetDateTimeInvalidCharsResponse, error) {
	req, err := client.getDateTimeInvalidCharsPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateTimeInvalidCharsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateTimeInvalidCharsResponse), err
}

// getDateTimeInvalidCharsPreparer prepares the GetDateTimeInvalidChars request.
func (client ArrayClient) getDateTimeInvalidCharsPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date-time/invalidchars"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateTimeInvalidCharsResponder handles the response to the GetDateTimeInvalidChars request.
func (client ArrayClient) getDateTimeInvalidCharsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateTimeInvalidCharsResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateTimeInvalidNull get date array value ['2000-12-01t00:00:01z', null]
func (client ArrayClient) GetDateTimeInvalidNull(ctx context.Context) (*GetDateTimeInvalidNullResponse, error) {
	req, err := client.getDateTimeInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateTimeInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateTimeInvalidNullResponse), err
}

// getDateTimeInvalidNullPreparer prepares the GetDateTimeInvalidNull request.
func (client ArrayClient) getDateTimeInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date-time/invalidnull"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateTimeInvalidNullResponder handles the response to the GetDateTimeInvalidNull request.
func (client ArrayClient) getDateTimeInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateTimeInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateTimeRfc1123Valid get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT',
// 'Wed, 12 Oct 1492 10:15:01 GMT']
func (client ArrayClient) GetDateTimeRfc1123Valid(ctx context.Context) (*GetDateTimeRfc1123ValidResponse, error) {
	req, err := client.getDateTimeRfc1123ValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateTimeRfc1123ValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateTimeRfc1123ValidResponse), err
}

// getDateTimeRfc1123ValidPreparer prepares the GetDateTimeRfc1123Valid request.
func (client ArrayClient) getDateTimeRfc1123ValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date-time-rfc1123/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateTimeRfc1123ValidResponder handles the response to the GetDateTimeRfc1123Valid request.
func (client ArrayClient) getDateTimeRfc1123ValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateTimeRfc1123ValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateTimeValid get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00',
// '1492-10-12T10:15:01-08:00']
func (client ArrayClient) GetDateTimeValid(ctx context.Context) (*GetDateTimeValidResponse, error) {
	req, err := client.getDateTimeValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateTimeValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateTimeValidResponse), err
}

// getDateTimeValidPreparer prepares the GetDateTimeValid request.
func (client ArrayClient) getDateTimeValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date-time/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateTimeValidResponder handles the response to the GetDateTimeValid request.
func (client ArrayClient) getDateTimeValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateTimeValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDateValid get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
func (client ArrayClient) GetDateValid(ctx context.Context) (*GetDateValidResponse, error) {
	req, err := client.getDateValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDateValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDateValidResponse), err
}

// getDateValidPreparer prepares the GetDateValid request.
func (client ArrayClient) getDateValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDateValidResponder handles the response to the GetDateValid request.
func (client ArrayClient) getDateValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDateValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDictionaryEmpty get an array of Dictionaries of type <string, string> with value []
func (client ArrayClient) GetDictionaryEmpty(ctx context.Context) (*GetDictionaryEmptyResponse, error) {
	req, err := client.getDictionaryEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDictionaryEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDictionaryEmptyResponse), err
}

// getDictionaryEmptyPreparer prepares the GetDictionaryEmpty request.
func (client ArrayClient) getDictionaryEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/dictionary/empty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDictionaryEmptyResponder handles the response to the GetDictionaryEmpty request.
func (client ArrayClient) getDictionaryEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDictionaryEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDictionaryItemEmpty get an array of Dictionaries of type <string, string> with value [{'1': 'one', '2': 'two',
// '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
func (client ArrayClient) GetDictionaryItemEmpty(ctx context.Context) (*GetDictionaryItemEmptyResponse, error) {
	req, err := client.getDictionaryItemEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDictionaryItemEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDictionaryItemEmptyResponse), err
}

// getDictionaryItemEmptyPreparer prepares the GetDictionaryItemEmpty request.
func (client ArrayClient) getDictionaryItemEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/dictionary/itemempty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDictionaryItemEmptyResponder handles the response to the GetDictionaryItemEmpty request.
func (client ArrayClient) getDictionaryItemEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDictionaryItemEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDictionaryItemNull get an array of Dictionaries of type <string, string> with value [{'1': 'one', '2': 'two',
// '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}]
func (client ArrayClient) GetDictionaryItemNull(ctx context.Context) (*GetDictionaryItemNullResponse, error) {
	req, err := client.getDictionaryItemNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDictionaryItemNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDictionaryItemNullResponse), err
}

// getDictionaryItemNullPreparer prepares the GetDictionaryItemNull request.
func (client ArrayClient) getDictionaryItemNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/dictionary/itemnull"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDictionaryItemNullResponder handles the response to the GetDictionaryItemNull request.
func (client ArrayClient) getDictionaryItemNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDictionaryItemNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDictionaryNull get an array of Dictionaries with value null
func (client ArrayClient) GetDictionaryNull(ctx context.Context) (*GetDictionaryNullResponse, error) {
	req, err := client.getDictionaryNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDictionaryNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDictionaryNullResponse), err
}

// getDictionaryNullPreparer prepares the GetDictionaryNull request.
func (client ArrayClient) getDictionaryNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/dictionary/null"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDictionaryNullResponder handles the response to the GetDictionaryNull request.
func (client ArrayClient) getDictionaryNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDictionaryNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDictionaryValid get an array of Dictionaries of type <string, string> with value [{'1': 'one', '2': 'two', '3':
// 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
func (client ArrayClient) GetDictionaryValid(ctx context.Context) (*GetDictionaryValidResponse, error) {
	req, err := client.getDictionaryValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDictionaryValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDictionaryValidResponse), err
}

// getDictionaryValidPreparer prepares the GetDictionaryValid request.
func (client ArrayClient) getDictionaryValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/dictionary/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDictionaryValidResponder handles the response to the GetDictionaryValid request.
func (client ArrayClient) getDictionaryValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDictionaryValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDoubleInvalidNull get float array value [0.0, null, -1.2e20]
func (client ArrayClient) GetDoubleInvalidNull(ctx context.Context) (*GetDoubleInvalidNullResponse, error) {
	req, err := client.getDoubleInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDoubleInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDoubleInvalidNullResponse), err
}

// getDoubleInvalidNullPreparer prepares the GetDoubleInvalidNull request.
func (client ArrayClient) getDoubleInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/double/0.0-null-1.2e20"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDoubleInvalidNullResponder handles the response to the GetDoubleInvalidNull request.
func (client ArrayClient) getDoubleInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDoubleInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDoubleInvalidString get boolean array value [1.0, 'number', 0.0]
func (client ArrayClient) GetDoubleInvalidString(ctx context.Context) (*GetDoubleInvalidStringResponse, error) {
	req, err := client.getDoubleInvalidStringPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDoubleInvalidStringResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDoubleInvalidStringResponse), err
}

// getDoubleInvalidStringPreparer prepares the GetDoubleInvalidString request.
func (client ArrayClient) getDoubleInvalidStringPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/double/1.number.0"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDoubleInvalidStringResponder handles the response to the GetDoubleInvalidString request.
func (client ArrayClient) getDoubleInvalidStringResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDoubleInvalidStringResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDoubleValid get float array value [0, -0.01, 1.2e20]
func (client ArrayClient) GetDoubleValid(ctx context.Context) (*GetDoubleValidResponse, error) {
	req, err := client.getDoubleValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDoubleValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDoubleValidResponse), err
}

// getDoubleValidPreparer prepares the GetDoubleValid request.
func (client ArrayClient) getDoubleValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/double/0--0.01-1.2e20"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDoubleValidResponder handles the response to the GetDoubleValid request.
func (client ArrayClient) getDoubleValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDoubleValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDurationValid get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
func (client ArrayClient) GetDurationValid(ctx context.Context) (*GetDurationValidResponse, error) {
	req, err := client.getDurationValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDurationValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetDurationValidResponse), err
}

// getDurationValidPreparer prepares the GetDurationValid request.
func (client ArrayClient) getDurationValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/duration/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDurationValidResponder handles the response to the GetDurationValid request.
func (client ArrayClient) getDurationValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetDurationValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetEmpty get empty array value []
func (client ArrayClient) GetEmpty(ctx context.Context) (*GetEmptyResponse, error) {
	req, err := client.getEmptyPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetEmptyResponse), err
}

// getEmptyPreparer prepares the GetEmpty request.
func (client ArrayClient) getEmptyPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/empty"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getEmptyResponder handles the response to the GetEmpty request.
func (client ArrayClient) getEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetEmptyResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetEnumValid get enum array value ['foo1', 'foo2', 'foo3']
func (client ArrayClient) GetEnumValid(ctx context.Context) (*GetEnumValidResponse, error) {
	req, err := client.getEnumValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getEnumValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetEnumValidResponse), err
}

// getEnumValidPreparer prepares the GetEnumValid request.
func (client ArrayClient) getEnumValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/enum/foo1.foo2.foo3"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getEnumValidResponder handles the response to the GetEnumValid request.
func (client ArrayClient) getEnumValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetEnumValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetFloatInvalidNull get float array value [0.0, null, -1.2e20]
func (client ArrayClient) GetFloatInvalidNull(ctx context.Context) (*GetFloatInvalidNullResponse, error) {
	req, err := client.getFloatInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getFloatInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetFloatInvalidNullResponse), err
}

// getFloatInvalidNullPreparer prepares the GetFloatInvalidNull request.
func (client ArrayClient) getFloatInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/float/0.0-null-1.2e20"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getFloatInvalidNullResponder handles the response to the GetFloatInvalidNull request.
func (client ArrayClient) getFloatInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetFloatInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetFloatInvalidString get boolean array value [1.0, 'number', 0.0]
func (client ArrayClient) GetFloatInvalidString(ctx context.Context) (*GetFloatInvalidStringResponse, error) {
	req, err := client.getFloatInvalidStringPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getFloatInvalidStringResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetFloatInvalidStringResponse), err
}

// getFloatInvalidStringPreparer prepares the GetFloatInvalidString request.
func (client ArrayClient) getFloatInvalidStringPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/float/1.number.0"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getFloatInvalidStringResponder handles the response to the GetFloatInvalidString request.
func (client ArrayClient) getFloatInvalidStringResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetFloatInvalidStringResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetFloatValid get float array value [0, -0.01, 1.2e20]
func (client ArrayClient) GetFloatValid(ctx context.Context) (*GetFloatValidResponse, error) {
	req, err := client.getFloatValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getFloatValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetFloatValidResponse), err
}

// getFloatValidPreparer prepares the GetFloatValid request.
func (client ArrayClient) getFloatValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/float/0--0.01-1.2e20"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getFloatValidResponder handles the response to the GetFloatValid request.
func (client ArrayClient) getFloatValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetFloatValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetIntegerValid get integer array value [1, -1, 3, 300]
func (client ArrayClient) GetIntegerValid(ctx context.Context) (*GetIntegerValidResponse, error) {
	req, err := client.getIntegerValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getIntegerValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetIntegerValidResponse), err
}

// getIntegerValidPreparer prepares the GetIntegerValid request.
func (client ArrayClient) getIntegerValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/integer/1.-1.3.300"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getIntegerValidResponder handles the response to the GetIntegerValid request.
func (client ArrayClient) getIntegerValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetIntegerValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetIntInvalidNull get integer array value [1, null, 0]
func (client ArrayClient) GetIntInvalidNull(ctx context.Context) (*GetIntInvalidNullResponse, error) {
	req, err := client.getIntInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getIntInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetIntInvalidNullResponse), err
}

// getIntInvalidNullPreparer prepares the GetIntInvalidNull request.
func (client ArrayClient) getIntInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/integer/1.null.zero"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getIntInvalidNullResponder handles the response to the GetIntInvalidNull request.
func (client ArrayClient) getIntInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetIntInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetIntInvalidString get integer array value [1, 'integer', 0]
func (client ArrayClient) GetIntInvalidString(ctx context.Context) (*GetIntInvalidStringResponse, error) {
	req, err := client.getIntInvalidStringPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getIntInvalidStringResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetIntInvalidStringResponse), err
}

// getIntInvalidStringPreparer prepares the GetIntInvalidString request.
func (client ArrayClient) getIntInvalidStringPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/integer/1.integer.0"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getIntInvalidStringResponder handles the response to the GetIntInvalidString request.
func (client ArrayClient) getIntInvalidStringResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetIntInvalidStringResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetInvalid get invalid array [1, 2, 3
func (client ArrayClient) GetInvalid(ctx context.Context) (*GetInvalidResponse, error) {
	req, err := client.getInvalidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getInvalidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetInvalidResponse), err
}

// getInvalidPreparer prepares the GetInvalid request.
func (client ArrayClient) getInvalidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/invalid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getInvalidResponder handles the response to the GetInvalid request.
func (client ArrayClient) getInvalidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetInvalidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetLongInvalidNull get long array value [1, null, 0]
func (client ArrayClient) GetLongInvalidNull(ctx context.Context) (*GetLongInvalidNullResponse, error) {
	req, err := client.getLongInvalidNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getLongInvalidNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetLongInvalidNullResponse), err
}

// getLongInvalidNullPreparer prepares the GetLongInvalidNull request.
func (client ArrayClient) getLongInvalidNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/long/1.null.zero"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getLongInvalidNullResponder handles the response to the GetLongInvalidNull request.
func (client ArrayClient) getLongInvalidNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetLongInvalidNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetLongInvalidString get long array value [1, 'integer', 0]
func (client ArrayClient) GetLongInvalidString(ctx context.Context) (*GetLongInvalidStringResponse, error) {
	req, err := client.getLongInvalidStringPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getLongInvalidStringResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetLongInvalidStringResponse), err
}

// getLongInvalidStringPreparer prepares the GetLongInvalidString request.
func (client ArrayClient) getLongInvalidStringPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/long/1.integer.0"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getLongInvalidStringResponder handles the response to the GetLongInvalidString request.
func (client ArrayClient) getLongInvalidStringResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetLongInvalidStringResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetLongValid get integer array value [1, -1, 3, 300]
func (client ArrayClient) GetLongValid(ctx context.Context) (*GetLongValidResponse, error) {
	req, err := client.getLongValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getLongValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetLongValidResponse), err
}

// getLongValidPreparer prepares the GetLongValid request.
func (client ArrayClient) getLongValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/long/1.-1.3.300"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getLongValidResponder handles the response to the GetLongValid request.
func (client ArrayClient) getLongValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetLongValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetNull get null array value
func (client ArrayClient) GetNull(ctx context.Context) (*GetNullResponse, error) {
	req, err := client.getNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetNullResponse), err
}

// getNullPreparer prepares the GetNull request.
func (client ArrayClient) getNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/null"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getNullResponder handles the response to the GetNull request.
func (client ArrayClient) getNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetStringEnumValid get enum array value ['foo1', 'foo2', 'foo3']
func (client ArrayClient) GetStringEnumValid(ctx context.Context) (*GetStringEnumValidResponse, error) {
	req, err := client.getStringEnumValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getStringEnumValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetStringEnumValidResponse), err
}

// getStringEnumValidPreparer prepares the GetStringEnumValid request.
func (client ArrayClient) getStringEnumValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/string-enum/foo1.foo2.foo3"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getStringEnumValidResponder handles the response to the GetStringEnumValid request.
func (client ArrayClient) getStringEnumValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetStringEnumValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetStringValid get string array value ['foo1', 'foo2', 'foo3']
func (client ArrayClient) GetStringValid(ctx context.Context) (*GetStringValidResponse, error) {
	req, err := client.getStringValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getStringValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetStringValidResponse), err
}

// getStringValidPreparer prepares the GetStringValid request.
func (client ArrayClient) getStringValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/string/foo1.foo2.foo3"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getStringValidResponder handles the response to the GetStringValid request.
func (client ArrayClient) getStringValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetStringValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetStringWithInvalid get string array value ['foo', 123, 'foo2']
func (client ArrayClient) GetStringWithInvalid(ctx context.Context) (*GetStringWithInvalidResponse, error) {
	req, err := client.getStringWithInvalidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getStringWithInvalidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetStringWithInvalidResponse), err
}

// getStringWithInvalidPreparer prepares the GetStringWithInvalid request.
func (client ArrayClient) getStringWithInvalidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/string/foo.123.foo2"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getStringWithInvalidResponder handles the response to the GetStringWithInvalid request.
func (client ArrayClient) getStringWithInvalidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetStringWithInvalidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetStringWithNull get string array value ['foo', null, 'foo2']
func (client ArrayClient) GetStringWithNull(ctx context.Context) (*GetStringWithNullResponse, error) {
	req, err := client.getStringWithNullPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getStringWithNullResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetStringWithNullResponse), err
}

// getStringWithNullPreparer prepares the GetStringWithNull request.
func (client ArrayClient) getStringWithNullPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/string/foo.null.foo2"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getStringWithNullResponder handles the response to the GetStringWithNull request.
func (client ArrayClient) getStringWithNullResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetStringWithNullResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetUUIDInvalidChars get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo']
func (client ArrayClient) GetUUIDInvalidChars(ctx context.Context) (*GetUUIDInvalidCharsResponse, error) {
	req, err := client.getUUIDInvalidCharsPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getUUIDInvalidCharsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetUUIDInvalidCharsResponse), err
}

// getUUIDInvalidCharsPreparer prepares the GetUUIDInvalidChars request.
func (client ArrayClient) getUUIDInvalidCharsPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/uuid/invalidchars"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getUUIDInvalidCharsResponder handles the response to the GetUUIDInvalidChars request.
func (client ArrayClient) getUUIDInvalidCharsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetUUIDInvalidCharsResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetUUIDValid get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
// 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
func (client ArrayClient) GetUUIDValid(ctx context.Context) (*GetUUIDValidResponse, error) {
	req, err := client.getUUIDValidPreparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getUUIDValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetUUIDValidResponse), err
}

// getUUIDValidPreparer prepares the GetUUIDValid request.
func (client ArrayClient) getUUIDValidPreparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/uuid/valid"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getUUIDValidResponder handles the response to the GetUUIDValid request.
func (client ArrayClient) getUUIDValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &GetUUIDValidResponse{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, &result.Items)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// PutArrayValid put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
//
func (client ArrayClient) PutArrayValid(ctx context.Context, arrayBody [][]string) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putArrayValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putArrayValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putArrayValidPreparer prepares the PutArrayValid request.
func (client ArrayClient) putArrayValidPreparer(arrayBody [][]string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/array/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putArrayValidResponder handles the response to the PutArrayValid request.
func (client ArrayClient) putArrayValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutBooleanTfft set array value empty [true, false, false, true]
//
func (client ArrayClient) PutBooleanTfft(ctx context.Context, arrayBody []bool) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putBooleanTfftPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putBooleanTfftResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putBooleanTfftPreparer prepares the PutBooleanTfft request.
func (client ArrayClient) putBooleanTfftPreparer(arrayBody []bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/boolean/tfft"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putBooleanTfftResponder handles the response to the PutBooleanTfft request.
func (client ArrayClient) putBooleanTfftResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutByteValid put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in
// base 64
//
func (client ArrayClient) PutByteValid(ctx context.Context, arrayBody [][]byte) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putByteValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putByteValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putByteValidPreparer prepares the PutByteValid request.
func (client ArrayClient) putByteValidPreparer(arrayBody [][]byte) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/byte/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putByteValidResponder handles the response to the PutByteValid request.
func (client ArrayClient) putByteValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutComplexValid put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string':
// '4'}, {'integer': 5, 'string': '6'}]
//
func (client ArrayClient) PutComplexValid(ctx context.Context, arrayBody []Product) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putComplexValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putComplexValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putComplexValidPreparer prepares the PutComplexValid request.
func (client ArrayClient) putComplexValidPreparer(arrayBody []Product) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/complex/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putComplexValidResponder handles the response to the PutComplexValid request.
func (client ArrayClient) putComplexValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutDateTimeRfc1123Valid set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12
// Oct 1492 10:15:01 GMT']
//
func (client ArrayClient) PutDateTimeRfc1123Valid(ctx context.Context, arrayBody []time.Time) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putDateTimeRfc1123ValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putDateTimeRfc1123ValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putDateTimeRfc1123ValidPreparer prepares the PutDateTimeRfc1123Valid request.
func (client ArrayClient) putDateTimeRfc1123ValidPreparer(arrayBody []time.Time) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date-time-rfc1123/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putDateTimeRfc1123ValidResponder handles the response to the PutDateTimeRfc1123Valid request.
func (client ArrayClient) putDateTimeRfc1123ValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutDateTimeValid set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
//
func (client ArrayClient) PutDateTimeValid(ctx context.Context, arrayBody []time.Time) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putDateTimeValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putDateTimeValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putDateTimeValidPreparer prepares the PutDateTimeValid request.
func (client ArrayClient) putDateTimeValidPreparer(arrayBody []time.Time) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date-time/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putDateTimeValidResponder handles the response to the PutDateTimeValid request.
func (client ArrayClient) putDateTimeValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutDateValid set array value  ['2000-12-01', '1980-01-02', '1492-10-12']
//
func (client ArrayClient) PutDateValid(ctx context.Context, arrayBody []time.Time) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putDateValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putDateValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putDateValidPreparer prepares the PutDateValid request.
func (client ArrayClient) putDateValidPreparer(arrayBody []time.Time) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/date/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putDateValidResponder handles the response to the PutDateValid request.
func (client ArrayClient) putDateValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutDictionaryValid get an array of Dictionaries of type <string, string> with value [{'1': 'one', '2': 'two', '3':
// 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
//
func (client ArrayClient) PutDictionaryValid(ctx context.Context, arrayBody []map[string]string) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putDictionaryValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putDictionaryValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putDictionaryValidPreparer prepares the PutDictionaryValid request.
func (client ArrayClient) putDictionaryValidPreparer(arrayBody []map[string]string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/dictionary/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putDictionaryValidResponder handles the response to the PutDictionaryValid request.
func (client ArrayClient) putDictionaryValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutDoubleValid set array value [0, -0.01, 1.2e20]
//
func (client ArrayClient) PutDoubleValid(ctx context.Context, arrayBody []float64) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putDoubleValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putDoubleValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putDoubleValidPreparer prepares the PutDoubleValid request.
func (client ArrayClient) putDoubleValidPreparer(arrayBody []float64) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/double/0--0.01-1.2e20"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putDoubleValidResponder handles the response to the PutDoubleValid request.
func (client ArrayClient) putDoubleValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutDurationValid set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S']
//
func (client ArrayClient) PutDurationValid(ctx context.Context, arrayBody []string) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putDurationValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putDurationValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putDurationValidPreparer prepares the PutDurationValid request.
func (client ArrayClient) putDurationValidPreparer(arrayBody []string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/duration/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putDurationValidResponder handles the response to the PutDurationValid request.
func (client ArrayClient) putDurationValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutEmpty set array value empty []
//
func (client ArrayClient) PutEmpty(ctx context.Context, arrayBody []string) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putEmptyPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putEmptyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putEmptyPreparer prepares the PutEmpty request.
func (client ArrayClient) putEmptyPreparer(arrayBody []string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/empty"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putEmptyResponder handles the response to the PutEmpty request.
func (client ArrayClient) putEmptyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutEnumValid set array value ['foo1', 'foo2', 'foo3']
//
func (client ArrayClient) PutEnumValid(ctx context.Context, arrayBody []FooEnumType) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putEnumValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putEnumValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putEnumValidPreparer prepares the PutEnumValid request.
func (client ArrayClient) putEnumValidPreparer(arrayBody []FooEnumType) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/enum/foo1.foo2.foo3"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putEnumValidResponder handles the response to the PutEnumValid request.
func (client ArrayClient) putEnumValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutFloatValid set array value [0, -0.01, 1.2e20]
//
func (client ArrayClient) PutFloatValid(ctx context.Context, arrayBody []float64) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putFloatValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putFloatValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putFloatValidPreparer prepares the PutFloatValid request.
func (client ArrayClient) putFloatValidPreparer(arrayBody []float64) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/float/0--0.01-1.2e20"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putFloatValidResponder handles the response to the PutFloatValid request.
func (client ArrayClient) putFloatValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutIntegerValid set array value empty [1, -1, 3, 300]
//
func (client ArrayClient) PutIntegerValid(ctx context.Context, arrayBody []int32) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putIntegerValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putIntegerValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putIntegerValidPreparer prepares the PutIntegerValid request.
func (client ArrayClient) putIntegerValidPreparer(arrayBody []int32) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/integer/1.-1.3.300"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putIntegerValidResponder handles the response to the PutIntegerValid request.
func (client ArrayClient) putIntegerValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutLongValid set array value empty [1, -1, 3, 300]
//
func (client ArrayClient) PutLongValid(ctx context.Context, arrayBody []int64) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putLongValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putLongValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putLongValidPreparer prepares the PutLongValid request.
func (client ArrayClient) putLongValidPreparer(arrayBody []int64) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/long/1.-1.3.300"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putLongValidResponder handles the response to the PutLongValid request.
func (client ArrayClient) putLongValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutStringEnumValid set array value ['foo1', 'foo2', 'foo3']
//
func (client ArrayClient) PutStringEnumValid(ctx context.Context, arrayBody []string) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putStringEnumValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putStringEnumValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putStringEnumValidPreparer prepares the PutStringEnumValid request.
func (client ArrayClient) putStringEnumValidPreparer(arrayBody []string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/string-enum/foo1.foo2.foo3"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putStringEnumValidResponder handles the response to the PutStringEnumValid request.
func (client ArrayClient) putStringEnumValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutStringValid set array value ['foo1', 'foo2', 'foo3']
//
func (client ArrayClient) PutStringValid(ctx context.Context, arrayBody []string) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putStringValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putStringValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putStringValidPreparer prepares the PutStringValid request.
func (client ArrayClient) putStringValidPreparer(arrayBody []string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/string/foo1.foo2.foo3"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putStringValidResponder handles the response to the PutStringValid request.
func (client ArrayClient) putStringValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}

// PutUUIDValid set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db',
// 'f42f6aa1-a5bc-4ddf-907e-5f915de43205']
//
func (client ArrayClient) PutUUIDValid(ctx context.Context, arrayBody []uuid.UUID) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: arrayBody,
			constraints: []constraint{{target: "arrayBody", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.putUUIDValidPreparer(arrayBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.putUUIDValidResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// putUUIDValidPreparer prepares the PutUUIDValid request.
func (client ArrayClient) putUUIDValidPreparer(arrayBody []uuid.UUID) (pipeline.Request, error) {
	u := client.url
	u.Path = "/array/prim/uuid/valid"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(arrayBody)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// putUUIDValidResponder handles the response to the PutUUIDValid request.
func (client ArrayClient) putUUIDValidResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return resp, err
}
