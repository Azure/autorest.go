package httpinfrastructuregroup

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"tests/pipeline"
)

// HTTPClientFailureClient is the test Infrastructure for AutoRest
type HTTPClientFailureClient struct {
	ManagementClient
}

// NewHTTPClientFailureClient creates an instance of the HTTPClientFailureClient client.
func NewHTTPClientFailureClient(p pipeline.Pipeline) HTTPClientFailureClient {
	return HTTPClientFailureClient{NewManagementClient(p)}
}

// Delete400 return 400 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Delete400(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.delete400Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.delete400Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// delete400Preparer prepares the Delete400 request.
func (client HTTPClientFailureClient) delete400Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/400"
	req, err := pipeline.NewRequest("DELETE", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// delete400Responder handles the response to the Delete400 request.
func (client HTTPClientFailureClient) delete400Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Delete407 return 407 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Delete407(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.delete407Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.delete407Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// delete407Preparer prepares the Delete407 request.
func (client HTTPClientFailureClient) delete407Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/407"
	req, err := pipeline.NewRequest("DELETE", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// delete407Responder handles the response to the Delete407 request.
func (client HTTPClientFailureClient) delete407Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Delete417 return 417 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Delete417(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.delete417Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.delete417Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// delete417Preparer prepares the Delete417 request.
func (client HTTPClientFailureClient) delete417Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/417"
	req, err := pipeline.NewRequest("DELETE", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// delete417Responder handles the response to the Delete417 request.
func (client HTTPClientFailureClient) delete417Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Get400 return 400 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Get400(ctx context.Context) (*Error, error) {
	req, err := client.get400Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.get400Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// get400Preparer prepares the Get400 request.
func (client HTTPClientFailureClient) get400Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/400"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// get400Responder handles the response to the Get400 request.
func (client HTTPClientFailureClient) get400Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Get402 return 402 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Get402(ctx context.Context) (*Error, error) {
	req, err := client.get402Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.get402Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// get402Preparer prepares the Get402 request.
func (client HTTPClientFailureClient) get402Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/402"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// get402Responder handles the response to the Get402 request.
func (client HTTPClientFailureClient) get402Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Get403 return 403 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Get403(ctx context.Context) (*Error, error) {
	req, err := client.get403Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.get403Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// get403Preparer prepares the Get403 request.
func (client HTTPClientFailureClient) get403Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/403"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// get403Responder handles the response to the Get403 request.
func (client HTTPClientFailureClient) get403Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Get411 return 411 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Get411(ctx context.Context) (*Error, error) {
	req, err := client.get411Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.get411Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// get411Preparer prepares the Get411 request.
func (client HTTPClientFailureClient) get411Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/411"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// get411Responder handles the response to the Get411 request.
func (client HTTPClientFailureClient) get411Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Get412 return 412 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Get412(ctx context.Context) (*Error, error) {
	req, err := client.get412Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.get412Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// get412Preparer prepares the Get412 request.
func (client HTTPClientFailureClient) get412Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/412"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// get412Responder handles the response to the Get412 request.
func (client HTTPClientFailureClient) get412Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Get416 return 416 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Get416(ctx context.Context) (*Error, error) {
	req, err := client.get416Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.get416Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// get416Preparer prepares the Get416 request.
func (client HTTPClientFailureClient) get416Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/416"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// get416Responder handles the response to the Get416 request.
func (client HTTPClientFailureClient) get416Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Head400 return 400 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Head400(ctx context.Context) (*Error, error) {
	req, err := client.head400Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.head400Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// head400Preparer prepares the Head400 request.
func (client HTTPClientFailureClient) head400Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/400"
	req, err := pipeline.NewRequest("HEAD", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// head400Responder handles the response to the Head400 request.
func (client HTTPClientFailureClient) head400Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Head401 return 401 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Head401(ctx context.Context) (*Error, error) {
	req, err := client.head401Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.head401Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// head401Preparer prepares the Head401 request.
func (client HTTPClientFailureClient) head401Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/401"
	req, err := pipeline.NewRequest("HEAD", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// head401Responder handles the response to the Head401 request.
func (client HTTPClientFailureClient) head401Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Head410 return 410 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Head410(ctx context.Context) (*Error, error) {
	req, err := client.head410Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.head410Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// head410Preparer prepares the Head410 request.
func (client HTTPClientFailureClient) head410Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/410"
	req, err := pipeline.NewRequest("HEAD", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// head410Responder handles the response to the Head410 request.
func (client HTTPClientFailureClient) head410Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Head429 return 429 status code - should be represented in the client as an error
func (client HTTPClientFailureClient) Head429(ctx context.Context) (*Error, error) {
	req, err := client.head429Preparer()
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.head429Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// head429Preparer prepares the Head429 request.
func (client HTTPClientFailureClient) head429Preparer() (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/429"
	req, err := pipeline.NewRequest("HEAD", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// head429Responder handles the response to the Head429 request.
func (client HTTPClientFailureClient) head429Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Patch400 return 400 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Patch400(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.patch400Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.patch400Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// patch400Preparer prepares the Patch400 request.
func (client HTTPClientFailureClient) patch400Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/400"
	req, err := pipeline.NewRequest("PATCH", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// patch400Responder handles the response to the Patch400 request.
func (client HTTPClientFailureClient) patch400Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Patch405 return 405 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Patch405(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.patch405Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.patch405Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// patch405Preparer prepares the Patch405 request.
func (client HTTPClientFailureClient) patch405Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/405"
	req, err := pipeline.NewRequest("PATCH", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// patch405Responder handles the response to the Patch405 request.
func (client HTTPClientFailureClient) patch405Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Patch414 return 414 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Patch414(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.patch414Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.patch414Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// patch414Preparer prepares the Patch414 request.
func (client HTTPClientFailureClient) patch414Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/414"
	req, err := pipeline.NewRequest("PATCH", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// patch414Responder handles the response to the Patch414 request.
func (client HTTPClientFailureClient) patch414Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Post400 return 400 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Post400(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.post400Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.post400Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// post400Preparer prepares the Post400 request.
func (client HTTPClientFailureClient) post400Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/400"
	req, err := pipeline.NewRequest("POST", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// post400Responder handles the response to the Post400 request.
func (client HTTPClientFailureClient) post400Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Post406 return 406 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Post406(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.post406Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.post406Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// post406Preparer prepares the Post406 request.
func (client HTTPClientFailureClient) post406Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/406"
	req, err := pipeline.NewRequest("POST", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// post406Responder handles the response to the Post406 request.
func (client HTTPClientFailureClient) post406Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Post415 return 415 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Post415(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.post415Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.post415Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// post415Preparer prepares the Post415 request.
func (client HTTPClientFailureClient) post415Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/415"
	req, err := pipeline.NewRequest("POST", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// post415Responder handles the response to the Post415 request.
func (client HTTPClientFailureClient) post415Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Put400 return 400 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Put400(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.put400Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.put400Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// put400Preparer prepares the Put400 request.
func (client HTTPClientFailureClient) put400Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/400"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// put400Responder handles the response to the Put400 request.
func (client HTTPClientFailureClient) put400Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Put404 return 404 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Put404(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.put404Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.put404Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// put404Preparer prepares the Put404 request.
func (client HTTPClientFailureClient) put404Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/404"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// put404Responder handles the response to the Put404 request.
func (client HTTPClientFailureClient) put404Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Put409 return 409 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Put409(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.put409Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.put409Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// put409Preparer prepares the Put409 request.
func (client HTTPClientFailureClient) put409Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/409"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// put409Responder handles the response to the Put409 request.
func (client HTTPClientFailureClient) put409Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Put413 return 413 status code - should be represented in the client as an error
//
// booleanValue is simple boolean value true
func (client HTTPClientFailureClient) Put413(ctx context.Context, booleanValue *bool) (*Error, error) {
	req, err := client.put413Preparer(booleanValue)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.put413Responder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*Error), err
}

// put413Preparer prepares the Put413 request.
func (client HTTPClientFailureClient) put413Preparer(booleanValue *bool) (pipeline.Request, error) {
	u := client.url
	u.Path = "/http/failure/client/413"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(booleanValue)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// put413Responder handles the response to the Put413 request.
func (client HTTPClientFailureClient) put413Responder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &Error{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}
