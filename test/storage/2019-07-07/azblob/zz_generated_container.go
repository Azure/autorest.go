// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/xml"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// ContainerOperations contains the methods for the Container group.
type ContainerOperations interface {
	// AcquireLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	AcquireLease(ctx context.Context, containerAcquireLeaseOptions *ContainerAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerAcquireLeaseResponse, error)
	// BreakLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	BreakLease(ctx context.Context, containerBreakLeaseOptions *ContainerBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerBreakLeaseResponse, error)
	// ChangeLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, containerChangeLeaseOptions *ContainerChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerChangeLeaseResponse, error)
	// Create - creates a new container under the specified account. If the container with the same name already exists, the operation fails
	Create(ctx context.Context, containerCreateOptions *ContainerCreateOptions, containerCpkScopeInfo *ContainerCpkScopeInfo) (*ContainerCreateResponse, error)
	// Delete - operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection
	Delete(ctx context.Context, containerDeleteOptions *ContainerDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerDeleteResponse, error)
	// GetAccessPolicy - gets the permissions for the specified container. The permissions indicate whether container data may be accessed publicly.
	GetAccessPolicy(ctx context.Context, containerGetAccessPolicyOptions *ContainerGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*SignedIDentifierArrayResponse, error)
	// GetAccountInfo - Returns the sku name and account kind
	GetAccountInfo(ctx context.Context) (*ContainerGetAccountInfoResponse, error)
	// GetProperties - returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs
	GetProperties(ctx context.Context, containerGetPropertiesOptions *ContainerGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*ContainerGetPropertiesResponse, error)
	// ListBlobFlatSegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
	ListBlobFlatSegment(containerListBlobFlatSegmentOptions *ContainerListBlobFlatSegmentOptions) (ListBlobsFlatSegmentResponsePager, error)
	// ListBlobHierarchySegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
	ListBlobHierarchySegment(delimiter string, containerListBlobHierarchySegmentOptions *ContainerListBlobHierarchySegmentOptions) (ListBlobsHierarchySegmentResponsePager, error)
	// ReleaseLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	ReleaseLease(ctx context.Context, leaseId string, containerReleaseLeaseOptions *ContainerReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerReleaseLeaseResponse, error)
	// RenewLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	RenewLease(ctx context.Context, leaseId string, containerRenewLeaseOptions *ContainerRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerRenewLeaseResponse, error)
	// SetAccessPolicy - sets the permissions for the specified container. The permissions indicate whether blobs in a container may be accessed publicly.
	SetAccessPolicy(ctx context.Context, containerSetAccessPolicyOptions *ContainerSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerSetAccessPolicyResponse, error)
	// SetMetadata - operation sets one or more user-defined name-value pairs for the specified container.
	SetMetadata(ctx context.Context, containerSetMetadataOptions *ContainerSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerSetMetadataResponse, error)
}

// ContainerClient implements the ContainerOperations interface.
// Don't use this type directly, use NewContainerClient() instead.
type ContainerClient struct {
	*client
}

// NewContainerClient creates a new instance of ContainerClient with the specified values.
func NewContainerClient(c *Client) ContainerOperations {
	return &ContainerClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *ContainerClient) Do(ctx context.Context, req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(ctx, req)
}

// AcquireLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *ContainerClient) AcquireLease(ctx context.Context, containerAcquireLeaseOptions *ContainerAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerAcquireLeaseResponse, error) {
	req, err := client.AcquireLeaseCreateRequest(containerAcquireLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.AcquireLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// AcquireLeaseCreateRequest creates the AcquireLease request.
func (client *ContainerClient) AcquireLeaseCreateRequest(containerAcquireLeaseOptions *ContainerAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if containerAcquireLeaseOptions != nil && containerAcquireLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerAcquireLeaseOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "acquire")
	if containerAcquireLeaseOptions != nil && containerAcquireLeaseOptions.Duration != nil {
		req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*containerAcquireLeaseOptions.Duration), 10))
	}
	if containerAcquireLeaseOptions != nil && containerAcquireLeaseOptions.ProposedLeaseId != nil {
		req.Header.Set("x-ms-proposed-lease-id", *containerAcquireLeaseOptions.ProposedLeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerAcquireLeaseOptions != nil && containerAcquireLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerAcquireLeaseOptions.RequestId)
	}
	return req, nil
}

// AcquireLeaseHandleResponse handles the AcquireLease response.
func (client *ContainerClient) AcquireLeaseHandleResponse(resp *azcore.Response) (*ContainerAcquireLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.AcquireLeaseHandleError(resp)
	}
	result := ContainerAcquireLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// AcquireLeaseHandleError handles the AcquireLease error response.
func (client *ContainerClient) AcquireLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// BreakLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *ContainerClient) BreakLease(ctx context.Context, containerBreakLeaseOptions *ContainerBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerBreakLeaseResponse, error) {
	req, err := client.BreakLeaseCreateRequest(containerBreakLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.BreakLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// BreakLeaseCreateRequest creates the BreakLease request.
func (client *ContainerClient) BreakLeaseCreateRequest(containerBreakLeaseOptions *ContainerBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if containerBreakLeaseOptions != nil && containerBreakLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerBreakLeaseOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "break")
	if containerBreakLeaseOptions != nil && containerBreakLeaseOptions.BreakPeriod != nil {
		req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*containerBreakLeaseOptions.BreakPeriod), 10))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerBreakLeaseOptions != nil && containerBreakLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerBreakLeaseOptions.RequestId)
	}
	return req, nil
}

// BreakLeaseHandleResponse handles the BreakLease response.
func (client *ContainerClient) BreakLeaseHandleResponse(resp *azcore.Response) (*ContainerBreakLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.BreakLeaseHandleError(resp)
	}
	result := ContainerBreakLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-time"); val != "" {
		leaseTime32, err := strconv.ParseInt(val, 10, 32)
		leaseTime := int32(leaseTime32)
		if err != nil {
			return nil, err
		}
		result.LeaseTime = &leaseTime
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// BreakLeaseHandleError handles the BreakLease error response.
func (client *ContainerClient) BreakLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// ChangeLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *ContainerClient) ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, containerChangeLeaseOptions *ContainerChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerChangeLeaseResponse, error) {
	req, err := client.ChangeLeaseCreateRequest(leaseId, proposedLeaseId, containerChangeLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.ChangeLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ChangeLeaseCreateRequest creates the ChangeLease request.
func (client *ContainerClient) ChangeLeaseCreateRequest(leaseId string, proposedLeaseId string, containerChangeLeaseOptions *ContainerChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if containerChangeLeaseOptions != nil && containerChangeLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerChangeLeaseOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "change")
	req.Header.Set("x-ms-lease-id", leaseId)
	req.Header.Set("x-ms-proposed-lease-id", proposedLeaseId)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerChangeLeaseOptions != nil && containerChangeLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerChangeLeaseOptions.RequestId)
	}
	return req, nil
}

// ChangeLeaseHandleResponse handles the ChangeLease response.
func (client *ContainerClient) ChangeLeaseHandleResponse(resp *azcore.Response) (*ContainerChangeLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ChangeLeaseHandleError(resp)
	}
	result := ContainerChangeLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// ChangeLeaseHandleError handles the ChangeLease error response.
func (client *ContainerClient) ChangeLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// Create - creates a new container under the specified account. If the container with the same name already exists, the operation fails
func (client *ContainerClient) Create(ctx context.Context, containerCreateOptions *ContainerCreateOptions, containerCpkScopeInfo *ContainerCpkScopeInfo) (*ContainerCreateResponse, error) {
	req, err := client.CreateCreateRequest(containerCreateOptions, containerCpkScopeInfo)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.CreateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// CreateCreateRequest creates the Create request.
func (client *ContainerClient) CreateCreateRequest(containerCreateOptions *ContainerCreateOptions, containerCpkScopeInfo *ContainerCpkScopeInfo) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	if containerCreateOptions != nil && containerCreateOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerCreateOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if containerCreateOptions != nil && containerCreateOptions.Metadata != nil {
		for k, v := range *containerCreateOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if containerCreateOptions != nil && containerCreateOptions.Access != nil {
		req.Header.Set("x-ms-blob-public-access", string(*containerCreateOptions.Access))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerCreateOptions != nil && containerCreateOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerCreateOptions.RequestId)
	}
	if containerCpkScopeInfo != nil && containerCpkScopeInfo.DefaultEncryptionScope != nil {
		req.Header.Set("x-ms-default-encryption-scope", *containerCpkScopeInfo.DefaultEncryptionScope)
	}
	if containerCpkScopeInfo != nil && containerCpkScopeInfo.PreventEncryptionScopeOverride != nil {
		req.Header.Set("x-ms-deny-encryption-scope-override", strconv.FormatBool(*containerCpkScopeInfo.PreventEncryptionScopeOverride))
	}
	return req, nil
}

// CreateHandleResponse handles the Create response.
func (client *ContainerClient) CreateHandleResponse(resp *azcore.Response) (*ContainerCreateResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.CreateHandleError(resp)
	}
	result := ContainerCreateResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// CreateHandleError handles the Create error response.
func (client *ContainerClient) CreateHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// Delete - operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection
func (client *ContainerClient) Delete(ctx context.Context, containerDeleteOptions *ContainerDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerDeleteResponse, error) {
	req, err := client.DeleteCreateRequest(containerDeleteOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DeleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DeleteCreateRequest creates the Delete request.
func (client *ContainerClient) DeleteCreateRequest(containerDeleteOptions *ContainerDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	if containerDeleteOptions != nil && containerDeleteOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerDeleteOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerDeleteOptions != nil && containerDeleteOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerDeleteOptions.RequestId)
	}
	return req, nil
}

// DeleteHandleResponse handles the Delete response.
func (client *ContainerClient) DeleteHandleResponse(resp *azcore.Response) (*ContainerDeleteResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.DeleteHandleError(resp)
	}
	result := ContainerDeleteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// DeleteHandleError handles the Delete error response.
func (client *ContainerClient) DeleteHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// GetAccessPolicy - gets the permissions for the specified container. The permissions indicate whether container data may be accessed publicly.
func (client *ContainerClient) GetAccessPolicy(ctx context.Context, containerGetAccessPolicyOptions *ContainerGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*SignedIDentifierArrayResponse, error) {
	req, err := client.GetAccessPolicyCreateRequest(containerGetAccessPolicyOptions, leaseAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetAccessPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAccessPolicyCreateRequest creates the GetAccessPolicy request.
func (client *ContainerClient) GetAccessPolicyCreateRequest(containerGetAccessPolicyOptions *ContainerGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "acl")
	if containerGetAccessPolicyOptions != nil && containerGetAccessPolicyOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerGetAccessPolicyOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerGetAccessPolicyOptions != nil && containerGetAccessPolicyOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerGetAccessPolicyOptions.RequestId)
	}
	return req, nil
}

// GetAccessPolicyHandleResponse handles the GetAccessPolicy response.
func (client *ContainerClient) GetAccessPolicyHandleResponse(resp *azcore.Response) (*SignedIDentifierArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAccessPolicyHandleError(resp)
	}
	result := SignedIDentifierArrayResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-blob-public-access"); val != "" {
		result.BlobPublicAccess = (*PublicAccessType)(&val)
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, resp.UnmarshalAsXML(&result)
}

// GetAccessPolicyHandleError handles the GetAccessPolicy error response.
func (client *ContainerClient) GetAccessPolicyHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// GetAccountInfo - Returns the sku name and account kind
func (client *ContainerClient) GetAccountInfo(ctx context.Context) (*ContainerGetAccountInfoResponse, error) {
	req, err := client.GetAccountInfoCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetAccountInfoHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetAccountInfoCreateRequest creates the GetAccountInfo request.
func (client *ContainerClient) GetAccountInfoCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "account")
	query.Set("comp", "properties")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// GetAccountInfoHandleResponse handles the GetAccountInfo response.
func (client *ContainerClient) GetAccountInfoHandleResponse(resp *azcore.Response) (*ContainerGetAccountInfoResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetAccountInfoHandleError(resp)
	}
	result := ContainerGetAccountInfoResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-sku-name"); val != "" {
		result.SKUName = (*SKUName)(&val)
	}
	if val := resp.Header.Get("x-ms-account-kind"); val != "" {
		result.AccountKind = (*AccountKind)(&val)
	}
	return &result, nil
}

// GetAccountInfoHandleError handles the GetAccountInfo error response.
func (client *ContainerClient) GetAccountInfoHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// GetProperties - returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs
func (client *ContainerClient) GetProperties(ctx context.Context, containerGetPropertiesOptions *ContainerGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*ContainerGetPropertiesResponse, error) {
	req, err := client.GetPropertiesCreateRequest(containerGetPropertiesOptions, leaseAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetPropertiesCreateRequest creates the GetProperties request.
func (client *ContainerClient) GetPropertiesCreateRequest(containerGetPropertiesOptions *ContainerGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	if containerGetPropertiesOptions != nil && containerGetPropertiesOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerGetPropertiesOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerGetPropertiesOptions != nil && containerGetPropertiesOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerGetPropertiesOptions.RequestId)
	}
	return req, nil
}

// GetPropertiesHandleResponse handles the GetProperties response.
func (client *ContainerClient) GetPropertiesHandleResponse(resp *azcore.Response) (*ContainerGetPropertiesResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetPropertiesHandleError(resp)
	}
	result := ContainerGetPropertiesResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-meta"); val != "" {
		result.Metadata = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-blob-public-access"); val != "" {
		result.BlobPublicAccess = (*PublicAccessType)(&val)
	}
	if val := resp.Header.Get("x-ms-has-immutability-policy"); val != "" {
		hasImmutabilityPolicy, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.HasImmutabilityPolicy = &hasImmutabilityPolicy
	}
	if val := resp.Header.Get("x-ms-has-legal-hold"); val != "" {
		hasLegalHold, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.HasLegalHold = &hasLegalHold
	}
	if val := resp.Header.Get("x-ms-default-encryption-scope"); val != "" {
		result.DefaultEncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-deny-encryption-scope-override"); val != "" {
		denyEncryptionScopeOverride, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.DenyEncryptionScopeOverride = &denyEncryptionScopeOverride
	}
	return &result, nil
}

// GetPropertiesHandleError handles the GetProperties error response.
func (client *ContainerClient) GetPropertiesHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// ListBlobFlatSegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
func (client *ContainerClient) ListBlobFlatSegment(containerListBlobFlatSegmentOptions *ContainerListBlobFlatSegmentOptions) (ListBlobsFlatSegmentResponsePager, error) {
	req, err := client.ListBlobFlatSegmentCreateRequest(containerListBlobFlatSegmentOptions)
	if err != nil {
		return nil, err
	}
	return &listBlobsFlatSegmentResponsePager{
		pipeline:  client.p,
		request:   req,
		responder: client.ListBlobFlatSegmentHandleResponse,
		advancer: func(resp *ListBlobsFlatSegmentResponseResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.EnumerationResults.NextMarker)
			if err != nil {
				return nil, fmt.Errorf("invalid NextMarker: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextMarker %s", *resp.EnumerationResults.NextMarker)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// ListBlobFlatSegmentCreateRequest creates the ListBlobFlatSegment request.
func (client *ContainerClient) ListBlobFlatSegmentCreateRequest(containerListBlobFlatSegmentOptions *ContainerListBlobFlatSegmentOptions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "list")
	if containerListBlobFlatSegmentOptions != nil && containerListBlobFlatSegmentOptions.Prefix != nil {
		query.Set("prefix", *containerListBlobFlatSegmentOptions.Prefix)
	}
	if containerListBlobFlatSegmentOptions != nil && containerListBlobFlatSegmentOptions.Marker != nil {
		query.Set("marker", *containerListBlobFlatSegmentOptions.Marker)
	}
	if containerListBlobFlatSegmentOptions != nil && containerListBlobFlatSegmentOptions.Maxresults != nil {
		query.Set("maxresults", strconv.FormatInt(int64(*containerListBlobFlatSegmentOptions.Maxresults), 10))
	}
	if containerListBlobFlatSegmentOptions != nil && containerListBlobFlatSegmentOptions.Include != nil {
		query.Set("include", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(*containerListBlobFlatSegmentOptions.Include), "[]")), ","))
	}
	if containerListBlobFlatSegmentOptions != nil && containerListBlobFlatSegmentOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerListBlobFlatSegmentOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerListBlobFlatSegmentOptions != nil && containerListBlobFlatSegmentOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerListBlobFlatSegmentOptions.RequestId)
	}
	return req, nil
}

// ListBlobFlatSegmentHandleResponse handles the ListBlobFlatSegment response.
func (client *ContainerClient) ListBlobFlatSegmentHandleResponse(resp *azcore.Response) (*ListBlobsFlatSegmentResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListBlobFlatSegmentHandleError(resp)
	}
	result := ListBlobsFlatSegmentResponseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// ListBlobFlatSegmentHandleError handles the ListBlobFlatSegment error response.
func (client *ContainerClient) ListBlobFlatSegmentHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// ListBlobHierarchySegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
func (client *ContainerClient) ListBlobHierarchySegment(delimiter string, containerListBlobHierarchySegmentOptions *ContainerListBlobHierarchySegmentOptions) (ListBlobsHierarchySegmentResponsePager, error) {
	req, err := client.ListBlobHierarchySegmentCreateRequest(delimiter, containerListBlobHierarchySegmentOptions)
	if err != nil {
		return nil, err
	}
	return &listBlobsHierarchySegmentResponsePager{
		pipeline:  client.p,
		request:   req,
		responder: client.ListBlobHierarchySegmentHandleResponse,
		advancer: func(resp *ListBlobsHierarchySegmentResponseResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.EnumerationResults.NextMarker)
			if err != nil {
				return nil, fmt.Errorf("invalid NextMarker: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextMarker %s", *resp.EnumerationResults.NextMarker)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// ListBlobHierarchySegmentCreateRequest creates the ListBlobHierarchySegment request.
func (client *ContainerClient) ListBlobHierarchySegmentCreateRequest(delimiter string, containerListBlobHierarchySegmentOptions *ContainerListBlobHierarchySegmentOptions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "list")
	if containerListBlobHierarchySegmentOptions != nil && containerListBlobHierarchySegmentOptions.Prefix != nil {
		query.Set("prefix", *containerListBlobHierarchySegmentOptions.Prefix)
	}
	query.Set("delimiter", delimiter)
	if containerListBlobHierarchySegmentOptions != nil && containerListBlobHierarchySegmentOptions.Marker != nil {
		query.Set("marker", *containerListBlobHierarchySegmentOptions.Marker)
	}
	if containerListBlobHierarchySegmentOptions != nil && containerListBlobHierarchySegmentOptions.Maxresults != nil {
		query.Set("maxresults", strconv.FormatInt(int64(*containerListBlobHierarchySegmentOptions.Maxresults), 10))
	}
	if containerListBlobHierarchySegmentOptions != nil && containerListBlobHierarchySegmentOptions.Include != nil {
		query.Set("include", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(*containerListBlobHierarchySegmentOptions.Include), "[]")), ","))
	}
	if containerListBlobHierarchySegmentOptions != nil && containerListBlobHierarchySegmentOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerListBlobHierarchySegmentOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerListBlobHierarchySegmentOptions != nil && containerListBlobHierarchySegmentOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerListBlobHierarchySegmentOptions.RequestId)
	}
	return req, nil
}

// ListBlobHierarchySegmentHandleResponse handles the ListBlobHierarchySegment response.
func (client *ContainerClient) ListBlobHierarchySegmentHandleResponse(resp *azcore.Response) (*ListBlobsHierarchySegmentResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListBlobHierarchySegmentHandleError(resp)
	}
	result := ListBlobsHierarchySegmentResponseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// ListBlobHierarchySegmentHandleError handles the ListBlobHierarchySegment error response.
func (client *ContainerClient) ListBlobHierarchySegmentHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// ReleaseLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *ContainerClient) ReleaseLease(ctx context.Context, leaseId string, containerReleaseLeaseOptions *ContainerReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerReleaseLeaseResponse, error) {
	req, err := client.ReleaseLeaseCreateRequest(leaseId, containerReleaseLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.ReleaseLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ReleaseLeaseCreateRequest creates the ReleaseLease request.
func (client *ContainerClient) ReleaseLeaseCreateRequest(leaseId string, containerReleaseLeaseOptions *ContainerReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if containerReleaseLeaseOptions != nil && containerReleaseLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerReleaseLeaseOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "release")
	req.Header.Set("x-ms-lease-id", leaseId)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerReleaseLeaseOptions != nil && containerReleaseLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerReleaseLeaseOptions.RequestId)
	}
	return req, nil
}

// ReleaseLeaseHandleResponse handles the ReleaseLease response.
func (client *ContainerClient) ReleaseLeaseHandleResponse(resp *azcore.Response) (*ContainerReleaseLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ReleaseLeaseHandleError(resp)
	}
	result := ContainerReleaseLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// ReleaseLeaseHandleError handles the ReleaseLease error response.
func (client *ContainerClient) ReleaseLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// RenewLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *ContainerClient) RenewLease(ctx context.Context, leaseId string, containerRenewLeaseOptions *ContainerRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerRenewLeaseResponse, error) {
	req, err := client.RenewLeaseCreateRequest(leaseId, containerRenewLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.RenewLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// RenewLeaseCreateRequest creates the RenewLease request.
func (client *ContainerClient) RenewLeaseCreateRequest(leaseId string, containerRenewLeaseOptions *ContainerRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if containerRenewLeaseOptions != nil && containerRenewLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerRenewLeaseOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "renew")
	req.Header.Set("x-ms-lease-id", leaseId)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerRenewLeaseOptions != nil && containerRenewLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerRenewLeaseOptions.RequestId)
	}
	return req, nil
}

// RenewLeaseHandleResponse handles the RenewLease response.
func (client *ContainerClient) RenewLeaseHandleResponse(resp *azcore.Response) (*ContainerRenewLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.RenewLeaseHandleError(resp)
	}
	result := ContainerRenewLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// RenewLeaseHandleError handles the RenewLease error response.
func (client *ContainerClient) RenewLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// SetAccessPolicy - sets the permissions for the specified container. The permissions indicate whether blobs in a container may be accessed publicly.
func (client *ContainerClient) SetAccessPolicy(ctx context.Context, containerSetAccessPolicyOptions *ContainerSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerSetAccessPolicyResponse, error) {
	req, err := client.SetAccessPolicyCreateRequest(containerSetAccessPolicyOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.SetAccessPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// SetAccessPolicyCreateRequest creates the SetAccessPolicy request.
func (client *ContainerClient) SetAccessPolicyCreateRequest(containerSetAccessPolicyOptions *ContainerSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "acl")
	if containerSetAccessPolicyOptions != nil && containerSetAccessPolicyOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerSetAccessPolicyOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if containerSetAccessPolicyOptions != nil && containerSetAccessPolicyOptions.Access != nil {
		req.Header.Set("x-ms-blob-public-access", string(*containerSetAccessPolicyOptions.Access))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerSetAccessPolicyOptions != nil && containerSetAccessPolicyOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerSetAccessPolicyOptions.RequestId)
	}
	type wrapper struct {
		XMLName      xml.Name            `xml:"SignedIdentifiers"`
		ContainerAcl *[]SignedIDentifier `xml:"SignedIdentifier"`
	}
	if containerSetAccessPolicyOptions != nil {
		return req, req.MarshalAsXML(wrapper{ContainerAcl: containerSetAccessPolicyOptions.ContainerAcl})
	}
	return req, nil
}

// SetAccessPolicyHandleResponse handles the SetAccessPolicy response.
func (client *ContainerClient) SetAccessPolicyHandleResponse(resp *azcore.Response) (*ContainerSetAccessPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.SetAccessPolicyHandleError(resp)
	}
	result := ContainerSetAccessPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// SetAccessPolicyHandleError handles the SetAccessPolicy error response.
func (client *ContainerClient) SetAccessPolicyHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// SetMetadata - operation sets one or more user-defined name-value pairs for the specified container.
func (client *ContainerClient) SetMetadata(ctx context.Context, containerSetMetadataOptions *ContainerSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*ContainerSetMetadataResponse, error) {
	req, err := client.SetMetadataCreateRequest(containerSetMetadataOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.SetMetadataHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// SetMetadataCreateRequest creates the SetMetadata request.
func (client *ContainerClient) SetMetadataCreateRequest(containerSetMetadataOptions *ContainerSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "metadata")
	if containerSetMetadataOptions != nil && containerSetMetadataOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*containerSetMetadataOptions.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if containerSetMetadataOptions != nil && containerSetMetadataOptions.Metadata != nil {
		for k, v := range *containerSetMetadataOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if containerSetMetadataOptions != nil && containerSetMetadataOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *containerSetMetadataOptions.RequestId)
	}
	return req, nil
}

// SetMetadataHandleResponse handles the SetMetadata response.
func (client *ContainerClient) SetMetadataHandleResponse(resp *azcore.Response) (*ContainerSetMetadataResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.SetMetadataHandleError(resp)
	}
	result := ContainerSetMetadataResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// SetMetadataHandleError handles the SetMetadata error response.
func (client *ContainerClient) SetMetadataHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}
