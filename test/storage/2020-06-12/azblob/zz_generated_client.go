//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type client struct {
	endpoint       string
	version        Enum2
	pathRenameMode *PathRenameMode
	pl             runtime.Pipeline
}

// newClient creates a new instance of client with the specified values.
// endpoint - The URL of the service account, container, or blob that is the targe of the desired operation.
// version - Specifies the version of the operation to use for this request.
// pathRenameMode - Determines the behavior of the rename operation
// pl - the pipeline used for sending requests and handling responses.
func newClient(endpoint string, version Enum2, pathRenameMode *PathRenameMode, pl runtime.Pipeline) *client {
	client := &client{
		endpoint:       endpoint,
		version:        version,
		pathRenameMode: pathRenameMode,
		pl:             pl,
	}
	return client
}

// AbortCopyFromURL - The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination
// blob with zero length and full metadata.
// If the operation fails it returns an *azcore.ResponseError type.
// copyID - The copy identifier provided in the x-ms-copy-id header of the original Copy Blob operation.
// clientAbortCopyFromURLOptions - clientAbortCopyFromURLOptions contains the optional parameters for the client.AbortCopyFromURL
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
func (client *client) AbortCopyFromURL(ctx context.Context, comp Enum30, copyActionAbortConstant Enum31, copyID string, clientAbortCopyFromURLOptions *clientAbortCopyFromURLOptions, leaseAccessConditions *LeaseAccessConditions) (clientAbortCopyFromURLResponse, error) {
	req, err := client.abortCopyFromURLCreateRequest(ctx, comp, copyActionAbortConstant, copyID, clientAbortCopyFromURLOptions, leaseAccessConditions)
	if err != nil {
		return clientAbortCopyFromURLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientAbortCopyFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return clientAbortCopyFromURLResponse{}, runtime.NewResponseError(resp)
	}
	return client.abortCopyFromURLHandleResponse(resp)
}

// abortCopyFromURLCreateRequest creates the AbortCopyFromURL request.
func (client *client) abortCopyFromURLCreateRequest(ctx context.Context, comp Enum30, copyActionAbortConstant Enum31, copyID string, clientAbortCopyFromURLOptions *clientAbortCopyFromURLOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	reqQP.Set("copyid", copyID)
	if clientAbortCopyFromURLOptions != nil && clientAbortCopyFromURLOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientAbortCopyFromURLOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-copy-action", string(copyActionAbortConstant))
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientAbortCopyFromURLOptions != nil && clientAbortCopyFromURLOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientAbortCopyFromURLOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// abortCopyFromURLHandleResponse handles the AbortCopyFromURL response.
func (client *client) abortCopyFromURLHandleResponse(resp *http.Response) (clientAbortCopyFromURLResponse, error) {
	result := clientAbortCopyFromURLResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientAbortCopyFromURLResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// AcquireLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// clientAcquireLeaseOptions - clientAcquireLeaseOptions contains the optional parameters for the client.AcquireLease method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) AcquireLease(ctx context.Context, comp Enum16, clientAcquireLeaseOptions *clientAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (clientAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, comp, clientAcquireLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return clientAcquireLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientAcquireLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return clientAcquireLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.acquireLeaseHandleResponse(resp)
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *client) acquireLeaseCreateRequest(ctx context.Context, comp Enum16, clientAcquireLeaseOptions *clientAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientAcquireLeaseOptions != nil && clientAcquireLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientAcquireLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "acquire")
	if clientAcquireLeaseOptions != nil && clientAcquireLeaseOptions.Duration != nil {
		req.Raw().Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*clientAcquireLeaseOptions.Duration), 10))
	}
	if clientAcquireLeaseOptions != nil && clientAcquireLeaseOptions.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *clientAcquireLeaseOptions.ProposedLeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientAcquireLeaseOptions != nil && clientAcquireLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientAcquireLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *client) acquireLeaseHandleResponse(resp *http.Response) (clientAcquireLeaseResponse, error) {
	result := clientAcquireLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// BreakLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// clientBreakLeaseOptions - clientBreakLeaseOptions contains the optional parameters for the client.BreakLease method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) BreakLease(ctx context.Context, comp Enum16, clientBreakLeaseOptions *clientBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (clientBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, comp, clientBreakLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return clientBreakLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientBreakLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return clientBreakLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.breakLeaseHandleResponse(resp)
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *client) breakLeaseCreateRequest(ctx context.Context, comp Enum16, clientBreakLeaseOptions *clientBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientBreakLeaseOptions != nil && clientBreakLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientBreakLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "break")
	if clientBreakLeaseOptions != nil && clientBreakLeaseOptions.BreakPeriod != nil {
		req.Raw().Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*clientBreakLeaseOptions.BreakPeriod), 10))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientBreakLeaseOptions != nil && clientBreakLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientBreakLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *client) breakLeaseHandleResponse(resp *http.Response) (clientBreakLeaseResponse, error) {
	result := clientBreakLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-time"); val != "" {
		leaseTime32, err := strconv.ParseInt(val, 10, 32)
		leaseTime := int32(leaseTime32)
		if err != nil {
			return clientBreakLeaseResponse{}, err
		}
		result.LeaseTime = &leaseTime
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// ChangeLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// leaseID - Specifies the current lease ID on the resource.
// proposedLeaseID - Proposed lease ID, in a GUID string format. The Blob service returns 400 (Invalid request) if the proposed
// lease ID is not in the correct format. See Guid Constructor (String) for a list of valid GUID
// string formats.
// clientChangeLeaseOptions - clientChangeLeaseOptions contains the optional parameters for the client.ChangeLease method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) ChangeLease(ctx context.Context, comp Enum16, leaseID string, proposedLeaseID string, clientChangeLeaseOptions *clientChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (clientChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, comp, leaseID, proposedLeaseID, clientChangeLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return clientChangeLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientChangeLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientChangeLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.changeLeaseHandleResponse(resp)
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *client) changeLeaseCreateRequest(ctx context.Context, comp Enum16, leaseID string, proposedLeaseID string, clientChangeLeaseOptions *clientChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientChangeLeaseOptions != nil && clientChangeLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientChangeLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "change")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	req.Raw().Header.Set("x-ms-proposed-lease-id", proposedLeaseID)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientChangeLeaseOptions != nil && clientChangeLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientChangeLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *client) changeLeaseHandleResponse(resp *http.Response) (clientChangeLeaseResponse, error) {
	result := clientChangeLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// CopyFromURL - The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response
// until the copy is complete.
// If the operation fails it returns an *azcore.ResponseError type.
// copySource - Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies
// a page blob snapshot. The value should be URL-encoded as it would appear in a request
// URI. The source blob must either be public or must be authenticated via a shared access signature.
// clientCopyFromURLOptions - clientCopyFromURLOptions contains the optional parameters for the client.CopyFromURL method.
// SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the directoryClient.Rename
// method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
func (client *client) CopyFromURL(ctx context.Context, xmsRequiresSync Enum29, copySource string, clientCopyFromURLOptions *clientCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (clientCopyFromURLResponse, error) {
	req, err := client.copyFromURLCreateRequest(ctx, xmsRequiresSync, copySource, clientCopyFromURLOptions, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return clientCopyFromURLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientCopyFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return clientCopyFromURLResponse{}, runtime.NewResponseError(resp)
	}
	return client.copyFromURLHandleResponse(resp)
}

// copyFromURLCreateRequest creates the CopyFromURL request.
func (client *client) copyFromURLCreateRequest(ctx context.Context, xmsRequiresSync Enum29, copySource string, clientCopyFromURLOptions *clientCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientCopyFromURLOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-requires-sync", string(xmsRequiresSync))
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.Metadata != nil {
		for k, v := range clientCopyFromURLOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.Tier != nil {
		req.Raw().Header.Set("x-ms-access-tier", string(*clientCopyFromURLOptions.Tier))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-copy-source", copySource)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientCopyFromURLOptions.RequestID)
	}
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.SourceContentMD5 != nil {
		req.Raw().Header.Set("x-ms-source-content-md5", base64.StdEncoding.EncodeToString(clientCopyFromURLOptions.SourceContentMD5))
	}
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.BlobTagsString != nil {
		req.Raw().Header.Set("x-ms-tags", *clientCopyFromURLOptions.BlobTagsString)
	}
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.ImmutabilityPolicyExpiry != nil {
		req.Raw().Header.Set("x-ms-immutability-policy-until-date", clientCopyFromURLOptions.ImmutabilityPolicyExpiry.Format(time.RFC1123))
	}
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.ImmutabilityPolicyMode != nil {
		req.Raw().Header.Set("x-ms-immutability-policy-mode", string(*clientCopyFromURLOptions.ImmutabilityPolicyMode))
	}
	if clientCopyFromURLOptions != nil && clientCopyFromURLOptions.LegalHold != nil {
		req.Raw().Header.Set("x-ms-legal-hold", strconv.FormatBool(*clientCopyFromURLOptions.LegalHold))
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// copyFromURLHandleResponse handles the CopyFromURL response.
func (client *client) copyFromURLHandleResponse(resp *http.Response) (clientCopyFromURLResponse, error) {
	result := clientCopyFromURLResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientCopyFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientCopyFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientCopyFromURLResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientCopyFromURLResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	return result, nil
}

// CreateSnapshot - The Create Snapshot operation creates a read-only snapshot of a blob
// If the operation fails it returns an *azcore.ResponseError type.
// clientCreateSnapshotOptions - clientCreateSnapshotOptions contains the optional parameters for the client.CreateSnapshot
// method.
// CpkInfo - CpkInfo contains a group of parameters for the client.Download method.
// CpkScopeInfo - CpkScopeInfo contains a group of parameters for the client.SetMetadata method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
func (client *client) CreateSnapshot(ctx context.Context, comp Enum28, clientCreateSnapshotOptions *clientCreateSnapshotOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (clientCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(ctx, comp, clientCreateSnapshotOptions, cpkInfo, cpkScopeInfo, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return clientCreateSnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientCreateSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return clientCreateSnapshotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createSnapshotHandleResponse(resp)
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client *client) createSnapshotCreateRequest(ctx context.Context, comp Enum28, clientCreateSnapshotOptions *clientCreateSnapshotOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientCreateSnapshotOptions != nil && clientCreateSnapshotOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientCreateSnapshotOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if clientCreateSnapshotOptions != nil && clientCreateSnapshotOptions.Metadata != nil {
		for k, v := range clientCreateSnapshotOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySHA256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientCreateSnapshotOptions != nil && clientCreateSnapshotOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientCreateSnapshotOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client *client) createSnapshotHandleResponse(resp *http.Response) (clientCreateSnapshotResponse, error) {
	result := clientCreateSnapshotResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-snapshot"); val != "" {
		result.Snapshot = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientCreateSnapshotResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientCreateSnapshotResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return clientCreateSnapshotResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// Delete - If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed
// from the storage account. If the storage account's soft delete feature is enabled,
// then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service
// retains the blob or snapshot for the number of days specified by the
// DeleteRetentionPolicy section of Storage service properties [Set-Blob-Service-Properties.md]. After the specified number
// of days has passed, the blob's data is permanently removed from the storage
// account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use
// the List Blobs API and specify the "include=deleted" query parameter to discover
// which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob.
// All other operations on a soft-deleted blob or snapshot causes the service to
// return an HTTP status code of 404 (ResourceNotFound).
// If the operation fails it returns an *azcore.ResponseError type.
// clientDeleteOptions - clientDeleteOptions contains the optional parameters for the client.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) Delete(ctx context.Context, clientDeleteOptions *clientDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (clientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, clientDeleteOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return clientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return clientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *client) deleteCreateRequest(ctx context.Context, clientDeleteOptions *clientDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if clientDeleteOptions != nil && clientDeleteOptions.Snapshot != nil {
		reqQP.Set("snapshot", *clientDeleteOptions.Snapshot)
	}
	if clientDeleteOptions != nil && clientDeleteOptions.VersionID != nil {
		reqQP.Set("versionid", *clientDeleteOptions.VersionID)
	}
	if clientDeleteOptions != nil && clientDeleteOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientDeleteOptions.Timeout), 10))
	}
	if clientDeleteOptions != nil && clientDeleteOptions.BlobDeleteType != nil {
		reqQP.Set("deletetype", "Permanent")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if clientDeleteOptions != nil && clientDeleteOptions.DeleteSnapshots != nil {
		req.Raw().Header.Set("x-ms-delete-snapshots", string(*clientDeleteOptions.DeleteSnapshots))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientDeleteOptions != nil && clientDeleteOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientDeleteOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *client) deleteHandleResponse(resp *http.Response) (clientDeleteResponse, error) {
	result := clientDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// DeleteImmutabilityPolicy - The Delete Immutability Policy operation deletes the immutability policy on the blob
// If the operation fails it returns an *azcore.ResponseError type.
// options - clientDeleteImmutabilityPolicyOptions contains the optional parameters for the client.DeleteImmutabilityPolicy
// method.
func (client *client) DeleteImmutabilityPolicy(ctx context.Context, comp Enum26, options *clientDeleteImmutabilityPolicyOptions) (clientDeleteImmutabilityPolicyResponse, error) {
	req, err := client.deleteImmutabilityPolicyCreateRequest(ctx, comp, options)
	if err != nil {
		return clientDeleteImmutabilityPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientDeleteImmutabilityPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientDeleteImmutabilityPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteImmutabilityPolicyHandleResponse(resp)
}

// deleteImmutabilityPolicyCreateRequest creates the DeleteImmutabilityPolicy request.
func (client *client) deleteImmutabilityPolicyCreateRequest(ctx context.Context, comp Enum26, options *clientDeleteImmutabilityPolicyOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteImmutabilityPolicyHandleResponse handles the DeleteImmutabilityPolicy response.
func (client *client) deleteImmutabilityPolicyHandleResponse(resp *http.Response) (clientDeleteImmutabilityPolicyResponse, error) {
	result := clientDeleteImmutabilityPolicyResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDeleteImmutabilityPolicyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Download - The Download operation reads or downloads a blob from the system, including its metadata and properties. You
// can also call Download to read a snapshot.
// If the operation fails it returns an *azcore.ResponseError type.
// clientDownloadOptions - clientDownloadOptions contains the optional parameters for the client.Download method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// CpkInfo - CpkInfo contains a group of parameters for the client.Download method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) Download(ctx context.Context, clientDownloadOptions *clientDownloadOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (clientDownloadResponse, error) {
	req, err := client.downloadCreateRequest(ctx, clientDownloadOptions, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if err != nil {
		return clientDownloadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientDownloadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusPartialContent) {
		return clientDownloadResponse{}, runtime.NewResponseError(resp)
	}
	return client.downloadHandleResponse(resp)
}

// downloadCreateRequest creates the Download request.
func (client *client) downloadCreateRequest(ctx context.Context, clientDownloadOptions *clientDownloadOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if clientDownloadOptions != nil && clientDownloadOptions.Snapshot != nil {
		reqQP.Set("snapshot", *clientDownloadOptions.Snapshot)
	}
	if clientDownloadOptions != nil && clientDownloadOptions.VersionID != nil {
		reqQP.Set("versionid", *clientDownloadOptions.VersionID)
	}
	if clientDownloadOptions != nil && clientDownloadOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientDownloadOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	if clientDownloadOptions != nil && clientDownloadOptions.Range != nil {
		req.Raw().Header.Set("x-ms-range", *clientDownloadOptions.Range)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if clientDownloadOptions != nil && clientDownloadOptions.RangeGetContentMD5 != nil {
		req.Raw().Header.Set("x-ms-range-get-content-md5", strconv.FormatBool(*clientDownloadOptions.RangeGetContentMD5))
	}
	if clientDownloadOptions != nil && clientDownloadOptions.RangeGetContentCRC64 != nil {
		req.Raw().Header.Set("x-ms-range-get-content-crc64", strconv.FormatBool(*clientDownloadOptions.RangeGetContentCRC64))
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySHA256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientDownloadOptions != nil && clientDownloadOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientDownloadOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client *client) downloadHandleResponse(resp *http.Response) (clientDownloadResponse, error) {
	result := clientDownloadResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-or-policy-id"); val != "" {
		result.ObjectReplicationPolicyID = &val
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-or-") && strings.EqualFold(hh[:len("x-ms-or-")], "x-ms-or-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-or-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("x-ms-is-current-version"); val != "" {
		isCurrentVersion, err := strconv.ParseBool(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.IsCurrentVersion = &isCurrentVersion
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-blob-content-md5"); val != "" {
		blobContentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.BlobContentMD5 = blobContentMD5
	}
	if val := resp.Header.Get("x-ms-tag-count"); val != "" {
		tagCount, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.TagCount = &tagCount
	}
	if val := resp.Header.Get("x-ms-blob-sealed"); val != "" {
		isSealed, err := strconv.ParseBool(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.IsSealed = &isSealed
	}
	if val := resp.Header.Get("x-ms-last-access-time"); val != "" {
		lastAccessed, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.LastAccessed = &lastAccessed
	}
	if val := resp.Header.Get("x-ms-immutability-policy-until-date"); val != "" {
		immutabilityPolicyExpiresOn, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.ImmutabilityPolicyExpiresOn = &immutabilityPolicyExpiresOn
	}
	if val := resp.Header.Get("x-ms-immutability-policy-mode"); val != "" {
		result.ImmutabilityPolicyMode = (*BlobImmutabilityPolicyMode)(&val)
	}
	if val := resp.Header.Get("x-ms-legal-hold"); val != "" {
		legalHold, err := strconv.ParseBool(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.LegalHold = &legalHold
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientDownloadResponse{}, err
		}
		result.ContentCRC64 = contentCRC64
	}
	return result, nil
}

// GetAccessControl - Get the owner, group, permissions, or access control list for a blob.
// If the operation fails it returns an *azcore.ResponseError type.
// clientGetAccessControlOptions - clientGetAccessControlOptions contains the optional parameters for the client.GetAccessControl
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) GetAccessControl(ctx context.Context, action Enum22, clientGetAccessControlOptions *clientGetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (clientGetAccessControlResponse, error) {
	req, err := client.getAccessControlCreateRequest(ctx, action, clientGetAccessControlOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return clientGetAccessControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientGetAccessControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientGetAccessControlResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAccessControlHandleResponse(resp)
}

// getAccessControlCreateRequest creates the GetAccessControl request.
func (client *client) getAccessControlCreateRequest(ctx context.Context, action Enum22, clientGetAccessControlOptions *clientGetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodHead, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("action", string(action))
	if clientGetAccessControlOptions != nil && clientGetAccessControlOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientGetAccessControlOptions.Timeout), 10))
	}
	if clientGetAccessControlOptions != nil && clientGetAccessControlOptions.Upn != nil {
		reqQP.Set("upn", strconv.FormatBool(*clientGetAccessControlOptions.Upn))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if clientGetAccessControlOptions != nil && clientGetAccessControlOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientGetAccessControlOptions.RequestID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccessControlHandleResponse handles the GetAccessControl response.
func (client *client) getAccessControlHandleResponse(resp *http.Response) (clientGetAccessControlResponse, error) {
	result := clientGetAccessControlResponse{RawResponse: resp}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetAccessControlResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetAccessControlResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-owner"); val != "" {
		result.XMSOwner = &val
	}
	if val := resp.Header.Get("x-ms-group"); val != "" {
		result.XMSGroup = &val
	}
	if val := resp.Header.Get("x-ms-permissions"); val != "" {
		result.XMSPermissions = &val
	}
	if val := resp.Header.Get("x-ms-acl"); val != "" {
		result.XMSACL = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// GetAccountInfo - Returns the sku name and account kind
// If the operation fails it returns an *azcore.ResponseError type.
// options - clientGetAccountInfoOptions contains the optional parameters for the client.GetAccountInfo method.
func (client *client) GetAccountInfo(ctx context.Context, restype Enum8, comp Enum1, options *clientGetAccountInfoOptions) (clientGetAccountInfoResponse, error) {
	req, err := client.getAccountInfoCreateRequest(ctx, restype, comp, options)
	if err != nil {
		return clientGetAccountInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientGetAccountInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientGetAccountInfoResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAccountInfoHandleResponse(resp)
}

// getAccountInfoCreateRequest creates the GetAccountInfo request.
func (client *client) getAccountInfoCreateRequest(ctx context.Context, restype Enum8, comp Enum1, options *clientGetAccountInfoOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", string(restype))
	reqQP.Set("comp", string(comp))
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccountInfoHandleResponse handles the GetAccountInfo response.
func (client *client) getAccountInfoHandleResponse(resp *http.Response) (clientGetAccountInfoResponse, error) {
	result := clientGetAccountInfoResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetAccountInfoResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-sku-name"); val != "" {
		result.SKUName = (*SKUName)(&val)
	}
	if val := resp.Header.Get("x-ms-account-kind"); val != "" {
		result.AccountKind = (*AccountKind)(&val)
	}
	return result, nil
}

// GetProperties - The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties
// for the blob. It does not return the content of the blob.
// If the operation fails it returns an *azcore.ResponseError type.
// clientGetPropertiesOptions - clientGetPropertiesOptions contains the optional parameters for the client.GetProperties method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// CpkInfo - CpkInfo contains a group of parameters for the client.Download method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) GetProperties(ctx context.Context, clientGetPropertiesOptions *clientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (clientGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, clientGetPropertiesOptions, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if err != nil {
		return clientGetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientGetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *client) getPropertiesCreateRequest(ctx context.Context, clientGetPropertiesOptions *clientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodHead, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if clientGetPropertiesOptions != nil && clientGetPropertiesOptions.Snapshot != nil {
		reqQP.Set("snapshot", *clientGetPropertiesOptions.Snapshot)
	}
	if clientGetPropertiesOptions != nil && clientGetPropertiesOptions.VersionID != nil {
		reqQP.Set("versionid", *clientGetPropertiesOptions.VersionID)
	}
	if clientGetPropertiesOptions != nil && clientGetPropertiesOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientGetPropertiesOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySHA256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientGetPropertiesOptions != nil && clientGetPropertiesOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientGetPropertiesOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *client) getPropertiesHandleResponse(resp *http.Response) (clientGetPropertiesResponse, error) {
	result := clientGetPropertiesResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-creation-time"); val != "" {
		creationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.CreationTime = &creationTime
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-or-policy-id"); val != "" {
		result.ObjectReplicationPolicyID = &val
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-or-") && strings.EqualFold(hh[:len("x-ms-or-")], "x-ms-or-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-or-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-incremental-copy"); val != "" {
		isIncrementalCopy, err := strconv.ParseBool(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.IsIncrementalCopy = &isIncrementalCopy
	}
	if val := resp.Header.Get("x-ms-copy-destination-snapshot"); val != "" {
		result.DestinationSnapshot = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-access-tier"); val != "" {
		result.AccessTier = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-inferred"); val != "" {
		accessTierInferred, err := strconv.ParseBool(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.AccessTierInferred = &accessTierInferred
	}
	if val := resp.Header.Get("x-ms-archive-status"); val != "" {
		result.ArchiveStatus = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-change-time"); val != "" {
		accessTierChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.AccessTierChangeTime = &accessTierChangeTime
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("x-ms-is-current-version"); val != "" {
		isCurrentVersion, err := strconv.ParseBool(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.IsCurrentVersion = &isCurrentVersion
	}
	if val := resp.Header.Get("x-ms-tag-count"); val != "" {
		tagCount, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.TagCount = &tagCount
	}
	if val := resp.Header.Get("x-ms-expiry-time"); val != "" {
		expiresOn, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.ExpiresOn = &expiresOn
	}
	if val := resp.Header.Get("x-ms-blob-sealed"); val != "" {
		isSealed, err := strconv.ParseBool(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.IsSealed = &isSealed
	}
	if val := resp.Header.Get("x-ms-rehydrate-priority"); val != "" {
		result.RehydratePriority = &val
	}
	if val := resp.Header.Get("x-ms-last-access-time"); val != "" {
		lastAccessed, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.LastAccessed = &lastAccessed
	}
	if val := resp.Header.Get("x-ms-immutability-policy-until-date"); val != "" {
		immutabilityPolicyExpiresOn, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.ImmutabilityPolicyExpiresOn = &immutabilityPolicyExpiresOn
	}
	if val := resp.Header.Get("x-ms-immutability-policy-mode"); val != "" {
		result.ImmutabilityPolicyMode = (*BlobImmutabilityPolicyMode)(&val)
	}
	if val := resp.Header.Get("x-ms-legal-hold"); val != "" {
		legalHold, err := strconv.ParseBool(val)
		if err != nil {
			return clientGetPropertiesResponse{}, err
		}
		result.LegalHold = &legalHold
	}
	return result, nil
}

// GetTags - The Get Tags operation enables users to get the tags associated with a blob.
// If the operation fails it returns an *azcore.ResponseError type.
// clientGetTagsOptions - clientGetTagsOptions contains the optional parameters for the client.GetTags method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
func (client *client) GetTags(ctx context.Context, comp Enum42, clientGetTagsOptions *clientGetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (clientGetTagsResponse, error) {
	req, err := client.getTagsCreateRequest(ctx, comp, clientGetTagsOptions, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return clientGetTagsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientGetTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientGetTagsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getTagsHandleResponse(resp)
}

// getTagsCreateRequest creates the GetTags request.
func (client *client) getTagsCreateRequest(ctx context.Context, comp Enum42, clientGetTagsOptions *clientGetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientGetTagsOptions != nil && clientGetTagsOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientGetTagsOptions.Timeout), 10))
	}
	if clientGetTagsOptions != nil && clientGetTagsOptions.Snapshot != nil {
		reqQP.Set("snapshot", *clientGetTagsOptions.Snapshot)
	}
	if clientGetTagsOptions != nil && clientGetTagsOptions.VersionID != nil {
		reqQP.Set("versionid", *clientGetTagsOptions.VersionID)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientGetTagsOptions != nil && clientGetTagsOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientGetTagsOptions.RequestID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getTagsHandleResponse handles the GetTags response.
func (client *client) getTagsHandleResponse(resp *http.Response) (clientGetTagsResponse, error) {
	result := clientGetTagsResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientGetTagsResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.Tags); err != nil {
		return clientGetTagsResponse{}, err
	}
	return result, nil
}

// Query - The Query operation enables users to select/project on blob data by providing simple query expressions.
// If the operation fails it returns an *azcore.ResponseError type.
// clientQueryOptions - clientQueryOptions contains the optional parameters for the client.Query method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// CpkInfo - CpkInfo contains a group of parameters for the client.Download method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) Query(ctx context.Context, comp Enum40, clientQueryOptions *clientQueryOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (clientQueryResponse, error) {
	req, err := client.queryCreateRequest(ctx, comp, clientQueryOptions, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if err != nil {
		return clientQueryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientQueryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusPartialContent) {
		return clientQueryResponse{}, runtime.NewResponseError(resp)
	}
	return client.queryHandleResponse(resp)
}

// queryCreateRequest creates the Query request.
func (client *client) queryCreateRequest(ctx context.Context, comp Enum40, clientQueryOptions *clientQueryOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPost, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientQueryOptions != nil && clientQueryOptions.Snapshot != nil {
		reqQP.Set("snapshot", *clientQueryOptions.Snapshot)
	}
	if clientQueryOptions != nil && clientQueryOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientQueryOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySHA256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientQueryOptions != nil && clientQueryOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientQueryOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	if clientQueryOptions != nil && clientQueryOptions.QueryRequest != nil {
		return req, runtime.MarshalAsXML(req, *clientQueryOptions.QueryRequest)
	}
	return req, nil
}

// queryHandleResponse handles the Query response.
func (client *client) queryHandleResponse(resp *http.Response) (clientQueryResponse, error) {
	result := clientQueryResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-blob-content-md5"); val != "" {
		blobContentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.BlobContentMD5 = blobContentMD5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return clientQueryResponse{}, err
		}
		result.ContentCRC64 = contentCRC64
	}
	return result, nil
}

// ReleaseLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// leaseID - Specifies the current lease ID on the resource.
// clientReleaseLeaseOptions - clientReleaseLeaseOptions contains the optional parameters for the client.ReleaseLease method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) ReleaseLease(ctx context.Context, comp Enum16, leaseID string, clientReleaseLeaseOptions *clientReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (clientReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, comp, leaseID, clientReleaseLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return clientReleaseLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientReleaseLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientReleaseLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.releaseLeaseHandleResponse(resp)
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *client) releaseLeaseCreateRequest(ctx context.Context, comp Enum16, leaseID string, clientReleaseLeaseOptions *clientReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientReleaseLeaseOptions != nil && clientReleaseLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientReleaseLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "release")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientReleaseLeaseOptions != nil && clientReleaseLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientReleaseLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *client) releaseLeaseHandleResponse(resp *http.Response) (clientReleaseLeaseResponse, error) {
	result := clientReleaseLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Rename - Rename a blob/file. By default, the destination is overwritten and if the destination already exists and has a
// lease the lease is broken. This operation supports conditional HTTP requests. For more
// information, see Specifying Conditional Headers for Blob Service Operations [https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations].
// To
// fail if the destination already exists, use a conditional request with If-None-Match: "*".
// If the operation fails it returns an *azcore.ResponseError type.
// renameSource - The file or directory to be renamed. The value must have the following format: "/{filesysystem}/{path}".
// If "x-ms-properties" is specified, the properties will overwrite the existing properties;
// otherwise, the existing properties will be preserved.
// clientRenameOptions - clientRenameOptions contains the optional parameters for the client.Rename method.
// DirectoryHTTPHeaders - DirectoryHTTPHeaders contains a group of parameters for the directoryClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the directoryClient.Rename
// method.
func (client *client) Rename(ctx context.Context, renameSource string, clientRenameOptions *clientRenameOptions, directoryHTTPHeaders *DirectoryHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (clientRenameResponse, error) {
	req, err := client.renameCreateRequest(ctx, renameSource, clientRenameOptions, directoryHTTPHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions)
	if err != nil {
		return clientRenameResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientRenameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return clientRenameResponse{}, runtime.NewResponseError(resp)
	}
	return client.renameHandleResponse(resp)
}

// renameCreateRequest creates the Rename request.
func (client *client) renameCreateRequest(ctx context.Context, renameSource string, clientRenameOptions *clientRenameOptions, directoryHTTPHeaders *DirectoryHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if clientRenameOptions != nil && clientRenameOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientRenameOptions.Timeout), 10))
	}
	if client.pathRenameMode != nil {
		reqQP.Set("mode", string(*client.pathRenameMode))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-rename-source", renameSource)
	if clientRenameOptions != nil && clientRenameOptions.DirectoryProperties != nil {
		req.Raw().Header.Set("x-ms-properties", *clientRenameOptions.DirectoryProperties)
	}
	if clientRenameOptions != nil && clientRenameOptions.PosixPermissions != nil {
		req.Raw().Header.Set("x-ms-permissions", *clientRenameOptions.PosixPermissions)
	}
	if clientRenameOptions != nil && clientRenameOptions.PosixUmask != nil {
		req.Raw().Header.Set("x-ms-umask", *clientRenameOptions.PosixUmask)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.CacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *directoryHTTPHeaders.CacheControl)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *directoryHTTPHeaders.ContentType)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *directoryHTTPHeaders.ContentEncoding)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *directoryHTTPHeaders.ContentLanguage)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *directoryHTTPHeaders.ContentDisposition)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if clientRenameOptions != nil && clientRenameOptions.SourceLeaseID != nil {
		req.Raw().Header.Set("x-ms-source-lease-id", *clientRenameOptions.SourceLeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientRenameOptions != nil && clientRenameOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientRenameOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// renameHandleResponse handles the Rename response.
func (client *client) renameHandleResponse(resp *http.Response) (clientRenameResponse, error) {
	result := clientRenameResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientRenameResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientRenameResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientRenameResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// RenewLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// leaseID - Specifies the current lease ID on the resource.
// clientRenewLeaseOptions - clientRenewLeaseOptions contains the optional parameters for the client.RenewLease method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) RenewLease(ctx context.Context, comp Enum16, leaseID string, clientRenewLeaseOptions *clientRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (clientRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(ctx, comp, leaseID, clientRenewLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return clientRenewLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientRenewLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientRenewLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.renewLeaseHandleResponse(resp)
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client *client) renewLeaseCreateRequest(ctx context.Context, comp Enum16, leaseID string, clientRenewLeaseOptions *clientRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientRenewLeaseOptions != nil && clientRenewLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientRenewLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "renew")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientRenewLeaseOptions != nil && clientRenewLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientRenewLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client *client) renewLeaseHandleResponse(resp *http.Response) (clientRenewLeaseResponse, error) {
	result := clientRenewLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientRenewLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientRenewLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetAccessControl - Set the owner, group, permissions, or access control list for a blob.
// If the operation fails it returns an *azcore.ResponseError type.
// clientSetAccessControlOptions - clientSetAccessControlOptions contains the optional parameters for the client.SetAccessControl
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) SetAccessControl(ctx context.Context, action Enum21, clientSetAccessControlOptions *clientSetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (clientSetAccessControlResponse, error) {
	req, err := client.setAccessControlCreateRequest(ctx, action, clientSetAccessControlOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return clientSetAccessControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetAccessControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientSetAccessControlResponse{}, runtime.NewResponseError(resp)
	}
	return client.setAccessControlHandleResponse(resp)
}

// setAccessControlCreateRequest creates the SetAccessControl request.
func (client *client) setAccessControlCreateRequest(ctx context.Context, action Enum21, clientSetAccessControlOptions *clientSetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPatch, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("action", string(action))
	if clientSetAccessControlOptions != nil && clientSetAccessControlOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientSetAccessControlOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if clientSetAccessControlOptions != nil && clientSetAccessControlOptions.Owner != nil {
		req.Raw().Header.Set("x-ms-owner", *clientSetAccessControlOptions.Owner)
	}
	if clientSetAccessControlOptions != nil && clientSetAccessControlOptions.Group != nil {
		req.Raw().Header.Set("x-ms-group", *clientSetAccessControlOptions.Group)
	}
	if clientSetAccessControlOptions != nil && clientSetAccessControlOptions.PosixPermissions != nil {
		req.Raw().Header.Set("x-ms-permissions", *clientSetAccessControlOptions.PosixPermissions)
	}
	if clientSetAccessControlOptions != nil && clientSetAccessControlOptions.PosixACL != nil {
		req.Raw().Header.Set("x-ms-acl", *clientSetAccessControlOptions.PosixACL)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if clientSetAccessControlOptions != nil && clientSetAccessControlOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientSetAccessControlOptions.RequestID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setAccessControlHandleResponse handles the SetAccessControl response.
func (client *client) setAccessControlHandleResponse(resp *http.Response) (clientSetAccessControlResponse, error) {
	result := clientSetAccessControlResponse{RawResponse: resp}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetAccessControlResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetAccessControlResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// SetExpiry - Sets the time a blob will expire and be deleted.
// If the operation fails it returns an *azcore.ResponseError type.
// expiryOptions - Required. Indicates mode of the expiry time
// options - clientSetExpiryOptions contains the optional parameters for the client.SetExpiry method.
func (client *client) SetExpiry(ctx context.Context, comp Enum24, expiryOptions BlobExpiryOptions, options *clientSetExpiryOptions) (clientSetExpiryResponse, error) {
	req, err := client.setExpiryCreateRequest(ctx, comp, expiryOptions, options)
	if err != nil {
		return clientSetExpiryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetExpiryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientSetExpiryResponse{}, runtime.NewResponseError(resp)
	}
	return client.setExpiryHandleResponse(resp)
}

// setExpiryCreateRequest creates the SetExpiry request.
func (client *client) setExpiryCreateRequest(ctx context.Context, comp Enum24, expiryOptions BlobExpiryOptions, options *clientSetExpiryOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("x-ms-expiry-option", string(expiryOptions))
	if options != nil && options.ExpiresOn != nil {
		req.Raw().Header.Set("x-ms-expiry-time", *options.ExpiresOn)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setExpiryHandleResponse handles the SetExpiry response.
func (client *client) setExpiryHandleResponse(resp *http.Response) (clientSetExpiryResponse, error) {
	result := clientSetExpiryResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetExpiryResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetExpiryResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetHTTPHeaders - The Set HTTP Headers operation sets system properties on the blob
// If the operation fails it returns an *azcore.ResponseError type.
// clientSetHTTPHeadersOptions - clientSetHTTPHeadersOptions contains the optional parameters for the client.SetHTTPHeaders
// method.
// BlobHTTPHeaders - BlobHTTPHeaders contains a group of parameters for the client.SetHTTPHeaders method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) SetHTTPHeaders(ctx context.Context, comp Enum1, clientSetHTTPHeadersOptions *clientSetHTTPHeadersOptions, blobHTTPHeaders *BlobHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (clientSetHTTPHeadersResponse, error) {
	req, err := client.setHTTPHeadersCreateRequest(ctx, comp, clientSetHTTPHeadersOptions, blobHTTPHeaders, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return clientSetHTTPHeadersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetHTTPHeadersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientSetHTTPHeadersResponse{}, runtime.NewResponseError(resp)
	}
	return client.setHTTPHeadersHandleResponse(resp)
}

// setHTTPHeadersCreateRequest creates the SetHTTPHeaders request.
func (client *client) setHTTPHeadersCreateRequest(ctx context.Context, comp Enum1, clientSetHTTPHeadersOptions *clientSetHTTPHeadersOptions, blobHTTPHeaders *BlobHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientSetHTTPHeadersOptions != nil && clientSetHTTPHeadersOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientSetHTTPHeadersOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobCacheControl != nil {
		req.Raw().Header.Set("x-ms-blob-cache-control", *blobHTTPHeaders.BlobCacheControl)
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentType != nil {
		req.Raw().Header.Set("x-ms-blob-content-type", *blobHTTPHeaders.BlobContentType)
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentMD5 != nil {
		req.Raw().Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(blobHTTPHeaders.BlobContentMD5))
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentEncoding != nil {
		req.Raw().Header.Set("x-ms-blob-content-encoding", *blobHTTPHeaders.BlobContentEncoding)
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentLanguage != nil {
		req.Raw().Header.Set("x-ms-blob-content-language", *blobHTTPHeaders.BlobContentLanguage)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	if blobHTTPHeaders != nil && blobHTTPHeaders.BlobContentDisposition != nil {
		req.Raw().Header.Set("x-ms-blob-content-disposition", *blobHTTPHeaders.BlobContentDisposition)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientSetHTTPHeadersOptions != nil && clientSetHTTPHeadersOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientSetHTTPHeadersOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setHTTPHeadersHandleResponse handles the SetHTTPHeaders response.
func (client *client) setHTTPHeadersHandleResponse(resp *http.Response) (clientSetHTTPHeadersResponse, error) {
	result := clientSetHTTPHeadersResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetHTTPHeadersResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return clientSetHTTPHeadersResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetHTTPHeadersResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetImmutabilityPolicy - The Set Immutability Policy operation sets the immutability policy on the blob
// If the operation fails it returns an *azcore.ResponseError type.
// clientSetImmutabilityPolicyOptions - clientSetImmutabilityPolicyOptions contains the optional parameters for the client.SetImmutabilityPolicy
// method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) SetImmutabilityPolicy(ctx context.Context, comp Enum26, clientSetImmutabilityPolicyOptions *clientSetImmutabilityPolicyOptions, modifiedAccessConditions *ModifiedAccessConditions) (clientSetImmutabilityPolicyResponse, error) {
	req, err := client.setImmutabilityPolicyCreateRequest(ctx, comp, clientSetImmutabilityPolicyOptions, modifiedAccessConditions)
	if err != nil {
		return clientSetImmutabilityPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetImmutabilityPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientSetImmutabilityPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.setImmutabilityPolicyHandleResponse(resp)
}

// setImmutabilityPolicyCreateRequest creates the SetImmutabilityPolicy request.
func (client *client) setImmutabilityPolicyCreateRequest(ctx context.Context, comp Enum26, clientSetImmutabilityPolicyOptions *clientSetImmutabilityPolicyOptions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientSetImmutabilityPolicyOptions != nil && clientSetImmutabilityPolicyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientSetImmutabilityPolicyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientSetImmutabilityPolicyOptions != nil && clientSetImmutabilityPolicyOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientSetImmutabilityPolicyOptions.RequestID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if clientSetImmutabilityPolicyOptions != nil && clientSetImmutabilityPolicyOptions.ImmutabilityPolicyExpiry != nil {
		req.Raw().Header.Set("x-ms-immutability-policy-until-date", clientSetImmutabilityPolicyOptions.ImmutabilityPolicyExpiry.Format(time.RFC1123))
	}
	if clientSetImmutabilityPolicyOptions != nil && clientSetImmutabilityPolicyOptions.ImmutabilityPolicyMode != nil {
		req.Raw().Header.Set("x-ms-immutability-policy-mode", string(*clientSetImmutabilityPolicyOptions.ImmutabilityPolicyMode))
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setImmutabilityPolicyHandleResponse handles the SetImmutabilityPolicy response.
func (client *client) setImmutabilityPolicyHandleResponse(resp *http.Response) (clientSetImmutabilityPolicyResponse, error) {
	result := clientSetImmutabilityPolicyResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetImmutabilityPolicyResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-immutability-policy-until-date"); val != "" {
		immutabilityPolicyExpiry, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetImmutabilityPolicyResponse{}, err
		}
		result.ImmutabilityPolicyExpiry = &immutabilityPolicyExpiry
	}
	if val := resp.Header.Get("x-ms-immutability-policy-mode"); val != "" {
		result.ImmutabilityPolicyMode = (*BlobImmutabilityPolicyMode)(&val)
	}
	return result, nil
}

// SetLegalHold - The Set Legal Hold operation sets a legal hold on the blob.
// If the operation fails it returns an *azcore.ResponseError type.
// legalHold - Specified if a legal hold should be set on the blob.
// options - clientSetLegalHoldOptions contains the optional parameters for the client.SetLegalHold method.
func (client *client) SetLegalHold(ctx context.Context, comp Enum27, legalHold bool, options *clientSetLegalHoldOptions) (clientSetLegalHoldResponse, error) {
	req, err := client.setLegalHoldCreateRequest(ctx, comp, legalHold, options)
	if err != nil {
		return clientSetLegalHoldResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetLegalHoldResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientSetLegalHoldResponse{}, runtime.NewResponseError(resp)
	}
	return client.setLegalHoldHandleResponse(resp)
}

// setLegalHoldCreateRequest creates the SetLegalHold request.
func (client *client) setLegalHoldCreateRequest(ctx context.Context, comp Enum27, legalHold bool, options *clientSetLegalHoldOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("x-ms-legal-hold", strconv.FormatBool(legalHold))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setLegalHoldHandleResponse handles the SetLegalHold response.
func (client *client) setLegalHoldHandleResponse(resp *http.Response) (clientSetLegalHoldResponse, error) {
	result := clientSetLegalHoldResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetLegalHoldResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-legal-hold"); val != "" {
		legalHold, err := strconv.ParseBool(val)
		if err != nil {
			return clientSetLegalHoldResponse{}, err
		}
		result.LegalHold = &legalHold
	}
	return result, nil
}

// SetMetadata - The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value
// pairs
// If the operation fails it returns an *azcore.ResponseError type.
// clientSetMetadataOptions - clientSetMetadataOptions contains the optional parameters for the client.SetMetadata method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// CpkInfo - CpkInfo contains a group of parameters for the client.Download method.
// CpkScopeInfo - CpkScopeInfo contains a group of parameters for the client.SetMetadata method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) SetMetadata(ctx context.Context, comp Enum12, clientSetMetadataOptions *clientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (clientSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, comp, clientSetMetadataOptions, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if err != nil {
		return clientSetMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientSetMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *client) setMetadataCreateRequest(ctx context.Context, comp Enum12, clientSetMetadataOptions *clientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientSetMetadataOptions != nil && clientSetMetadataOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientSetMetadataOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if clientSetMetadataOptions != nil && clientSetMetadataOptions.Metadata != nil {
		for k, v := range clientSetMetadataOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Raw().Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySHA256 != nil {
		req.Raw().Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySHA256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Raw().Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Raw().Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientSetMetadataOptions != nil && clientSetMetadataOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientSetMetadataOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *client) setMetadataHandleResponse(resp *http.Response) (clientSetMetadataResponse, error) {
	result := clientSetMetadataResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return clientSetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return result, nil
}

// SetTags - The Set Tags operation enables users to set tags on a blob.
// If the operation fails it returns an *azcore.ResponseError type.
// clientSetTagsOptions - clientSetTagsOptions contains the optional parameters for the client.SetTags method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
func (client *client) SetTags(ctx context.Context, comp Enum42, clientSetTagsOptions *clientSetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (clientSetTagsResponse, error) {
	req, err := client.setTagsCreateRequest(ctx, comp, clientSetTagsOptions, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return clientSetTagsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return clientSetTagsResponse{}, runtime.NewResponseError(resp)
	}
	return client.setTagsHandleResponse(resp)
}

// setTagsCreateRequest creates the SetTags request.
func (client *client) setTagsCreateRequest(ctx context.Context, comp Enum42, clientSetTagsOptions *clientSetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientSetTagsOptions != nil && clientSetTagsOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientSetTagsOptions.Timeout), 10))
	}
	if clientSetTagsOptions != nil && clientSetTagsOptions.VersionID != nil {
		reqQP.Set("versionid", *clientSetTagsOptions.VersionID)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientSetTagsOptions != nil && clientSetTagsOptions.TransactionalContentMD5 != nil {
		req.Raw().Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(clientSetTagsOptions.TransactionalContentMD5))
	}
	if clientSetTagsOptions != nil && clientSetTagsOptions.TransactionalContentCRC64 != nil {
		req.Raw().Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(clientSetTagsOptions.TransactionalContentCRC64))
	}
	if clientSetTagsOptions != nil && clientSetTagsOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientSetTagsOptions.RequestID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	if clientSetTagsOptions != nil && clientSetTagsOptions.Tags != nil {
		return req, runtime.MarshalAsXML(req, *clientSetTagsOptions.Tags)
	}
	return req, nil
}

// setTagsHandleResponse handles the SetTags response.
func (client *client) setTagsHandleResponse(resp *http.Response) (clientSetTagsResponse, error) {
	result := clientSetTagsResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientSetTagsResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetTier - The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage
// account and on a block blob in a blob storage account (locally redundant storage only). A
// premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive
// storage type. This operation does not update the blob's ETag.
// If the operation fails it returns an *azcore.ResponseError type.
// tier - Indicates the tier to be set on the blob.
// clientSetTierOptions - clientSetTierOptions contains the optional parameters for the client.SetTier method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *client) SetTier(ctx context.Context, comp Enum32, tier AccessTier, clientSetTierOptions *clientSetTierOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (clientSetTierResponse, error) {
	req, err := client.setTierCreateRequest(ctx, comp, tier, clientSetTierOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return clientSetTierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientSetTierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return clientSetTierResponse{}, runtime.NewResponseError(resp)
	}
	return client.setTierHandleResponse(resp)
}

// setTierCreateRequest creates the SetTier request.
func (client *client) setTierCreateRequest(ctx context.Context, comp Enum32, tier AccessTier, clientSetTierOptions *clientSetTierOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if clientSetTierOptions != nil && clientSetTierOptions.Snapshot != nil {
		reqQP.Set("snapshot", *clientSetTierOptions.Snapshot)
	}
	if clientSetTierOptions != nil && clientSetTierOptions.VersionID != nil {
		reqQP.Set("versionid", *clientSetTierOptions.VersionID)
	}
	if clientSetTierOptions != nil && clientSetTierOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientSetTierOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-access-tier", string(tier))
	if clientSetTierOptions != nil && clientSetTierOptions.RehydratePriority != nil {
		req.Raw().Header.Set("x-ms-rehydrate-priority", string(*clientSetTierOptions.RehydratePriority))
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientSetTierOptions != nil && clientSetTierOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientSetTierOptions.RequestID)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setTierHandleResponse handles the SetTier response.
func (client *client) setTierHandleResponse(resp *http.Response) (clientSetTierResponse, error) {
	result := clientSetTierResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// StartCopyFromURL - The Start Copy From URL operation copies a blob or an internet resource to a new blob.
// If the operation fails it returns an *azcore.ResponseError type.
// copySource - Specifies the name of the source page blob snapshot. This value is a URL of up to 2 KB in length that specifies
// a page blob snapshot. The value should be URL-encoded as it would appear in a request
// URI. The source blob must either be public or must be authenticated via a shared access signature.
// clientStartCopyFromURLOptions - clientStartCopyFromURLOptions contains the optional parameters for the client.StartCopyFromURL
// method.
// SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the directoryClient.Rename
// method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
func (client *client) StartCopyFromURL(ctx context.Context, copySource string, clientStartCopyFromURLOptions *clientStartCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (clientStartCopyFromURLResponse, error) {
	req, err := client.startCopyFromURLCreateRequest(ctx, copySource, clientStartCopyFromURLOptions, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return clientStartCopyFromURLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientStartCopyFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return clientStartCopyFromURLResponse{}, runtime.NewResponseError(resp)
	}
	return client.startCopyFromURLHandleResponse(resp)
}

// startCopyFromURLCreateRequest creates the StartCopyFromURL request.
func (client *client) startCopyFromURLCreateRequest(ctx context.Context, copySource string, clientStartCopyFromURLOptions *clientStartCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*clientStartCopyFromURLOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.Metadata != nil {
		for k, v := range clientStartCopyFromURLOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.Tier != nil {
		req.Raw().Header.Set("x-ms-access-tier", string(*clientStartCopyFromURLOptions.Tier))
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.RehydratePriority != nil {
		req.Raw().Header.Set("x-ms-rehydrate-priority", string(*clientStartCopyFromURLOptions.RehydratePriority))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfTags != nil {
		req.Raw().Header.Set("x-ms-source-if-tags", *sourceModifiedAccessConditions.SourceIfTags)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Raw().Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Raw().Header.Set("x-ms-copy-source", copySource)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *clientStartCopyFromURLOptions.RequestID)
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.BlobTagsString != nil {
		req.Raw().Header.Set("x-ms-tags", *clientStartCopyFromURLOptions.BlobTagsString)
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.SealBlob != nil {
		req.Raw().Header.Set("x-ms-seal-blob", strconv.FormatBool(*clientStartCopyFromURLOptions.SealBlob))
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.ImmutabilityPolicyExpiry != nil {
		req.Raw().Header.Set("x-ms-immutability-policy-until-date", clientStartCopyFromURLOptions.ImmutabilityPolicyExpiry.Format(time.RFC1123))
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.ImmutabilityPolicyMode != nil {
		req.Raw().Header.Set("x-ms-immutability-policy-mode", string(*clientStartCopyFromURLOptions.ImmutabilityPolicyMode))
	}
	if clientStartCopyFromURLOptions != nil && clientStartCopyFromURLOptions.LegalHold != nil {
		req.Raw().Header.Set("x-ms-legal-hold", strconv.FormatBool(*clientStartCopyFromURLOptions.LegalHold))
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// startCopyFromURLHandleResponse handles the StartCopyFromURL response.
func (client *client) startCopyFromURLHandleResponse(resp *http.Response) (clientStartCopyFromURLResponse, error) {
	result := clientStartCopyFromURLResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientStartCopyFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientStartCopyFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	return result, nil
}

// Undelete - Undelete a blob that was previously soft deleted
// If the operation fails it returns an *azcore.ResponseError type.
// options - clientUndeleteOptions contains the optional parameters for the client.Undelete method.
func (client *client) Undelete(ctx context.Context, comp Enum14, options *clientUndeleteOptions) (clientUndeleteResponse, error) {
	req, err := client.undeleteCreateRequest(ctx, comp, options)
	if err != nil {
		return clientUndeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return clientUndeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return clientUndeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.undeleteHandleResponse(resp)
}

// undeleteCreateRequest creates the Undelete request.
func (client *client) undeleteCreateRequest(ctx context.Context, comp Enum14, options *clientUndeleteOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", string(comp))
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// undeleteHandleResponse handles the Undelete response.
func (client *client) undeleteHandleResponse(resp *http.Response) (clientUndeleteResponse, error) {
	result := clientUndeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return clientUndeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}
