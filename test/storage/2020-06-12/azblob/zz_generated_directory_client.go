//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"time"
)

type directoryClient struct {
	endpoint       string
	version        Enum2
	pathRenameMode *PathRenameMode
	pl             runtime.Pipeline
}

// newDirectoryClient creates a new instance of directoryClient with the specified values.
// endpoint - The URL of the service account, container, or blob that is the targe of the desired operation.
// version - Specifies the version of the operation to use for this request.
// pathRenameMode - Determines the behavior of the rename operation
// pl - the pipeline used for sending requests and handling responses.
func newDirectoryClient(endpoint string, version Enum2, pathRenameMode *PathRenameMode, pl runtime.Pipeline) *directoryClient {
	client := &directoryClient{
		endpoint:       endpoint,
		version:        version,
		pathRenameMode: pathRenameMode,
		pl:             pl,
	}
	return client
}

// Create - Create a directory. By default, the destination is overwritten and if the destination already exists and has a
// lease the lease is broken. This operation supports conditional HTTP requests. For more
// information, see Specifying Conditional Headers for Blob Service Operations [https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations].
// To
// fail if the destination already exists, use a conditional request with If-None-Match: "*".
// If the operation fails it returns the *DataLakeStorageError error type.
// directoryClientCreateOptions - directoryClientCreateOptions contains the optional parameters for the directoryClient.Create
// method.
// DirectoryHTTPHeaders - DirectoryHTTPHeaders contains a group of parameters for the directoryClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *directoryClient) Create(ctx context.Context, resource Enum20, directoryClientCreateOptions *directoryClientCreateOptions, directoryHTTPHeaders *DirectoryHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (directoryClientCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, resource, directoryClientCreateOptions, directoryHTTPHeaders, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return directoryClientCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return directoryClientCreateResponse{}, client.createHandleError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *directoryClient) createCreateRequest(ctx context.Context, resource Enum20, directoryClientCreateOptions *directoryClientCreateOptions, directoryHTTPHeaders *DirectoryHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("resource", string(resource))
	if directoryClientCreateOptions != nil && directoryClientCreateOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*directoryClientCreateOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if directoryClientCreateOptions != nil && directoryClientCreateOptions.DirectoryProperties != nil {
		req.Raw().Header.Set("x-ms-properties", *directoryClientCreateOptions.DirectoryProperties)
	}
	if directoryClientCreateOptions != nil && directoryClientCreateOptions.PosixPermissions != nil {
		req.Raw().Header.Set("x-ms-permissions", *directoryClientCreateOptions.PosixPermissions)
	}
	if directoryClientCreateOptions != nil && directoryClientCreateOptions.PosixUmask != nil {
		req.Raw().Header.Set("x-ms-umask", *directoryClientCreateOptions.PosixUmask)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.CacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *directoryHTTPHeaders.CacheControl)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *directoryHTTPHeaders.ContentType)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *directoryHTTPHeaders.ContentEncoding)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *directoryHTTPHeaders.ContentLanguage)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *directoryHTTPHeaders.ContentDisposition)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if directoryClientCreateOptions != nil && directoryClientCreateOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *directoryClientCreateOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *directoryClient) createHandleResponse(resp *http.Response) (directoryClientCreateResponse, error) {
	result := directoryClientCreateResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return directoryClientCreateResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientCreateResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// createHandleError handles the Create error response.
func (client *directoryClient) createHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DataLakeStorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - Deletes the directory
// If the operation fails it returns the *DataLakeStorageError error type.
// recursiveDirectoryDelete - If "true", all paths beneath the directory will be deleted. If "false" and the directory is
// non-empty, an error occurs.
// directoryClientDeleteOptions - directoryClientDeleteOptions contains the optional parameters for the directoryClient.Delete
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *directoryClient) Delete(ctx context.Context, recursiveDirectoryDelete bool, directoryClientDeleteOptions *directoryClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (directoryClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, recursiveDirectoryDelete, directoryClientDeleteOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return directoryClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientDeleteResponse{}, client.deleteHandleError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *directoryClient) deleteCreateRequest(ctx context.Context, recursiveDirectoryDelete bool, directoryClientDeleteOptions *directoryClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if directoryClientDeleteOptions != nil && directoryClientDeleteOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*directoryClientDeleteOptions.Timeout), 10))
	}
	reqQP.Set("recursive", strconv.FormatBool(recursiveDirectoryDelete))
	if directoryClientDeleteOptions != nil && directoryClientDeleteOptions.Marker != nil {
		reqQP.Set("continuation", *directoryClientDeleteOptions.Marker)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if directoryClientDeleteOptions != nil && directoryClientDeleteOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *directoryClientDeleteOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *directoryClient) deleteHandleResponse(resp *http.Response) (directoryClientDeleteResponse, error) {
	result := directoryClientDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-continuation"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client *directoryClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DataLakeStorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAccessControl - Get the owner, group, permissions, or access control list for a directory.
// If the operation fails it returns the *DataLakeStorageError error type.
// directoryClientGetAccessControlOptions - directoryClientGetAccessControlOptions contains the optional parameters for the
// directoryClient.GetAccessControl method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *directoryClient) GetAccessControl(ctx context.Context, action Enum22, directoryClientGetAccessControlOptions *directoryClientGetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (directoryClientGetAccessControlResponse, error) {
	req, err := client.getAccessControlCreateRequest(ctx, action, directoryClientGetAccessControlOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return directoryClientGetAccessControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientGetAccessControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientGetAccessControlResponse{}, client.getAccessControlHandleError(resp)
	}
	return client.getAccessControlHandleResponse(resp)
}

// getAccessControlCreateRequest creates the GetAccessControl request.
func (client *directoryClient) getAccessControlCreateRequest(ctx context.Context, action Enum22, directoryClientGetAccessControlOptions *directoryClientGetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodHead, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("action", string(action))
	if directoryClientGetAccessControlOptions != nil && directoryClientGetAccessControlOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*directoryClientGetAccessControlOptions.Timeout), 10))
	}
	if directoryClientGetAccessControlOptions != nil && directoryClientGetAccessControlOptions.Upn != nil {
		reqQP.Set("upn", strconv.FormatBool(*directoryClientGetAccessControlOptions.Upn))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if directoryClientGetAccessControlOptions != nil && directoryClientGetAccessControlOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *directoryClientGetAccessControlOptions.RequestID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccessControlHandleResponse handles the GetAccessControl response.
func (client *directoryClient) getAccessControlHandleResponse(resp *http.Response) (directoryClientGetAccessControlResponse, error) {
	result := directoryClientGetAccessControlResponse{RawResponse: resp}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientGetAccessControlResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientGetAccessControlResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-owner"); val != "" {
		result.XMSOwner = &val
	}
	if val := resp.Header.Get("x-ms-group"); val != "" {
		result.XMSGroup = &val
	}
	if val := resp.Header.Get("x-ms-permissions"); val != "" {
		result.XMSPermissions = &val
	}
	if val := resp.Header.Get("x-ms-acl"); val != "" {
		result.XMSACL = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// getAccessControlHandleError handles the GetAccessControl error response.
func (client *directoryClient) getAccessControlHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DataLakeStorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Rename - Rename a directory. By default, the destination is overwritten and if the destination already exists and has a
// lease the lease is broken. This operation supports conditional HTTP requests. For more
// information, see Specifying Conditional Headers for Blob Service Operations [https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations].
// To
// fail if the destination already exists, use a conditional request with If-None-Match: "*".
// If the operation fails it returns the *DataLakeStorageError error type.
// renameSource - The file or directory to be renamed. The value must have the following format: "/{filesysystem}/{path}".
// If "x-ms-properties" is specified, the properties will overwrite the existing properties;
// otherwise, the existing properties will be preserved.
// directoryClientRenameOptions - directoryClientRenameOptions contains the optional parameters for the directoryClient.Rename
// method.
// DirectoryHTTPHeaders - DirectoryHTTPHeaders contains a group of parameters for the directoryClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
// SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the directoryClient.Rename
// method.
func (client *directoryClient) Rename(ctx context.Context, renameSource string, directoryClientRenameOptions *directoryClientRenameOptions, directoryHTTPHeaders *DirectoryHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (directoryClientRenameResponse, error) {
	req, err := client.renameCreateRequest(ctx, renameSource, directoryClientRenameOptions, directoryHTTPHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions)
	if err != nil {
		return directoryClientRenameResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientRenameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return directoryClientRenameResponse{}, client.renameHandleError(resp)
	}
	return client.renameHandleResponse(resp)
}

// renameCreateRequest creates the Rename request.
func (client *directoryClient) renameCreateRequest(ctx context.Context, renameSource string, directoryClientRenameOptions *directoryClientRenameOptions, directoryHTTPHeaders *DirectoryHTTPHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*directoryClientRenameOptions.Timeout), 10))
	}
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.Marker != nil {
		reqQP.Set("continuation", *directoryClientRenameOptions.Marker)
	}
	if client.pathRenameMode != nil {
		reqQP.Set("mode", string(*client.pathRenameMode))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-rename-source", renameSource)
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.DirectoryProperties != nil {
		req.Raw().Header.Set("x-ms-properties", *directoryClientRenameOptions.DirectoryProperties)
	}
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.PosixPermissions != nil {
		req.Raw().Header.Set("x-ms-permissions", *directoryClientRenameOptions.PosixPermissions)
	}
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.PosixUmask != nil {
		req.Raw().Header.Set("x-ms-umask", *directoryClientRenameOptions.PosixUmask)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.CacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *directoryHTTPHeaders.CacheControl)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *directoryHTTPHeaders.ContentType)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *directoryHTTPHeaders.ContentEncoding)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *directoryHTTPHeaders.ContentLanguage)
	}
	if directoryHTTPHeaders != nil && directoryHTTPHeaders.ContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *directoryHTTPHeaders.ContentDisposition)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.SourceLeaseID != nil {
		req.Raw().Header.Set("x-ms-source-lease-id", *directoryClientRenameOptions.SourceLeaseID)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Raw().Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Raw().Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	if directoryClientRenameOptions != nil && directoryClientRenameOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *directoryClientRenameOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// renameHandleResponse handles the Rename response.
func (client *directoryClient) renameHandleResponse(resp *http.Response) (directoryClientRenameResponse, error) {
	result := directoryClientRenameResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-continuation"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientRenameResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return directoryClientRenameResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientRenameResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// renameHandleError handles the Rename error response.
func (client *directoryClient) renameHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DataLakeStorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetAccessControl - Set the owner, group, permissions, or access control list for a directory.
// If the operation fails it returns the *DataLakeStorageError error type.
// directoryClientSetAccessControlOptions - directoryClientSetAccessControlOptions contains the optional parameters for the
// directoryClient.SetAccessControl method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the containerClient.GetProperties method.
// ModifiedAccessConditions - ModifiedAccessConditions contains a group of parameters for the containerClient.Delete method.
func (client *directoryClient) SetAccessControl(ctx context.Context, action Enum21, directoryClientSetAccessControlOptions *directoryClientSetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (directoryClientSetAccessControlResponse, error) {
	req, err := client.setAccessControlCreateRequest(ctx, action, directoryClientSetAccessControlOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return directoryClientSetAccessControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientSetAccessControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientSetAccessControlResponse{}, client.setAccessControlHandleError(resp)
	}
	return client.setAccessControlHandleResponse(resp)
}

// setAccessControlCreateRequest creates the SetAccessControl request.
func (client *directoryClient) setAccessControlCreateRequest(ctx context.Context, action Enum21, directoryClientSetAccessControlOptions *directoryClientSetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPatch, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("action", string(action))
	if directoryClientSetAccessControlOptions != nil && directoryClientSetAccessControlOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*directoryClientSetAccessControlOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if directoryClientSetAccessControlOptions != nil && directoryClientSetAccessControlOptions.Owner != nil {
		req.Raw().Header.Set("x-ms-owner", *directoryClientSetAccessControlOptions.Owner)
	}
	if directoryClientSetAccessControlOptions != nil && directoryClientSetAccessControlOptions.Group != nil {
		req.Raw().Header.Set("x-ms-group", *directoryClientSetAccessControlOptions.Group)
	}
	if directoryClientSetAccessControlOptions != nil && directoryClientSetAccessControlOptions.PosixPermissions != nil {
		req.Raw().Header.Set("x-ms-permissions", *directoryClientSetAccessControlOptions.PosixPermissions)
	}
	if directoryClientSetAccessControlOptions != nil && directoryClientSetAccessControlOptions.PosixACL != nil {
		req.Raw().Header.Set("x-ms-acl", *directoryClientSetAccessControlOptions.PosixACL)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Raw().Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Raw().Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Raw().Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Raw().Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if directoryClientSetAccessControlOptions != nil && directoryClientSetAccessControlOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *directoryClientSetAccessControlOptions.RequestID)
	}
	req.Raw().Header.Set("x-ms-version", string(client.version))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setAccessControlHandleResponse handles the SetAccessControl response.
func (client *directoryClient) setAccessControlHandleResponse(resp *http.Response) (directoryClientSetAccessControlResponse, error) {
	result := directoryClientSetAccessControlResponse{RawResponse: resp}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientSetAccessControlResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientSetAccessControlResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// setAccessControlHandleError handles the SetAccessControl error response.
func (client *directoryClient) setAccessControlHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DataLakeStorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
