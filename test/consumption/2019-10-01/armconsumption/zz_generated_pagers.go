//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armconsumption

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// BudgetsClientListPager provides operations for iterating over paged responses.
type BudgetsClientListPager struct {
	client    *BudgetsClient
	current   BudgetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BudgetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BudgetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BudgetsListResult.NextLink == nil || len(*p.current.BudgetsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BudgetsClientListPager) NextPage(ctx context.Context) (BudgetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BudgetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return BudgetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return BudgetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BudgetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return BudgetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventsClientListPager provides operations for iterating over paged responses.
type EventsClientListPager struct {
	client    *EventsClient
	current   EventsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.Events.NextLink == nil || len(*p.current.Events.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventsClientListPager) NextPage(ctx context.Context) (EventsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return EventsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return EventsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return EventsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LotsClientListPager provides operations for iterating over paged responses.
type LotsClientListPager struct {
	client    *LotsClient
	current   LotsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LotsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LotsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.Lots.NextLink == nil || len(*p.current.Lots.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LotsClientListPager) NextPage(ctx context.Context) (LotsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LotsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return LotsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return LotsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LotsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return LotsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// MarketplacesClientListPager provides operations for iterating over paged responses.
type MarketplacesClientListPager struct {
	client    *MarketplacesClient
	current   MarketplacesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, MarketplacesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *MarketplacesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.MarketplacesListResult.NextLink == nil || len(*p.current.MarketplacesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *MarketplacesClientListPager) NextPage(ctx context.Context) (MarketplacesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return MarketplacesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return MarketplacesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return MarketplacesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return MarketplacesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return MarketplacesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationRecommendationsClientListPager provides operations for iterating over paged responses.
type ReservationRecommendationsClientListPager struct {
	client    *ReservationRecommendationsClient
	current   ReservationRecommendationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationRecommendationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationRecommendationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationRecommendationsListResult.NextLink == nil || len(*p.current.ReservationRecommendationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationRecommendationsClientListPager) NextPage(ctx context.Context) (ReservationRecommendationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationRecommendationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationRecommendationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationRecommendationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {

		return ReservationRecommendationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return ReservationRecommendationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationTransactionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type ReservationTransactionsClientListByBillingProfilePager struct {
	client    *ReservationTransactionsClient
	current   ReservationTransactionsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationTransactionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationTransactionsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ModernReservationTransactionsListResult.NextLink == nil || len(*p.current.ModernReservationTransactionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationTransactionsClientListByBillingProfilePager) NextPage(ctx context.Context) (ReservationTransactionsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationTransactionsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationTransactionsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationTransactionsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationTransactionsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {

		return ReservationTransactionsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationTransactionsClientListPager provides operations for iterating over paged responses.
type ReservationTransactionsClientListPager struct {
	client    *ReservationTransactionsClient
	current   ReservationTransactionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationTransactionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationTransactionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationTransactionsListResult.NextLink == nil || len(*p.current.ReservationTransactionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationTransactionsClientListPager) NextPage(ctx context.Context) (ReservationTransactionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationTransactionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationTransactionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationTransactionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationTransactionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return ReservationTransactionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsDetailsClientListByReservationOrderAndReservationPager provides operations for iterating over paged responses.
type ReservationsDetailsClientListByReservationOrderAndReservationPager struct {
	client    *ReservationsDetailsClient
	current   ReservationsDetailsClientListByReservationOrderAndReservationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsDetailsClientListByReservationOrderAndReservationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsDetailsClientListByReservationOrderAndReservationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationDetailsListResult.NextLink == nil || len(*p.current.ReservationDetailsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsDetailsClientListByReservationOrderAndReservationPager) NextPage(ctx context.Context) (ReservationsDetailsClientListByReservationOrderAndReservationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsDetailsClientListByReservationOrderAndReservationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationsDetailsClientListByReservationOrderAndReservationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationsDetailsClientListByReservationOrderAndReservationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsDetailsClientListByReservationOrderAndReservationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByReservationOrderAndReservationHandleResponse(resp)
	if err != nil {

		return ReservationsDetailsClientListByReservationOrderAndReservationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsDetailsClientListByReservationOrderPager provides operations for iterating over paged responses.
type ReservationsDetailsClientListByReservationOrderPager struct {
	client    *ReservationsDetailsClient
	current   ReservationsDetailsClientListByReservationOrderResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsDetailsClientListByReservationOrderResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsDetailsClientListByReservationOrderPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationDetailsListResult.NextLink == nil || len(*p.current.ReservationDetailsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsDetailsClientListByReservationOrderPager) NextPage(ctx context.Context) (ReservationsDetailsClientListByReservationOrderResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsDetailsClientListByReservationOrderResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationsDetailsClientListByReservationOrderResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationsDetailsClientListByReservationOrderResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsDetailsClientListByReservationOrderResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByReservationOrderHandleResponse(resp)
	if err != nil {

		return ReservationsDetailsClientListByReservationOrderResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsDetailsClientListPager provides operations for iterating over paged responses.
type ReservationsDetailsClientListPager struct {
	client    *ReservationsDetailsClient
	current   ReservationsDetailsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsDetailsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsDetailsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationDetailsListResult.NextLink == nil || len(*p.current.ReservationDetailsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsDetailsClientListPager) NextPage(ctx context.Context) (ReservationsDetailsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsDetailsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationsDetailsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationsDetailsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsDetailsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return ReservationsDetailsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsSummariesClientListByReservationOrderAndReservationPager provides operations for iterating over paged responses.
type ReservationsSummariesClientListByReservationOrderAndReservationPager struct {
	client    *ReservationsSummariesClient
	current   ReservationsSummariesClientListByReservationOrderAndReservationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsSummariesClientListByReservationOrderAndReservationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsSummariesClientListByReservationOrderAndReservationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationSummariesListResult.NextLink == nil || len(*p.current.ReservationSummariesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsSummariesClientListByReservationOrderAndReservationPager) NextPage(ctx context.Context) (ReservationsSummariesClientListByReservationOrderAndReservationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsSummariesClientListByReservationOrderAndReservationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationsSummariesClientListByReservationOrderAndReservationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationsSummariesClientListByReservationOrderAndReservationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsSummariesClientListByReservationOrderAndReservationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByReservationOrderAndReservationHandleResponse(resp)
	if err != nil {

		return ReservationsSummariesClientListByReservationOrderAndReservationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsSummariesClientListByReservationOrderPager provides operations for iterating over paged responses.
type ReservationsSummariesClientListByReservationOrderPager struct {
	client    *ReservationsSummariesClient
	current   ReservationsSummariesClientListByReservationOrderResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsSummariesClientListByReservationOrderResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsSummariesClientListByReservationOrderPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationSummariesListResult.NextLink == nil || len(*p.current.ReservationSummariesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsSummariesClientListByReservationOrderPager) NextPage(ctx context.Context) (ReservationsSummariesClientListByReservationOrderResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsSummariesClientListByReservationOrderResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationsSummariesClientListByReservationOrderResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationsSummariesClientListByReservationOrderResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsSummariesClientListByReservationOrderResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByReservationOrderHandleResponse(resp)
	if err != nil {

		return ReservationsSummariesClientListByReservationOrderResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsSummariesClientListPager provides operations for iterating over paged responses.
type ReservationsSummariesClientListPager struct {
	client    *ReservationsSummariesClient
	current   ReservationsSummariesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsSummariesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsSummariesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationSummariesListResult.NextLink == nil || len(*p.current.ReservationSummariesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsSummariesClientListPager) NextPage(ctx context.Context) (ReservationsSummariesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsSummariesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return ReservationsSummariesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return ReservationsSummariesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsSummariesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return ReservationsSummariesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UsageDetailsClientListPager provides operations for iterating over paged responses.
type UsageDetailsClientListPager struct {
	client    *UsageDetailsClient
	current   UsageDetailsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsageDetailsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UsageDetailsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsageDetailsListResult.NextLink == nil || len(*p.current.UsageDetailsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UsageDetailsClientListPager) NextPage(ctx context.Context) (UsageDetailsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UsageDetailsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {

		return UsageDetailsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {

		return UsageDetailsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UsageDetailsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {

		return UsageDetailsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
