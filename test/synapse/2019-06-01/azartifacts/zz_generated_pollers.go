//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"time"
)

// dataFlowClientCreateOrUpdateDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientCreateOrUpdateDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Poll(ctx context.Context) (dataFlowClientCreateOrUpdateDataFlowResponse, error) {
	result := dataFlowClientCreateOrUpdateDataFlowResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.DataFlowResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientCreateOrUpdateDataFlowResponse, error) {
	result := dataFlowClientCreateOrUpdateDataFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DataFlowResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowClientCreateOrUpdateDataFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Resume(ctx context.Context, client *dataFlowClient, token string) (dataFlowClientCreateOrUpdateDataFlowResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("dataFlowClient.CreateOrUpdateDataFlow", token, client.pl); err != nil {
		return dataFlowClientCreateOrUpdateDataFlowResponse{}, err
	}
	return p.Poll(ctx)
}

// dataFlowClientDeleteDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientDeleteDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientDeleteDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowClientDeleteDataFlowPoller) Poll(ctx context.Context) (dataFlowClientDeleteDataFlowResponse, error) {
	result := dataFlowClientDeleteDataFlowResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowClientDeleteDataFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientDeleteDataFlowResponse, error) {
	result := dataFlowClientDeleteDataFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowClientDeleteDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowClientDeleteDataFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowClientDeleteDataFlowPoller) Resume(ctx context.Context, client *dataFlowClient, token string) (dataFlowClientDeleteDataFlowResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("dataFlowClient.DeleteDataFlow", token, client.pl); err != nil {
		return dataFlowClientDeleteDataFlowResponse{}, err
	}
	return p.Poll(ctx)
}

// dataFlowClientRenameDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientRenameDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientRenameDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowClientRenameDataFlowPoller) Poll(ctx context.Context) (dataFlowClientRenameDataFlowResponse, error) {
	result := dataFlowClientRenameDataFlowResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowClientRenameDataFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientRenameDataFlowResponse, error) {
	result := dataFlowClientRenameDataFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowClientRenameDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowClientRenameDataFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowClientRenameDataFlowPoller) Resume(ctx context.Context, client *dataFlowClient, token string) (dataFlowClientRenameDataFlowResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("dataFlowClient.RenameDataFlow", token, client.pl); err != nil {
		return dataFlowClientRenameDataFlowResponse{}, err
	}
	return p.Poll(ctx)
}

// dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Poll(ctx context.Context) (dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, error) {
	result := dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.CreateDataFlowDebugSessionResponse)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, error) {
	result := dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.CreateDataFlowDebugSessionResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Resume(ctx context.Context, client *dataFlowDebugSessionClient, token string) (dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("dataFlowDebugSessionClient.CreateDataFlowDebugSession", token, client.pl); err != nil {
		return dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}, err
	}
	return p.Poll(ctx)
}

// dataFlowDebugSessionClientExecuteCommandPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowDebugSessionClientExecuteCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Poll(ctx context.Context) (dataFlowDebugSessionClientExecuteCommandResponse, error) {
	result := dataFlowDebugSessionClientExecuteCommandResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.DataFlowDebugCommandResponse)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowDebugSessionClientExecuteCommandResponse, error) {
	result := dataFlowDebugSessionClientExecuteCommandResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DataFlowDebugCommandResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowDebugSessionClientExecuteCommandPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Resume(ctx context.Context, client *dataFlowDebugSessionClient, token string) (dataFlowDebugSessionClientExecuteCommandResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("dataFlowDebugSessionClient.ExecuteCommand", token, client.pl); err != nil {
		return dataFlowDebugSessionClientExecuteCommandResponse{}, err
	}
	return p.Poll(ctx)
}

// datasetClientCreateOrUpdateDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientCreateOrUpdateDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientCreateOrUpdateDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *datasetClientCreateOrUpdateDatasetPoller) Poll(ctx context.Context) (datasetClientCreateOrUpdateDatasetResponse, error) {
	result := datasetClientCreateOrUpdateDatasetResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.DatasetResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *datasetClientCreateOrUpdateDatasetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientCreateOrUpdateDatasetResponse, error) {
	result := datasetClientCreateOrUpdateDatasetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DatasetResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *datasetClientCreateOrUpdateDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a datasetClientCreateOrUpdateDatasetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *datasetClientCreateOrUpdateDatasetPoller) Resume(ctx context.Context, client *datasetClient, token string) (datasetClientCreateOrUpdateDatasetResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("datasetClient.CreateOrUpdateDataset", token, client.pl); err != nil {
		return datasetClientCreateOrUpdateDatasetResponse{}, err
	}
	return p.Poll(ctx)
}

// datasetClientDeleteDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientDeleteDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientDeleteDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *datasetClientDeleteDatasetPoller) Poll(ctx context.Context) (datasetClientDeleteDatasetResponse, error) {
	result := datasetClientDeleteDatasetResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *datasetClientDeleteDatasetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientDeleteDatasetResponse, error) {
	result := datasetClientDeleteDatasetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *datasetClientDeleteDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a datasetClientDeleteDatasetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *datasetClientDeleteDatasetPoller) Resume(ctx context.Context, client *datasetClient, token string) (datasetClientDeleteDatasetResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("datasetClient.DeleteDataset", token, client.pl); err != nil {
		return datasetClientDeleteDatasetResponse{}, err
	}
	return p.Poll(ctx)
}

// datasetClientRenameDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientRenameDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientRenameDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *datasetClientRenameDatasetPoller) Poll(ctx context.Context) (datasetClientRenameDatasetResponse, error) {
	result := datasetClientRenameDatasetResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *datasetClientRenameDatasetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientRenameDatasetResponse, error) {
	result := datasetClientRenameDatasetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *datasetClientRenameDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a datasetClientRenameDatasetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *datasetClientRenameDatasetPoller) Resume(ctx context.Context, client *datasetClient, token string) (datasetClientRenameDatasetResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("datasetClient.RenameDataset", token, client.pl); err != nil {
		return datasetClientRenameDatasetResponse{}, err
	}
	return p.Poll(ctx)
}

// libraryClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type libraryClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *libraryClientCreatePoller) Poll(ctx context.Context) (libraryClientCreateResponse, error) {
	result := libraryClientCreateResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.LibraryResourceInfo)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *libraryClientCreatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientCreateResponse, error) {
	result := libraryClientCreateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LibraryResourceInfo)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *libraryClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a libraryClientCreatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *libraryClientCreatePoller) Resume(ctx context.Context, client *libraryClient, token string) (libraryClientCreateResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("libraryClient.Create", token, client.pl); err != nil {
		return libraryClientCreateResponse{}, err
	}
	return p.Poll(ctx)
}

// libraryClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type libraryClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *libraryClientDeletePoller) Poll(ctx context.Context) (libraryClientDeleteResponse, error) {
	result := libraryClientDeleteResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.LibraryResourceInfo)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *libraryClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientDeleteResponse, error) {
	result := libraryClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LibraryResourceInfo)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *libraryClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a libraryClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *libraryClientDeletePoller) Resume(ctx context.Context, client *libraryClient, token string) (libraryClientDeleteResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("libraryClient.Delete", token, client.pl); err != nil {
		return libraryClientDeleteResponse{}, err
	}
	return p.Poll(ctx)
}

// libraryClientFlushPoller provides polling facilities until the operation reaches a terminal state.
type libraryClientFlushPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientFlushPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *libraryClientFlushPoller) Poll(ctx context.Context) (libraryClientFlushResponse, error) {
	result := libraryClientFlushResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.LibraryResourceInfo)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *libraryClientFlushPoller) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientFlushResponse, error) {
	result := libraryClientFlushResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LibraryResourceInfo)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *libraryClientFlushPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a libraryClientFlushPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *libraryClientFlushPoller) Resume(ctx context.Context, client *libraryClient, token string) (libraryClientFlushResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("libraryClient.Flush", token, client.pl); err != nil {
		return libraryClientFlushResponse{}, err
	}
	return p.Poll(ctx)
}

// linkedServiceClientCreateOrUpdateLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientCreateOrUpdateLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Poll(ctx context.Context) (linkedServiceClientCreateOrUpdateLinkedServiceResponse, error) {
	result := linkedServiceClientCreateOrUpdateLinkedServiceResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.LinkedServiceResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientCreateOrUpdateLinkedServiceResponse, error) {
	result := linkedServiceClientCreateOrUpdateLinkedServiceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LinkedServiceResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a linkedServiceClientCreateOrUpdateLinkedServicePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Resume(ctx context.Context, client *linkedServiceClient, token string) (linkedServiceClientCreateOrUpdateLinkedServiceResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("linkedServiceClient.CreateOrUpdateLinkedService", token, client.pl); err != nil {
		return linkedServiceClientCreateOrUpdateLinkedServiceResponse{}, err
	}
	return p.Poll(ctx)
}

// linkedServiceClientDeleteLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientDeleteLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientDeleteLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *linkedServiceClientDeleteLinkedServicePoller) Poll(ctx context.Context) (linkedServiceClientDeleteLinkedServiceResponse, error) {
	result := linkedServiceClientDeleteLinkedServiceResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *linkedServiceClientDeleteLinkedServicePoller) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientDeleteLinkedServiceResponse, error) {
	result := linkedServiceClientDeleteLinkedServiceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *linkedServiceClientDeleteLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a linkedServiceClientDeleteLinkedServicePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *linkedServiceClientDeleteLinkedServicePoller) Resume(ctx context.Context, client *linkedServiceClient, token string) (linkedServiceClientDeleteLinkedServiceResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("linkedServiceClient.DeleteLinkedService", token, client.pl); err != nil {
		return linkedServiceClientDeleteLinkedServiceResponse{}, err
	}
	return p.Poll(ctx)
}

// linkedServiceClientRenameLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientRenameLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientRenameLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *linkedServiceClientRenameLinkedServicePoller) Poll(ctx context.Context) (linkedServiceClientRenameLinkedServiceResponse, error) {
	result := linkedServiceClientRenameLinkedServiceResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *linkedServiceClientRenameLinkedServicePoller) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientRenameLinkedServiceResponse, error) {
	result := linkedServiceClientRenameLinkedServiceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *linkedServiceClientRenameLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a linkedServiceClientRenameLinkedServicePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *linkedServiceClientRenameLinkedServicePoller) Resume(ctx context.Context, client *linkedServiceClient, token string) (linkedServiceClientRenameLinkedServiceResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("linkedServiceClient.RenameLinkedService", token, client.pl); err != nil {
		return linkedServiceClientRenameLinkedServiceResponse{}, err
	}
	return p.Poll(ctx)
}

// notebookClientCreateOrUpdateNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientCreateOrUpdateNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientCreateOrUpdateNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *notebookClientCreateOrUpdateNotebookPoller) Poll(ctx context.Context) (notebookClientCreateOrUpdateNotebookResponse, error) {
	result := notebookClientCreateOrUpdateNotebookResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.NotebookResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *notebookClientCreateOrUpdateNotebookPoller) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientCreateOrUpdateNotebookResponse, error) {
	result := notebookClientCreateOrUpdateNotebookResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.NotebookResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *notebookClientCreateOrUpdateNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a notebookClientCreateOrUpdateNotebookPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *notebookClientCreateOrUpdateNotebookPoller) Resume(ctx context.Context, client *notebookClient, token string) (notebookClientCreateOrUpdateNotebookResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("notebookClient.CreateOrUpdateNotebook", token, client.pl); err != nil {
		return notebookClientCreateOrUpdateNotebookResponse{}, err
	}
	return p.Poll(ctx)
}

// notebookClientDeleteNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientDeleteNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientDeleteNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *notebookClientDeleteNotebookPoller) Poll(ctx context.Context) (notebookClientDeleteNotebookResponse, error) {
	result := notebookClientDeleteNotebookResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *notebookClientDeleteNotebookPoller) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientDeleteNotebookResponse, error) {
	result := notebookClientDeleteNotebookResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *notebookClientDeleteNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a notebookClientDeleteNotebookPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *notebookClientDeleteNotebookPoller) Resume(ctx context.Context, client *notebookClient, token string) (notebookClientDeleteNotebookResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("notebookClient.DeleteNotebook", token, client.pl); err != nil {
		return notebookClientDeleteNotebookResponse{}, err
	}
	return p.Poll(ctx)
}

// notebookClientRenameNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientRenameNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientRenameNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *notebookClientRenameNotebookPoller) Poll(ctx context.Context) (notebookClientRenameNotebookResponse, error) {
	result := notebookClientRenameNotebookResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *notebookClientRenameNotebookPoller) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientRenameNotebookResponse, error) {
	result := notebookClientRenameNotebookResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *notebookClientRenameNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a notebookClientRenameNotebookPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *notebookClientRenameNotebookPoller) Resume(ctx context.Context, client *notebookClient, token string) (notebookClientRenameNotebookResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("notebookClient.RenameNotebook", token, client.pl); err != nil {
		return notebookClientRenameNotebookResponse{}, err
	}
	return p.Poll(ctx)
}

// pipelineClientCreateOrUpdatePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientCreateOrUpdatePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Poll(ctx context.Context) (pipelineClientCreateOrUpdatePipelineResponse, error) {
	result := pipelineClientCreateOrUpdatePipelineResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.PipelineResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *pipelineClientCreateOrUpdatePipelinePoller) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientCreateOrUpdatePipelineResponse, error) {
	result := pipelineClientCreateOrUpdatePipelineResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PipelineResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *pipelineClientCreateOrUpdatePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a pipelineClientCreateOrUpdatePipelinePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Resume(ctx context.Context, client *pipelineClient, token string) (pipelineClientCreateOrUpdatePipelineResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("pipelineClient.CreateOrUpdatePipeline", token, client.pl); err != nil {
		return pipelineClientCreateOrUpdatePipelineResponse{}, err
	}
	return p.Poll(ctx)
}

// pipelineClientDeletePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientDeletePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientDeletePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *pipelineClientDeletePipelinePoller) Poll(ctx context.Context) (pipelineClientDeletePipelineResponse, error) {
	result := pipelineClientDeletePipelineResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *pipelineClientDeletePipelinePoller) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientDeletePipelineResponse, error) {
	result := pipelineClientDeletePipelineResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *pipelineClientDeletePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a pipelineClientDeletePipelinePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *pipelineClientDeletePipelinePoller) Resume(ctx context.Context, client *pipelineClient, token string) (pipelineClientDeletePipelineResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("pipelineClient.DeletePipeline", token, client.pl); err != nil {
		return pipelineClientDeletePipelineResponse{}, err
	}
	return p.Poll(ctx)
}

// pipelineClientRenamePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientRenamePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientRenamePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *pipelineClientRenamePipelinePoller) Poll(ctx context.Context) (pipelineClientRenamePipelineResponse, error) {
	result := pipelineClientRenamePipelineResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *pipelineClientRenamePipelinePoller) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientRenamePipelineResponse, error) {
	result := pipelineClientRenamePipelineResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *pipelineClientRenamePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a pipelineClientRenamePipelinePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *pipelineClientRenamePipelinePoller) Resume(ctx context.Context, client *pipelineClient, token string) (pipelineClientRenamePipelineResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("pipelineClient.RenamePipeline", token, client.pl); err != nil {
		return pipelineClientRenamePipelineResponse{}, err
	}
	return p.Poll(ctx)
}

// sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Poll(ctx context.Context) (sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.SparkJobDefinitionResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SparkJobDefinitionResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) (sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.CreateOrUpdateSparkJobDefinition", token, client.pl); err != nil {
		return sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}, err
	}
	return p.Poll(ctx)
}

// sparkJobDefinitionClientDebugSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientDebugSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Poll(ctx context.Context) (sparkJobDefinitionClientDebugSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.SparkBatchJob)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientDebugSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SparkBatchJob)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientDebugSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) (sparkJobDefinitionClientDebugSparkJobDefinitionResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.DebugSparkJobDefinition", token, client.pl); err != nil {
		return sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}, err
	}
	return p.Poll(ctx)
}

// sparkJobDefinitionClientDeleteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientDeleteSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Poll(ctx context.Context) (sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientDeleteSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) (sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.DeleteSparkJobDefinition", token, client.pl); err != nil {
		return sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}, err
	}
	return p.Poll(ctx)
}

// sparkJobDefinitionClientExecuteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientExecuteSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Poll(ctx context.Context) (sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.SparkBatchJob)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SparkBatchJob)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientExecuteSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) (sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.ExecuteSparkJobDefinition", token, client.pl); err != nil {
		return sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}, err
	}
	return p.Poll(ctx)
}

// sparkJobDefinitionClientRenameSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientRenameSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Poll(ctx context.Context) (sparkJobDefinitionClientRenameSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientRenameSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientRenameSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) (sparkJobDefinitionClientRenameSparkJobDefinitionResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.RenameSparkJobDefinition", token, client.pl); err != nil {
		return sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}, err
	}
	return p.Poll(ctx)
}

// sqlScriptClientCreateOrUpdateSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientCreateOrUpdateSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Poll(ctx context.Context) (sqlScriptClientCreateOrUpdateSQLScriptResponse, error) {
	result := sqlScriptClientCreateOrUpdateSQLScriptResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.SQLScriptResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientCreateOrUpdateSQLScriptResponse, error) {
	result := sqlScriptClientCreateOrUpdateSQLScriptResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SQLScriptResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sqlScriptClientCreateOrUpdateSQLScriptPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Resume(ctx context.Context, client *sqlScriptClient, token string) (sqlScriptClientCreateOrUpdateSQLScriptResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sqlScriptClient.CreateOrUpdateSQLScript", token, client.pl); err != nil {
		return sqlScriptClientCreateOrUpdateSQLScriptResponse{}, err
	}
	return p.Poll(ctx)
}

// sqlScriptClientDeleteSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientDeleteSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientDeleteSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sqlScriptClientDeleteSQLScriptPoller) Poll(ctx context.Context) (sqlScriptClientDeleteSQLScriptResponse, error) {
	result := sqlScriptClientDeleteSQLScriptResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sqlScriptClientDeleteSQLScriptPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientDeleteSQLScriptResponse, error) {
	result := sqlScriptClientDeleteSQLScriptResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sqlScriptClientDeleteSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sqlScriptClientDeleteSQLScriptPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sqlScriptClientDeleteSQLScriptPoller) Resume(ctx context.Context, client *sqlScriptClient, token string) (sqlScriptClientDeleteSQLScriptResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sqlScriptClient.DeleteSQLScript", token, client.pl); err != nil {
		return sqlScriptClientDeleteSQLScriptResponse{}, err
	}
	return p.Poll(ctx)
}

// sqlScriptClientRenameSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientRenameSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientRenameSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sqlScriptClientRenameSQLScriptPoller) Poll(ctx context.Context) (sqlScriptClientRenameSQLScriptResponse, error) {
	result := sqlScriptClientRenameSQLScriptResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sqlScriptClientRenameSQLScriptPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientRenameSQLScriptResponse, error) {
	result := sqlScriptClientRenameSQLScriptResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sqlScriptClientRenameSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sqlScriptClientRenameSQLScriptPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sqlScriptClientRenameSQLScriptPoller) Resume(ctx context.Context, client *sqlScriptClient, token string) (sqlScriptClientRenameSQLScriptResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("sqlScriptClient.RenameSQLScript", token, client.pl); err != nil {
		return sqlScriptClientRenameSQLScriptResponse{}, err
	}
	return p.Poll(ctx)
}

// triggerClientCreateOrUpdateTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientCreateOrUpdateTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientCreateOrUpdateTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientCreateOrUpdateTriggerPoller) Poll(ctx context.Context) (triggerClientCreateOrUpdateTriggerResponse, error) {
	result := triggerClientCreateOrUpdateTriggerResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.TriggerResource)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientCreateOrUpdateTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientCreateOrUpdateTriggerResponse, error) {
	result := triggerClientCreateOrUpdateTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TriggerResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientCreateOrUpdateTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientCreateOrUpdateTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientCreateOrUpdateTriggerPoller) Resume(ctx context.Context, client *triggerClient, token string) (triggerClientCreateOrUpdateTriggerResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.CreateOrUpdateTrigger", token, client.pl); err != nil {
		return triggerClientCreateOrUpdateTriggerResponse{}, err
	}
	return p.Poll(ctx)
}

// triggerClientDeleteTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientDeleteTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientDeleteTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientDeleteTriggerPoller) Poll(ctx context.Context) (triggerClientDeleteTriggerResponse, error) {
	result := triggerClientDeleteTriggerResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientDeleteTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientDeleteTriggerResponse, error) {
	result := triggerClientDeleteTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientDeleteTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientDeleteTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientDeleteTriggerPoller) Resume(ctx context.Context, client *triggerClient, token string) (triggerClientDeleteTriggerResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.DeleteTrigger", token, client.pl); err != nil {
		return triggerClientDeleteTriggerResponse{}, err
	}
	return p.Poll(ctx)
}

// triggerClientStartTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientStartTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientStartTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientStartTriggerPoller) Poll(ctx context.Context) (triggerClientStartTriggerResponse, error) {
	result := triggerClientStartTriggerResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientStartTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientStartTriggerResponse, error) {
	result := triggerClientStartTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientStartTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientStartTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientStartTriggerPoller) Resume(ctx context.Context, client *triggerClient, token string) (triggerClientStartTriggerResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.StartTrigger", token, client.pl); err != nil {
		return triggerClientStartTriggerResponse{}, err
	}
	return p.Poll(ctx)
}

// triggerClientStopTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientStopTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientStopTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientStopTriggerPoller) Poll(ctx context.Context) (triggerClientStopTriggerResponse, error) {
	result := triggerClientStopTriggerResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, nil)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientStopTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientStopTriggerResponse, error) {
	result := triggerClientStopTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientStopTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientStopTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientStopTriggerPoller) Resume(ctx context.Context, client *triggerClient, token string) (triggerClientStopTriggerResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.StopTrigger", token, client.pl); err != nil {
		return triggerClientStopTriggerResponse{}, err
	}
	return p.Poll(ctx)
}

// triggerClientSubscribeTriggerToEventsPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientSubscribeTriggerToEventsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientSubscribeTriggerToEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientSubscribeTriggerToEventsPoller) Poll(ctx context.Context) (triggerClientSubscribeTriggerToEventsResponse, error) {
	result := triggerClientSubscribeTriggerToEventsResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.TriggerSubscriptionOperationStatus)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientSubscribeTriggerToEventsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientSubscribeTriggerToEventsResponse, error) {
	result := triggerClientSubscribeTriggerToEventsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TriggerSubscriptionOperationStatus)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientSubscribeTriggerToEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientSubscribeTriggerToEventsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientSubscribeTriggerToEventsPoller) Resume(ctx context.Context, client *triggerClient, token string) (triggerClientSubscribeTriggerToEventsResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.SubscribeTriggerToEvents", token, client.pl); err != nil {
		return triggerClientSubscribeTriggerToEventsResponse{}, err
	}
	return p.Poll(ctx)
}

// triggerClientUnsubscribeTriggerFromEventsPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientUnsubscribeTriggerFromEventsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// a zero-value response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Poll(ctx context.Context) (triggerClientUnsubscribeTriggerFromEventsResponse, error) {
	result := triggerClientUnsubscribeTriggerFromEventsResponse{}
	if _, err := p.pt.Poll(ctx); err != nil {
		return result, err
	}
	if !p.Done() {
		return result, nil
	}
	_, err := p.pt.FinalResponse(ctx, &result.TriggerSubscriptionOperationStatus)
	return result, err
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientUnsubscribeTriggerFromEventsResponse, error) {
	result := triggerClientUnsubscribeTriggerFromEventsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TriggerSubscriptionOperationStatus)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientUnsubscribeTriggerFromEventsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Resume(ctx context.Context, client *triggerClient, token string) (triggerClientUnsubscribeTriggerFromEventsResponse, error) {
	var err error
	if p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.UnsubscribeTriggerFromEvents", token, client.pl); err != nil {
		return triggerClientUnsubscribeTriggerFromEventsResponse{}, err
	}
	return p.Poll(ctx)
}
