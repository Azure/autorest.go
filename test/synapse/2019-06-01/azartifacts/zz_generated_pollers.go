// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// DataFlowCreateOrUpdateDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type DataFlowCreateOrUpdateDataFlowPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DataFlowCreateOrUpdateDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DataFlowCreateOrUpdateDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DataFlowCreateOrUpdateDataFlowResponse will be returned.
func (p *DataFlowCreateOrUpdateDataFlowPoller) FinalResponse(ctx context.Context) (DataFlowCreateOrUpdateDataFlowResponse, error) {
	respType := DataFlowCreateOrUpdateDataFlowResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataFlowResource)
	if err != nil {
		return DataFlowCreateOrUpdateDataFlowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DataFlowCreateOrUpdateDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DataFlowDebugSessionCreateDataFlowDebugSessionPoller provides polling facilities until the operation reaches a terminal state.
type DataFlowDebugSessionCreateDataFlowDebugSessionPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DataFlowDebugSessionCreateDataFlowDebugSessionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DataFlowDebugSessionCreateDataFlowDebugSessionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DataFlowDebugSessionCreateDataFlowDebugSessionResponse will be returned.
func (p *DataFlowDebugSessionCreateDataFlowDebugSessionPoller) FinalResponse(ctx context.Context) (DataFlowDebugSessionCreateDataFlowDebugSessionResponse, error) {
	respType := DataFlowDebugSessionCreateDataFlowDebugSessionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.CreateDataFlowDebugSessionResponse)
	if err != nil {
		return DataFlowDebugSessionCreateDataFlowDebugSessionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DataFlowDebugSessionCreateDataFlowDebugSessionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DataFlowDebugSessionExecuteCommandPoller provides polling facilities until the operation reaches a terminal state.
type DataFlowDebugSessionExecuteCommandPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DataFlowDebugSessionExecuteCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DataFlowDebugSessionExecuteCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DataFlowDebugSessionExecuteCommandResponse will be returned.
func (p *DataFlowDebugSessionExecuteCommandPoller) FinalResponse(ctx context.Context) (DataFlowDebugSessionExecuteCommandResponse, error) {
	respType := DataFlowDebugSessionExecuteCommandResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DataFlowDebugCommandResponse)
	if err != nil {
		return DataFlowDebugSessionExecuteCommandResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DataFlowDebugSessionExecuteCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DataFlowDeleteDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type DataFlowDeleteDataFlowPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DataFlowDeleteDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DataFlowDeleteDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DataFlowDeleteDataFlowResponse will be returned.
func (p *DataFlowDeleteDataFlowPoller) FinalResponse(ctx context.Context) (DataFlowDeleteDataFlowResponse, error) {
	respType := DataFlowDeleteDataFlowResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DataFlowDeleteDataFlowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DataFlowDeleteDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DataFlowRenameDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type DataFlowRenameDataFlowPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DataFlowRenameDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DataFlowRenameDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DataFlowRenameDataFlowResponse will be returned.
func (p *DataFlowRenameDataFlowPoller) FinalResponse(ctx context.Context) (DataFlowRenameDataFlowResponse, error) {
	respType := DataFlowRenameDataFlowResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DataFlowRenameDataFlowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DataFlowRenameDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatasetCreateOrUpdateDatasetPoller provides polling facilities until the operation reaches a terminal state.
type DatasetCreateOrUpdateDatasetPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatasetCreateOrUpdateDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatasetCreateOrUpdateDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatasetCreateOrUpdateDatasetResponse will be returned.
func (p *DatasetCreateOrUpdateDatasetPoller) FinalResponse(ctx context.Context) (DatasetCreateOrUpdateDatasetResponse, error) {
	respType := DatasetCreateOrUpdateDatasetResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.DatasetResource)
	if err != nil {
		return DatasetCreateOrUpdateDatasetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatasetCreateOrUpdateDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatasetDeleteDatasetPoller provides polling facilities until the operation reaches a terminal state.
type DatasetDeleteDatasetPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatasetDeleteDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatasetDeleteDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatasetDeleteDatasetResponse will be returned.
func (p *DatasetDeleteDatasetPoller) FinalResponse(ctx context.Context) (DatasetDeleteDatasetResponse, error) {
	respType := DatasetDeleteDatasetResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatasetDeleteDatasetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatasetDeleteDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DatasetRenameDatasetPoller provides polling facilities until the operation reaches a terminal state.
type DatasetRenameDatasetPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DatasetRenameDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DatasetRenameDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DatasetRenameDatasetResponse will be returned.
func (p *DatasetRenameDatasetPoller) FinalResponse(ctx context.Context) (DatasetRenameDatasetResponse, error) {
	respType := DatasetRenameDatasetResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DatasetRenameDatasetResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DatasetRenameDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LibraryCreatePoller provides polling facilities until the operation reaches a terminal state.
type LibraryCreatePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LibraryCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LibraryCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LibraryCreateResponse will be returned.
func (p *LibraryCreatePoller) FinalResponse(ctx context.Context) (LibraryCreateResponse, error) {
	respType := LibraryCreateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LibraryResourceInfo)
	if err != nil {
		return LibraryCreateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LibraryCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LibraryDeletePoller provides polling facilities until the operation reaches a terminal state.
type LibraryDeletePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LibraryDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LibraryDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LibraryDeleteResponse will be returned.
func (p *LibraryDeletePoller) FinalResponse(ctx context.Context) (LibraryDeleteResponse, error) {
	respType := LibraryDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LibraryResourceInfo)
	if err != nil {
		return LibraryDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LibraryDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LibraryFlushPoller provides polling facilities until the operation reaches a terminal state.
type LibraryFlushPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LibraryFlushPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LibraryFlushPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LibraryFlushResponse will be returned.
func (p *LibraryFlushPoller) FinalResponse(ctx context.Context) (LibraryFlushResponse, error) {
	respType := LibraryFlushResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LibraryResourceInfo)
	if err != nil {
		return LibraryFlushResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LibraryFlushPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LinkedServiceCreateOrUpdateLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type LinkedServiceCreateOrUpdateLinkedServicePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LinkedServiceCreateOrUpdateLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LinkedServiceCreateOrUpdateLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LinkedServiceCreateOrUpdateLinkedServiceResponse will be returned.
func (p *LinkedServiceCreateOrUpdateLinkedServicePoller) FinalResponse(ctx context.Context) (LinkedServiceCreateOrUpdateLinkedServiceResponse, error) {
	respType := LinkedServiceCreateOrUpdateLinkedServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.LinkedServiceResource)
	if err != nil {
		return LinkedServiceCreateOrUpdateLinkedServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LinkedServiceCreateOrUpdateLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LinkedServiceDeleteLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type LinkedServiceDeleteLinkedServicePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LinkedServiceDeleteLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LinkedServiceDeleteLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LinkedServiceDeleteLinkedServiceResponse will be returned.
func (p *LinkedServiceDeleteLinkedServicePoller) FinalResponse(ctx context.Context) (LinkedServiceDeleteLinkedServiceResponse, error) {
	respType := LinkedServiceDeleteLinkedServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LinkedServiceDeleteLinkedServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LinkedServiceDeleteLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// LinkedServiceRenameLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type LinkedServiceRenameLinkedServicePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *LinkedServiceRenameLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *LinkedServiceRenameLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final LinkedServiceRenameLinkedServiceResponse will be returned.
func (p *LinkedServiceRenameLinkedServicePoller) FinalResponse(ctx context.Context) (LinkedServiceRenameLinkedServiceResponse, error) {
	respType := LinkedServiceRenameLinkedServiceResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return LinkedServiceRenameLinkedServiceResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *LinkedServiceRenameLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookCreateOrUpdateNotebookPoller provides polling facilities until the operation reaches a terminal state.
type NotebookCreateOrUpdateNotebookPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookCreateOrUpdateNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookCreateOrUpdateNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookCreateOrUpdateNotebookResponse will be returned.
func (p *NotebookCreateOrUpdateNotebookPoller) FinalResponse(ctx context.Context) (NotebookCreateOrUpdateNotebookResponse, error) {
	respType := NotebookCreateOrUpdateNotebookResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NotebookResource)
	if err != nil {
		return NotebookCreateOrUpdateNotebookResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookCreateOrUpdateNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookDeleteNotebookPoller provides polling facilities until the operation reaches a terminal state.
type NotebookDeleteNotebookPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookDeleteNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookDeleteNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookDeleteNotebookResponse will be returned.
func (p *NotebookDeleteNotebookPoller) FinalResponse(ctx context.Context) (NotebookDeleteNotebookResponse, error) {
	respType := NotebookDeleteNotebookResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookDeleteNotebookResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookDeleteNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// NotebookRenameNotebookPoller provides polling facilities until the operation reaches a terminal state.
type NotebookRenameNotebookPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *NotebookRenameNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *NotebookRenameNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final NotebookRenameNotebookResponse will be returned.
func (p *NotebookRenameNotebookPoller) FinalResponse(ctx context.Context) (NotebookRenameNotebookResponse, error) {
	respType := NotebookRenameNotebookResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return NotebookRenameNotebookResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *NotebookRenameNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PipelineCreateOrUpdatePipelinePoller provides polling facilities until the operation reaches a terminal state.
type PipelineCreateOrUpdatePipelinePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PipelineCreateOrUpdatePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PipelineCreateOrUpdatePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PipelineCreateOrUpdatePipelineResponse will be returned.
func (p *PipelineCreateOrUpdatePipelinePoller) FinalResponse(ctx context.Context) (PipelineCreateOrUpdatePipelineResponse, error) {
	respType := PipelineCreateOrUpdatePipelineResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.PipelineResource)
	if err != nil {
		return PipelineCreateOrUpdatePipelineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PipelineCreateOrUpdatePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PipelineDeletePipelinePoller provides polling facilities until the operation reaches a terminal state.
type PipelineDeletePipelinePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PipelineDeletePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PipelineDeletePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PipelineDeletePipelineResponse will be returned.
func (p *PipelineDeletePipelinePoller) FinalResponse(ctx context.Context) (PipelineDeletePipelineResponse, error) {
	respType := PipelineDeletePipelineResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PipelineDeletePipelineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PipelineDeletePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PipelineRenamePipelinePoller provides polling facilities until the operation reaches a terminal state.
type PipelineRenamePipelinePoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PipelineRenamePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PipelineRenamePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PipelineRenamePipelineResponse will be returned.
func (p *PipelineRenamePipelinePoller) FinalResponse(ctx context.Context) (PipelineRenamePipelineResponse, error) {
	respType := PipelineRenamePipelineResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PipelineRenamePipelineResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PipelineRenamePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLScriptCreateOrUpdateSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type SQLScriptCreateOrUpdateSQLScriptPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLScriptCreateOrUpdateSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLScriptCreateOrUpdateSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLScriptCreateOrUpdateSQLScriptResponse will be returned.
func (p *SQLScriptCreateOrUpdateSQLScriptPoller) FinalResponse(ctx context.Context) (SQLScriptCreateOrUpdateSQLScriptResponse, error) {
	respType := SQLScriptCreateOrUpdateSQLScriptResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SQLScriptResource)
	if err != nil {
		return SQLScriptCreateOrUpdateSQLScriptResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLScriptCreateOrUpdateSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLScriptDeleteSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type SQLScriptDeleteSQLScriptPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLScriptDeleteSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLScriptDeleteSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLScriptDeleteSQLScriptResponse will be returned.
func (p *SQLScriptDeleteSQLScriptPoller) FinalResponse(ctx context.Context) (SQLScriptDeleteSQLScriptResponse, error) {
	respType := SQLScriptDeleteSQLScriptResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLScriptDeleteSQLScriptResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLScriptDeleteSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SQLScriptRenameSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type SQLScriptRenameSQLScriptPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SQLScriptRenameSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SQLScriptRenameSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SQLScriptRenameSQLScriptResponse will be returned.
func (p *SQLScriptRenameSQLScriptPoller) FinalResponse(ctx context.Context) (SQLScriptRenameSQLScriptResponse, error) {
	respType := SQLScriptRenameSQLScriptResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SQLScriptRenameSQLScriptResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SQLScriptRenameSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse will be returned.
func (p *SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SparkJobDefinitionResource)
	if err != nil {
		return SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SparkJobDefinitionDebugSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SparkJobDefinitionDebugSparkJobDefinitionPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SparkJobDefinitionDebugSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SparkJobDefinitionDebugSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SparkJobDefinitionDebugSparkJobDefinitionResponse will be returned.
func (p *SparkJobDefinitionDebugSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (SparkJobDefinitionDebugSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionDebugSparkJobDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SparkBatchJob)
	if err != nil {
		return SparkJobDefinitionDebugSparkJobDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SparkJobDefinitionDebugSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SparkJobDefinitionDeleteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SparkJobDefinitionDeleteSparkJobDefinitionPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SparkJobDefinitionDeleteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SparkJobDefinitionDeleteSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SparkJobDefinitionDeleteSparkJobDefinitionResponse will be returned.
func (p *SparkJobDefinitionDeleteSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (SparkJobDefinitionDeleteSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionDeleteSparkJobDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SparkJobDefinitionDeleteSparkJobDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SparkJobDefinitionDeleteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SparkJobDefinitionExecuteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SparkJobDefinitionExecuteSparkJobDefinitionPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SparkJobDefinitionExecuteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SparkJobDefinitionExecuteSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SparkJobDefinitionExecuteSparkJobDefinitionResponse will be returned.
func (p *SparkJobDefinitionExecuteSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (SparkJobDefinitionExecuteSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionExecuteSparkJobDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SparkBatchJob)
	if err != nil {
		return SparkJobDefinitionExecuteSparkJobDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SparkJobDefinitionExecuteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// SparkJobDefinitionRenameSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type SparkJobDefinitionRenameSparkJobDefinitionPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *SparkJobDefinitionRenameSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *SparkJobDefinitionRenameSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final SparkJobDefinitionRenameSparkJobDefinitionResponse will be returned.
func (p *SparkJobDefinitionRenameSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (SparkJobDefinitionRenameSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionRenameSparkJobDefinitionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return SparkJobDefinitionRenameSparkJobDefinitionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *SparkJobDefinitionRenameSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TriggerCreateOrUpdateTriggerPoller provides polling facilities until the operation reaches a terminal state.
type TriggerCreateOrUpdateTriggerPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggerCreateOrUpdateTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TriggerCreateOrUpdateTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TriggerCreateOrUpdateTriggerResponse will be returned.
func (p *TriggerCreateOrUpdateTriggerPoller) FinalResponse(ctx context.Context) (TriggerCreateOrUpdateTriggerResponse, error) {
	respType := TriggerCreateOrUpdateTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TriggerResource)
	if err != nil {
		return TriggerCreateOrUpdateTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TriggerCreateOrUpdateTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TriggerDeleteTriggerPoller provides polling facilities until the operation reaches a terminal state.
type TriggerDeleteTriggerPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggerDeleteTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TriggerDeleteTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TriggerDeleteTriggerResponse will be returned.
func (p *TriggerDeleteTriggerPoller) FinalResponse(ctx context.Context) (TriggerDeleteTriggerResponse, error) {
	respType := TriggerDeleteTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TriggerDeleteTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TriggerDeleteTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TriggerStartTriggerPoller provides polling facilities until the operation reaches a terminal state.
type TriggerStartTriggerPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggerStartTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TriggerStartTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TriggerStartTriggerResponse will be returned.
func (p *TriggerStartTriggerPoller) FinalResponse(ctx context.Context) (TriggerStartTriggerResponse, error) {
	respType := TriggerStartTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TriggerStartTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TriggerStartTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TriggerStopTriggerPoller provides polling facilities until the operation reaches a terminal state.
type TriggerStopTriggerPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggerStopTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TriggerStopTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TriggerStopTriggerResponse will be returned.
func (p *TriggerStopTriggerPoller) FinalResponse(ctx context.Context) (TriggerStopTriggerResponse, error) {
	respType := TriggerStopTriggerResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TriggerStopTriggerResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TriggerStopTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TriggerSubscribeTriggerToEventsPoller provides polling facilities until the operation reaches a terminal state.
type TriggerSubscribeTriggerToEventsPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggerSubscribeTriggerToEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TriggerSubscribeTriggerToEventsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TriggerSubscribeTriggerToEventsResponse will be returned.
func (p *TriggerSubscribeTriggerToEventsPoller) FinalResponse(ctx context.Context) (TriggerSubscribeTriggerToEventsResponse, error) {
	respType := TriggerSubscribeTriggerToEventsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return TriggerSubscribeTriggerToEventsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TriggerSubscribeTriggerToEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TriggerUnsubscribeTriggerFromEventsPoller provides polling facilities until the operation reaches a terminal state.
type TriggerUnsubscribeTriggerFromEventsPoller struct {
	pt *azcore.LROPoller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TriggerUnsubscribeTriggerFromEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TriggerUnsubscribeTriggerFromEventsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TriggerUnsubscribeTriggerFromEventsResponse will be returned.
func (p *TriggerUnsubscribeTriggerFromEventsPoller) FinalResponse(ctx context.Context) (TriggerUnsubscribeTriggerFromEventsResponse, error) {
	respType := TriggerUnsubscribeTriggerFromEventsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return TriggerUnsubscribeTriggerFromEventsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TriggerUnsubscribeTriggerFromEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
