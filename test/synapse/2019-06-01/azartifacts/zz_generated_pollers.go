//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// dataFlowClientCreateOrUpdateDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientCreateOrUpdateDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final dataFlowClientCreateOrUpdateDataFlowResponse will be returned.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) FinalResponse(ctx context.Context) (dataFlowClientCreateOrUpdateDataFlowResponse, error) {
	respType := dataFlowClientCreateOrUpdateDataFlowResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.DataFlowResource)
	if err != nil {
		return dataFlowClientCreateOrUpdateDataFlowResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// dataFlowClientDeleteDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientDeleteDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientDeleteDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *dataFlowClientDeleteDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final dataFlowClientDeleteDataFlowResponse will be returned.
func (p *dataFlowClientDeleteDataFlowPoller) FinalResponse(ctx context.Context) (dataFlowClientDeleteDataFlowResponse, error) {
	respType := dataFlowClientDeleteDataFlowResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return dataFlowClientDeleteDataFlowResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *dataFlowClientDeleteDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// dataFlowClientRenameDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientRenameDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientRenameDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *dataFlowClientRenameDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final dataFlowClientRenameDataFlowResponse will be returned.
func (p *dataFlowClientRenameDataFlowPoller) FinalResponse(ctx context.Context) (dataFlowClientRenameDataFlowResponse, error) {
	respType := dataFlowClientRenameDataFlowResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return dataFlowClientRenameDataFlowResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *dataFlowClientRenameDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse will be returned.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) FinalResponse(ctx context.Context) (dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, error) {
	respType := dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.CreateDataFlowDebugSessionResponse)
	if err != nil {
		return dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// dataFlowDebugSessionClientExecuteCommandPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowDebugSessionClientExecuteCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final dataFlowDebugSessionClientExecuteCommandResponse will be returned.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) FinalResponse(ctx context.Context) (dataFlowDebugSessionClientExecuteCommandResponse, error) {
	respType := dataFlowDebugSessionClientExecuteCommandResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.DataFlowDebugCommandResponse)
	if err != nil {
		return dataFlowDebugSessionClientExecuteCommandResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// datasetClientCreateOrUpdateDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientCreateOrUpdateDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientCreateOrUpdateDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *datasetClientCreateOrUpdateDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final datasetClientCreateOrUpdateDatasetResponse will be returned.
func (p *datasetClientCreateOrUpdateDatasetPoller) FinalResponse(ctx context.Context) (datasetClientCreateOrUpdateDatasetResponse, error) {
	respType := datasetClientCreateOrUpdateDatasetResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.DatasetResource)
	if err != nil {
		return datasetClientCreateOrUpdateDatasetResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *datasetClientCreateOrUpdateDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// datasetClientDeleteDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientDeleteDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientDeleteDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *datasetClientDeleteDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final datasetClientDeleteDatasetResponse will be returned.
func (p *datasetClientDeleteDatasetPoller) FinalResponse(ctx context.Context) (datasetClientDeleteDatasetResponse, error) {
	respType := datasetClientDeleteDatasetResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return datasetClientDeleteDatasetResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *datasetClientDeleteDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// datasetClientRenameDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientRenameDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientRenameDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *datasetClientRenameDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final datasetClientRenameDatasetResponse will be returned.
func (p *datasetClientRenameDatasetPoller) FinalResponse(ctx context.Context) (datasetClientRenameDatasetResponse, error) {
	respType := datasetClientRenameDatasetResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return datasetClientRenameDatasetResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *datasetClientRenameDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// libraryClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type libraryClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *libraryClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final libraryClientCreateResponse will be returned.
func (p *libraryClientCreatePoller) FinalResponse(ctx context.Context) (libraryClientCreateResponse, error) {
	respType := libraryClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.LibraryResourceInfo)
	if err != nil {
		return libraryClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *libraryClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// libraryClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type libraryClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *libraryClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final libraryClientDeleteResponse will be returned.
func (p *libraryClientDeletePoller) FinalResponse(ctx context.Context) (libraryClientDeleteResponse, error) {
	respType := libraryClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.LibraryResourceInfo)
	if err != nil {
		return libraryClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *libraryClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// libraryClientFlushPoller provides polling facilities until the operation reaches a terminal state.
type libraryClientFlushPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientFlushPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *libraryClientFlushPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final libraryClientFlushResponse will be returned.
func (p *libraryClientFlushPoller) FinalResponse(ctx context.Context) (libraryClientFlushResponse, error) {
	respType := libraryClientFlushResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.LibraryResourceInfo)
	if err != nil {
		return libraryClientFlushResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *libraryClientFlushPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// linkedServiceClientCreateOrUpdateLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientCreateOrUpdateLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final linkedServiceClientCreateOrUpdateLinkedServiceResponse will be returned.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) FinalResponse(ctx context.Context) (linkedServiceClientCreateOrUpdateLinkedServiceResponse, error) {
	respType := linkedServiceClientCreateOrUpdateLinkedServiceResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.LinkedServiceResource)
	if err != nil {
		return linkedServiceClientCreateOrUpdateLinkedServiceResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// linkedServiceClientDeleteLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientDeleteLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientDeleteLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *linkedServiceClientDeleteLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final linkedServiceClientDeleteLinkedServiceResponse will be returned.
func (p *linkedServiceClientDeleteLinkedServicePoller) FinalResponse(ctx context.Context) (linkedServiceClientDeleteLinkedServiceResponse, error) {
	respType := linkedServiceClientDeleteLinkedServiceResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return linkedServiceClientDeleteLinkedServiceResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *linkedServiceClientDeleteLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// linkedServiceClientRenameLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientRenameLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientRenameLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *linkedServiceClientRenameLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final linkedServiceClientRenameLinkedServiceResponse will be returned.
func (p *linkedServiceClientRenameLinkedServicePoller) FinalResponse(ctx context.Context) (linkedServiceClientRenameLinkedServiceResponse, error) {
	respType := linkedServiceClientRenameLinkedServiceResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return linkedServiceClientRenameLinkedServiceResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *linkedServiceClientRenameLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// notebookClientCreateOrUpdateNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientCreateOrUpdateNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientCreateOrUpdateNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *notebookClientCreateOrUpdateNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final notebookClientCreateOrUpdateNotebookResponse will be returned.
func (p *notebookClientCreateOrUpdateNotebookPoller) FinalResponse(ctx context.Context) (notebookClientCreateOrUpdateNotebookResponse, error) {
	respType := notebookClientCreateOrUpdateNotebookResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.NotebookResource)
	if err != nil {
		return notebookClientCreateOrUpdateNotebookResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *notebookClientCreateOrUpdateNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// notebookClientDeleteNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientDeleteNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientDeleteNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *notebookClientDeleteNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final notebookClientDeleteNotebookResponse will be returned.
func (p *notebookClientDeleteNotebookPoller) FinalResponse(ctx context.Context) (notebookClientDeleteNotebookResponse, error) {
	respType := notebookClientDeleteNotebookResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return notebookClientDeleteNotebookResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *notebookClientDeleteNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// notebookClientRenameNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientRenameNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientRenameNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *notebookClientRenameNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final notebookClientRenameNotebookResponse will be returned.
func (p *notebookClientRenameNotebookPoller) FinalResponse(ctx context.Context) (notebookClientRenameNotebookResponse, error) {
	respType := notebookClientRenameNotebookResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return notebookClientRenameNotebookResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *notebookClientRenameNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// pipelineClientCreateOrUpdatePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientCreateOrUpdatePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final pipelineClientCreateOrUpdatePipelineResponse will be returned.
func (p *pipelineClientCreateOrUpdatePipelinePoller) FinalResponse(ctx context.Context) (pipelineClientCreateOrUpdatePipelineResponse, error) {
	respType := pipelineClientCreateOrUpdatePipelineResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.PipelineResource)
	if err != nil {
		return pipelineClientCreateOrUpdatePipelineResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *pipelineClientCreateOrUpdatePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// pipelineClientDeletePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientDeletePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientDeletePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *pipelineClientDeletePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final pipelineClientDeletePipelineResponse will be returned.
func (p *pipelineClientDeletePipelinePoller) FinalResponse(ctx context.Context) (pipelineClientDeletePipelineResponse, error) {
	respType := pipelineClientDeletePipelineResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return pipelineClientDeletePipelineResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *pipelineClientDeletePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// pipelineClientRenamePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientRenamePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientRenamePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *pipelineClientRenamePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final pipelineClientRenamePipelineResponse will be returned.
func (p *pipelineClientRenamePipelinePoller) FinalResponse(ctx context.Context) (pipelineClientRenamePipelineResponse, error) {
	respType := pipelineClientRenamePipelineResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return pipelineClientRenamePipelineResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *pipelineClientRenamePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse will be returned.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.SparkJobDefinitionResource)
	if err != nil {
		return sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sparkJobDefinitionClientDebugSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientDebugSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sparkJobDefinitionClientDebugSparkJobDefinitionResponse will be returned.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (sparkJobDefinitionClientDebugSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.SparkBatchJob)
	if err != nil {
		return sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sparkJobDefinitionClientDeleteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientDeleteSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sparkJobDefinitionClientDeleteSparkJobDefinitionResponse will be returned.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sparkJobDefinitionClientExecuteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientExecuteSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sparkJobDefinitionClientExecuteSparkJobDefinitionResponse will be returned.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.SparkBatchJob)
	if err != nil {
		return sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sparkJobDefinitionClientRenameSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientRenameSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sparkJobDefinitionClientRenameSparkJobDefinitionResponse will be returned.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) FinalResponse(ctx context.Context) (sparkJobDefinitionClientRenameSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sqlScriptClientCreateOrUpdateSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientCreateOrUpdateSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sqlScriptClientCreateOrUpdateSQLScriptResponse will be returned.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) FinalResponse(ctx context.Context) (sqlScriptClientCreateOrUpdateSQLScriptResponse, error) {
	respType := sqlScriptClientCreateOrUpdateSQLScriptResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.SQLScriptResource)
	if err != nil {
		return sqlScriptClientCreateOrUpdateSQLScriptResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sqlScriptClientDeleteSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientDeleteSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientDeleteSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sqlScriptClientDeleteSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sqlScriptClientDeleteSQLScriptResponse will be returned.
func (p *sqlScriptClientDeleteSQLScriptPoller) FinalResponse(ctx context.Context) (sqlScriptClientDeleteSQLScriptResponse, error) {
	respType := sqlScriptClientDeleteSQLScriptResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return sqlScriptClientDeleteSQLScriptResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sqlScriptClientDeleteSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// sqlScriptClientRenameSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientRenameSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientRenameSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *sqlScriptClientRenameSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final sqlScriptClientRenameSQLScriptResponse will be returned.
func (p *sqlScriptClientRenameSQLScriptPoller) FinalResponse(ctx context.Context) (sqlScriptClientRenameSQLScriptResponse, error) {
	respType := sqlScriptClientRenameSQLScriptResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return sqlScriptClientRenameSQLScriptResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *sqlScriptClientRenameSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// triggerClientCreateOrUpdateTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientCreateOrUpdateTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientCreateOrUpdateTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *triggerClientCreateOrUpdateTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final triggerClientCreateOrUpdateTriggerResponse will be returned.
func (p *triggerClientCreateOrUpdateTriggerPoller) FinalResponse(ctx context.Context) (triggerClientCreateOrUpdateTriggerResponse, error) {
	respType := triggerClientCreateOrUpdateTriggerResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.TriggerResource)
	if err != nil {
		return triggerClientCreateOrUpdateTriggerResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *triggerClientCreateOrUpdateTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// triggerClientDeleteTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientDeleteTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientDeleteTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *triggerClientDeleteTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final triggerClientDeleteTriggerResponse will be returned.
func (p *triggerClientDeleteTriggerPoller) FinalResponse(ctx context.Context) (triggerClientDeleteTriggerResponse, error) {
	respType := triggerClientDeleteTriggerResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return triggerClientDeleteTriggerResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *triggerClientDeleteTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// triggerClientStartTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientStartTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientStartTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *triggerClientStartTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final triggerClientStartTriggerResponse will be returned.
func (p *triggerClientStartTriggerPoller) FinalResponse(ctx context.Context) (triggerClientStartTriggerResponse, error) {
	respType := triggerClientStartTriggerResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return triggerClientStartTriggerResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *triggerClientStartTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// triggerClientStopTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientStopTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientStopTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *triggerClientStopTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final triggerClientStopTriggerResponse will be returned.
func (p *triggerClientStopTriggerPoller) FinalResponse(ctx context.Context) (triggerClientStopTriggerResponse, error) {
	respType := triggerClientStopTriggerResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return triggerClientStopTriggerResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *triggerClientStopTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// triggerClientSubscribeTriggerToEventsPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientSubscribeTriggerToEventsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientSubscribeTriggerToEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *triggerClientSubscribeTriggerToEventsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final triggerClientSubscribeTriggerToEventsResponse will be returned.
func (p *triggerClientSubscribeTriggerToEventsPoller) FinalResponse(ctx context.Context) (triggerClientSubscribeTriggerToEventsResponse, error) {
	respType := triggerClientSubscribeTriggerToEventsResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return triggerClientSubscribeTriggerToEventsResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *triggerClientSubscribeTriggerToEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// triggerClientUnsubscribeTriggerFromEventsPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientUnsubscribeTriggerFromEventsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final triggerClientUnsubscribeTriggerFromEventsResponse will be returned.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) FinalResponse(ctx context.Context) (triggerClientUnsubscribeTriggerFromEventsResponse, error) {
	respType := triggerClientUnsubscribeTriggerFromEventsResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return triggerClientUnsubscribeTriggerFromEventsResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
