//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"time"
)

// dataFlowClientCreateOrUpdateDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientCreateOrUpdateDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Result(ctx context.Context) (resp dataFlowClientCreateOrUpdateDataFlowResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientCreateOrUpdateDataFlowResponse, error) {
	result := dataFlowClientCreateOrUpdateDataFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DataFlowResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowClientCreateOrUpdateDataFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowClientCreateOrUpdateDataFlowPoller) Resume(token string, client *dataFlowClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("dataFlowClient.CreateOrUpdateDataFlow", token, client.pl)
	return
}

// dataFlowClientDeleteDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientDeleteDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientDeleteDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowClientDeleteDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *dataFlowClientDeleteDataFlowPoller) Result(ctx context.Context) (resp dataFlowClientDeleteDataFlowResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowClientDeleteDataFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientDeleteDataFlowResponse, error) {
	result := dataFlowClientDeleteDataFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowClientDeleteDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowClientDeleteDataFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowClientDeleteDataFlowPoller) Resume(token string, client *dataFlowClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("dataFlowClient.DeleteDataFlow", token, client.pl)
	return
}

// dataFlowClientRenameDataFlowPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowClientRenameDataFlowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowClientRenameDataFlowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowClientRenameDataFlowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *dataFlowClientRenameDataFlowPoller) Result(ctx context.Context) (resp dataFlowClientRenameDataFlowResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowClientRenameDataFlowPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientRenameDataFlowResponse, error) {
	result := dataFlowClientRenameDataFlowResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowClientRenameDataFlowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowClientRenameDataFlowPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowClientRenameDataFlowPoller) Resume(token string, client *dataFlowClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("dataFlowClient.RenameDataFlow", token, client.pl)
	return
}

// dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Result(ctx context.Context) (resp dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, error) {
	result := dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.CreateDataFlowDebugSessionResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller) Resume(token string, client *dataFlowDebugSessionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("dataFlowDebugSessionClient.CreateDataFlowDebugSession", token, client.pl)
	return
}

// dataFlowDebugSessionClientExecuteCommandPoller provides polling facilities until the operation reaches a terminal state.
type dataFlowDebugSessionClientExecuteCommandPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Result(ctx context.Context) (resp dataFlowDebugSessionClientExecuteCommandResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowDebugSessionClientExecuteCommandResponse, error) {
	result := dataFlowDebugSessionClientExecuteCommandResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DataFlowDebugCommandResponse)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a dataFlowDebugSessionClientExecuteCommandPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *dataFlowDebugSessionClientExecuteCommandPoller) Resume(token string, client *dataFlowDebugSessionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("dataFlowDebugSessionClient.ExecuteCommand", token, client.pl)
	return
}

// datasetClientCreateOrUpdateDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientCreateOrUpdateDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientCreateOrUpdateDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *datasetClientCreateOrUpdateDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *datasetClientCreateOrUpdateDatasetPoller) Result(ctx context.Context) (resp datasetClientCreateOrUpdateDatasetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *datasetClientCreateOrUpdateDatasetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientCreateOrUpdateDatasetResponse, error) {
	result := datasetClientCreateOrUpdateDatasetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.DatasetResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *datasetClientCreateOrUpdateDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a datasetClientCreateOrUpdateDatasetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *datasetClientCreateOrUpdateDatasetPoller) Resume(token string, client *datasetClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("datasetClient.CreateOrUpdateDataset", token, client.pl)
	return
}

// datasetClientDeleteDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientDeleteDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientDeleteDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *datasetClientDeleteDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *datasetClientDeleteDatasetPoller) Result(ctx context.Context) (resp datasetClientDeleteDatasetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *datasetClientDeleteDatasetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientDeleteDatasetResponse, error) {
	result := datasetClientDeleteDatasetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *datasetClientDeleteDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a datasetClientDeleteDatasetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *datasetClientDeleteDatasetPoller) Resume(token string, client *datasetClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("datasetClient.DeleteDataset", token, client.pl)
	return
}

// datasetClientRenameDatasetPoller provides polling facilities until the operation reaches a terminal state.
type datasetClientRenameDatasetPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *datasetClientRenameDatasetPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *datasetClientRenameDatasetPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *datasetClientRenameDatasetPoller) Result(ctx context.Context) (resp datasetClientRenameDatasetResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *datasetClientRenameDatasetPoller) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientRenameDatasetResponse, error) {
	result := datasetClientRenameDatasetResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *datasetClientRenameDatasetPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a datasetClientRenameDatasetPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *datasetClientRenameDatasetPoller) Resume(token string, client *datasetClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("datasetClient.RenameDataset", token, client.pl)
	return
}

// libraryClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type libraryClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *libraryClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *libraryClientCreatePoller) Result(ctx context.Context) (resp libraryClientCreateResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *libraryClientCreatePoller) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientCreateResponse, error) {
	result := libraryClientCreateResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LibraryResourceInfo)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *libraryClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a libraryClientCreatePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *libraryClientCreatePoller) Resume(token string, client *libraryClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("libraryClient.Create", token, client.pl)
	return
}

// libraryClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type libraryClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *libraryClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *libraryClientDeletePoller) Result(ctx context.Context) (resp libraryClientDeleteResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *libraryClientDeletePoller) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientDeleteResponse, error) {
	result := libraryClientDeleteResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LibraryResourceInfo)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *libraryClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a libraryClientDeletePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *libraryClientDeletePoller) Resume(token string, client *libraryClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("libraryClient.Delete", token, client.pl)
	return
}

// libraryClientFlushPoller provides polling facilities until the operation reaches a terminal state.
type libraryClientFlushPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *libraryClientFlushPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *libraryClientFlushPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *libraryClientFlushPoller) Result(ctx context.Context) (resp libraryClientFlushResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *libraryClientFlushPoller) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientFlushResponse, error) {
	result := libraryClientFlushResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LibraryResourceInfo)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *libraryClientFlushPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a libraryClientFlushPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *libraryClientFlushPoller) Resume(token string, client *libraryClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("libraryClient.Flush", token, client.pl)
	return
}

// linkedServiceClientCreateOrUpdateLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientCreateOrUpdateLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Result(ctx context.Context) (resp linkedServiceClientCreateOrUpdateLinkedServiceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientCreateOrUpdateLinkedServiceResponse, error) {
	result := linkedServiceClientCreateOrUpdateLinkedServiceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.LinkedServiceResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a linkedServiceClientCreateOrUpdateLinkedServicePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *linkedServiceClientCreateOrUpdateLinkedServicePoller) Resume(token string, client *linkedServiceClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("linkedServiceClient.CreateOrUpdateLinkedService", token, client.pl)
	return
}

// linkedServiceClientDeleteLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientDeleteLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientDeleteLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *linkedServiceClientDeleteLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *linkedServiceClientDeleteLinkedServicePoller) Result(ctx context.Context) (resp linkedServiceClientDeleteLinkedServiceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *linkedServiceClientDeleteLinkedServicePoller) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientDeleteLinkedServiceResponse, error) {
	result := linkedServiceClientDeleteLinkedServiceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *linkedServiceClientDeleteLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a linkedServiceClientDeleteLinkedServicePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *linkedServiceClientDeleteLinkedServicePoller) Resume(token string, client *linkedServiceClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("linkedServiceClient.DeleteLinkedService", token, client.pl)
	return
}

// linkedServiceClientRenameLinkedServicePoller provides polling facilities until the operation reaches a terminal state.
type linkedServiceClientRenameLinkedServicePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *linkedServiceClientRenameLinkedServicePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *linkedServiceClientRenameLinkedServicePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *linkedServiceClientRenameLinkedServicePoller) Result(ctx context.Context) (resp linkedServiceClientRenameLinkedServiceResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *linkedServiceClientRenameLinkedServicePoller) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientRenameLinkedServiceResponse, error) {
	result := linkedServiceClientRenameLinkedServiceResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *linkedServiceClientRenameLinkedServicePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a linkedServiceClientRenameLinkedServicePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *linkedServiceClientRenameLinkedServicePoller) Resume(token string, client *linkedServiceClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("linkedServiceClient.RenameLinkedService", token, client.pl)
	return
}

// notebookClientCreateOrUpdateNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientCreateOrUpdateNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientCreateOrUpdateNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *notebookClientCreateOrUpdateNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *notebookClientCreateOrUpdateNotebookPoller) Result(ctx context.Context) (resp notebookClientCreateOrUpdateNotebookResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *notebookClientCreateOrUpdateNotebookPoller) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientCreateOrUpdateNotebookResponse, error) {
	result := notebookClientCreateOrUpdateNotebookResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.NotebookResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *notebookClientCreateOrUpdateNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a notebookClientCreateOrUpdateNotebookPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *notebookClientCreateOrUpdateNotebookPoller) Resume(token string, client *notebookClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("notebookClient.CreateOrUpdateNotebook", token, client.pl)
	return
}

// notebookClientDeleteNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientDeleteNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientDeleteNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *notebookClientDeleteNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *notebookClientDeleteNotebookPoller) Result(ctx context.Context) (resp notebookClientDeleteNotebookResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *notebookClientDeleteNotebookPoller) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientDeleteNotebookResponse, error) {
	result := notebookClientDeleteNotebookResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *notebookClientDeleteNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a notebookClientDeleteNotebookPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *notebookClientDeleteNotebookPoller) Resume(token string, client *notebookClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("notebookClient.DeleteNotebook", token, client.pl)
	return
}

// notebookClientRenameNotebookPoller provides polling facilities until the operation reaches a terminal state.
type notebookClientRenameNotebookPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *notebookClientRenameNotebookPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *notebookClientRenameNotebookPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *notebookClientRenameNotebookPoller) Result(ctx context.Context) (resp notebookClientRenameNotebookResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *notebookClientRenameNotebookPoller) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientRenameNotebookResponse, error) {
	result := notebookClientRenameNotebookResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *notebookClientRenameNotebookPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a notebookClientRenameNotebookPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *notebookClientRenameNotebookPoller) Resume(token string, client *notebookClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("notebookClient.RenameNotebook", token, client.pl)
	return
}

// pipelineClientCreateOrUpdatePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientCreateOrUpdatePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Result(ctx context.Context) (resp pipelineClientCreateOrUpdatePipelineResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *pipelineClientCreateOrUpdatePipelinePoller) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientCreateOrUpdatePipelineResponse, error) {
	result := pipelineClientCreateOrUpdatePipelineResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.PipelineResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *pipelineClientCreateOrUpdatePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a pipelineClientCreateOrUpdatePipelinePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *pipelineClientCreateOrUpdatePipelinePoller) Resume(token string, client *pipelineClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("pipelineClient.CreateOrUpdatePipeline", token, client.pl)
	return
}

// pipelineClientDeletePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientDeletePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientDeletePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *pipelineClientDeletePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *pipelineClientDeletePipelinePoller) Result(ctx context.Context) (resp pipelineClientDeletePipelineResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *pipelineClientDeletePipelinePoller) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientDeletePipelineResponse, error) {
	result := pipelineClientDeletePipelineResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *pipelineClientDeletePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a pipelineClientDeletePipelinePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *pipelineClientDeletePipelinePoller) Resume(token string, client *pipelineClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("pipelineClient.DeletePipeline", token, client.pl)
	return
}

// pipelineClientRenamePipelinePoller provides polling facilities until the operation reaches a terminal state.
type pipelineClientRenamePipelinePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *pipelineClientRenamePipelinePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *pipelineClientRenamePipelinePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *pipelineClientRenamePipelinePoller) Result(ctx context.Context) (resp pipelineClientRenamePipelineResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *pipelineClientRenamePipelinePoller) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientRenamePipelineResponse, error) {
	result := pipelineClientRenamePipelineResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *pipelineClientRenamePipelinePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a pipelineClientRenamePipelinePoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *pipelineClientRenamePipelinePoller) Resume(token string, client *pipelineClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("pipelineClient.RenamePipeline", token, client.pl)
	return
}

// sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Result(ctx context.Context) (resp sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SparkJobDefinitionResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller) Resume(token string, client *sparkJobDefinitionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.CreateOrUpdateSparkJobDefinition", token, client.pl)
	return
}

// sparkJobDefinitionClientDebugSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientDebugSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Result(ctx context.Context) (resp sparkJobDefinitionClientDebugSparkJobDefinitionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientDebugSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SparkBatchJob)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientDebugSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientDebugSparkJobDefinitionPoller) Resume(token string, client *sparkJobDefinitionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.DebugSparkJobDefinition", token, client.pl)
	return
}

// sparkJobDefinitionClientDeleteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientDeleteSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Result(ctx context.Context) (resp sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientDeleteSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller) Resume(token string, client *sparkJobDefinitionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.DeleteSparkJobDefinition", token, client.pl)
	return
}

// sparkJobDefinitionClientExecuteSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientExecuteSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Result(ctx context.Context) (resp sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SparkBatchJob)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientExecuteSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller) Resume(token string, client *sparkJobDefinitionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.ExecuteSparkJobDefinition", token, client.pl)
	return
}

// sparkJobDefinitionClientRenameSparkJobDefinitionPoller provides polling facilities until the operation reaches a terminal state.
type sparkJobDefinitionClientRenameSparkJobDefinitionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Result(ctx context.Context) (resp sparkJobDefinitionClientRenameSparkJobDefinitionResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientRenameSparkJobDefinitionResponse, error) {
	result := sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sparkJobDefinitionClientRenameSparkJobDefinitionPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sparkJobDefinitionClientRenameSparkJobDefinitionPoller) Resume(token string, client *sparkJobDefinitionClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.RenameSparkJobDefinition", token, client.pl)
	return
}

// sqlScriptClientCreateOrUpdateSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientCreateOrUpdateSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Result(ctx context.Context) (resp sqlScriptClientCreateOrUpdateSQLScriptResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientCreateOrUpdateSQLScriptResponse, error) {
	result := sqlScriptClientCreateOrUpdateSQLScriptResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.SQLScriptResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sqlScriptClientCreateOrUpdateSQLScriptPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sqlScriptClientCreateOrUpdateSQLScriptPoller) Resume(token string, client *sqlScriptClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sqlScriptClient.CreateOrUpdateSQLScript", token, client.pl)
	return
}

// sqlScriptClientDeleteSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientDeleteSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientDeleteSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sqlScriptClientDeleteSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sqlScriptClientDeleteSQLScriptPoller) Result(ctx context.Context) (resp sqlScriptClientDeleteSQLScriptResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sqlScriptClientDeleteSQLScriptPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientDeleteSQLScriptResponse, error) {
	result := sqlScriptClientDeleteSQLScriptResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sqlScriptClientDeleteSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sqlScriptClientDeleteSQLScriptPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sqlScriptClientDeleteSQLScriptPoller) Resume(token string, client *sqlScriptClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sqlScriptClient.DeleteSQLScript", token, client.pl)
	return
}

// sqlScriptClientRenameSQLScriptPoller provides polling facilities until the operation reaches a terminal state.
type sqlScriptClientRenameSQLScriptPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *sqlScriptClientRenameSQLScriptPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *sqlScriptClientRenameSQLScriptPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *sqlScriptClientRenameSQLScriptPoller) Result(ctx context.Context) (resp sqlScriptClientRenameSQLScriptResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *sqlScriptClientRenameSQLScriptPoller) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientRenameSQLScriptResponse, error) {
	result := sqlScriptClientRenameSQLScriptResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *sqlScriptClientRenameSQLScriptPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a sqlScriptClientRenameSQLScriptPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *sqlScriptClientRenameSQLScriptPoller) Resume(token string, client *sqlScriptClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("sqlScriptClient.RenameSQLScript", token, client.pl)
	return
}

// triggerClientCreateOrUpdateTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientCreateOrUpdateTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientCreateOrUpdateTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientCreateOrUpdateTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *triggerClientCreateOrUpdateTriggerPoller) Result(ctx context.Context) (resp triggerClientCreateOrUpdateTriggerResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientCreateOrUpdateTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientCreateOrUpdateTriggerResponse, error) {
	result := triggerClientCreateOrUpdateTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TriggerResource)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientCreateOrUpdateTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientCreateOrUpdateTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientCreateOrUpdateTriggerPoller) Resume(token string, client *triggerClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.CreateOrUpdateTrigger", token, client.pl)
	return
}

// triggerClientDeleteTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientDeleteTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientDeleteTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientDeleteTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *triggerClientDeleteTriggerPoller) Result(ctx context.Context) (resp triggerClientDeleteTriggerResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientDeleteTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientDeleteTriggerResponse, error) {
	result := triggerClientDeleteTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientDeleteTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientDeleteTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientDeleteTriggerPoller) Resume(token string, client *triggerClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.DeleteTrigger", token, client.pl)
	return
}

// triggerClientStartTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientStartTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientStartTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientStartTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *triggerClientStartTriggerPoller) Result(ctx context.Context) (resp triggerClientStartTriggerResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientStartTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientStartTriggerResponse, error) {
	result := triggerClientStartTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientStartTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientStartTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientStartTriggerPoller) Resume(token string, client *triggerClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.StartTrigger", token, client.pl)
	return
}

// triggerClientStopTriggerPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientStopTriggerPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientStopTriggerPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientStopTriggerPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *triggerClientStopTriggerPoller) Result(ctx context.Context) (resp triggerClientStopTriggerResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientStopTriggerPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientStopTriggerResponse, error) {
	result := triggerClientStopTriggerResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, nil)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientStopTriggerPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientStopTriggerPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientStopTriggerPoller) Resume(token string, client *triggerClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.StopTrigger", token, client.pl)
	return
}

// triggerClientSubscribeTriggerToEventsPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientSubscribeTriggerToEventsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientSubscribeTriggerToEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientSubscribeTriggerToEventsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *triggerClientSubscribeTriggerToEventsPoller) Result(ctx context.Context) (resp triggerClientSubscribeTriggerToEventsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientSubscribeTriggerToEventsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientSubscribeTriggerToEventsResponse, error) {
	result := triggerClientSubscribeTriggerToEventsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TriggerSubscriptionOperationStatus)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientSubscribeTriggerToEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientSubscribeTriggerToEventsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientSubscribeTriggerToEventsPoller) Resume(token string, client *triggerClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.SubscribeTriggerToEvents", token, client.pl)
	return
}

// triggerClientUnsubscribeTriggerFromEventsPoller provides polling facilities until the operation reaches a terminal state.
type triggerClientUnsubscribeTriggerFromEventsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.
// If the LRO has completed successfully, the poller's state is updated and the
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// response or error.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// Result returns the result of the LRO and is meant to be used in conjunction with Poll and Done.
// Depending on the operation, calls to Result might perform an additional HTTP GET to fetch the result.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Result(ctx context.Context) (resp triggerClientUnsubscribeTriggerFromEventsResponse, err error) {
	_, err = p.pt.FinalResponse(ctx, &resp)
	return
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientUnsubscribeTriggerFromEventsResponse, error) {
	result := triggerClientUnsubscribeTriggerFromEventsResponse{}
	_, err := p.pt.PollUntilDone(ctx, freq, &result.TriggerSubscriptionOperationStatus)
	return result, err
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
// Returns an error if the poller is in a terminal state.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// Resume rehydrates a triggerClientUnsubscribeTriggerFromEventsPoller from the provided client and resume token.
// Returns an error if the token is isn't applicable to this poller type.
func (p *triggerClientUnsubscribeTriggerFromEventsPoller) Resume(token string, client *triggerClient) (err error) {
	p.pt, err = runtime.NewPollerFromResumeToken("triggerClient.UnsubscribeTriggerFromEvents", token, client.pl)
	return
}
