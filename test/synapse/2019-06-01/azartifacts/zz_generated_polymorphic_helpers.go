// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import "encoding/json"

func unmarshalActivityClassification(body []byte) (ActivityClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b ActivityClassification
	switch m["type"] {
	case "AppendVariable":
		b = &AppendVariableActivity{}
	case "AzureDataExplorerCommand":
		b = &AzureDataExplorerCommandActivity{}
	case "AzureFunctionActivity":
		b = &AzureFunctionActivity{}
	case "AzureMLBatchExecution":
		b = &AzureMlBatchExecutionActivity{}
	case "AzureMLExecutePipeline":
		b = &AzureMlExecutePipelineActivity{}
	case "AzureMLUpdateResource":
		b = &AzureMlUpdateResourceActivity{}
	case "Container":
		b = &ControlActivity{}
	case "Copy":
		b = &CopyActivity{}
	case "Custom":
		b = &CustomActivity{}
	case "DataLakeAnalyticsU-SQL":
		b = &DataLakeAnalyticsUsqlActivity{}
	case "DatabricksNotebook":
		b = &DatabricksNotebookActivity{}
	case "DatabricksSparkJar":
		b = &DatabricksSparkJarActivity{}
	case "DatabricksSparkPython":
		b = &DatabricksSparkPythonActivity{}
	case "Delete":
		b = &DeleteActivity{}
	case "ExecuteDataFlow":
		b = &ExecuteDataFlowActivity{}
	case "ExecutePipeline":
		b = &ExecutePipelineActivity{}
	case "ExecuteSSISPackage":
		b = &ExecuteSsisPackageActivity{}
	case "Execution":
		b = &ExecutionActivity{}
	case "Filter":
		b = &FilterActivity{}
	case "ForEach":
		b = &ForEachActivity{}
	case "GetMetadata":
		b = &GetMetadataActivity{}
	case "HDInsightHive":
		b = &HdInsightHiveActivity{}
	case "HDInsightMapReduce":
		b = &HdInsightMapReduceActivity{}
	case "HDInsightPig":
		b = &HdInsightPigActivity{}
	case "HDInsightSpark":
		b = &HdInsightSparkActivity{}
	case "HDInsightStreaming":
		b = &HdInsightStreamingActivity{}
	case "IfCondition":
		b = &IfConditionActivity{}
	case "Lookup":
		b = &LookupActivity{}
	case "SetVariable":
		b = &SetVariableActivity{}
	case "SparkJob":
		b = &SynapseSparkJobDefinitionActivity{}
	case "SqlPoolStoredProcedure":
		b = &SQLPoolStoredProcedureActivity{}
	case "SqlServerStoredProcedure":
		b = &SQLServerStoredProcedureActivity{}
	case "Switch":
		b = &SwitchActivity{}
	case "SynapseNotebook":
		b = &SynapseNotebookActivity{}
	case "Until":
		b = &UntilActivity{}
	case "Validation":
		b = &ValidationActivity{}
	case "Wait":
		b = &WaitActivity{}
	case "WebActivity":
		b = &WebActivity{}
	case "WebHook":
		b = &WebHookActivity{}
	default:
		b = &Activity{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalActivityClassificationArray(body []byte) (*[]ActivityClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ActivityClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalActivityClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalExecutionActivityClassification(body []byte) (ExecutionActivityClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b ExecutionActivityClassification
	switch m["type"] {
	case "AzureDataExplorerCommand":
		b = &AzureDataExplorerCommandActivity{}
	case "AzureFunctionActivity":
		b = &AzureFunctionActivity{}
	case "AzureMLBatchExecution":
		b = &AzureMlBatchExecutionActivity{}
	case "AzureMLExecutePipeline":
		b = &AzureMlExecutePipelineActivity{}
	case "AzureMLUpdateResource":
		b = &AzureMlUpdateResourceActivity{}
	case "Copy":
		b = &CopyActivity{}
	case "Custom":
		b = &CustomActivity{}
	case "DataLakeAnalyticsU-SQL":
		b = &DataLakeAnalyticsUsqlActivity{}
	case "DatabricksNotebook":
		b = &DatabricksNotebookActivity{}
	case "DatabricksSparkJar":
		b = &DatabricksSparkJarActivity{}
	case "DatabricksSparkPython":
		b = &DatabricksSparkPythonActivity{}
	case "Delete":
		b = &DeleteActivity{}
	case "ExecuteDataFlow":
		b = &ExecuteDataFlowActivity{}
	case "ExecuteSSISPackage":
		b = &ExecuteSsisPackageActivity{}
	case "GetMetadata":
		b = &GetMetadataActivity{}
	case "HDInsightHive":
		b = &HdInsightHiveActivity{}
	case "HDInsightMapReduce":
		b = &HdInsightMapReduceActivity{}
	case "HDInsightPig":
		b = &HdInsightPigActivity{}
	case "HDInsightSpark":
		b = &HdInsightSparkActivity{}
	case "HDInsightStreaming":
		b = &HdInsightStreamingActivity{}
	case "Lookup":
		b = &LookupActivity{}
	case "SqlServerStoredProcedure":
		b = &SQLServerStoredProcedureActivity{}
	case "WebActivity":
		b = &WebActivity{}
	default:
		b = &ExecutionActivity{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalExecutionActivityClassificationArray(body []byte) (*[]ExecutionActivityClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ExecutionActivityClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalExecutionActivityClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalCopySinkClassification(body []byte) (CopySinkClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b CopySinkClassification
	switch m["type"] {
	case "AvroSink":
		b = &AvroSink{}
	case "AzureBlobFSSink":
		b = &AzureBlobFsSink{}
	case "AzureDataExplorerSink":
		b = &AzureDataExplorerSink{}
	case "AzureDataLakeStoreSink":
		b = &AzureDataLakeStoreSink{}
	case "AzureMySqlSink":
		b = &AzureMySQLSink{}
	case "AzurePostgreSqlSink":
		b = &AzurePostgreSQLSink{}
	case "AzureQueueSink":
		b = &AzureQueueSink{}
	case "AzureSearchIndexSink":
		b = &AzureSearchIndexSink{}
	case "AzureSqlSink":
		b = &AzureSQLSink{}
	case "AzureTableSink":
		b = &AzureTableSink{}
	case "BinarySink":
		b = &BinarySink{}
	case "BlobSink":
		b = &BlobSink{}
	case "CommonDataServiceForAppsSink":
		b = &CommonDataServiceForAppsSink{}
	case "CosmosDbMongoDbApiSink":
		b = &CosmosDbMongoDbAPISink{}
	case "CosmosDbSqlApiSink":
		b = &CosmosDbSQLAPISink{}
	case "DelimitedTextSink":
		b = &DelimitedTextSink{}
	case "DocumentDbCollectionSink":
		b = &DocumentDbCollectionSink{}
	case "DynamicsCrmSink":
		b = &DynamicsCrmSink{}
	case "DynamicsSink":
		b = &DynamicsSink{}
	case "FileSystemSink":
		b = &FileSystemSink{}
	case "InformixSink":
		b = &InformixSink{}
	case "JsonSink":
		b = &JSONSink{}
	case "MicrosoftAccessSink":
		b = &MicrosoftAccessSink{}
	case "OdbcSink":
		b = &OdbcSink{}
	case "OracleSink":
		b = &OracleSink{}
	case "OrcSink":
		b = &OrcSink{}
	case "ParquetSink":
		b = &ParquetSink{}
	case "SalesforceServiceCloudSink":
		b = &SalesforceServiceCloudSink{}
	case "SalesforceSink":
		b = &SalesforceSink{}
	case "SapCloudForCustomerSink":
		b = &SapCloudForCustomerSink{}
	case "SqlDWSink":
		b = &SQLDwSink{}
	case "SqlMISink":
		b = &SQLMiSink{}
	case "SqlServerSink":
		b = &SQLServerSink{}
	case "SqlSink":
		b = &SQLSink{}
	default:
		b = &CopySink{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalCopySinkClassificationArray(body []byte) (*[]CopySinkClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CopySinkClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCopySinkClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalCopySourceClassification(body []byte) (CopySourceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b CopySourceClassification
	switch m["type"] {
	case "AmazonMWSSource":
		b = &AmazonMwsSource{}
	case "AmazonRedshiftSource":
		b = &AmazonRedshiftSource{}
	case "AvroSource":
		b = &AvroSource{}
	case "AzureBlobFSSource":
		b = &AzureBlobFsSource{}
	case "AzureDataExplorerSource":
		b = &AzureDataExplorerSource{}
	case "AzureDataLakeStoreSource":
		b = &AzureDataLakeStoreSource{}
	case "AzureMariaDBSource":
		b = &AzureMariaDbSource{}
	case "AzureMySqlSource":
		b = &AzureMySQLSource{}
	case "AzurePostgreSqlSource":
		b = &AzurePostgreSQLSource{}
	case "AzureSqlSource":
		b = &AzureSQLSource{}
	case "AzureTableSource":
		b = &AzureTableSource{}
	case "BinarySource":
		b = &BinarySource{}
	case "BlobSource":
		b = &BlobSource{}
	case "CassandraSource":
		b = &CassandraSource{}
	case "CommonDataServiceForAppsSource":
		b = &CommonDataServiceForAppsSource{}
	case "ConcurSource":
		b = &ConcurSource{}
	case "CosmosDbMongoDbApiSource":
		b = &CosmosDbMongoDbAPISource{}
	case "CosmosDbSqlApiSource":
		b = &CosmosDbSQLAPISource{}
	case "CouchbaseSource":
		b = &CouchbaseSource{}
	case "Db2Source":
		b = &Db2Source{}
	case "DelimitedTextSource":
		b = &DelimitedTextSource{}
	case "DocumentDbCollectionSource":
		b = &DocumentDbCollectionSource{}
	case "DrillSource":
		b = &DrillSource{}
	case "DynamicsAXSource":
		b = &DynamicsAxSource{}
	case "DynamicsCrmSource":
		b = &DynamicsCrmSource{}
	case "DynamicsSource":
		b = &DynamicsSource{}
	case "EloquaSource":
		b = &EloquaSource{}
	case "FileSystemSource":
		b = &FileSystemSource{}
	case "GoogleAdWordsSource":
		b = &GoogleAdWordsSource{}
	case "GoogleBigQuerySource":
		b = &GoogleBigQuerySource{}
	case "GreenplumSource":
		b = &GreenplumSource{}
	case "HBaseSource":
		b = &HBaseSource{}
	case "HdfsSource":
		b = &HdfsSource{}
	case "HiveSource":
		b = &HiveSource{}
	case "HttpSource":
		b = &HTTPSource{}
	case "HubspotSource":
		b = &HubspotSource{}
	case "ImpalaSource":
		b = &ImpalaSource{}
	case "InformixSource":
		b = &InformixSource{}
	case "JiraSource":
		b = &JiraSource{}
	case "JsonSource":
		b = &JSONSource{}
	case "MagentoSource":
		b = &MagentoSource{}
	case "MariaDBSource":
		b = &MariaDbSource{}
	case "MarketoSource":
		b = &MarketoSource{}
	case "MicrosoftAccessSource":
		b = &MicrosoftAccessSource{}
	case "MongoDbSource":
		b = &MongoDbSource{}
	case "MongoDbV2Source":
		b = &MongoDbV2Source{}
	case "MySqlSource":
		b = &MySQLSource{}
	case "NetezzaSource":
		b = &NetezzaSource{}
	case "ODataSource":
		b = &ODataSource{}
	case "OdbcSource":
		b = &OdbcSource{}
	case "Office365Source":
		b = &Office365Source{}
	case "OracleServiceCloudSource":
		b = &OracleServiceCloudSource{}
	case "OracleSource":
		b = &OracleSource{}
	case "OrcSource":
		b = &OrcSource{}
	case "ParquetSource":
		b = &ParquetSource{}
	case "PaypalSource":
		b = &PaypalSource{}
	case "PhoenixSource":
		b = &PhoenixSource{}
	case "PostgreSqlSource":
		b = &PostgreSQLSource{}
	case "PrestoSource":
		b = &PrestoSource{}
	case "QuickBooksSource":
		b = &QuickBooksSource{}
	case "RelationalSource":
		b = &RelationalSource{}
	case "ResponsysSource":
		b = &ResponsysSource{}
	case "RestSource":
		b = &RestSource{}
	case "SalesforceMarketingCloudSource":
		b = &SalesforceMarketingCloudSource{}
	case "SalesforceServiceCloudSource":
		b = &SalesforceServiceCloudSource{}
	case "SalesforceSource":
		b = &SalesforceSource{}
	case "SapBwSource":
		b = &SapBwSource{}
	case "SapCloudForCustomerSource":
		b = &SapCloudForCustomerSource{}
	case "SapEccSource":
		b = &SapEccSource{}
	case "SapHanaSource":
		b = &SapHanaSource{}
	case "SapOpenHubSource":
		b = &SapOpenHubSource{}
	case "SapTableSource":
		b = &SapTableSource{}
	case "ServiceNowSource":
		b = &ServiceNowSource{}
	case "ShopifySource":
		b = &ShopifySource{}
	case "SparkSource":
		b = &SparkSource{}
	case "SqlDWSource":
		b = &SQLDwSource{}
	case "SqlMISource":
		b = &SQLMiSource{}
	case "SqlServerSource":
		b = &SQLServerSource{}
	case "SqlSource":
		b = &SQLSource{}
	case "SquareSource":
		b = &SquareSource{}
	case "SybaseSource":
		b = &SybaseSource{}
	case "TabularSource":
		b = &TabularSource{}
	case "TeradataSource":
		b = &TeradataSource{}
	case "VerticaSource":
		b = &VerticaSource{}
	case "WebSource":
		b = &WebSource{}
	case "XeroSource":
		b = &XeroSource{}
	case "ZohoSource":
		b = &ZohoSource{}
	default:
		b = &CopySource{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalCopySourceClassificationArray(body []byte) (*[]CopySourceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CopySourceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCopySourceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalTabularSourceClassification(body []byte) (TabularSourceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b TabularSourceClassification
	switch m["type"] {
	case "AmazonMWSSource":
		b = &AmazonMwsSource{}
	case "AmazonRedshiftSource":
		b = &AmazonRedshiftSource{}
	case "AzureMariaDBSource":
		b = &AzureMariaDbSource{}
	case "AzureMySqlSource":
		b = &AzureMySQLSource{}
	case "AzurePostgreSqlSource":
		b = &AzurePostgreSQLSource{}
	case "AzureSqlSource":
		b = &AzureSQLSource{}
	case "AzureTableSource":
		b = &AzureTableSource{}
	case "CassandraSource":
		b = &CassandraSource{}
	case "ConcurSource":
		b = &ConcurSource{}
	case "CouchbaseSource":
		b = &CouchbaseSource{}
	case "Db2Source":
		b = &Db2Source{}
	case "DrillSource":
		b = &DrillSource{}
	case "DynamicsAXSource":
		b = &DynamicsAxSource{}
	case "EloquaSource":
		b = &EloquaSource{}
	case "GoogleAdWordsSource":
		b = &GoogleAdWordsSource{}
	case "GoogleBigQuerySource":
		b = &GoogleBigQuerySource{}
	case "GreenplumSource":
		b = &GreenplumSource{}
	case "HBaseSource":
		b = &HBaseSource{}
	case "HiveSource":
		b = &HiveSource{}
	case "HubspotSource":
		b = &HubspotSource{}
	case "ImpalaSource":
		b = &ImpalaSource{}
	case "InformixSource":
		b = &InformixSource{}
	case "JiraSource":
		b = &JiraSource{}
	case "MagentoSource":
		b = &MagentoSource{}
	case "MariaDBSource":
		b = &MariaDbSource{}
	case "MarketoSource":
		b = &MarketoSource{}
	case "MySqlSource":
		b = &MySQLSource{}
	case "NetezzaSource":
		b = &NetezzaSource{}
	case "OdbcSource":
		b = &OdbcSource{}
	case "OracleServiceCloudSource":
		b = &OracleServiceCloudSource{}
	case "PaypalSource":
		b = &PaypalSource{}
	case "PhoenixSource":
		b = &PhoenixSource{}
	case "PostgreSqlSource":
		b = &PostgreSQLSource{}
	case "PrestoSource":
		b = &PrestoSource{}
	case "QuickBooksSource":
		b = &QuickBooksSource{}
	case "ResponsysSource":
		b = &ResponsysSource{}
	case "SalesforceMarketingCloudSource":
		b = &SalesforceMarketingCloudSource{}
	case "SalesforceSource":
		b = &SalesforceSource{}
	case "SapBwSource":
		b = &SapBwSource{}
	case "SapCloudForCustomerSource":
		b = &SapCloudForCustomerSource{}
	case "SapEccSource":
		b = &SapEccSource{}
	case "SapHanaSource":
		b = &SapHanaSource{}
	case "SapOpenHubSource":
		b = &SapOpenHubSource{}
	case "SapTableSource":
		b = &SapTableSource{}
	case "ServiceNowSource":
		b = &ServiceNowSource{}
	case "ShopifySource":
		b = &ShopifySource{}
	case "SparkSource":
		b = &SparkSource{}
	case "SqlDWSource":
		b = &SQLDwSource{}
	case "SqlMISource":
		b = &SQLMiSource{}
	case "SqlServerSource":
		b = &SQLServerSource{}
	case "SqlSource":
		b = &SQLSource{}
	case "SquareSource":
		b = &SquareSource{}
	case "SybaseSource":
		b = &SybaseSource{}
	case "TeradataSource":
		b = &TeradataSource{}
	case "VerticaSource":
		b = &VerticaSource{}
	case "XeroSource":
		b = &XeroSource{}
	case "ZohoSource":
		b = &ZohoSource{}
	default:
		b = &TabularSource{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalTabularSourceClassificationArray(body []byte) (*[]TabularSourceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TabularSourceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTabularSourceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalCopyTranslatorClassification(body []byte) (CopyTranslatorClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b CopyTranslatorClassification
	switch m["type"] {
	case "TabularTranslator":
		b = &TabularTranslator{}
	default:
		b = &CopyTranslator{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalCopyTranslatorClassificationArray(body []byte) (*[]CopyTranslatorClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CopyTranslatorClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCopyTranslatorClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalCustomSetupBaseClassification(body []byte) (CustomSetupBaseClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b CustomSetupBaseClassification
	switch m["type"] {
	default:
		b = &CustomSetupBase{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalCustomSetupBaseClassificationArray(body []byte) (*[]CustomSetupBaseClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CustomSetupBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCustomSetupBaseClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDataFlowClassification(body []byte) (DataFlowClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DataFlowClassification
	switch m["type"] {
	case "MappingDataFlow":
		b = &MappingDataFlow{}
	default:
		b = &DataFlow{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDataFlowClassificationArray(body []byte) (*[]DataFlowClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DataFlowClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDataFlowClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetClassification(body []byte) (DatasetClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetClassification
	switch m["type"] {
	case "AmazonMWSObject":
		b = &AmazonMwsObjectDataset{}
	case "AmazonRedshiftTable":
		b = &AmazonRedshiftTableDataset{}
	case "Avro":
		b = &AvroDataset{}
	case "AzureDataExplorerTable":
		b = &AzureDataExplorerTableDataset{}
	case "AzureMariaDBTable":
		b = &AzureMariaDbTableDataset{}
	case "AzureMySqlTable":
		b = &AzureMySQLTableDataset{}
	case "AzurePostgreSqlTable":
		b = &AzurePostgreSQLTableDataset{}
	case "AzureSearchIndex":
		b = &AzureSearchIndexDataset{}
	case "AzureSqlDWTable":
		b = &AzureSQLDwTableDataset{}
	case "AzureSqlMITable":
		b = &AzureSQLMiTableDataset{}
	case "AzureSqlTable":
		b = &AzureSQLTableDataset{}
	case "AzureTable":
		b = &AzureTableDataset{}
	case "Binary":
		b = &BinaryDataset{}
	case "CassandraTable":
		b = &CassandraTableDataset{}
	case "CommonDataServiceForAppsEntity":
		b = &CommonDataServiceForAppsEntityDataset{}
	case "ConcurObject":
		b = &ConcurObjectDataset{}
	case "CosmosDbMongoDbApiCollection":
		b = &CosmosDbMongoDbAPICollectionDataset{}
	case "CosmosDbSqlApiCollection":
		b = &CosmosDbSQLAPICollectionDataset{}
	case "CouchbaseTable":
		b = &CouchbaseTableDataset{}
	case "CustomDataset":
		b = &CustomDataset{}
	case "Db2Table":
		b = &Db2TableDataset{}
	case "DelimitedText":
		b = &DelimitedTextDataset{}
	case "DocumentDbCollection":
		b = &DocumentDbCollectionDataset{}
	case "DrillTable":
		b = &DrillTableDataset{}
	case "DynamicsAXResource":
		b = &DynamicsAxResourceDataset{}
	case "DynamicsCrmEntity":
		b = &DynamicsCrmEntityDataset{}
	case "DynamicsEntity":
		b = &DynamicsEntityDataset{}
	case "EloquaObject":
		b = &EloquaObjectDataset{}
	case "GoogleAdWordsObject":
		b = &GoogleAdWordsObjectDataset{}
	case "GoogleBigQueryObject":
		b = &GoogleBigQueryObjectDataset{}
	case "GreenplumTable":
		b = &GreenplumTableDataset{}
	case "HBaseObject":
		b = &HBaseObjectDataset{}
	case "HiveObject":
		b = &HiveObjectDataset{}
	case "HubspotObject":
		b = &HubspotObjectDataset{}
	case "ImpalaObject":
		b = &ImpalaObjectDataset{}
	case "InformixTable":
		b = &InformixTableDataset{}
	case "JiraObject":
		b = &JiraObjectDataset{}
	case "Json":
		b = &JSONDataset{}
	case "MagentoObject":
		b = &MagentoObjectDataset{}
	case "MariaDBTable":
		b = &MariaDbTableDataset{}
	case "MarketoObject":
		b = &MarketoObjectDataset{}
	case "MicrosoftAccessTable":
		b = &MicrosoftAccessTableDataset{}
	case "MongoDbCollection":
		b = &MongoDbCollectionDataset{}
	case "MongoDbV2Collection":
		b = &MongoDbV2CollectionDataset{}
	case "MySqlTable":
		b = &MySQLTableDataset{}
	case "NetezzaTable":
		b = &NetezzaTableDataset{}
	case "ODataResource":
		b = &ODataResourceDataset{}
	case "OdbcTable":
		b = &OdbcTableDataset{}
	case "Office365Table":
		b = &Office365Dataset{}
	case "OracleServiceCloudObject":
		b = &OracleServiceCloudObjectDataset{}
	case "OracleTable":
		b = &OracleTableDataset{}
	case "Orc":
		b = &OrcDataset{}
	case "Parquet":
		b = &ParquetDataset{}
	case "PaypalObject":
		b = &PaypalObjectDataset{}
	case "PhoenixObject":
		b = &PhoenixObjectDataset{}
	case "PostgreSqlTable":
		b = &PostgreSQLTableDataset{}
	case "PrestoObject":
		b = &PrestoObjectDataset{}
	case "QuickBooksObject":
		b = &QuickBooksObjectDataset{}
	case "RelationalTable":
		b = &RelationalTableDataset{}
	case "ResponsysObject":
		b = &ResponsysObjectDataset{}
	case "RestResource":
		b = &RestResourceDataset{}
	case "SalesforceMarketingCloudObject":
		b = &SalesforceMarketingCloudObjectDataset{}
	case "SalesforceObject":
		b = &SalesforceObjectDataset{}
	case "SalesforceServiceCloudObject":
		b = &SalesforceServiceCloudObjectDataset{}
	case "SapBwCube":
		b = &SapBwCubeDataset{}
	case "SapCloudForCustomerResource":
		b = &SapCloudForCustomerResourceDataset{}
	case "SapEccResource":
		b = &SapEccResourceDataset{}
	case "SapHanaTable":
		b = &SapHanaTableDataset{}
	case "SapOpenHubTable":
		b = &SapOpenHubTableDataset{}
	case "SapTableResource":
		b = &SapTableResourceDataset{}
	case "ServiceNowObject":
		b = &ServiceNowObjectDataset{}
	case "ShopifyObject":
		b = &ShopifyObjectDataset{}
	case "SparkObject":
		b = &SparkObjectDataset{}
	case "SqlServerTable":
		b = &SQLServerTableDataset{}
	case "SquareObject":
		b = &SquareObjectDataset{}
	case "SybaseTable":
		b = &SybaseTableDataset{}
	case "TeradataTable":
		b = &TeradataTableDataset{}
	case "VerticaTable":
		b = &VerticaTableDataset{}
	case "WebTable":
		b = &WebTableDataset{}
	case "XeroObject":
		b = &XeroObjectDataset{}
	case "ZohoObject":
		b = &ZohoObjectDataset{}
	default:
		b = &Dataset{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetClassificationArray(body []byte) (*[]DatasetClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetCompressionClassification(body []byte) (DatasetCompressionClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetCompressionClassification
	switch m["type"] {
	case "BZip2":
		b = &DatasetBZip2Compression{}
	case "Deflate":
		b = &DatasetDeflateCompression{}
	case "GZip":
		b = &DatasetGZipCompression{}
	case "ZipDeflate":
		b = &DatasetZipDeflateCompression{}
	default:
		b = &DatasetCompression{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetCompressionClassificationArray(body []byte) (*[]DatasetCompressionClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetCompressionClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetCompressionClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetLocationClassification(body []byte) (DatasetLocationClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetLocationClassification
	switch m["type"] {
	case "AmazonS3Location":
		b = &AmazonS3Location{}
	case "AzureBlobFSLocation":
		b = &AzureBlobFsLocation{}
	case "AzureBlobStorageLocation":
		b = &AzureBlobStorageLocation{}
	case "AzureDataLakeStoreLocation":
		b = &AzureDataLakeStoreLocation{}
	case "AzureFileStorageLocation":
		b = &AzureFileStorageLocation{}
	case "FileServerLocation":
		b = &FileServerLocation{}
	case "FtpServerLocation":
		b = &FtpServerLocation{}
	case "GoogleCloudStorageLocation":
		b = &GoogleCloudStorageLocation{}
	case "HdfsLocation":
		b = &HdfsLocation{}
	case "HttpServerLocation":
		b = &HTTPServerLocation{}
	case "SftpLocation":
		b = &SftpLocation{}
	default:
		b = &DatasetLocation{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetLocationClassificationArray(body []byte) (*[]DatasetLocationClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetLocationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetLocationClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetStorageFormatClassification(body []byte) (DatasetStorageFormatClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetStorageFormatClassification
	switch m["type"] {
	case "AvroFormat":
		b = &AvroFormat{}
	case "JsonFormat":
		b = &JSONFormat{}
	case "OrcFormat":
		b = &OrcFormat{}
	case "ParquetFormat":
		b = &ParquetFormat{}
	case "TextFormat":
		b = &TextFormat{}
	default:
		b = &DatasetStorageFormat{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetStorageFormatClassificationArray(body []byte) (*[]DatasetStorageFormatClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetStorageFormatClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetStorageFormatClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDependencyReferenceClassification(body []byte) (DependencyReferenceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DependencyReferenceClassification
	switch m["type"] {
	case "SelfDependencyTumblingWindowTriggerReference":
		b = &SelfDependencyTumblingWindowTriggerReference{}
	case "TriggerDependencyReference":
		b = &TriggerDependencyReference{}
	case "TumblingWindowTriggerDependencyReference":
		b = &TumblingWindowTriggerDependencyReference{}
	default:
		b = &DependencyReference{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDependencyReferenceClassificationArray(body []byte) (*[]DependencyReferenceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DependencyReferenceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDependencyReferenceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalTriggerDependencyReferenceClassification(body []byte) (TriggerDependencyReferenceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b TriggerDependencyReferenceClassification
	switch m["type"] {
	case "TumblingWindowTriggerDependencyReference":
		b = &TumblingWindowTriggerDependencyReference{}
	default:
		b = &TriggerDependencyReference{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalTriggerDependencyReferenceClassificationArray(body []byte) (*[]TriggerDependencyReferenceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TriggerDependencyReferenceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTriggerDependencyReferenceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalFormatReadSettingsClassification(body []byte) (FormatReadSettingsClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b FormatReadSettingsClassification
	switch m["type"] {
	case "DelimitedTextReadSettings":
		b = &DelimitedTextReadSettings{}
	default:
		b = &FormatReadSettings{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalFormatReadSettingsClassificationArray(body []byte) (*[]FormatReadSettingsClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]FormatReadSettingsClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalFormatReadSettingsClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalFormatWriteSettingsClassification(body []byte) (FormatWriteSettingsClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b FormatWriteSettingsClassification
	switch m["type"] {
	case "AvroWriteSettings":
		b = &AvroWriteSettings{}
	case "DelimitedTextWriteSettings":
		b = &DelimitedTextWriteSettings{}
	case "JsonWriteSettings":
		b = &JSONWriteSettings{}
	default:
		b = &FormatWriteSettings{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalFormatWriteSettingsClassificationArray(body []byte) (*[]FormatWriteSettingsClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]FormatWriteSettingsClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalFormatWriteSettingsClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalIntegrationRuntimeClassification(body []byte) (IntegrationRuntimeClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b IntegrationRuntimeClassification
	switch m["type"] {
	case IntegrationRuntimeTypeManaged:
		b = &ManagedIntegrationRuntime{}
	case IntegrationRuntimeTypeSelfHosted:
		b = &SelfHostedIntegrationRuntime{}
	default:
		b = &IntegrationRuntime{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalIntegrationRuntimeClassificationArray(body []byte) (*[]IntegrationRuntimeClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]IntegrationRuntimeClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalIntegrationRuntimeClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalLinkedIntegrationRuntimeTypeClassification(body []byte) (LinkedIntegrationRuntimeTypeClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b LinkedIntegrationRuntimeTypeClassification
	switch m["authorizationType"] {
	case "Key":
		b = &LinkedIntegrationRuntimeKeyAuthorization{}
	case "RBAC":
		b = &LinkedIntegrationRuntimeRbacAuthorization{}
	default:
		b = &LinkedIntegrationRuntimeType{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalLinkedIntegrationRuntimeTypeClassificationArray(body []byte) (*[]LinkedIntegrationRuntimeTypeClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]LinkedIntegrationRuntimeTypeClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalLinkedIntegrationRuntimeTypeClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalLinkedServiceClassification(body []byte) (LinkedServiceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b LinkedServiceClassification
	switch m["type"] {
	case "AmazonMWS":
		b = &AmazonMwsLinkedService{}
	case "AmazonRedshift":
		b = &AmazonRedshiftLinkedService{}
	case "AmazonS3":
		b = &AmazonS3LinkedService{}
	case "AzureBatch":
		b = &AzureBatchLinkedService{}
	case "AzureBlobFS":
		b = &AzureBlobFsLinkedService{}
	case "AzureBlobStorage":
		b = &AzureBlobStorageLinkedService{}
	case "AzureDataExplorer":
		b = &AzureDataExplorerLinkedService{}
	case "AzureDataLakeAnalytics":
		b = &AzureDataLakeAnalyticsLinkedService{}
	case "AzureDataLakeStore":
		b = &AzureDataLakeStoreLinkedService{}
	case "AzureDatabricks":
		b = &AzureDatabricksLinkedService{}
	case "AzureFileStorage":
		b = &AzureFileStorageLinkedService{}
	case "AzureFunction":
		b = &AzureFunctionLinkedService{}
	case "AzureKeyVault":
		b = &AzureKeyVaultLinkedService{}
	case "AzureML":
		b = &AzureMlLinkedService{}
	case "AzureMLService":
		b = &AzureMlServiceLinkedService{}
	case "AzureMariaDB":
		b = &AzureMariaDbLinkedService{}
	case "AzureMySql":
		b = &AzureMySQLLinkedService{}
	case "AzurePostgreSql":
		b = &AzurePostgreSQLLinkedService{}
	case "AzureSearch":
		b = &AzureSearchLinkedService{}
	case "AzureSqlDW":
		b = &AzureSQLDwLinkedService{}
	case "AzureSqlDatabase":
		b = &AzureSQLDatabaseLinkedService{}
	case "AzureSqlMI":
		b = &AzureSQLMiLinkedService{}
	case "AzureStorage":
		b = &AzureStorageLinkedService{}
	case "AzureTableStorage":
		b = &AzureTableStorageLinkedService{}
	case "Cassandra":
		b = &CassandraLinkedService{}
	case "CommonDataServiceForApps":
		b = &CommonDataServiceForAppsLinkedService{}
	case "Concur":
		b = &ConcurLinkedService{}
	case "CosmosDb":
		b = &CosmosDbLinkedService{}
	case "CosmosDbMongoDbApi":
		b = &CosmosDbMongoDbAPILinkedService{}
	case "Couchbase":
		b = &CouchbaseLinkedService{}
	case "CustomDataSource":
		b = &CustomDataSourceLinkedService{}
	case "Db2":
		b = &Db2LinkedService{}
	case "Drill":
		b = &DrillLinkedService{}
	case "Dynamics":
		b = &DynamicsLinkedService{}
	case "DynamicsAX":
		b = &DynamicsAxLinkedService{}
	case "DynamicsCrm":
		b = &DynamicsCrmLinkedService{}
	case "Eloqua":
		b = &EloquaLinkedService{}
	case "FileServer":
		b = &FileServerLinkedService{}
	case "FtpServer":
		b = &FtpServerLinkedService{}
	case "GoogleAdWords":
		b = &GoogleAdWordsLinkedService{}
	case "GoogleBigQuery":
		b = &GoogleBigQueryLinkedService{}
	case "GoogleCloudStorage":
		b = &GoogleCloudStorageLinkedService{}
	case "Greenplum":
		b = &GreenplumLinkedService{}
	case "HBase":
		b = &HBaseLinkedService{}
	case "HDInsight":
		b = &HdInsightLinkedService{}
	case "HDInsightOnDemand":
		b = &HdInsightOnDemandLinkedService{}
	case "Hdfs":
		b = &HdfsLinkedService{}
	case "Hive":
		b = &HiveLinkedService{}
	case "HttpServer":
		b = &HTTPLinkedService{}
	case "Hubspot":
		b = &HubspotLinkedService{}
	case "Impala":
		b = &ImpalaLinkedService{}
	case "Informix":
		b = &InformixLinkedService{}
	case "Jira":
		b = &JiraLinkedService{}
	case "Magento":
		b = &MagentoLinkedService{}
	case "MariaDB":
		b = &MariaDbLinkedService{}
	case "Marketo":
		b = &MarketoLinkedService{}
	case "MicrosoftAccess":
		b = &MicrosoftAccessLinkedService{}
	case "MongoDb":
		b = &MongoDbLinkedService{}
	case "MongoDbV2":
		b = &MongoDbV2LinkedService{}
	case "MySql":
		b = &MySQLLinkedService{}
	case "Netezza":
		b = &NetezzaLinkedService{}
	case "OData":
		b = &ODataLinkedService{}
	case "Odbc":
		b = &OdbcLinkedService{}
	case "Office365":
		b = &Office365LinkedService{}
	case "Oracle":
		b = &OracleLinkedService{}
	case "OracleServiceCloud":
		b = &OracleServiceCloudLinkedService{}
	case "Paypal":
		b = &PaypalLinkedService{}
	case "Phoenix":
		b = &PhoenixLinkedService{}
	case "PostgreSql":
		b = &PostgreSQLLinkedService{}
	case "Presto":
		b = &PrestoLinkedService{}
	case "QuickBooks":
		b = &QuickBooksLinkedService{}
	case "Responsys":
		b = &ResponsysLinkedService{}
	case "RestService":
		b = &RestServiceLinkedService{}
	case "Salesforce":
		b = &SalesforceLinkedService{}
	case "SalesforceMarketingCloud":
		b = &SalesforceMarketingCloudLinkedService{}
	case "SalesforceServiceCloud":
		b = &SalesforceServiceCloudLinkedService{}
	case "SapBW":
		b = &SapBwLinkedService{}
	case "SapCloudForCustomer":
		b = &SapCloudForCustomerLinkedService{}
	case "SapEcc":
		b = &SapEccLinkedService{}
	case "SapHana":
		b = &SapHanaLinkedService{}
	case "SapOpenHub":
		b = &SapOpenHubLinkedService{}
	case "SapTable":
		b = &SapTableLinkedService{}
	case "ServiceNow":
		b = &ServiceNowLinkedService{}
	case "Sftp":
		b = &SftpServerLinkedService{}
	case "Shopify":
		b = &ShopifyLinkedService{}
	case "Spark":
		b = &SparkLinkedService{}
	case "SqlServer":
		b = &SQLServerLinkedService{}
	case "Square":
		b = &SquareLinkedService{}
	case "Sybase":
		b = &SybaseLinkedService{}
	case "Teradata":
		b = &TeradataLinkedService{}
	case "Vertica":
		b = &VerticaLinkedService{}
	case "Web":
		b = &WebLinkedService{}
	case "Xero":
		b = &XeroLinkedService{}
	case "Zoho":
		b = &ZohoLinkedService{}
	default:
		b = &LinkedService{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalLinkedServiceClassificationArray(body []byte) (*[]LinkedServiceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]LinkedServiceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalLinkedServiceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalSecretBaseClassification(body []byte) (SecretBaseClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b SecretBaseClassification
	switch m["type"] {
	case "AzureKeyVaultSecret":
		b = &AzureKeyVaultSecretReference{}
	case "SecureString":
		b = &SecureString{}
	default:
		b = &SecretBase{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalSecretBaseClassificationArray(body []byte) (*[]SecretBaseClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SecretBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSecretBaseClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalStoreReadSettingsClassification(body []byte) (StoreReadSettingsClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b StoreReadSettingsClassification
	switch m["type"] {
	case "AmazonS3ReadSettings":
		b = &AmazonS3ReadSettings{}
	case "AzureBlobFSReadSettings":
		b = &AzureBlobFsReadSettings{}
	case "AzureBlobStorageReadSettings":
		b = &AzureBlobStorageReadSettings{}
	case "AzureDataLakeStoreReadSettings":
		b = &AzureDataLakeStoreReadSettings{}
	case "AzureFileStorageReadSettings":
		b = &AzureFileStorageReadSettings{}
	case "FileServerReadSettings":
		b = &FileServerReadSettings{}
	case "FtpReadSettings":
		b = &FtpReadSettings{}
	case "GoogleCloudStorageReadSettings":
		b = &GoogleCloudStorageReadSettings{}
	case "HdfsReadSettings":
		b = &HdfsReadSettings{}
	case "HttpReadSettings":
		b = &HTTPReadSettings{}
	case "SftpReadSettings":
		b = &SftpReadSettings{}
	default:
		b = &StoreReadSettings{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalStoreReadSettingsClassificationArray(body []byte) (*[]StoreReadSettingsClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]StoreReadSettingsClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalStoreReadSettingsClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalStoreWriteSettingsClassification(body []byte) (StoreWriteSettingsClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b StoreWriteSettingsClassification
	switch m["type"] {
	case "AzureBlobFSWriteSettings":
		b = &AzureBlobFsWriteSettings{}
	case "AzureBlobStorageWriteSettings":
		b = &AzureBlobStorageWriteSettings{}
	case "AzureDataLakeStoreWriteSettings":
		b = &AzureDataLakeStoreWriteSettings{}
	case "FileServerWriteSettings":
		b = &FileServerWriteSettings{}
	case "SftpWriteSettings":
		b = &SftpWriteSettings{}
	default:
		b = &StoreWriteSettings{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalStoreWriteSettingsClassificationArray(body []byte) (*[]StoreWriteSettingsClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]StoreWriteSettingsClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalStoreWriteSettingsClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalTriggerClassification(body []byte) (TriggerClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b TriggerClassification
	switch m["type"] {
	case "BlobEventsTrigger":
		b = &BlobEventsTrigger{}
	case "BlobTrigger":
		b = &BlobTrigger{}
	case "ChainingTrigger":
		b = &ChainingTrigger{}
	case "MultiplePipelineTrigger":
		b = &MultiplePipelineTrigger{}
	case "RerunTumblingWindowTrigger":
		b = &RerunTumblingWindowTrigger{}
	case "ScheduleTrigger":
		b = &ScheduleTrigger{}
	case "TumblingWindowTrigger":
		b = &TumblingWindowTrigger{}
	default:
		b = &Trigger{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalTriggerClassificationArray(body []byte) (*[]TriggerClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TriggerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTriggerClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalMultiplePipelineTriggerClassification(body []byte) (MultiplePipelineTriggerClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b MultiplePipelineTriggerClassification
	switch m["type"] {
	case "BlobEventsTrigger":
		b = &BlobEventsTrigger{}
	case "BlobTrigger":
		b = &BlobTrigger{}
	case "ScheduleTrigger":
		b = &ScheduleTrigger{}
	default:
		b = &MultiplePipelineTrigger{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalMultiplePipelineTriggerClassificationArray(body []byte) (*[]MultiplePipelineTriggerClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MultiplePipelineTriggerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMultiplePipelineTriggerClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalWebLinkedServiceTypePropertiesClassification(body []byte) (WebLinkedServiceTypePropertiesClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b WebLinkedServiceTypePropertiesClassification
	switch m["authenticationType"] {
	case WebAuthenticationTypeAnonymous:
		b = &WebAnonymousAuthentication{}
	case WebAuthenticationTypeBasic:
		b = &WebBasicAuthentication{}
	case WebAuthenticationTypeClientCertificate:
		b = &WebClientCertificateAuthentication{}
	default:
		b = &WebLinkedServiceTypeProperties{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalWebLinkedServiceTypePropertiesClassificationArray(body []byte) (*[]WebLinkedServiceTypePropertiesClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]WebLinkedServiceTypePropertiesClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalWebLinkedServiceTypePropertiesClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func strptr(s string) *string {
	return &s
}
