// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// ActivityClassification provides polymorphic access to related types.
// Call the interface's GetActivity() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Activity, *AppendVariableActivity, *AzureDataExplorerCommandActivity, *AzureFunctionActivity, *AzureMLBatchExecutionActivity,
// - *AzureMLExecutePipelineActivity, *AzureMLUpdateResourceActivity, *ControlActivity, *CopyActivity, *CustomActivity, *DataLakeAnalyticsUsqlActivity,
// - *DatabricksNotebookActivity, *DatabricksSparkJarActivity, *DatabricksSparkPythonActivity, *DeleteActivity, *ExecuteDataFlowActivity,
// - *ExecutePipelineActivity, *ExecuteSsisPackageActivity, *ExecutionActivity, *FilterActivity, *ForEachActivity, *GetMetadataActivity,
// - *HDInsightHiveActivity, *HDInsightMapReduceActivity, *HDInsightPigActivity, *HDInsightSparkActivity, *HDInsightStreamingActivity,
// - *IfConditionActivity, *LookupActivity, *SetVariableActivity, *SynapseSparkJobDefinitionActivity, *SqlPoolStoredProcedureActivity,
// - *SqlServerStoredProcedureActivity, *SwitchActivity, *SynapseNotebookActivity, *UntilActivity, *ValidationActivity, *WaitActivity,
// - *WebActivity, *WebHookActivity
type ActivityClassification interface {
	// GetActivity() returns the Activity content of the underlying type.
	GetActivity() *Activity
}

// A pipeline activity.
type Activity struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Activity depends on condition.
	DependsOn *[]ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity name.
	Name *string `json:"name,omitempty"`

	// Type of activity.
	Type *string `json:"type,omitempty"`

	// Activity user properties.
	UserProperties *[]UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type Activity.
func (a *Activity) GetActivity() *Activity { return a }

// UnmarshalJSON implements the json.Unmarshaller interface for type Activity.
func (a *Activity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a Activity) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if a.DependsOn != nil {
		objectMap["dependsOn"] = a.DependsOn
	}
	if a.Description != nil {
		objectMap["description"] = a.Description
	}
	if a.Name != nil {
		objectMap["name"] = a.Name
	}
	a.Type = &discValue
	objectMap["type"] = a.Type
	if a.UserProperties != nil {
		objectMap["userProperties"] = a.UserProperties
	}
	if a.AdditionalProperties != nil {
		for key, val := range *a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (a *Activity) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			if val != nil {
				err = json.Unmarshal(*val, &a.DependsOn)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &a.Description)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &a.Name)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &a.Type)
			}
			delete(rawMsg, key)
		case "userProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.UserProperties)
			}
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*a.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Activity dependency information.
type ActivityDependency struct {
	// Activity name.
	Activity *string `json:"activity,omitempty"`

	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Match-Condition for the dependency.
	DependencyConditions *[]DependencyCondition `json:"dependencyConditions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityDependency.
func (a ActivityDependency) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Activity != nil {
		objectMap["activity"] = a.Activity
	}
	if a.DependencyConditions != nil {
		objectMap["dependencyConditions"] = a.DependencyConditions
	}
	if a.AdditionalProperties != nil {
		for key, val := range *a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityDependency.
func (a *ActivityDependency) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activity":
			if val != nil {
				err = json.Unmarshal(*val, &a.Activity)
			}
			delete(rawMsg, key)
		case "dependencyConditions":
			if val != nil {
				err = json.Unmarshal(*val, &a.DependencyConditions)
			}
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*a.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Execution policy for an activity.
type ActivityPolicy struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
	Retry *interface{} `json:"retry,omitempty"`

	// Interval between each retry attempt (in seconds). The default is 30 sec.
	RetryIntervalInSeconds *int32 `json:"retryIntervalInSeconds,omitempty"`

	// When set to true, Input from activity is considered as secure and will not be logged to monitoring.
	SecureInput *bool `json:"secureInput,omitempty"`

	// When set to true, Output from activity is considered as secure and will not be logged to monitoring.
	SecureOutput *bool `json:"secureOutput,omitempty"`

	// Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *interface{} `json:"timeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityPolicy.
func (a ActivityPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Retry != nil {
		objectMap["retry"] = a.Retry
	}
	if a.RetryIntervalInSeconds != nil {
		objectMap["retryIntervalInSeconds"] = a.RetryIntervalInSeconds
	}
	if a.SecureInput != nil {
		objectMap["secureInput"] = a.SecureInput
	}
	if a.SecureOutput != nil {
		objectMap["secureOutput"] = a.SecureOutput
	}
	if a.Timeout != nil {
		objectMap["timeout"] = a.Timeout
	}
	if a.AdditionalProperties != nil {
		for key, val := range *a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityPolicy.
func (a *ActivityPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retry":
			if val != nil {
				err = json.Unmarshal(*val, &a.Retry)
			}
			delete(rawMsg, key)
		case "retryIntervalInSeconds":
			if val != nil {
				err = json.Unmarshal(*val, &a.RetryIntervalInSeconds)
			}
			delete(rawMsg, key)
		case "secureInput":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecureInput)
			}
			delete(rawMsg, key)
		case "secureOutput":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecureOutput)
			}
			delete(rawMsg, key)
		case "timeout":
			if val != nil {
				err = json.Unmarshal(*val, &a.Timeout)
			}
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*a.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Information about an activity run in a pipeline.
type ActivityRun struct {
	// The name of the activity.
	ActivityName *string `json:"activityName,omitempty" azure:"ro"`

	// The end time of the activity run in 'ISO 8601' format.
	ActivityRunEnd *time.Time `json:"activityRunEnd,omitempty" azure:"ro"`

	// The id of the activity run.
	ActivityRunID *string `json:"activityRunId,omitempty" azure:"ro"`

	// The start time of the activity run in 'ISO 8601' format.
	ActivityRunStart *time.Time `json:"activityRunStart,omitempty" azure:"ro"`

	// The type of the activity.
	ActivityType *string `json:"activityType,omitempty" azure:"ro"`

	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The duration of the activity run.
	DurationInMS *int32 `json:"durationInMs,omitempty" azure:"ro"`

	// The error if any from the activity run.
	Error *interface{} `json:"error,omitempty" azure:"ro"`

	// The input for the activity.
	Input *interface{} `json:"input,omitempty" azure:"ro"`

	// The name of the compute linked service.
	LinkedServiceName *string `json:"linkedServiceName,omitempty" azure:"ro"`

	// The output for the activity.
	Output *interface{} `json:"output,omitempty" azure:"ro"`

	// The name of the pipeline.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// The id of the pipeline run.
	PipelineRunID *string `json:"pipelineRunId,omitempty" azure:"ro"`

	// The status of the activity run.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityRun.
func (a ActivityRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.ActivityName != nil {
		objectMap["activityName"] = a.ActivityName
	}
	if a.ActivityRunEnd != nil {
		objectMap["activityRunEnd"] = (*timeRFC3339)(a.ActivityRunEnd)
	}
	if a.ActivityRunID != nil {
		objectMap["activityRunId"] = a.ActivityRunID
	}
	if a.ActivityRunStart != nil {
		objectMap["activityRunStart"] = (*timeRFC3339)(a.ActivityRunStart)
	}
	if a.ActivityType != nil {
		objectMap["activityType"] = a.ActivityType
	}
	if a.DurationInMS != nil {
		objectMap["durationInMs"] = a.DurationInMS
	}
	if a.Error != nil {
		objectMap["error"] = a.Error
	}
	if a.Input != nil {
		objectMap["input"] = a.Input
	}
	if a.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = a.LinkedServiceName
	}
	if a.Output != nil {
		objectMap["output"] = a.Output
	}
	if a.PipelineName != nil {
		objectMap["pipelineName"] = a.PipelineName
	}
	if a.PipelineRunID != nil {
		objectMap["pipelineRunId"] = a.PipelineRunID
	}
	if a.Status != nil {
		objectMap["status"] = a.Status
	}
	if a.AdditionalProperties != nil {
		for key, val := range *a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityRun.
func (a *ActivityRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ActivityName)
			}
			delete(rawMsg, key)
		case "activityRunEnd":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				a.ActivityRunEnd = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "activityRunId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ActivityRunID)
			}
			delete(rawMsg, key)
		case "activityRunStart":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				a.ActivityRunStart = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "activityType":
			if val != nil {
				err = json.Unmarshal(*val, &a.ActivityType)
			}
			delete(rawMsg, key)
		case "durationInMs":
			if val != nil {
				err = json.Unmarshal(*val, &a.DurationInMS)
			}
			delete(rawMsg, key)
		case "error":
			if val != nil {
				err = json.Unmarshal(*val, &a.Error)
			}
			delete(rawMsg, key)
		case "input":
			if val != nil {
				err = json.Unmarshal(*val, &a.Input)
			}
			delete(rawMsg, key)
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &a.LinkedServiceName)
			}
			delete(rawMsg, key)
		case "output":
			if val != nil {
				err = json.Unmarshal(*val, &a.Output)
			}
			delete(rawMsg, key)
		case "pipelineName":
			if val != nil {
				err = json.Unmarshal(*val, &a.PipelineName)
			}
			delete(rawMsg, key)
		case "pipelineRunId":
			if val != nil {
				err = json.Unmarshal(*val, &a.PipelineRunID)
			}
			delete(rawMsg, key)
		case "status":
			if val != nil {
				err = json.Unmarshal(*val, &a.Status)
			}
			delete(rawMsg, key)
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*a.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A list activity runs.
type ActivityRunsQueryResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of activity runs.
	Value *[]ActivityRun `json:"value,omitempty"`
}

// ActivityRunsQueryResponseResponse is the response envelope for operations that return a ActivityRunsQueryResponse type.
type ActivityRunsQueryResponseResponse struct {
	// A list activity runs.
	ActivityRunsQueryResponse *ActivityRunsQueryResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Response body structure for starting data flow debug session.
type AddDataFlowToDebugSessionResponse struct {
	// The ID of data flow debug job version.
	JobVersion *string `json:"jobVersion,omitempty"`
}

// AddDataFlowToDebugSessionResponseResponse is the response envelope for operations that return a AddDataFlowToDebugSessionResponse type.
type AddDataFlowToDebugSessionResponseResponse struct {
	// Response body structure for starting data flow debug session.
	AddDataFlowToDebugSessionResponse *AddDataFlowToDebugSessionResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Amazon Marketplace Web Service linked service.
type AmazonMwsLinkedService struct {
	LinkedService
	// Amazon Marketplace Web Service linked service properties.
	TypeProperties *AmazonMwsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMwsLinkedService.
func (a AmazonMwsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AmazonMWS")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsLinkedService.
func (a *AmazonMwsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Amazon Marketplace Web Service linked service properties.
type AmazonMwsLinkedServiceTypeProperties struct {
	// The access key id used to access data.
	AccessKeyID *interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate them with a comma (,). (i.e. A2EUQ1WTGCTBG2)
	MarketplaceID *interface{} `json:"marketplaceID,omitempty"`

	// The Amazon MWS authentication token.
	MwsAuthToken SecretBaseClassification `json:"mwsAuthToken,omitempty"`

	// The secret key used to access data.
	SecretKey SecretBaseClassification `json:"secretKey,omitempty"`

	// The Amazon seller ID.
	SellerID *interface{} `json:"sellerID,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsLinkedServiceTypeProperties.
func (a *AmazonMwsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccessKeyID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.Endpoint)
			}
			delete(rawMsg, key)
		case "marketplaceID":
			if val != nil {
				err = json.Unmarshal(*val, &a.MarketplaceID)
			}
			delete(rawMsg, key)
		case "mwsAuthToken":
			if val != nil {
				a.MwsAuthToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "secretKey":
			if val != nil {
				a.SecretKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "sellerID":
			if val != nil {
				err = json.Unmarshal(*val, &a.SellerID)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &a.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &a.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &a.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Amazon Marketplace Web Service dataset.
type AmazonMwsObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMwsObjectDataset.
func (a AmazonMwsObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AmazonMWSObject")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsObjectDataset.
func (a *AmazonMwsObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Amazon Marketplace Web Service source.
type AmazonMwsSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMwsSource.
func (a AmazonMwsSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AmazonMWSSource")
	if a.Query != nil {
		objectMap["query"] = a.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsSource.
func (a *AmazonMwsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &a.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// Linked service for Amazon Redshift.
type AmazonRedshiftLinkedService struct {
	LinkedService
	// Amazon Redshift linked service properties.
	TypeProperties *AmazonRedshiftLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftLinkedService.
func (a AmazonRedshiftLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AmazonRedshift")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedService.
func (a *AmazonRedshiftLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Amazon Redshift linked service properties.
type AmazonRedshiftLinkedServiceTypeProperties struct {
	// The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password of the Amazon Redshift source.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type: integer (or Expression with
	// resultType integer).
	Port *interface{} `json:"port,omitempty"`

	// The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedServiceTypeProperties.
func (a *AmazonRedshiftLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &a.Database)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				a.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &a.Port)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &a.Server)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &a.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for Amazon Redshift Source.
type AmazonRedshiftSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`

	// The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with unload. With this, data from Amazon Redshift source will
	// be unloaded into S3 first and then copied into
	// the targeted sink from the interim S3.
	RedshiftUnloadSettings *RedshiftUnloadSettings `json:"redshiftUnloadSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftSource.
func (a AmazonRedshiftSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AmazonRedshiftSource")
	if a.Query != nil {
		objectMap["query"] = a.Query
	}
	if a.RedshiftUnloadSettings != nil {
		objectMap["redshiftUnloadSettings"] = a.RedshiftUnloadSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftSource.
func (a *AmazonRedshiftSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &a.Query)
			}
			delete(rawMsg, key)
		case "redshiftUnloadSettings":
			if val != nil {
				err = json.Unmarshal(*val, &a.RedshiftUnloadSettings)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// The Amazon Redshift table dataset.
type AmazonRedshiftTableDataset struct {
	Dataset
	// Amazon Redshift table dataset properties.
	TypeProperties *AmazonRedshiftTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftTableDataset.
func (a AmazonRedshiftTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AmazonRedshiftTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftTableDataset.
func (a *AmazonRedshiftTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Amazon Redshift table dataset properties.
type AmazonRedshiftTableDatasetTypeProperties struct {
	// The Amazon Redshift schema name. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The Amazon Redshift table name. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Linked service for Amazon S3.
type AmazonS3LinkedService struct {
	LinkedService
	// Amazon S3 linked service properties.
	TypeProperties *AmazonS3LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3LinkedService.
func (a AmazonS3LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AmazonS3")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedService.
func (a *AmazonS3LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Amazon S3 linked service properties.
type AmazonS3LinkedServiceTypeProperties struct {
	// The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
	AccessKeyID *interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you want to try a different service
	// endpoint or want to switch between https and
	// http. Type: string (or Expression with resultType string).
	ServiceURL *interface{} `json:"serviceUrl,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedServiceTypeProperties.
func (a *AmazonS3LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccessKeyID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "secretAccessKey":
			if val != nil {
				a.SecretAccessKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "serviceUrl":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServiceURL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of amazon S3 dataset.
type AmazonS3Location struct {
	DatasetLocation
	// Specify the bucketName of amazon S3. Type: string (or Expression with resultType string)
	BucketName *interface{} `json:"bucketName,omitempty"`

	// Specify the version of amazon S3. Type: string (or Expression with resultType string).
	Version *interface{} `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3Location.
func (a AmazonS3Location) MarshalJSON() ([]byte, error) {
	objectMap := a.DatasetLocation.marshalInternal("AmazonS3Location")
	if a.BucketName != nil {
		objectMap["bucketName"] = a.BucketName
	}
	if a.Version != nil {
		objectMap["version"] = a.Version
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3Location.
func (a *AmazonS3Location) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			if val != nil {
				err = json.Unmarshal(*val, &a.BucketName)
			}
			delete(rawMsg, key)
		case "version":
			if val != nil {
				err = json.Unmarshal(*val, &a.Version)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.DatasetLocation.unmarshalInternal(rawMsg)
}

// Azure data lake store read settings.
type AmazonS3ReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// The prefix filter for the S3 object name. Type: string (or Expression with resultType string).
	Prefix *interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// AmazonS3 wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// AmazonS3 wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3ReadSettings.
func (a AmazonS3ReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreReadSettings.marshalInternal("AmazonS3ReadSettings")
	if a.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = a.EnablePartitionDiscovery
	}
	if a.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = a.ModifiedDatetimeEnd
	}
	if a.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = a.ModifiedDatetimeStart
	}
	if a.Prefix != nil {
		objectMap["prefix"] = a.Prefix
	}
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	if a.WildcardFileName != nil {
		objectMap["wildcardFileName"] = a.WildcardFileName
	}
	if a.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = a.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3ReadSettings.
func (a *AmazonS3ReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &a.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "prefix":
			if val != nil {
				err = json.Unmarshal(*val, &a.Prefix)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreReadSettings.unmarshalInternal(rawMsg)
}

// Append value for a Variable of type Array.
type AppendVariableActivity struct {
	Activity
	// Append Variable activity properties.
	TypeProperties *AppendVariableActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AppendVariableActivity.
func (a AppendVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.Activity.marshalInternal("AppendVariable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppendVariableActivity.
func (a *AppendVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Activity.unmarshalInternal(rawMsg)
}

// AppendVariable activity properties.
type AppendVariableActivityTypeProperties struct {
	// Value to be appended. Could be a static value or Expression
	Value *interface{} `json:"value,omitempty"`

	// Name of the variable whose value needs to be appended to.
	VariableName *string `json:"variableName,omitempty"`
}

// Request body structure for rename artifact.
type ArtifactRenameRequest struct {
	// New name of the artifact.
	NewName *string `json:"newName,omitempty"`
}

// Auto-pausing properties of a Big Data pool powered by Apache Spark
type AutoPauseProperties struct {
	// Number of minutes of idle time before the Big Data pool is automatically paused.
	DelayInMinutes *int32 `json:"delayInMinutes,omitempty"`

	// Whether auto-pausing is enabled for the Big Data pool.
	Enabled *bool `json:"enabled,omitempty"`
}

// Auto-scaling properties of a Big Data pool powered by Apache Spark
type AutoScaleProperties struct {
	// Whether automatic scaling is enabled for the Big Data pool.
	Enabled *bool `json:"enabled,omitempty"`

	// The maximum number of nodes the Big Data pool can support.
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`

	// The minimum number of nodes the Big Data pool can support.
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
}

// Avro dataset.
type AvroDataset struct {
	Dataset
	// Avro dataset properties.
	TypeProperties *AvroDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvroDataset.
func (a AvroDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("Avro")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDataset.
func (a *AvroDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Avro dataset properties.
type AvroDatasetTypeProperties struct {
	AvroCompressionCodec *AvroCompressionCodec `json:"avroCompressionCodec,omitempty"`
	AvroCompressionLevel *int32                `json:"avroCompressionLevel,omitempty"`

	// The location of the avro storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDatasetTypeProperties.
func (a *AvroDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avroCompressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &a.AvroCompressionCodec)
			}
			delete(rawMsg, key)
		case "avroCompressionLevel":
			if val != nil {
				err = json.Unmarshal(*val, &a.AvroCompressionLevel)
			}
			delete(rawMsg, key)
		case "location":
			if val != nil {
				a.Location, err = unmarshalDatasetLocationClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The data stored in Avro format.
type AvroFormat struct {
	DatasetStorageFormat
}

// MarshalJSON implements the json.Marshaller interface for type AvroFormat.
func (a AvroFormat) MarshalJSON() ([]byte, error) {
	objectMap := a.DatasetStorageFormat.marshalInternal("AvroFormat")
	return json.Marshal(objectMap)
}

// A copy activity Avro sink.
type AvroSink struct {
	CopySink
	// Avro format settings.
	FormatSettings *AvroWriteSettings `json:"formatSettings,omitempty"`

	// Avro store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvroSink.
func (a AvroSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AvroSink")
	if a.FormatSettings != nil {
		objectMap["formatSettings"] = a.FormatSettings
	}
	if a.StoreSettings != nil {
		objectMap["storeSettings"] = a.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSink.
func (a *AvroSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "formatSettings":
			if val != nil {
				err = json.Unmarshal(*val, &a.FormatSettings)
			}
			delete(rawMsg, key)
		case "storeSettings":
			if val != nil {
				a.StoreSettings, err = unmarshalStoreWriteSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Avro source.
type AvroSource struct {
	CopySource
	// Avro store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvroSource.
func (a AvroSource) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySource.marshalInternal("AvroSource")
	if a.StoreSettings != nil {
		objectMap["storeSettings"] = a.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroSource.
func (a *AvroSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				a.StoreSettings, err = unmarshalStoreReadSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySource.unmarshalInternal(rawMsg)
}

// Avro write settings.
type AvroWriteSettings struct {
	FormatWriteSettings
	// Top level record name in write result, which is required in AVRO spec.
	RecordName *string `json:"recordName,omitempty"`

	// Record namespace in the write result.
	RecordNamespace *string `json:"recordNamespace,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvroWriteSettings.
func (a AvroWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.FormatWriteSettings.marshalInternal("AvroWriteSettings")
	if a.RecordName != nil {
		objectMap["recordName"] = a.RecordName
	}
	if a.RecordNamespace != nil {
		objectMap["recordNamespace"] = a.RecordNamespace
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroWriteSettings.
func (a *AvroWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recordName":
			if val != nil {
				err = json.Unmarshal(*val, &a.RecordName)
			}
			delete(rawMsg, key)
		case "recordNamespace":
			if val != nil {
				err = json.Unmarshal(*val, &a.RecordNamespace)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.FormatWriteSettings.unmarshalInternal(rawMsg)
}

// Azure Batch linked service.
type AzureBatchLinkedService struct {
	LinkedService
	// Azure Batch linked service properties.
	TypeProperties *AzureBatchLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBatchLinkedService.
func (a AzureBatchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureBatch")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedService.
func (a *AzureBatchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Batch linked service properties.
type AzureBatchLinkedServiceTypeProperties struct {
	// The Azure Batch account access key.
	AccessKey SecretBaseClassification `json:"accessKey,omitempty"`

	// The Azure Batch account name. Type: string (or Expression with resultType string).
	AccountName *interface{} `json:"accountName,omitempty"`

	// The Azure Batch URI. Type: string (or Expression with resultType string).
	BatchURI *interface{} `json:"batchUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure Storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The Azure Batch pool name. Type: string (or Expression with resultType string).
	PoolName *interface{} `json:"poolName,omitempty"`
}

// Azure Data Lake Storage Gen2 linked service.
type AzureBlobFsLinkedService struct {
	LinkedService
	// Azure Data Lake Storage Gen2 linked service properties.
	TypeProperties *AzureBlobFsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsLinkedService.
func (a AzureBlobFsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureBlobFS")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsLinkedService.
func (a *AzureBlobFsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Data Lake Storage Gen2 linked service properties.
type AzureBlobFsLinkedServiceTypeProperties struct {
	// Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
	AccountKey *interface{} `json:"accountKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsLinkedServiceTypeProperties.
func (a *AzureBlobFsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountKey)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &a.URL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of azure blobFS dataset.
type AzureBlobFsLocation struct {
	DatasetLocation
	// Specify the fileSystem of azure blobFS. Type: string (or Expression with resultType string).
	FileSystem *interface{} `json:"fileSystem,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsLocation.
func (a AzureBlobFsLocation) MarshalJSON() ([]byte, error) {
	objectMap := a.DatasetLocation.marshalInternal("AzureBlobFSLocation")
	if a.FileSystem != nil {
		objectMap["fileSystem"] = a.FileSystem
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsLocation.
func (a *AzureBlobFsLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileSystem":
			if val != nil {
				err = json.Unmarshal(*val, &a.FileSystem)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.DatasetLocation.unmarshalInternal(rawMsg)
}

// Azure blobFS read settings.
type AzureBlobFsReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Azure blobFS wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// Azure blobFS wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsReadSettings.
func (a AzureBlobFsReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreReadSettings.marshalInternal("AzureBlobFSReadSettings")
	if a.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = a.EnablePartitionDiscovery
	}
	if a.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = a.ModifiedDatetimeEnd
	}
	if a.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = a.ModifiedDatetimeStart
	}
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	if a.WildcardFileName != nil {
		objectMap["wildcardFileName"] = a.WildcardFileName
	}
	if a.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = a.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsReadSettings.
func (a *AzureBlobFsReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &a.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreReadSettings.unmarshalInternal(rawMsg)
}

// A copy activity Azure Data Lake Storage Gen2 sink.
type AzureBlobFsSink struct {
	CopySink
	// The type of copy behavior for copy sink.
	CopyBehavior *interface{} `json:"copyBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsSink.
func (a AzureBlobFsSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureBlobFSSink")
	if a.CopyBehavior != nil {
		objectMap["copyBehavior"] = a.CopyBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsSink.
func (a *AzureBlobFsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &a.CopyBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure BlobFS source.
type AzureBlobFsSource struct {
	CopySource
	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
	SkipHeaderLineCount *interface{} `json:"skipHeaderLineCount,omitempty"`

	// Treat empty as null. Type: boolean (or Expression with resultType boolean).
	TreatEmptyAsNull *interface{} `json:"treatEmptyAsNull,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsSource.
func (a AzureBlobFsSource) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySource.marshalInternal("AzureBlobFSSource")
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	if a.SkipHeaderLineCount != nil {
		objectMap["skipHeaderLineCount"] = a.SkipHeaderLineCount
	}
	if a.TreatEmptyAsNull != nil {
		objectMap["treatEmptyAsNull"] = a.TreatEmptyAsNull
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsSource.
func (a *AzureBlobFsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		case "skipHeaderLineCount":
			if val != nil {
				err = json.Unmarshal(*val, &a.SkipHeaderLineCount)
			}
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			if val != nil {
				err = json.Unmarshal(*val, &a.TreatEmptyAsNull)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySource.unmarshalInternal(rawMsg)
}

// Azure blobFS write settings.
type AzureBlobFsWriteSettings struct {
	StoreWriteSettings
	// Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
	BlockSizeInMb *interface{} `json:"blockSizeInMB,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsWriteSettings.
func (a AzureBlobFsWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreWriteSettings.marshalInternal("AzureBlobFSWriteSettings")
	if a.BlockSizeInMb != nil {
		objectMap["blockSizeInMB"] = a.BlockSizeInMb
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsWriteSettings.
func (a *AzureBlobFsWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blockSizeInMB":
			if val != nil {
				err = json.Unmarshal(*val, &a.BlockSizeInMb)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreWriteSettings.unmarshalInternal(rawMsg)
}

// The azure blob storage linked service.
type AzureBlobStorageLinkedService struct {
	LinkedService
	// Azure Blob Storage linked service properties.
	TypeProperties *AzureBlobStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLinkedService.
func (a AzureBlobStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureBlobStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedService.
func (a *AzureBlobStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Blob Storage linked service properties.
type AzureBlobStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
	SasURI *interface{} `json:"sasUri,omitempty"`

	// Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
	ServiceEndpoint *string `json:"serviceEndpoint,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Data Warehouse.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedServiceTypeProperties.
func (a *AzureBlobStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountKey)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "sasToken":
			if val != nil {
				err = json.Unmarshal(*val, &a.SasToken)
			}
			delete(rawMsg, key)
		case "sasUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.SasURI)
			}
			delete(rawMsg, key)
		case "serviceEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServiceEndpoint)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of azure blob dataset.
type AzureBlobStorageLocation struct {
	DatasetLocation
	// Specify the container of azure blob. Type: string (or Expression with resultType string).
	Container *interface{} `json:"container,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLocation.
func (a AzureBlobStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := a.DatasetLocation.marshalInternal("AzureBlobStorageLocation")
	if a.Container != nil {
		objectMap["container"] = a.Container
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLocation.
func (a *AzureBlobStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "container":
			if val != nil {
				err = json.Unmarshal(*val, &a.Container)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.DatasetLocation.unmarshalInternal(rawMsg)
}

// Azure blob read settings.
type AzureBlobStorageReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// The prefix filter for the Azure Blob name. Type: string (or Expression with resultType string).
	Prefix *interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Azure blob wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// Azure blob wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageReadSettings.
func (a AzureBlobStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreReadSettings.marshalInternal("AzureBlobStorageReadSettings")
	if a.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = a.EnablePartitionDiscovery
	}
	if a.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = a.ModifiedDatetimeEnd
	}
	if a.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = a.ModifiedDatetimeStart
	}
	if a.Prefix != nil {
		objectMap["prefix"] = a.Prefix
	}
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	if a.WildcardFileName != nil {
		objectMap["wildcardFileName"] = a.WildcardFileName
	}
	if a.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = a.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageReadSettings.
func (a *AzureBlobStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &a.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "prefix":
			if val != nil {
				err = json.Unmarshal(*val, &a.Prefix)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreReadSettings.unmarshalInternal(rawMsg)
}

// Azure blob write settings.
type AzureBlobStorageWriteSettings struct {
	StoreWriteSettings
	// Indicates the block size(MB) when writing data to blob. Type: integer (or Expression with resultType integer).
	BlockSizeInMb *interface{} `json:"blockSizeInMB,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageWriteSettings.
func (a AzureBlobStorageWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreWriteSettings.marshalInternal("AzureBlobStorageWriteSettings")
	if a.BlockSizeInMb != nil {
		objectMap["blockSizeInMB"] = a.BlockSizeInMb
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageWriteSettings.
func (a *AzureBlobStorageWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blockSizeInMB":
			if val != nil {
				err = json.Unmarshal(*val, &a.BlockSizeInMb)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreWriteSettings.unmarshalInternal(rawMsg)
}

// Azure Data Explorer command activity.
type AzureDataExplorerCommandActivity struct {
	ExecutionActivity
	// Azure Data Explorer command activity properties.
	TypeProperties *AzureDataExplorerCommandActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerCommandActivity.
func (a AzureDataExplorerCommandActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureDataExplorerCommand")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerCommandActivity.
func (a *AzureDataExplorerCommandActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Azure Data Explorer command activity properties.
type AzureDataExplorerCommandActivityTypeProperties struct {
	// A control command, according to the Azure Data Explorer command syntax. Type: string (or Expression with resultType string).
	Command *interface{} `json:"command,omitempty"`

	// Control command timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..)
	CommandTimeout *interface{} `json:"commandTimeout,omitempty"`
}

// Azure Data Explorer (Kusto) dataset properties.
type AzureDataExplorerDatasetTypeProperties struct {
	// The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`
}

// Azure Data Explorer (Kusto) linked service.
type AzureDataExplorerLinkedService struct {
	LinkedService
	// Azure Data Explorer (Kusto) linked service properties.
	TypeProperties *AzureDataExplorerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerLinkedService.
func (a AzureDataExplorerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDataExplorer")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedService.
func (a *AzureDataExplorerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Data Explorer (Kusto) linked service properties.
type AzureDataExplorerLinkedServiceTypeProperties struct {
	// Database name for connection. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://..kusto.windows.net. Type: string (or Expression with
	// resultType string)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Kusto.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedServiceTypeProperties.
func (a *AzureDataExplorerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &a.Database)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.Endpoint)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Azure Data Explorer sink.
type AzureDataExplorerSink struct {
	CopySink
	// If set to true, any aggregation will be skipped. Default is false. Type: boolean.
	FlushImmediately *interface{} `json:"flushImmediately,omitempty"`

	// An explicit column mapping description provided in a json format. Type: string.
	IngestionMappingAsJSON *interface{} `json:"ingestionMappingAsJson,omitempty"`

	// A name of a pre-created csv mapping that was defined on the target Kusto table. Type: string.
	IngestionMappingName *interface{} `json:"ingestionMappingName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerSink.
func (a AzureDataExplorerSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureDataExplorerSink")
	if a.FlushImmediately != nil {
		objectMap["flushImmediately"] = a.FlushImmediately
	}
	if a.IngestionMappingAsJSON != nil {
		objectMap["ingestionMappingAsJson"] = a.IngestionMappingAsJSON
	}
	if a.IngestionMappingName != nil {
		objectMap["ingestionMappingName"] = a.IngestionMappingName
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerSink.
func (a *AzureDataExplorerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "flushImmediately":
			if val != nil {
				err = json.Unmarshal(*val, &a.FlushImmediately)
			}
			delete(rawMsg, key)
		case "ingestionMappingAsJson":
			if val != nil {
				err = json.Unmarshal(*val, &a.IngestionMappingAsJSON)
			}
			delete(rawMsg, key)
		case "ingestionMappingName":
			if val != nil {
				err = json.Unmarshal(*val, &a.IngestionMappingName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure Data Explorer (Kusto) source.
type AzureDataExplorerSource struct {
	CopySource
	// The name of the Boolean option that controls whether truncation is applied to result-sets that go beyond a certain row-count limit.
	NoTruncation *interface{} `json:"noTruncation,omitempty"`

	// Database query. Should be a Kusto Query Language (KQL) query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..
	QueryTimeout *interface{} `json:"queryTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerSource.
func (a AzureDataExplorerSource) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySource.marshalInternal("AzureDataExplorerSource")
	if a.NoTruncation != nil {
		objectMap["noTruncation"] = a.NoTruncation
	}
	if a.Query != nil {
		objectMap["query"] = a.Query
	}
	if a.QueryTimeout != nil {
		objectMap["queryTimeout"] = a.QueryTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerSource.
func (a *AzureDataExplorerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "noTruncation":
			if val != nil {
				err = json.Unmarshal(*val, &a.NoTruncation)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &a.Query)
			}
			delete(rawMsg, key)
		case "queryTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &a.QueryTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySource.unmarshalInternal(rawMsg)
}

// The Azure Data Explorer (Kusto) dataset.
type AzureDataExplorerTableDataset struct {
	Dataset
	// Azure Data Explorer (Kusto) dataset properties.
	TypeProperties *AzureDataExplorerDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerTableDataset.
func (a AzureDataExplorerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureDataExplorerTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerTableDataset.
func (a *AzureDataExplorerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure Data Lake Analytics linked service.
type AzureDataLakeAnalyticsLinkedService struct {
	LinkedService
	// Azure Data Lake Analytics linked service properties.
	TypeProperties *AzureDataLakeAnalyticsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a AzureDataLakeAnalyticsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDataLakeAnalytics")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a *AzureDataLakeAnalyticsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Data Lake Analytics linked service properties.
type AzureDataLakeAnalyticsLinkedServiceTypeProperties struct {
	// The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
	AccountName *interface{} `json:"accountName,omitempty"`

	// Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
	DataLakeAnalyticsURI *interface{} `json:"dataLakeAnalyticsUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
	ResourceGroupName *interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Analytics account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
	SubscriptionID *interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedServiceTypeProperties.
func (a *AzureDataLakeAnalyticsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountName)
			}
			delete(rawMsg, key)
		case "dataLakeAnalyticsUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.DataLakeAnalyticsURI)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "resourceGroupName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceGroupName)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "subscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &a.SubscriptionID)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Data Lake Store linked service.
type AzureDataLakeStoreLinkedService struct {
	LinkedService
	// Azure Data Lake Store linked service properties.
	TypeProperties *AzureDataLakeStoreLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLinkedService.
func (a AzureDataLakeStoreLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDataLakeStore")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedService.
func (a *AzureDataLakeStoreLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Data Lake Store linked service properties.
type AzureDataLakeStoreLinkedServiceTypeProperties struct {
	// Data Lake Store account name. Type: string (or Expression with resultType string).
	AccountName *interface{} `json:"accountName,omitempty"`

	// Data Lake Store service URI. Type: string (or Expression with resultType string).
	DataLakeStoreURI *interface{} `json:"dataLakeStoreUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with resultType string).
	ResourceGroupName *interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Store account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType string).
	SubscriptionID *interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedServiceTypeProperties.
func (a *AzureDataLakeStoreLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountName)
			}
			delete(rawMsg, key)
		case "dataLakeStoreUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.DataLakeStoreURI)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "resourceGroupName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceGroupName)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "subscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &a.SubscriptionID)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of azure data lake store dataset.
type AzureDataLakeStoreLocation struct {
	DatasetLocation
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLocation.
func (a AzureDataLakeStoreLocation) MarshalJSON() ([]byte, error) {
	objectMap := a.DatasetLocation.marshalInternal("AzureDataLakeStoreLocation")
	return json.Marshal(objectMap)
}

// Azure data lake store read settings.
type AzureDataLakeStoreReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// ADLS wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// ADLS wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreReadSettings.
func (a AzureDataLakeStoreReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreReadSettings.marshalInternal("AzureDataLakeStoreReadSettings")
	if a.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = a.EnablePartitionDiscovery
	}
	if a.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = a.ModifiedDatetimeEnd
	}
	if a.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = a.ModifiedDatetimeStart
	}
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	if a.WildcardFileName != nil {
		objectMap["wildcardFileName"] = a.WildcardFileName
	}
	if a.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = a.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreReadSettings.
func (a *AzureDataLakeStoreReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &a.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreReadSettings.unmarshalInternal(rawMsg)
}

// A copy activity Azure Data Lake Store sink.
type AzureDataLakeStoreSink struct {
	CopySink
	// The type of copy behavior for copy sink.
	CopyBehavior *interface{} `json:"copyBehavior,omitempty"`

	// Single File Parallel.
	EnableAdlsSingleFileParallel *interface{} `json:"enableAdlsSingleFileParallel,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreSink.
func (a AzureDataLakeStoreSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureDataLakeStoreSink")
	if a.CopyBehavior != nil {
		objectMap["copyBehavior"] = a.CopyBehavior
	}
	if a.EnableAdlsSingleFileParallel != nil {
		objectMap["enableAdlsSingleFileParallel"] = a.EnableAdlsSingleFileParallel
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreSink.
func (a *AzureDataLakeStoreSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &a.CopyBehavior)
			}
			delete(rawMsg, key)
		case "enableAdlsSingleFileParallel":
			if val != nil {
				err = json.Unmarshal(*val, &a.EnableAdlsSingleFileParallel)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure Data Lake source.
type AzureDataLakeStoreSource struct {
	CopySource
	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreSource.
func (a AzureDataLakeStoreSource) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySource.marshalInternal("AzureDataLakeStoreSource")
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreSource.
func (a *AzureDataLakeStoreSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySource.unmarshalInternal(rawMsg)
}

// Azure data lake store write settings.
type AzureDataLakeStoreWriteSettings struct {
	StoreWriteSettings
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreWriteSettings.
func (a AzureDataLakeStoreWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreWriteSettings.marshalInternal("AzureDataLakeStoreWriteSettings")
	return json.Marshal(objectMap)
}

// Azure Databricks linked service.
type AzureDatabricksLinkedService struct {
	LinkedService
	// Azure Databricks linked service properties.
	TypeProperties *AzureDatabricksLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksLinkedService.
func (a AzureDatabricksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDatabricks")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedService.
func (a *AzureDatabricksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Databricks linked service properties.
type AzureDatabricksLinkedServiceTypeProperties struct {
	// Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string (or Expression with resultType
	// string).
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// .azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
	Domain *interface{} `json:"domain,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression with resultType string).
	ExistingClusterID *interface{} `json:"existingClusterId,omitempty"`

	// The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType string).
	InstancePoolID *interface{} `json:"instancePoolId,omitempty"`

	// Additional tags for cluster resources. This property is ignored in instance pool configurations.
	NewClusterCustomTags *map[string]interface{} `json:"newClusterCustomTags,omitempty"`

	// The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or Expression with resultType string).
	NewClusterDriverNodeType *interface{} `json:"newClusterDriverNodeType,omitempty"`

	// Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in Databricks (elastic disks are
	// always enabled). Type: boolean (or Expression
	// with resultType boolean).
	NewClusterEnableElasticDisk *interface{} `json:"newClusterEnableElasticDisk,omitempty"`

	// User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of strings).
	NewClusterInitScripts *interface{} `json:"newClusterInitScripts,omitempty"`

	// The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is not specified. If instancePoolId
	// is specified, this property is ignored. Type:
	// string (or Expression with resultType string).
	NewClusterNodeType *interface{} `json:"newClusterNodeType,omitempty"`

	// If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster or instance pool. For new job
	// clusters, this a string-formatted Int32, like '1'
	// means numOfWorker is 1 or '1:10' means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted Int32, and can only specify
	// a fixed number of worker nodes, such as '2'.
	// Required if newClusterVersion is specified. Type: string (or Expression with resultType string).
	NewClusterNumOfWorker *interface{} `json:"newClusterNumOfWorker,omitempty"`

	// A set of optional, user-specified Spark configuration key-value pairs.
	NewClusterSparkConf *map[string]interface{} `json:"newClusterSparkConf,omitempty"`

	// A set of optional, user-specified Spark environment variables key-value pairs.
	NewClusterSparkEnvVars *map[string]interface{} `json:"newClusterSparkEnvVars,omitempty"`

	// If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes created for each run of this
	// activity. Required if instancePoolId is
	// specified. Type: string (or Expression with resultType string).
	NewClusterVersion *interface{} `json:"newClusterVersion,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedServiceTypeProperties.
func (a *AzureDatabricksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				a.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "domain":
			if val != nil {
				err = json.Unmarshal(*val, &a.Domain)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "existingClusterId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ExistingClusterID)
			}
			delete(rawMsg, key)
		case "instancePoolId":
			if val != nil {
				err = json.Unmarshal(*val, &a.InstancePoolID)
			}
			delete(rawMsg, key)
		case "newClusterCustomTags":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterCustomTags)
			}
			delete(rawMsg, key)
		case "newClusterDriverNodeType":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterDriverNodeType)
			}
			delete(rawMsg, key)
		case "newClusterEnableElasticDisk":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterEnableElasticDisk)
			}
			delete(rawMsg, key)
		case "newClusterInitScripts":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterInitScripts)
			}
			delete(rawMsg, key)
		case "newClusterNodeType":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterNodeType)
			}
			delete(rawMsg, key)
		case "newClusterNumOfWorker":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterNumOfWorker)
			}
			delete(rawMsg, key)
		case "newClusterSparkConf":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterSparkConf)
			}
			delete(rawMsg, key)
		case "newClusterSparkEnvVars":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterSparkEnvVars)
			}
			delete(rawMsg, key)
		case "newClusterVersion":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterVersion)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	Resource
	// Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureEntityResource.
func (a AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := a.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureEntityResource.
func (a *AzureEntityResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return a.unmarshalInternal(rawMsg)
}

func (a AzureEntityResource) marshalInternal() map[string]interface{} {
	objectMap := a.Resource.marshalInternal()
	if a.Etag != nil {
		objectMap["etag"] = a.Etag
	}
	return objectMap
}

func (a *AzureEntityResource) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			if val != nil {
				err = json.Unmarshal(*val, &a.Etag)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Resource.unmarshalInternal(rawMsg)
}

// Azure File Storage linked service.
type AzureFileStorageLinkedService struct {
	LinkedService
	// Azure File Storage linked service properties.
	TypeProperties *AzureFileStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLinkedService.
func (a AzureFileStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureFileStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedService.
func (a *AzureFileStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure File Storage linked service properties.
type AzureFileStorageLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name of the server. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password to logon the server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User ID to logon the server. Type: string (or Expression with resultType string).
	UserID *interface{} `json:"userId,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedServiceTypeProperties.
func (a *AzureFileStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &a.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				a.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userId":
			if val != nil {
				err = json.Unmarshal(*val, &a.UserID)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of file server dataset.
type AzureFileStorageLocation struct {
	DatasetLocation
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLocation.
func (a AzureFileStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := a.DatasetLocation.marshalInternal("AzureFileStorageLocation")
	return json.Marshal(objectMap)
}

// Azure File Storage read settings.
type AzureFileStorageReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Azure File Storage wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// Azure File Storage wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageReadSettings.
func (a AzureFileStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := a.StoreReadSettings.marshalInternal("AzureFileStorageReadSettings")
	if a.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = a.EnablePartitionDiscovery
	}
	if a.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = a.ModifiedDatetimeEnd
	}
	if a.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = a.ModifiedDatetimeStart
	}
	if a.Recursive != nil {
		objectMap["recursive"] = a.Recursive
	}
	if a.WildcardFileName != nil {
		objectMap["wildcardFileName"] = a.WildcardFileName
	}
	if a.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = a.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageReadSettings.
func (a *AzureFileStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &a.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &a.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &a.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &a.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.StoreReadSettings.unmarshalInternal(rawMsg)
}

// Azure Function activity.
type AzureFunctionActivity struct {
	ExecutionActivity
	// Azure Function activity properties.
	TypeProperties *AzureFunctionActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionActivity.
func (a AzureFunctionActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureFunctionActivity")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionActivity.
func (a *AzureFunctionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Azure Function activity type properties.
type AzureFunctionActivityTypeProperties struct {
	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType
	// string).
	Body *interface{} `json:"body,omitempty"`

	// Name of the Function that the Azure Function Activity will call. Type: string (or Expression with resultType string)
	FunctionName *interface{} `json:"functionName,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us",
	// "Content-Type": "application/json" }. Type:
	// string (or Expression with resultType string).
	Headers *interface{} `json:"headers,omitempty"`

	// Rest API method for target endpoint.
	Method *AzureFunctionActivityMethod `json:"method,omitempty"`
}

// Azure Function linked service.
type AzureFunctionLinkedService struct {
	LinkedService
	// Azure Function linked service properties.
	TypeProperties *AzureFunctionLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionLinkedService.
func (a AzureFunctionLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureFunction")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedService.
func (a *AzureFunctionLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Function linked service properties.
type AzureFunctionLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Azure Function App. URL will be in the format https://.azurewebsites.net.
	FunctionAppURL *interface{} `json:"functionAppUrl,omitempty"`

	// Function or Host key for Azure Function App.
	FunctionKey SecretBaseClassification `json:"functionKey,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedServiceTypeProperties.
func (a *AzureFunctionLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "functionAppUrl":
			if val != nil {
				err = json.Unmarshal(*val, &a.FunctionAppURL)
			}
			delete(rawMsg, key)
		case "functionKey":
			if val != nil {
				a.FunctionKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Key Vault linked service.
type AzureKeyVaultLinkedService struct {
	LinkedService
	// Azure Key Vault linked service properties.
	TypeProperties *AzureKeyVaultLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultLinkedService.
func (a AzureKeyVaultLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureKeyVault")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultLinkedService.
func (a *AzureKeyVaultLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Key Vault linked service properties.
type AzureKeyVaultLinkedServiceTypeProperties struct {
	// The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType string).
	BaseURL *interface{} `json:"baseUrl,omitempty"`
}

// Azure Key Vault secret reference.
type AzureKeyVaultSecretReference struct {
	SecretBase
	// The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
	SecretName *interface{} `json:"secretName,omitempty"`

	// The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression with resultType string).
	SecretVersion *interface{} `json:"secretVersion,omitempty"`

	// The Azure Key Vault linked service reference.
	Store *LinkedServiceReference `json:"store,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultSecretReference.
func (a AzureKeyVaultSecretReference) MarshalJSON() ([]byte, error) {
	objectMap := a.SecretBase.marshalInternal("AzureKeyVaultSecret")
	if a.SecretName != nil {
		objectMap["secretName"] = a.SecretName
	}
	if a.SecretVersion != nil {
		objectMap["secretVersion"] = a.SecretVersion
	}
	if a.Store != nil {
		objectMap["store"] = a.Store
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultSecretReference.
func (a *AzureKeyVaultSecretReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretName":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecretName)
			}
			delete(rawMsg, key)
		case "secretVersion":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecretVersion)
			}
			delete(rawMsg, key)
		case "store":
			if val != nil {
				err = json.Unmarshal(*val, &a.Store)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.SecretBase.unmarshalInternal(rawMsg)
}

// Azure Database for MariaDB linked service.
type AzureMariaDbLinkedService struct {
	LinkedService
	// Azure Database for MariaDB linked service properties.
	TypeProperties *AzureMariaDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDbLinkedService.
func (a AzureMariaDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureMariaDB")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDbLinkedService.
func (a *AzureMariaDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Database for MariaDB linked service properties.
type AzureMariaDbLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// A copy activity Azure MariaDB source.
type AzureMariaDbSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDbSource.
func (a AzureMariaDbSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AzureMariaDBSource")
	if a.Query != nil {
		objectMap["query"] = a.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDbSource.
func (a *AzureMariaDbSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &a.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// Azure Database for MariaDB dataset.
type AzureMariaDbTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDbTableDataset.
func (a AzureMariaDbTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureMariaDBTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDbTableDataset.
func (a *AzureMariaDbTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure ML Batch Execution activity.
type AzureMlBatchExecutionActivity struct {
	ExecutionActivity
	// Azure ML Batch Execution activity properties.
	TypeProperties *AzureMlBatchExecutionActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlBatchExecutionActivity.
func (a AzureMlBatchExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureMLBatchExecution")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlBatchExecutionActivity.
func (a *AzureMlBatchExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Azure ML Batch Execution activity properties.
type AzureMlBatchExecutionActivityTypeProperties struct {
	// Key,Value pairs to be passed to the Azure ML Batch Execution Service endpoint. Keys must match the names of web service parameters defined in the published
	// Azure ML web service. Values will be passed
	// in the GlobalParameters property of the Azure ML batch execution request.
	GlobalParameters *map[string]interface{} `json:"globalParameters,omitempty"`

	// Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Inputs to AzureMLWebServiceFile objects specifying the input Blob locations.. This
	// information will be passed in the
	// WebServiceInputs property of the Azure ML batch execution request.
	WebServiceInputs *map[string]AzureMlWebServiceFile `json:"webServiceInputs,omitempty"`

	// Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Outputs to AzureMLWebServiceFile objects specifying the output Blob locations.
	// This information will be passed in the
	// WebServiceOutputs property of the Azure ML batch execution request.
	WebServiceOutputs *map[string]AzureMlWebServiceFile `json:"webServiceOutputs,omitempty"`
}

// Azure ML Execute Pipeline activity.
type AzureMlExecutePipelineActivity struct {
	ExecutionActivity
	// Azure ML Execute Pipeline activity properties.
	TypeProperties *AzureMlExecutePipelineActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlExecutePipelineActivity.
func (a AzureMlExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureMLExecutePipeline")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlExecutePipelineActivity.
func (a *AzureMlExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Azure ML Execute Pipeline activity properties.
type AzureMlExecutePipelineActivityTypeProperties struct {
	// Whether to continue execution of other steps in the PipelineRun if a step fails. This information will be passed in the continueOnStepFailure property
	// of the published pipeline execution request.
	// Type: boolean (or Expression with resultType boolean).
	ContinueOnStepFailure *interface{} `json:"continueOnStepFailure,omitempty"`

	// Run history experiment name of the pipeline run. This information will be passed in the ExperimentName property of the published pipeline execution request.
	// Type: string (or Expression with resultType
	// string).
	ExperimentName *interface{} `json:"experimentName,omitempty"`

	// The parent Azure ML Service pipeline run id. This information will be passed in the ParentRunId property of the published pipeline execution request.
	// Type: string (or Expression with resultType
	// string).
	MlParentRunID *interface{} `json:"mlParentRunId,omitempty"`

	// ID of the published Azure ML pipeline. Type: string (or Expression with resultType string).
	MlPipelineID *interface{} `json:"mlPipelineId,omitempty"`

	// Key,Value pairs to be passed to the published Azure ML pipeline endpoint. Keys must match the names of pipeline parameters defined in the published pipeline.
	// Values will be passed in the
	// ParameterAssignments property of the published pipeline execution request. Type: object with key value pairs (or Expression with resultType object).
	MlPipelineParameters *interface{} `json:"mlPipelineParameters,omitempty"`
}

// Azure ML Studio Web Service linked service.
type AzureMlLinkedService struct {
	LinkedService
	// Azure ML Studio Web Service linked service properties.
	TypeProperties *AzureMlLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlLinkedService.
func (a AzureMlLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureML")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlLinkedService.
func (a *AzureMlLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure ML Studio Web Service linked service properties.
type AzureMlLinkedServiceTypeProperties struct {
	// The API key for accessing the Azure ML model endpoint.
	APIKey SecretBaseClassification `json:"apiKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
	MlEndpoint *interface{} `json:"mlEndpoint,omitempty"`

	// The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service. Type: string (or
	// Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio web service.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
	UpdateResourceEndpoint *interface{} `json:"updateResourceEndpoint,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlLinkedServiceTypeProperties.
func (a *AzureMlLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiKey":
			if val != nil {
				a.APIKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "mlEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.MlEndpoint)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		case "updateResourceEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.UpdateResourceEndpoint)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure ML Service linked service.
type AzureMlServiceLinkedService struct {
	LinkedService
	// Azure ML Service linked service properties.
	TypeProperties *AzureMlServiceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlServiceLinkedService.
func (a AzureMlServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureMLService")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlServiceLinkedService.
func (a *AzureMlServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure ML Service linked service properties.
type AzureMlServiceLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Azure ML Service workspace name. Type: string (or Expression with resultType string).
	MlWorkspaceName *interface{} `json:"mlWorkspaceName,omitempty"`

	// Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
	ResourceGroupName *interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
	SubscriptionID *interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlServiceLinkedServiceTypeProperties.
func (a *AzureMlServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "mlWorkspaceName":
			if val != nil {
				err = json.Unmarshal(*val, &a.MlWorkspaceName)
			}
			delete(rawMsg, key)
		case "resourceGroupName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceGroupName)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "subscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &a.SubscriptionID)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure ML Update Resource management activity.
type AzureMlUpdateResourceActivity struct {
	ExecutionActivity
	// Azure ML Update Resource management activity properties.
	TypeProperties *AzureMlUpdateResourceActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlUpdateResourceActivity.
func (a AzureMlUpdateResourceActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureMLUpdateResource")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlUpdateResourceActivity.
func (a *AzureMlUpdateResourceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Azure ML Update Resource activity properties.
type AzureMlUpdateResourceActivityTypeProperties struct {
	// The relative file path in trainedModelLinkedService to represent the .ilearner file that will be uploaded by the update operation. Type: string (or Expression
	// with resultType string).
	TrainedModelFilePath *interface{} `json:"trainedModelFilePath,omitempty"`

	// Name of Azure Storage linked service holding the .ilearner file that will be uploaded by the update operation.
	TrainedModelLinkedServiceName *LinkedServiceReference `json:"trainedModelLinkedServiceName,omitempty"`

	// Name of the Trained Model module in the Web Service experiment to be updated. Type: string (or Expression with resultType string).
	TrainedModelName *interface{} `json:"trainedModelName,omitempty"`
}

// Azure ML WebService Input/Output file
type AzureMlWebServiceFile struct {
	// The relative file path, including container name, in the Azure Blob Storage specified by the LinkedService. Type: string (or Expression with resultType
	// string).
	FilePath *interface{} `json:"filePath,omitempty"`

	// Reference to an Azure Storage LinkedService, where Azure ML WebService Input/Output file located.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`
}

// Azure MySQL database linked service.
type AzureMySQLLinkedService struct {
	LinkedService
	// Azure MySQL database linked service properties.
	TypeProperties *AzureMySQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLLinkedService.
func (a AzureMySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureMySql")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLLinkedService.
func (a *AzureMySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure MySQL database linked service properties.
type AzureMySQLLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// A copy activity Azure MySql sink.
type AzureMySQLSink struct {
	CopySink
	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLSink.
func (a AzureMySQLSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureMySqlSink")
	if a.PreCopyScript != nil {
		objectMap["preCopyScript"] = a.PreCopyScript
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLSink.
func (a *AzureMySQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &a.PreCopyScript)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure MySQL source.
type AzureMySQLSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLSource.
func (a AzureMySQLSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AzureMySqlSource")
	if a.Query != nil {
		objectMap["query"] = a.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLSource.
func (a *AzureMySQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &a.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// The Azure MySQL database dataset.
type AzureMySQLTableDataset struct {
	Dataset
	// Azure MySQL database dataset properties.
	TypeProperties *AzureMySQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLTableDataset.
func (a AzureMySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureMySqlTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLTableDataset.
func (a *AzureMySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure MySQL database dataset properties.
type AzureMySQLTableDatasetTypeProperties struct {
	// The name of Azure MySQL database table. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// The Azure MySQL database table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Azure PostgreSQL linked service.
type AzurePostgreSQLLinkedService struct {
	LinkedService
	// Azure PostgreSQL linked service properties.
	TypeProperties *AzurePostgreSQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLLinkedService.
func (a AzurePostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzurePostgreSql")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLLinkedService.
func (a *AzurePostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure PostgreSQL linked service properties.
type AzurePostgreSQLLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// A copy activity Azure PostgreSQL sink.
type AzurePostgreSQLSink struct {
	CopySink
	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLSink.
func (a AzurePostgreSQLSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzurePostgreSqlSink")
	if a.PreCopyScript != nil {
		objectMap["preCopyScript"] = a.PreCopyScript
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLSink.
func (a *AzurePostgreSQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &a.PreCopyScript)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure PostgreSQL source.
type AzurePostgreSQLSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLSource.
func (a AzurePostgreSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AzurePostgreSqlSource")
	if a.Query != nil {
		objectMap["query"] = a.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLSource.
func (a *AzurePostgreSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &a.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// Azure PostgreSQL dataset.
type AzurePostgreSQLTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *AzurePostgreSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLTableDataset.
func (a AzurePostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzurePostgreSqlTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLTableDataset.
func (a *AzurePostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure PostgreSQL dataset properties.
type AzurePostgreSQLTableDatasetTypeProperties struct {
	// The schema name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// A copy activity Azure Queue sink.
type AzureQueueSink struct {
	CopySink
}

// MarshalJSON implements the json.Marshaller interface for type AzureQueueSink.
func (a AzureQueueSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureQueueSink")
	return json.Marshal(objectMap)
}

// Microsoft Azure SQL Database linked service.
type AzureSQLDatabaseLinkedService struct {
	LinkedService
	// Azure SQL Database linked service properties.
	TypeProperties *AzureSQLDatabaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseLinkedService.
func (a AzureSQLDatabaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSqlDatabase")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedService.
func (a *AzureSQLDatabaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure SQL Database linked service properties.
type AzureSQLDatabaseLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Database.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedServiceTypeProperties.
func (a *AzureSQLDatabaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				err = json.Unmarshal(*val, &a.Password)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure SQL Data Warehouse linked service.
type AzureSQLDwLinkedService struct {
	LinkedService
	// Azure SQL Data Warehouse linked service properties.
	TypeProperties *AzureSQLDwLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDwLinkedService.
func (a AzureSQLDwLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSqlDW")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDwLinkedService.
func (a *AzureSQLDwLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure SQL Data Warehouse linked service properties.
type AzureSQLDwLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Data Warehouse.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDwLinkedServiceTypeProperties.
func (a *AzureSQLDwLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				err = json.Unmarshal(*val, &a.Password)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Azure SQL Data Warehouse dataset.
type AzureSQLDwTableDataset struct {
	Dataset
	// Azure SQL Data Warehouse dataset properties.
	TypeProperties *AzureSQLDwTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDwTableDataset.
func (a AzureSQLDwTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSqlDWTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDwTableDataset.
func (a *AzureSQLDwTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure SQL Data Warehouse dataset properties.
type AzureSQLDwTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Azure SQL Managed Instance linked service.
type AzureSQLMiLinkedService struct {
	LinkedService
	// Azure SQL Managed Instance linked service properties.
	TypeProperties *AzureSQLMiLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMiLinkedService.
func (a AzureSQLMiLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSqlMI")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMiLinkedService.
func (a *AzureSQLMiLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure SQL Managed Instance linked service properties.
type AzureSQLMiLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Managed Instance.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMiLinkedServiceTypeProperties.
func (a *AzureSQLMiLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				err = json.Unmarshal(*val, &a.Password)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Azure SQL Managed Instance dataset.
type AzureSQLMiTableDataset struct {
	Dataset
	// Azure SQL Managed Instance dataset properties.
	TypeProperties *AzureSQLMiTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMiTableDataset.
func (a AzureSQLMiTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSqlMITable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMiTableDataset.
func (a *AzureSQLMiTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure SQL Managed Instance dataset properties.
type AzureSQLMiTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL Managed Instance. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// A copy activity Azure SQL sink.
type AzureSQLSink struct {
	CopySink
	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName *interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType *interface{} `json:"sqlWriterTableType,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName *interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
	TableOption *interface{} `json:"tableOption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSink.
func (a AzureSQLSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureSqlSink")
	if a.PreCopyScript != nil {
		objectMap["preCopyScript"] = a.PreCopyScript
	}
	if a.SQLWriterStoredProcedureName != nil {
		objectMap["sqlWriterStoredProcedureName"] = a.SQLWriterStoredProcedureName
	}
	if a.SQLWriterTableType != nil {
		objectMap["sqlWriterTableType"] = a.SQLWriterTableType
	}
	if a.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = a.StoredProcedureParameters
	}
	if a.StoredProcedureTableTypeParameterName != nil {
		objectMap["storedProcedureTableTypeParameterName"] = a.StoredProcedureTableTypeParameterName
	}
	if a.TableOption != nil {
		objectMap["tableOption"] = a.TableOption
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSink.
func (a *AzureSQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &a.PreCopyScript)
			}
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &a.SQLWriterStoredProcedureName)
			}
			delete(rawMsg, key)
		case "sqlWriterTableType":
			if val != nil {
				err = json.Unmarshal(*val, &a.SQLWriterTableType)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &a.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			if val != nil {
				err = json.Unmarshal(*val, &a.StoredProcedureTableTypeParameterName)
			}
			delete(rawMsg, key)
		case "tableOption":
			if val != nil {
				err = json.Unmarshal(*val, &a.TableOption)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure SQL source.
type AzureSQLSource struct {
	TabularSource
	// Which additional types to produce.
	ProduceAdditionalTypes *interface{} `json:"produceAdditionalTypes,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery *interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType
	// string).
	SQLReaderStoredProcedureName *interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLSource.
func (a AzureSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AzureSqlSource")
	if a.ProduceAdditionalTypes != nil {
		objectMap["produceAdditionalTypes"] = a.ProduceAdditionalTypes
	}
	if a.SQLReaderQuery != nil {
		objectMap["sqlReaderQuery"] = a.SQLReaderQuery
	}
	if a.SQLReaderStoredProcedureName != nil {
		objectMap["sqlReaderStoredProcedureName"] = a.SQLReaderStoredProcedureName
	}
	if a.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = a.StoredProcedureParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLSource.
func (a *AzureSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "produceAdditionalTypes":
			if val != nil {
				err = json.Unmarshal(*val, &a.ProduceAdditionalTypes)
			}
			delete(rawMsg, key)
		case "sqlReaderQuery":
			if val != nil {
				err = json.Unmarshal(*val, &a.SQLReaderQuery)
			}
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &a.SQLReaderStoredProcedureName)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &a.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// The Azure SQL Server database dataset.
type AzureSQLTableDataset struct {
	Dataset
	// Azure SQL dataset properties.
	TypeProperties *AzureSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLTableDataset.
func (a AzureSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSqlTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLTableDataset.
func (a *AzureSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure SQL dataset properties.
type AzureSQLTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL database. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// The Azure Search Index.
type AzureSearchIndexDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *AzureSearchIndexDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexDataset.
func (a AzureSearchIndexDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSearchIndex")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexDataset.
func (a *AzureSearchIndexDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Properties specific to this dataset type.
type AzureSearchIndexDatasetTypeProperties struct {
	// The name of the Azure Search Index. Type: string (or Expression with resultType string).
	IndexName *interface{} `json:"indexName,omitempty"`
}

// A copy activity Azure Search Index sink.
type AzureSearchIndexSink struct {
	CopySink
	// Specify the write behavior when upserting documents into Azure Search Index.
	WriteBehavior *AzureSearchIndexWriteBehaviorType `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexSink.
func (a AzureSearchIndexSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureSearchIndexSink")
	if a.WriteBehavior != nil {
		objectMap["writeBehavior"] = a.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexSink.
func (a *AzureSearchIndexSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &a.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// Linked service for Windows Azure Search Service.
type AzureSearchLinkedService struct {
	LinkedService
	// Windows Azure Search Service linked service properties.
	TypeProperties *AzureSearchLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchLinkedService.
func (a AzureSearchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSearch")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedService.
func (a *AzureSearchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Windows Azure Search Service linked service properties.
type AzureSearchLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Admin Key for Azure Search service
	Key SecretBaseClassification `json:"key,omitempty"`

	// URL for Azure Search service. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedServiceTypeProperties.
func (a *AzureSearchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "key":
			if val != nil {
				a.Key, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &a.URL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The storage account linked service.
type AzureStorageLinkedService struct {
	LinkedService
	// Azure Storage linked service properties.
	TypeProperties *AzureStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageLinkedService.
func (a AzureStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageLinkedService.
func (a *AzureStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Azure Storage linked service properties.
type AzureStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
	SasURI *interface{} `json:"sasUri,omitempty"`
}

// The Azure Table storage dataset.
type AzureTableDataset struct {
	Dataset
	// Azure Table dataset properties.
	TypeProperties *AzureTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableDataset.
func (a AzureTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableDataset.
func (a *AzureTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.Dataset.unmarshalInternal(rawMsg)
}

// Azure Table dataset properties.
type AzureTableDatasetTypeProperties struct {
	// The table name of the Azure Table storage. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// A copy activity Azure Table sink.
type AzureTableSink struct {
	CopySink
	// Azure Table default partition key value. Type: string (or Expression with resultType string).
	AzureTableDefaultPartitionKeyValue *interface{} `json:"azureTableDefaultPartitionKeyValue,omitempty"`

	// Azure Table insert type. Type: string (or Expression with resultType string).
	AzureTableInsertType *interface{} `json:"azureTableInsertType,omitempty"`

	// Azure Table partition key name. Type: string (or Expression with resultType string).
	AzureTablePartitionKeyName *interface{} `json:"azureTablePartitionKeyName,omitempty"`

	// Azure Table row key name. Type: string (or Expression with resultType string).
	AzureTableRowKeyName *interface{} `json:"azureTableRowKeyName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableSink.
func (a AzureTableSink) MarshalJSON() ([]byte, error) {
	objectMap := a.CopySink.marshalInternal("AzureTableSink")
	if a.AzureTableDefaultPartitionKeyValue != nil {
		objectMap["azureTableDefaultPartitionKeyValue"] = a.AzureTableDefaultPartitionKeyValue
	}
	if a.AzureTableInsertType != nil {
		objectMap["azureTableInsertType"] = a.AzureTableInsertType
	}
	if a.AzureTablePartitionKeyName != nil {
		objectMap["azureTablePartitionKeyName"] = a.AzureTablePartitionKeyName
	}
	if a.AzureTableRowKeyName != nil {
		objectMap["azureTableRowKeyName"] = a.AzureTableRowKeyName
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableSink.
func (a *AzureTableSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureTableDefaultPartitionKeyValue":
			if val != nil {
				err = json.Unmarshal(*val, &a.AzureTableDefaultPartitionKeyValue)
			}
			delete(rawMsg, key)
		case "azureTableInsertType":
			if val != nil {
				err = json.Unmarshal(*val, &a.AzureTableInsertType)
			}
			delete(rawMsg, key)
		case "azureTablePartitionKeyName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AzureTablePartitionKeyName)
			}
			delete(rawMsg, key)
		case "azureTableRowKeyName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AzureTableRowKeyName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure Table source.
type AzureTableSource struct {
	TabularSource
	// Azure Table source ignore table not found. Type: boolean (or Expression with resultType boolean).
	AzureTableSourceIgnoreTableNotFound *interface{} `json:"azureTableSourceIgnoreTableNotFound,omitempty"`

	// Azure Table source query. Type: string (or Expression with resultType string).
	AzureTableSourceQuery *interface{} `json:"azureTableSourceQuery,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableSource.
func (a AzureTableSource) MarshalJSON() ([]byte, error) {
	objectMap := a.TabularSource.marshalInternal("AzureTableSource")
	if a.AzureTableSourceIgnoreTableNotFound != nil {
		objectMap["azureTableSourceIgnoreTableNotFound"] = a.AzureTableSourceIgnoreTableNotFound
	}
	if a.AzureTableSourceQuery != nil {
		objectMap["azureTableSourceQuery"] = a.AzureTableSourceQuery
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableSource.
func (a *AzureTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureTableSourceIgnoreTableNotFound":
			if val != nil {
				err = json.Unmarshal(*val, &a.AzureTableSourceIgnoreTableNotFound)
			}
			delete(rawMsg, key)
		case "azureTableSourceQuery":
			if val != nil {
				err = json.Unmarshal(*val, &a.AzureTableSourceQuery)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.TabularSource.unmarshalInternal(rawMsg)
}

// The azure table storage linked service.
type AzureTableStorageLinkedService struct {
	LinkedService
	// Azure Table Storage linked service properties.
	TypeProperties *AzureStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableStorageLinkedService.
func (a AzureTableStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureTableStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableStorageLinkedService.
func (a *AzureTableStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return a.LinkedService.unmarshalInternal(rawMsg)
}

// Babylon Configuration
type BabylonConfiguration struct {
	// Babylon Resource ID
	BabylonResourceID *string `json:"babylonResourceId,omitempty"`
}

// Big data pool reference.
type BigDataPoolReference struct {
	// Reference big data pool name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Big data pool reference type.
	Type *BigDataPoolReferenceType `json:"type,omitempty"`
}

// A Big Data pool
type BigDataPoolResourceInfo struct {
	TrackedResource
	// Big Data pool properties
	Properties *BigDataPoolResourceProperties `json:"properties,omitempty"`
}

// Collection of Big Data pool information
type BigDataPoolResourceInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of Big Data pools
	Value *[]BigDataPoolResourceInfo `json:"value,omitempty"`
}

// BigDataPoolResourceInfoListResultResponse is the response envelope for operations that return a BigDataPoolResourceInfoListResult type.
type BigDataPoolResourceInfoListResultResponse struct {
	// Collection of Big Data pool information
	BigDataPoolResourceInfoListResult *BigDataPoolResourceInfoListResult

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BigDataPoolResourceInfoResponse is the response envelope for operations that return a BigDataPoolResourceInfo type.
type BigDataPoolResourceInfoResponse struct {
	// A Big Data pool
	BigDataPoolResourceInfo *BigDataPoolResourceInfo

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Properties of a Big Data pool powered by Apache Spark
type BigDataPoolResourceProperties struct {
	// Auto-pausing properties
	AutoPause *AutoPauseProperties `json:"autoPause,omitempty"`

	// Auto-scaling properties
	AutoScale *AutoScaleProperties `json:"autoScale,omitempty"`

	// The time when the Big Data pool was created.
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// List of custom libraries/packages associated with the spark pool.
	CustomLibraries *[]LibraryInfo `json:"customLibraries,omitempty"`

	// The default folder where Spark logs will be written.
	DefaultSparkLogFolder *string `json:"defaultSparkLogFolder,omitempty"`

	// Whether compute isolation is required or not.
	IsComputeIsolationEnabled *bool `json:"isComputeIsolationEnabled,omitempty"`

	// Library version requirements
	LibraryRequirements *LibraryRequirements `json:"libraryRequirements,omitempty"`

	// The number of nodes in the Big Data pool.
	NodeCount *int32 `json:"nodeCount,omitempty"`

	// The level of compute power that each node in the Big Data pool has.
	NodeSize *NodeSize `json:"nodeSize,omitempty"`

	// The kind of nodes that the Big Data pool provides.
	NodeSizeFamily *NodeSizeFamily `json:"nodeSizeFamily,omitempty"`

	// The state of the Big Data pool.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Whether session level library/package management is enabled or not.
	SessionLevelPackagesEnabled *bool `json:"sessionLevelPackagesEnabled,omitempty"`

	// Spark configuration file to specify additional properties
	SparkConfigProperties *LibraryRequirements `json:"sparkConfigProperties,omitempty"`

	// The Spark events folder
	SparkEventsFolder *string `json:"sparkEventsFolder,omitempty"`

	// The Apache Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BigDataPoolResourceProperties.
func (b BigDataPoolResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if b.AutoPause != nil {
		objectMap["autoPause"] = b.AutoPause
	}
	if b.AutoScale != nil {
		objectMap["autoScale"] = b.AutoScale
	}
	if b.CreationDate != nil {
		objectMap["creationDate"] = (*timeRFC3339)(b.CreationDate)
	}
	if b.CustomLibraries != nil {
		objectMap["customLibraries"] = b.CustomLibraries
	}
	if b.DefaultSparkLogFolder != nil {
		objectMap["defaultSparkLogFolder"] = b.DefaultSparkLogFolder
	}
	if b.IsComputeIsolationEnabled != nil {
		objectMap["isComputeIsolationEnabled"] = b.IsComputeIsolationEnabled
	}
	if b.LibraryRequirements != nil {
		objectMap["libraryRequirements"] = b.LibraryRequirements
	}
	if b.NodeCount != nil {
		objectMap["nodeCount"] = b.NodeCount
	}
	if b.NodeSize != nil {
		objectMap["nodeSize"] = b.NodeSize
	}
	if b.NodeSizeFamily != nil {
		objectMap["nodeSizeFamily"] = b.NodeSizeFamily
	}
	if b.ProvisioningState != nil {
		objectMap["provisioningState"] = b.ProvisioningState
	}
	if b.SessionLevelPackagesEnabled != nil {
		objectMap["sessionLevelPackagesEnabled"] = b.SessionLevelPackagesEnabled
	}
	if b.SparkConfigProperties != nil {
		objectMap["sparkConfigProperties"] = b.SparkConfigProperties
	}
	if b.SparkEventsFolder != nil {
		objectMap["sparkEventsFolder"] = b.SparkEventsFolder
	}
	if b.SparkVersion != nil {
		objectMap["sparkVersion"] = b.SparkVersion
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BigDataPoolResourceProperties.
func (b *BigDataPoolResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoPause":
			if val != nil {
				err = json.Unmarshal(*val, &b.AutoPause)
			}
			delete(rawMsg, key)
		case "autoScale":
			if val != nil {
				err = json.Unmarshal(*val, &b.AutoScale)
			}
			delete(rawMsg, key)
		case "creationDate":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				b.CreationDate = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "customLibraries":
			if val != nil {
				err = json.Unmarshal(*val, &b.CustomLibraries)
			}
			delete(rawMsg, key)
		case "defaultSparkLogFolder":
			if val != nil {
				err = json.Unmarshal(*val, &b.DefaultSparkLogFolder)
			}
			delete(rawMsg, key)
		case "isComputeIsolationEnabled":
			if val != nil {
				err = json.Unmarshal(*val, &b.IsComputeIsolationEnabled)
			}
			delete(rawMsg, key)
		case "libraryRequirements":
			if val != nil {
				err = json.Unmarshal(*val, &b.LibraryRequirements)
			}
			delete(rawMsg, key)
		case "nodeCount":
			if val != nil {
				err = json.Unmarshal(*val, &b.NodeCount)
			}
			delete(rawMsg, key)
		case "nodeSize":
			if val != nil {
				err = json.Unmarshal(*val, &b.NodeSize)
			}
			delete(rawMsg, key)
		case "nodeSizeFamily":
			if val != nil {
				err = json.Unmarshal(*val, &b.NodeSizeFamily)
			}
			delete(rawMsg, key)
		case "provisioningState":
			if val != nil {
				err = json.Unmarshal(*val, &b.ProvisioningState)
			}
			delete(rawMsg, key)
		case "sessionLevelPackagesEnabled":
			if val != nil {
				err = json.Unmarshal(*val, &b.SessionLevelPackagesEnabled)
			}
			delete(rawMsg, key)
		case "sparkConfigProperties":
			if val != nil {
				err = json.Unmarshal(*val, &b.SparkConfigProperties)
			}
			delete(rawMsg, key)
		case "sparkEventsFolder":
			if val != nil {
				err = json.Unmarshal(*val, &b.SparkEventsFolder)
			}
			delete(rawMsg, key)
		case "sparkVersion":
			if val != nil {
				err = json.Unmarshal(*val, &b.SparkVersion)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BigDataPoolsGetOptions contains the optional parameters for the BigDataPools.Get method.
type BigDataPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// BigDataPoolsListOptions contains the optional parameters for the BigDataPools.List method.
type BigDataPoolsListOptions struct {
	// placeholder for future optional parameters
}

// Binary dataset.
type BinaryDataset struct {
	Dataset
	// Binary dataset properties.
	TypeProperties *BinaryDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BinaryDataset.
func (b BinaryDataset) MarshalJSON() ([]byte, error) {
	objectMap := b.Dataset.marshalInternal("Binary")
	if b.TypeProperties != nil {
		objectMap["typeProperties"] = b.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDataset.
func (b *BinaryDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &b.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.Dataset.unmarshalInternal(rawMsg)
}

// Binary dataset properties.
type BinaryDatasetTypeProperties struct {
	// The data compression method used for the binary dataset.
	Compression DatasetCompressionClassification `json:"compression,omitempty"`

	// The location of the Binary storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDatasetTypeProperties.
func (b *BinaryDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			if val != nil {
				b.Compression, err = unmarshalDatasetCompressionClassification(*val)
			}
			delete(rawMsg, key)
		case "location":
			if val != nil {
				b.Location, err = unmarshalDatasetLocationClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Binary sink.
type BinarySink struct {
	CopySink
	// Binary store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BinarySink.
func (b BinarySink) MarshalJSON() ([]byte, error) {
	objectMap := b.CopySink.marshalInternal("BinarySink")
	if b.StoreSettings != nil {
		objectMap["storeSettings"] = b.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinarySink.
func (b *BinarySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				b.StoreSettings, err = unmarshalStoreWriteSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Binary source.
type BinarySource struct {
	CopySource
	// Binary store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BinarySource.
func (b BinarySource) MarshalJSON() ([]byte, error) {
	objectMap := b.CopySource.marshalInternal("BinarySource")
	if b.StoreSettings != nil {
		objectMap["storeSettings"] = b.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinarySource.
func (b *BinarySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				b.StoreSettings, err = unmarshalStoreReadSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.CopySource.unmarshalInternal(rawMsg)
}

// Trigger that runs every time a Blob event occurs.
type BlobEventsTrigger struct {
	MultiplePipelineTrigger
	// Blob Events Trigger properties.
	TypeProperties *BlobEventsTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobEventsTrigger.
func (b BlobEventsTrigger) MarshalJSON() ([]byte, error) {
	objectMap := b.MultiplePipelineTrigger.marshalInternal("BlobEventsTrigger")
	if b.TypeProperties != nil {
		objectMap["typeProperties"] = b.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobEventsTrigger.
func (b *BlobEventsTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &b.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.MultiplePipelineTrigger.unmarshalInternal(rawMsg)
}

// Blob Events Trigger properties.
type BlobEventsTriggerTypeProperties struct {
	// The blob path must begin with the pattern provided for trigger to fire. For example, '/records/blobs/december/' will only fire the trigger for blobs
	// in the december folder under the records container.
	// At least one of these must be provided: blobPathBeginsWith, blobPathEndsWith.
	BlobPathBeginsWith *string `json:"blobPathBeginsWith,omitempty"`

	// The blob path must end with the pattern provided for trigger to fire. For example, 'december/boxes.csv' will only fire the trigger for blobs named boxes
	// in a december folder. At least one of these
	// must be provided: blobPathBeginsWith, blobPathEndsWith.
	BlobPathEndsWith *string `json:"blobPathEndsWith,omitempty"`

	// The type of events that cause this trigger to fire.
	Events *[]BlobEventTypes `json:"events,omitempty"`

	// If set to true, blobs with zero bytes will be ignored.
	IgnoreEmptyBlobs *bool `json:"ignoreEmptyBlobs,omitempty"`

	// The ARM resource ID of the Storage Account.
	Scope *string `json:"scope,omitempty"`
}

// A copy activity Azure Blob sink.
type BlobSink struct {
	CopySink
	// Blob writer add header. Type: boolean (or Expression with resultType boolean).
	BlobWriterAddHeader *interface{} `json:"blobWriterAddHeader,omitempty"`

	// Blob writer date time format. Type: string (or Expression with resultType string).
	BlobWriterDateTimeFormat *interface{} `json:"blobWriterDateTimeFormat,omitempty"`

	// Blob writer overwrite files. Type: boolean (or Expression with resultType boolean).
	BlobWriterOverwriteFiles *interface{} `json:"blobWriterOverwriteFiles,omitempty"`

	// The type of copy behavior for copy sink.
	CopyBehavior *interface{} `json:"copyBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobSink.
func (b BlobSink) MarshalJSON() ([]byte, error) {
	objectMap := b.CopySink.marshalInternal("BlobSink")
	if b.BlobWriterAddHeader != nil {
		objectMap["blobWriterAddHeader"] = b.BlobWriterAddHeader
	}
	if b.BlobWriterDateTimeFormat != nil {
		objectMap["blobWriterDateTimeFormat"] = b.BlobWriterDateTimeFormat
	}
	if b.BlobWriterOverwriteFiles != nil {
		objectMap["blobWriterOverwriteFiles"] = b.BlobWriterOverwriteFiles
	}
	if b.CopyBehavior != nil {
		objectMap["copyBehavior"] = b.CopyBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobSink.
func (b *BlobSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobWriterAddHeader":
			if val != nil {
				err = json.Unmarshal(*val, &b.BlobWriterAddHeader)
			}
			delete(rawMsg, key)
		case "blobWriterDateTimeFormat":
			if val != nil {
				err = json.Unmarshal(*val, &b.BlobWriterDateTimeFormat)
			}
			delete(rawMsg, key)
		case "blobWriterOverwriteFiles":
			if val != nil {
				err = json.Unmarshal(*val, &b.BlobWriterOverwriteFiles)
			}
			delete(rawMsg, key)
		case "copyBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &b.CopyBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure Blob source.
type BlobSource struct {
	CopySource
	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Number of header lines to skip from each blob. Type: integer (or Expression with resultType integer).
	SkipHeaderLineCount *interface{} `json:"skipHeaderLineCount,omitempty"`

	// Treat empty as null. Type: boolean (or Expression with resultType boolean).
	TreatEmptyAsNull *interface{} `json:"treatEmptyAsNull,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobSource.
func (b BlobSource) MarshalJSON() ([]byte, error) {
	objectMap := b.CopySource.marshalInternal("BlobSource")
	if b.Recursive != nil {
		objectMap["recursive"] = b.Recursive
	}
	if b.SkipHeaderLineCount != nil {
		objectMap["skipHeaderLineCount"] = b.SkipHeaderLineCount
	}
	if b.TreatEmptyAsNull != nil {
		objectMap["treatEmptyAsNull"] = b.TreatEmptyAsNull
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobSource.
func (b *BlobSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &b.Recursive)
			}
			delete(rawMsg, key)
		case "skipHeaderLineCount":
			if val != nil {
				err = json.Unmarshal(*val, &b.SkipHeaderLineCount)
			}
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			if val != nil {
				err = json.Unmarshal(*val, &b.TreatEmptyAsNull)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.CopySource.unmarshalInternal(rawMsg)
}

// Trigger that runs every time the selected Blob container changes.
type BlobTrigger struct {
	MultiplePipelineTrigger
	// Blob Trigger properties.
	TypeProperties *BlobTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BlobTrigger.
func (b BlobTrigger) MarshalJSON() ([]byte, error) {
	objectMap := b.MultiplePipelineTrigger.marshalInternal("BlobTrigger")
	if b.TypeProperties != nil {
		objectMap["typeProperties"] = b.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobTrigger.
func (b *BlobTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &b.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.MultiplePipelineTrigger.unmarshalInternal(rawMsg)
}

// Blob Trigger properties.
type BlobTriggerTypeProperties struct {
	// The path of the container/folder that will trigger the pipeline.
	FolderPath *string `json:"folderPath,omitempty"`

	// The Azure Storage linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`

	// The max number of parallel files to handle when it is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`
}

// Linked service for Cassandra data source.
type CassandraLinkedService struct {
	LinkedService
	// Cassandra linked service properties.
	TypeProperties *CassandraLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CassandraLinkedService.
func (c CassandraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("Cassandra")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedService.
func (c *CassandraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// Cassandra linked service properties.
type CassandraLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name for connection. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port for the connection. Type: integer (or Expression with resultType integer).
	Port *interface{} `json:"port,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedServiceTypeProperties.
func (c *CassandraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &c.AuthenticationType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &c.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				c.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &c.Port)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &c.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for a Cassandra database.
type CassandraSource struct {
	TabularSource
	// The consistency level specifies how many Cassandra servers must respond to a read request before returning data to the client application. Cassandra
	// checks the specified number of Cassandra servers
	// for data to satisfy the read request. Must be one of cassandraSourceReadConsistencyLevels. The default value is 'ONE'. It is case-insensitive.
	ConsistencyLevel *CassandraSourceReadConsistencyLevels `json:"consistencyLevel,omitempty"`

	// Database query. Should be a SQL-92 query expression or Cassandra Query Language (CQL) command. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CassandraSource.
func (c CassandraSource) MarshalJSON() ([]byte, error) {
	objectMap := c.TabularSource.marshalInternal("CassandraSource")
	if c.ConsistencyLevel != nil {
		objectMap["consistencyLevel"] = c.ConsistencyLevel
	}
	if c.Query != nil {
		objectMap["query"] = c.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraSource.
func (c *CassandraSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consistencyLevel":
			if val != nil {
				err = json.Unmarshal(*val, &c.ConsistencyLevel)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &c.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.TabularSource.unmarshalInternal(rawMsg)
}

// The Cassandra database dataset.
type CassandraTableDataset struct {
	Dataset
	// Cassandra dataset properties.
	TypeProperties *CassandraTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CassandraTableDataset.
func (c CassandraTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CassandraTable")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraTableDataset.
func (c *CassandraTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// Cassandra dataset properties.
type CassandraTableDatasetTypeProperties struct {
	// The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
	Keyspace *interface{} `json:"keyspace,omitempty"`

	// The table name of the Cassandra database. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Trigger that allows the referenced pipeline to depend on other pipeline runs based on runDimension Name/Value pairs. Upstream pipelines should declare
// the same runDimension Name and their runs should
// have the values for those runDimensions. The referenced pipeline run would be triggered if the values for the runDimension match for all upstream pipeline
// runs.
type ChainingTrigger struct {
	Trigger
	// Pipeline for which runs are created when all upstream pipelines complete successfully.
	Pipeline *TriggerPipelineReference `json:"pipeline,omitempty"`

	// Chaining Trigger properties.
	TypeProperties *ChainingTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ChainingTrigger.
func (c ChainingTrigger) MarshalJSON() ([]byte, error) {
	objectMap := c.Trigger.marshalInternal("ChainingTrigger")
	if c.Pipeline != nil {
		objectMap["pipeline"] = c.Pipeline
	}
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ChainingTrigger.
func (c *ChainingTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pipeline":
			if val != nil {
				err = json.Unmarshal(*val, &c.Pipeline)
			}
			delete(rawMsg, key)
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Trigger.unmarshalInternal(rawMsg)
}

// Chaining Trigger properties.
type ChainingTriggerTypeProperties struct {
	// Upstream Pipelines.
	DependsOn *[]PipelineReference `json:"dependsOn,omitempty"`

	// Run Dimension property that needs to be emitted by upstream pipelines.
	RunDimension *string `json:"runDimension,omitempty"`
}

// The object that defines the structure of an Azure Synapse error response.
type CloudError struct {
	// Error data
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
func (e CloudError) Error() string {
	msg := ""
	if e.InnerError != nil {
		msg += fmt.Sprintf("InnerError: %v\n", *e.InnerError)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// The object that defines the structure of an Azure Synapse error.
type CloudErrorBody struct {
	// Error code.
	Code *string `json:"code,omitempty"`

	// Array with additional error details.
	Details *[]CloudError `json:"details,omitempty"`

	// Error message.
	Message *string `json:"message,omitempty"`

	// Property name/path in request associated with error.
	Target *string `json:"target,omitempty"`
}

// The Common Data Service for Apps entity dataset.
type CommonDataServiceForAppsEntityDataset struct {
	Dataset
	// Common Data Service for Apps entity dataset properties.
	TypeProperties *CommonDataServiceForAppsEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c CommonDataServiceForAppsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CommonDataServiceForAppsEntity")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c *CommonDataServiceForAppsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// Common Data Service for Apps entity dataset properties.
type CommonDataServiceForAppsEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName *interface{} `json:"entityName,omitempty"`
}

// Common Data Service for Apps linked service.
type CommonDataServiceForAppsLinkedService struct {
	LinkedService
	// Common Data Service for Apps linked service properties.
	TypeProperties *CommonDataServiceForAppsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsLinkedService.
func (c CommonDataServiceForAppsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CommonDataServiceForApps")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedService.
func (c *CommonDataServiceForAppsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// Common Data Service for Apps linked service properties.
type CommonDataServiceForAppsLinkedServiceTypeProperties struct {
	// The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario.
	// 'AADServicePrincipal' for Server-To-Server
	// authentication in online scenario. Type: string (or Expression with resultType string).
	AuthenticationType *DynamicsAuthenticationType `json:"authenticationType,omitempty"`

	// The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online and 'OnPremisesWithIfd' for Common
	// Data Service for Apps on-premises with Ifd. Type:
	// string (or Expression with resultType string).
	DeploymentType *DynamicsDeploymentType `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Type: string (or
	// Expression with resultType string).
	HostName *interface{} `json:"hostName,omitempty"`

	// The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for online when there are more
	// than one Common Data Service for Apps instances
	// associated with the user. Type: string (or Expression with resultType string).
	OrganizationName *interface{} `json:"organizationName,omitempty"`

	// Password to access the Common Data Service for Apps instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer
	// (or Expression with resultType integer),
	// minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential
	// can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate.
	// Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType *DynamicsServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression
	// with resultType string).
	ServiceURI *interface{} `json:"serviceUri,omitempty"`

	// User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedServiceTypeProperties.
func (c *CommonDataServiceForAppsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &c.AuthenticationType)
			}
			delete(rawMsg, key)
		case "deploymentType":
			if val != nil {
				err = json.Unmarshal(*val, &c.DeploymentType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "hostName":
			if val != nil {
				err = json.Unmarshal(*val, &c.HostName)
			}
			delete(rawMsg, key)
		case "organizationName":
			if val != nil {
				err = json.Unmarshal(*val, &c.OrganizationName)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				c.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &c.Port)
			}
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			if val != nil {
				c.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &c.ServicePrincipalCredentialType)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &c.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "serviceUri":
			if val != nil {
				err = json.Unmarshal(*val, &c.ServiceURI)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &c.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Common Data Service for Apps sink.
type CommonDataServiceForAppsSink struct {
	CopySink
	// The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
	AlternateKeyName *interface{} `json:"alternateKeyName,omitempty"`

	// The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or
	// Expression with resultType boolean).
	IgnoreNullValues *interface{} `json:"ignoreNullValues,omitempty"`

	// The write behavior for the operation.
	WriteBehavior *DynamicsSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsSink.
func (c CommonDataServiceForAppsSink) MarshalJSON() ([]byte, error) {
	objectMap := c.CopySink.marshalInternal("CommonDataServiceForAppsSink")
	if c.AlternateKeyName != nil {
		objectMap["alternateKeyName"] = c.AlternateKeyName
	}
	if c.IgnoreNullValues != nil {
		objectMap["ignoreNullValues"] = c.IgnoreNullValues
	}
	if c.WriteBehavior != nil {
		objectMap["writeBehavior"] = c.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsSink.
func (c *CommonDataServiceForAppsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			if val != nil {
				err = json.Unmarshal(*val, &c.AlternateKeyName)
			}
			delete(rawMsg, key)
		case "ignoreNullValues":
			if val != nil {
				err = json.Unmarshal(*val, &c.IgnoreNullValues)
			}
			delete(rawMsg, key)
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Common Data Service for Apps source.
type CommonDataServiceForAppsSource struct {
	CopySource
	// FetchXML is a proprietary query language that is used in Microsoft Common Data Service for Apps (online & on-premises). Type: string (or Expression with
	// resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsSource.
func (c CommonDataServiceForAppsSource) MarshalJSON() ([]byte, error) {
	objectMap := c.CopySource.marshalInternal("CommonDataServiceForAppsSource")
	if c.Query != nil {
		objectMap["query"] = c.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsSource.
func (c *CommonDataServiceForAppsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &c.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.CopySource.unmarshalInternal(rawMsg)
}

// Concur Service linked service.
type ConcurLinkedService struct {
	LinkedService
	// Concur Service linked service properties.
	TypeProperties *ConcurLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConcurLinkedService.
func (c ConcurLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("Concur")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedService.
func (c *ConcurLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// Concur Service linked service properties.
type ConcurLinkedServiceTypeProperties struct {
	// Application client_id supplied by Concur App Management.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name that you provided in the username field.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name that you use to access Concur Service.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedServiceTypeProperties.
func (c *ConcurLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &c.ClientID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				c.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &c.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &c.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &c.UsePeerVerification)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &c.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Concur Service dataset.
type ConcurObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConcurObjectDataset.
func (c ConcurObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("ConcurObject")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurObjectDataset.
func (c *ConcurObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Concur Service source.
type ConcurSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConcurSource.
func (c ConcurSource) MarshalJSON() ([]byte, error) {
	objectMap := c.TabularSource.marshalInternal("ConcurSource")
	if c.Query != nil {
		objectMap["query"] = c.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurSource.
func (c *ConcurSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &c.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.TabularSource.unmarshalInternal(rawMsg)
}

// Base class for all control activities like IfCondition, ForEach , Until.
type ControlActivity struct {
	Activity
}

// MarshalJSON implements the json.Marshaller interface for type ControlActivity.
func (c ControlActivity) MarshalJSON() ([]byte, error) {
	objectMap := c.Activity.marshalInternal("Container")
	return json.Marshal(objectMap)
}

// Copy activity.
type CopyActivity struct {
	ExecutionActivity
	// List of inputs for the activity.
	Inputs *[]DatasetReference `json:"inputs,omitempty"`

	// List of outputs for the activity.
	Outputs *[]DatasetReference `json:"outputs,omitempty"`

	// Copy activity properties.
	TypeProperties *CopyActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivity.
func (c CopyActivity) MarshalJSON() ([]byte, error) {
	objectMap := c.ExecutionActivity.marshalInternal("Copy")
	if c.Inputs != nil {
		objectMap["inputs"] = c.Inputs
	}
	if c.Outputs != nil {
		objectMap["outputs"] = c.Outputs
	}
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivity.
func (c *CopyActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			if val != nil {
				err = json.Unmarshal(*val, &c.Inputs)
			}
			delete(rawMsg, key)
		case "outputs":
			if val != nil {
				err = json.Unmarshal(*val, &c.Outputs)
			}
			delete(rawMsg, key)
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Copy activity properties.
type CopyActivityTypeProperties struct {
	// Maximum number of data integration units that can be used to perform this data movement. Type: integer (or Expression with resultType integer), minimum:
	// 0.
	DataIntegrationUnits *interface{} `json:"dataIntegrationUnits,omitempty"`

	// Whether to skip incompatible row. Default value is false. Type: boolean (or Expression with resultType boolean).
	EnableSkipIncompatibleRow *interface{} `json:"enableSkipIncompatibleRow,omitempty"`

	// Specifies whether to copy data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
	EnableStaging *interface{} `json:"enableStaging,omitempty"`

	// Maximum number of concurrent sessions opened on the source or sink to avoid overloading the data store. Type: integer (or Expression with resultType
	// integer), minimum: 0.
	ParallelCopies *interface{} `json:"parallelCopies,omitempty"`

	// Preserve rules.
	Preserve *[]interface{} `json:"preserve,omitempty"`

	// Preserve Rules.
	PreserveRules *[]interface{} `json:"preserveRules,omitempty"`

	// Redirect incompatible row settings when EnableSkipIncompatibleRow is true.
	RedirectIncompatibleRowSettings *RedirectIncompatibleRowSettings `json:"redirectIncompatibleRowSettings,omitempty"`

	// Copy activity sink.
	Sink CopySinkClassification `json:"sink,omitempty"`

	// Copy activity source.
	Source CopySourceClassification `json:"source,omitempty"`

	// Specifies interim staging settings when EnableStaging is true.
	StagingSettings *StagingSettings `json:"stagingSettings,omitempty"`

	// Copy activity translator. If not specified, tabular translator is used.
	Translator *interface{} `json:"translator,omitempty"`
}

// CopySinkClassification provides polymorphic access to related types.
// Call the interface's GetCopySink() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CopySink, *AvroSink, *AzureBlobFSSink, *AzureDataExplorerSink, *AzureDataLakeStoreSink, *AzureMySqlSink, *AzurePostgreSqlSink,
// - *AzureQueueSink, *AzureSearchIndexSink, *AzureSqlSink, *AzureTableSink, *BinarySink, *BlobSink, *CommonDataServiceForAppsSink,
// - *CosmosDbMongoDbApiSink, *CosmosDbSqlApiSink, *DelimitedTextSink, *DocumentDbCollectionSink, *DynamicsCrmSink, *DynamicsSink,
// - *FileSystemSink, *InformixSink, *JsonSink, *MicrosoftAccessSink, *OdbcSink, *OracleSink, *OrcSink, *ParquetSink, *SalesforceServiceCloudSink,
// - *SalesforceSink, *SapCloudForCustomerSink, *SqlDWSink, *SqlMISink, *SqlServerSink, *SqlSink
type CopySinkClassification interface {
	// GetCopySink() returns the CopySink content of the underlying type.
	GetCopySink() *CopySink
}

// A copy activity sink.
type CopySink struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections *interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount *interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait *interface{} `json:"sinkRetryWait,omitempty"`

	// Copy sink type.
	Type *string `json:"type,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize *interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout *interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type CopySink.
func (c *CopySink) GetCopySink() *CopySink { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySink.
func (c *CopySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CopySink) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if c.MaxConcurrentConnections != nil {
		objectMap["maxConcurrentConnections"] = c.MaxConcurrentConnections
	}
	if c.SinkRetryCount != nil {
		objectMap["sinkRetryCount"] = c.SinkRetryCount
	}
	if c.SinkRetryWait != nil {
		objectMap["sinkRetryWait"] = c.SinkRetryWait
	}
	c.Type = &discValue
	objectMap["type"] = c.Type
	if c.WriteBatchSize != nil {
		objectMap["writeBatchSize"] = c.WriteBatchSize
	}
	if c.WriteBatchTimeout != nil {
		objectMap["writeBatchTimeout"] = c.WriteBatchTimeout
	}
	if c.AdditionalProperties != nil {
		for key, val := range *c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (c *CopySink) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxConcurrentConnections":
			if val != nil {
				err = json.Unmarshal(*val, &c.MaxConcurrentConnections)
			}
			delete(rawMsg, key)
		case "sinkRetryCount":
			if val != nil {
				err = json.Unmarshal(*val, &c.SinkRetryCount)
			}
			delete(rawMsg, key)
		case "sinkRetryWait":
			if val != nil {
				err = json.Unmarshal(*val, &c.SinkRetryWait)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &c.Type)
			}
			delete(rawMsg, key)
		case "writeBatchSize":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBatchSize)
			}
			delete(rawMsg, key)
		case "writeBatchTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBatchTimeout)
			}
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*c.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopySourceClassification provides polymorphic access to related types.
// Call the interface's GetCopySource() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CopySource, *AmazonMWSSource, *AmazonRedshiftSource, *AvroSource, *AzureBlobFSSource, *AzureDataExplorerSource, *AzureDataLakeStoreSource,
// - *AzureMariaDBSource, *AzureMySqlSource, *AzurePostgreSqlSource, *AzureSqlSource, *AzureTableSource, *BinarySource, *BlobSource,
// - *CassandraSource, *CommonDataServiceForAppsSource, *ConcurSource, *CosmosDbMongoDbApiSource, *CosmosDbSqlApiSource, *CouchbaseSource,
// - *Db2Source, *DelimitedTextSource, *DocumentDbCollectionSource, *DrillSource, *DynamicsAXSource, *DynamicsCrmSource, *DynamicsSource,
// - *EloquaSource, *FileSystemSource, *GoogleAdWordsSource, *GoogleBigQuerySource, *GreenplumSource, *HBaseSource, *HdfsSource,
// - *HiveSource, *HttpSource, *HubspotSource, *ImpalaSource, *InformixSource, *JiraSource, *JsonSource, *MagentoSource, *MariaDBSource,
// - *MarketoSource, *MicrosoftAccessSource, *MongoDbSource, *MongoDbV2Source, *MySqlSource, *NetezzaSource, *ODataSource,
// - *OdbcSource, *Office365Source, *OracleServiceCloudSource, *OracleSource, *OrcSource, *ParquetSource, *PaypalSource, *PhoenixSource,
// - *PostgreSqlSource, *PrestoSource, *QuickBooksSource, *RelationalSource, *ResponsysSource, *RestSource, *SalesforceMarketingCloudSource,
// - *SalesforceServiceCloudSource, *SalesforceSource, *SapBwSource, *SapCloudForCustomerSource, *SapEccSource, *SapHanaSource,
// - *SapOpenHubSource, *SapTableSource, *ServiceNowSource, *ShopifySource, *SparkSource, *SqlDWSource, *SqlMISource, *SqlServerSource,
// - *SqlSource, *SquareSource, *SybaseSource, *TabularSource, *TeradataSource, *VerticaSource, *WebSource, *XeroSource, *ZohoSource
type CopySourceClassification interface {
	// GetCopySource() returns the CopySource content of the underlying type.
	GetCopySource() *CopySource
}

// A copy activity source.
type CopySource struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections *interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount *interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait *interface{} `json:"sourceRetryWait,omitempty"`

	// Copy source type.
	Type *string `json:"type,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CopySource.
func (c *CopySource) GetCopySource() *CopySource { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySource.
func (c *CopySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CopySource) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if c.MaxConcurrentConnections != nil {
		objectMap["maxConcurrentConnections"] = c.MaxConcurrentConnections
	}
	if c.SourceRetryCount != nil {
		objectMap["sourceRetryCount"] = c.SourceRetryCount
	}
	if c.SourceRetryWait != nil {
		objectMap["sourceRetryWait"] = c.SourceRetryWait
	}
	c.Type = &discValue
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range *c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (c *CopySource) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxConcurrentConnections":
			if val != nil {
				err = json.Unmarshal(*val, &c.MaxConcurrentConnections)
			}
			delete(rawMsg, key)
		case "sourceRetryCount":
			if val != nil {
				err = json.Unmarshal(*val, &c.SourceRetryCount)
			}
			delete(rawMsg, key)
		case "sourceRetryWait":
			if val != nil {
				err = json.Unmarshal(*val, &c.SourceRetryWait)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &c.Type)
			}
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*c.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopyTranslatorClassification provides polymorphic access to related types.
// Call the interface's GetCopyTranslator() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CopyTranslator, *TabularTranslator
type CopyTranslatorClassification interface {
	// GetCopyTranslator() returns the CopyTranslator content of the underlying type.
	GetCopyTranslator() *CopyTranslator
}

// A copy activity translator.
type CopyTranslator struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Copy translator type.
	Type *string `json:"type,omitempty"`
}

// GetCopyTranslator implements the CopyTranslatorClassification interface for type CopyTranslator.
func (c *CopyTranslator) GetCopyTranslator() *CopyTranslator { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyTranslator.
func (c *CopyTranslator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CopyTranslator) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	c.Type = &discValue
	objectMap["type"] = c.Type
	if c.AdditionalProperties != nil {
		for key, val := range *c.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (c *CopyTranslator) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &c.Type)
			}
			delete(rawMsg, key)
		default:
			if c.AdditionalProperties == nil {
				c.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*c.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Microsoft Azure Cosmos Database (CosmosDB) linked service.
type CosmosDbLinkedService struct {
	LinkedService
	// CosmosDB linked service properties.
	TypeProperties *CosmosDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbLinkedService.
func (c CosmosDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CosmosDb")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedService.
func (c *CosmosDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// CosmosDB linked service properties.
type CosmosDbLinkedServiceTypeProperties struct {
	// The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
	AccountEndpoint *interface{} `json:"accountEndpoint,omitempty"`

	// The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
	AccountKey SecretBaseClassification `json:"accountKey,omitempty"`

	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The name of the database. Type: string (or Expression with resultType string)
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedServiceTypeProperties.
func (c *CosmosDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &c.AccountEndpoint)
			}
			delete(rawMsg, key)
		case "accountKey":
			if val != nil {
				c.AccountKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &c.ConnectionString)
			}
			delete(rawMsg, key)
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &c.Database)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The CosmosDB (MongoDB API) database dataset.
type CosmosDbMongoDbAPICollectionDataset struct {
	Dataset
	// CosmosDB (MongoDB API) database dataset properties.
	TypeProperties *CosmosDbMongoDbAPICollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c CosmosDbMongoDbAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CosmosDbMongoDbApiCollection")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c *CosmosDbMongoDbAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// CosmosDB (MongoDB API) database dataset properties.
type CosmosDbMongoDbAPICollectionDatasetTypeProperties struct {
	// The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
	Collection *interface{} `json:"collection,omitempty"`
}

// Linked service for CosmosDB (MongoDB API) data source.
type CosmosDbMongoDbAPILinkedService struct {
	LinkedService
	// CosmosDB (MongoDB API) linked service properties.
	TypeProperties *CosmosDbMongoDbAPILinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c CosmosDbMongoDbAPILinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CosmosDbMongoDbApi")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c *CosmosDbMongoDbAPILinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// CosmosDB (MongoDB API) linked service properties.
type CosmosDbMongoDbAPILinkedServiceTypeProperties struct {
	// The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`
}

// A copy activity sink for a CosmosDB (MongoDB API) database.
type CosmosDbMongoDbAPISink struct {
	CopySink
	// Specifies whether the document with same key to be overwritten (upsert) rather than throw exception (insert). The default value is "insert". Type: string
	// (or Expression with resultType string). Type:
	// string (or Expression with resultType string).
	WriteBehavior *interface{} `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPISink.
func (c CosmosDbMongoDbAPISink) MarshalJSON() ([]byte, error) {
	objectMap := c.CopySink.marshalInternal("CosmosDbMongoDbApiSink")
	if c.WriteBehavior != nil {
		objectMap["writeBehavior"] = c.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPISink.
func (c *CosmosDbMongoDbAPISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity source for a CosmosDB (MongoDB API) database.
type CosmosDbMongoDbAPISource struct {
	CopySource
	// Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying the batch size will not affect
	// the user or the application. This property's
	// main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
	BatchSize *interface{} `json:"batchSize,omitempty"`

	// Cursor methods for Mongodb query.
	CursorMethods *MongoDbCursorMethodsProperties `json:"cursorMethods,omitempty"`

	// Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type:
	// string (or Expression with resultType string).
	Filter *interface{} `json:"filter,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout *interface{} `json:"queryTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPISource.
func (c CosmosDbMongoDbAPISource) MarshalJSON() ([]byte, error) {
	objectMap := c.CopySource.marshalInternal("CosmosDbMongoDbApiSource")
	if c.BatchSize != nil {
		objectMap["batchSize"] = c.BatchSize
	}
	if c.CursorMethods != nil {
		objectMap["cursorMethods"] = c.CursorMethods
	}
	if c.Filter != nil {
		objectMap["filter"] = c.Filter
	}
	if c.QueryTimeout != nil {
		objectMap["queryTimeout"] = c.QueryTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPISource.
func (c *CosmosDbMongoDbAPISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSize":
			if val != nil {
				err = json.Unmarshal(*val, &c.BatchSize)
			}
			delete(rawMsg, key)
		case "cursorMethods":
			if val != nil {
				err = json.Unmarshal(*val, &c.CursorMethods)
			}
			delete(rawMsg, key)
		case "filter":
			if val != nil {
				err = json.Unmarshal(*val, &c.Filter)
			}
			delete(rawMsg, key)
		case "queryTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &c.QueryTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.CopySource.unmarshalInternal(rawMsg)
}

// Microsoft Azure CosmosDB (SQL API) Collection dataset.
type CosmosDbSQLAPICollectionDataset struct {
	Dataset
	// CosmosDB (SQL API) Collection dataset properties.
	TypeProperties *CosmosDbSQLAPICollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c CosmosDbSQLAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CosmosDbSqlApiCollection")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c *CosmosDbSQLAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// CosmosDB (SQL API) Collection dataset properties.
type CosmosDbSQLAPICollectionDatasetTypeProperties struct {
	// CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
	CollectionName *interface{} `json:"collectionName,omitempty"`
}

// A copy activity Azure CosmosDB (SQL API) Collection sink.
type CosmosDbSQLAPISink struct {
	CopySink
	// Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert and upsert.
	WriteBehavior *interface{} `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPISink.
func (c CosmosDbSQLAPISink) MarshalJSON() ([]byte, error) {
	objectMap := c.CopySink.marshalInternal("CosmosDbSqlApiSink")
	if c.WriteBehavior != nil {
		objectMap["writeBehavior"] = c.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPISink.
func (c *CosmosDbSQLAPISink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure CosmosDB (SQL API) Collection source.
type CosmosDbSQLAPISource struct {
	CopySource
	// Page size of the result. Type: integer (or Expression with resultType integer).
	PageSize *interface{} `json:"pageSize,omitempty"`

	// Preferred regions. Type: array of strings (or Expression with resultType array of strings).
	PreferredRegions *interface{} `json:"preferredRegions,omitempty"`

	// SQL API query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPISource.
func (c CosmosDbSQLAPISource) MarshalJSON() ([]byte, error) {
	objectMap := c.CopySource.marshalInternal("CosmosDbSqlApiSource")
	if c.PageSize != nil {
		objectMap["pageSize"] = c.PageSize
	}
	if c.PreferredRegions != nil {
		objectMap["preferredRegions"] = c.PreferredRegions
	}
	if c.Query != nil {
		objectMap["query"] = c.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPISource.
func (c *CosmosDbSQLAPISource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pageSize":
			if val != nil {
				err = json.Unmarshal(*val, &c.PageSize)
			}
			delete(rawMsg, key)
		case "preferredRegions":
			if val != nil {
				err = json.Unmarshal(*val, &c.PreferredRegions)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &c.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.CopySource.unmarshalInternal(rawMsg)
}

// Couchbase server linked service.
type CouchbaseLinkedService struct {
	LinkedService
	// Couchbase server linked service properties.
	TypeProperties *CouchbaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseLinkedService.
func (c CouchbaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("Couchbase")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseLinkedService.
func (c *CouchbaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// Couchbase server linked service properties.
type CouchbaseLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The Azure key vault secret reference of credString in connection string.
	CredString *AzureKeyVaultSecretReference `json:"credString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`
}

// A copy activity Couchbase server source.
type CouchbaseSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseSource.
func (c CouchbaseSource) MarshalJSON() ([]byte, error) {
	objectMap := c.TabularSource.marshalInternal("CouchbaseSource")
	if c.Query != nil {
		objectMap["query"] = c.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseSource.
func (c *CouchbaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &c.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.TabularSource.unmarshalInternal(rawMsg)
}

// Couchbase server dataset.
type CouchbaseTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseTableDataset.
func (c CouchbaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CouchbaseTable")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseTableDataset.
func (c *CouchbaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// Request body structure for creating data flow debug session.
type CreateDataFlowDebugSessionRequest struct {
	// Timeout setting for Databricks cluster.
	ClusterTimeout *int32 `json:"clusterTimeout,omitempty"`

	// Data bricks linked service.
	DataBricksLinkedService *LinkedServiceResource `json:"dataBricksLinkedService,omitempty"`

	// The name of the data flow.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of existing Databricks cluster.
	ExistingClusterID *string `json:"existingClusterId,omitempty"`

	// The name of new Databricks cluster.
	NewClusterName *string `json:"newClusterName,omitempty"`

	// The type of new Databricks cluster.
	NewClusterNodeType *string `json:"newClusterNodeType,omitempty"`
}

// Response body structure for creating data flow debug session.
type CreateDataFlowDebugSessionResponse struct {
	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// CreateDataFlowDebugSessionResponsePollerResponse is the response envelope for operations that asynchronously return a CreateDataFlowDebugSessionResponse
// type.
type CreateDataFlowDebugSessionResponsePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*CreateDataFlowDebugSessionResponseResponse, error)

	// Poller contains an initialized poller.
	Poller CreateDataFlowDebugSessionResponsePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CreateDataFlowDebugSessionResponseResponse is the response envelope for operations that return a CreateDataFlowDebugSessionResponse type.
type CreateDataFlowDebugSessionResponseResponse struct {
	// Response body structure for creating data flow debug session.
	CreateDataFlowDebugSessionResponse *CreateDataFlowDebugSessionResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Response body with a run identifier.
type CreateRunResponse struct {
	// Identifier of a run.
	RunID *string `json:"runId,omitempty"`
}

// CreateRunResponseResponse is the response envelope for operations that return a CreateRunResponse type.
type CreateRunResponseResponse struct {
	// Response body with a run identifier.
	CreateRunResponse *CreateRunResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Custom activity type.
type CustomActivity struct {
	ExecutionActivity
	// Custom activity properties.
	TypeProperties *CustomActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivity.
func (c CustomActivity) MarshalJSON() ([]byte, error) {
	objectMap := c.ExecutionActivity.marshalInternal("Custom")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomActivity.
func (c *CustomActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Reference objects for custom activity
type CustomActivityReferenceObject struct {
	// Dataset references.
	Datasets *[]DatasetReference `json:"datasets,omitempty"`

	// Linked service references.
	LinkedServices *[]LinkedServiceReference `json:"linkedServices,omitempty"`
}

// Custom activity properties.
type CustomActivityTypeProperties struct {
	// Command for custom activity Type: string (or Expression with resultType string).
	Command *interface{} `json:"command,omitempty"`

	// User defined property bag. There is no restriction on the keys or values that can be used. The user specified custom activity has the full responsibility
	// to consume and interpret the content defined.
	ExtendedProperties *map[string]interface{} `json:"extendedProperties,omitempty"`

	// Folder path for resource files Type: string (or Expression with resultType string).
	FolderPath *interface{} `json:"folderPath,omitempty"`

	// Reference objects
	ReferenceObjects *CustomActivityReferenceObject `json:"referenceObjects,omitempty"`

	// Resource linked service reference.
	ResourceLinkedService *LinkedServiceReference `json:"resourceLinkedService,omitempty"`

	// The retention time for the files submitted for custom activity. Type: double (or Expression with resultType double).
	RetentionTimeInDays *interface{} `json:"retentionTimeInDays,omitempty"`
}

// Custom linked service.
type CustomDataSourceLinkedService struct {
	LinkedService
	// Custom linked service properties.
	TypeProperties *interface{} `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataSourceLinkedService.
func (c CustomDataSourceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CustomDataSource")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataSourceLinkedService.
func (c *CustomDataSourceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.LinkedService.unmarshalInternal(rawMsg)
}

// The custom dataset.
type CustomDataset struct {
	Dataset
	// Custom dataset properties.
	TypeProperties *interface{} `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataset.
func (c CustomDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CustomDataset")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataset.
func (c *CustomDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.Dataset.unmarshalInternal(rawMsg)
}

// CustomSetupBaseClassification provides polymorphic access to related types.
// Call the interface's GetCustomSetupBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CustomSetupBase
type CustomSetupBaseClassification interface {
	// GetCustomSetupBase() returns the CustomSetupBase content of the underlying type.
	GetCustomSetupBase() *CustomSetupBase
}

// The base definition of the custom setup.
type CustomSetupBase struct {
	// The type of custom setup.
	Type *string `json:"type,omitempty"`
}

// GetCustomSetupBase implements the CustomSetupBaseClassification interface for type CustomSetupBase.
func (c *CustomSetupBase) GetCustomSetupBase() *CustomSetupBase { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomSetupBase.
func (c *CustomSetupBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CustomSetupBase) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	c.Type = &discValue
	objectMap["type"] = c.Type
	return objectMap
}

func (c *CustomSetupBase) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &c.Type)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Details of the customer managed key associated with the workspace
type CustomerManagedKeyDetails struct {
	// The key object of the workspace
	Key *WorkspaceKeyDetails `json:"key,omitempty"`

	// The customer managed key status on the workspace
	Status *string `json:"status,omitempty" azure:"ro"`
}

// DataFlowClassification provides polymorphic access to related types.
// Call the interface's GetDataFlow() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DataFlow, *MappingDataFlow
type DataFlowClassification interface {
	// GetDataFlow() returns the DataFlow content of the underlying type.
	GetDataFlow() *DataFlow
}

// Azure Synapse nested object which contains a flow with data movements and transformations.
type DataFlow struct {
	// List of tags that can be used for describing the data flow.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// The description of the data flow.
	Description *string `json:"description,omitempty"`

	// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
	Folder *DataFlowFolder `json:"folder,omitempty"`

	// Type of data flow.
	Type *string `json:"type,omitempty"`
}

// GetDataFlow implements the DataFlowClassification interface for type DataFlow.
func (d *DataFlow) GetDataFlow() *DataFlow { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlow.
func (d *DataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DataFlow) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.Annotations != nil {
		objectMap["annotations"] = d.Annotations
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.Folder != nil {
		objectMap["folder"] = d.Folder
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	return objectMap
}

func (d *DataFlow) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &d.Annotations)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &d.Description)
			}
			delete(rawMsg, key)
		case "folder":
			if val != nil {
				err = json.Unmarshal(*val, &d.Folder)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowCreateOrUpdateDataFlowOptions contains the optional parameters for the DataFlow.CreateOrUpdateDataFlow method.
type DataFlowCreateOrUpdateDataFlowOptions struct {
	// ETag of the data flow entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// Request body structure for data flow expression preview.
type DataFlowDebugCommandRequest struct {
	// The command name.
	CommandName *string `json:"commandName,omitempty"`

	// The command payload object.
	CommandPayload *interface{} `json:"commandPayload,omitempty"`

	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// Response body structure of data flow result for data preview, statistics or expression preview.
type DataFlowDebugCommandResponse struct {
	// The result data of data preview, statistics or expression preview.
	Data *string `json:"data,omitempty"`

	// The run status of data preview, statistics or expression preview.
	Status *string `json:"status,omitempty"`
}

// DataFlowDebugCommandResponsePollerResponse is the response envelope for operations that asynchronously return a DataFlowDebugCommandResponse type.
type DataFlowDebugCommandResponsePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*DataFlowDebugCommandResponseResponse, error)

	// Poller contains an initialized poller.
	Poller DataFlowDebugCommandResponsePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugCommandResponseResponse is the response envelope for operations that return a DataFlowDebugCommandResponse type.
type DataFlowDebugCommandResponseResponse struct {
	// Response body structure of data flow result for data preview, statistics or expression preview.
	DataFlowDebugCommandResponse *DataFlowDebugCommandResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Request body structure for starting data flow debug session.
type DataFlowDebugPackage struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Data flow instance.
	DataFlow *DataFlowDebugResource `json:"dataFlow,omitempty"`

	// List of datasets.
	Datasets *[]DatasetDebugResource `json:"datasets,omitempty"`

	// Data flow debug settings.
	DebugSettings *DataFlowDebugPackageDebugSettings `json:"debugSettings,omitempty"`

	// List of linked services.
	LinkedServices *[]LinkedServiceDebugResource `json:"linkedServices,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Staging info for debug session.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugPackage.
func (d DataFlowDebugPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DataFlow != nil {
		objectMap["dataFlow"] = d.DataFlow
	}
	if d.Datasets != nil {
		objectMap["datasets"] = d.Datasets
	}
	if d.DebugSettings != nil {
		objectMap["debugSettings"] = d.DebugSettings
	}
	if d.LinkedServices != nil {
		objectMap["linkedServices"] = d.LinkedServices
	}
	if d.SessionID != nil {
		objectMap["sessionId"] = d.SessionID
	}
	if d.Staging != nil {
		objectMap["staging"] = d.Staging
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugPackage.
func (d *DataFlowDebugPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlow":
			if val != nil {
				err = json.Unmarshal(*val, &d.DataFlow)
			}
			delete(rawMsg, key)
		case "datasets":
			if val != nil {
				err = json.Unmarshal(*val, &d.Datasets)
			}
			delete(rawMsg, key)
		case "debugSettings":
			if val != nil {
				err = json.Unmarshal(*val, &d.DebugSettings)
			}
			delete(rawMsg, key)
		case "linkedServices":
			if val != nil {
				err = json.Unmarshal(*val, &d.LinkedServices)
			}
			delete(rawMsg, key)
		case "sessionId":
			if val != nil {
				err = json.Unmarshal(*val, &d.SessionID)
			}
			delete(rawMsg, key)
		case "staging":
			if val != nil {
				err = json.Unmarshal(*val, &d.Staging)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Data flow debug settings.
type DataFlowDebugPackageDebugSettings struct {
	// Parameters for dataset.
	DatasetParameters *interface{} `json:"datasetParameters,omitempty"`

	// Data flow parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Source setting for data flow debug.
	SourceSettings *[]DataFlowSourceSetting `json:"sourceSettings,omitempty"`
}

// Request body structure for data flow preview data.
type DataFlowDebugPreviewDataRequest struct {
	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The row limit for preview request.
	RowLimits *int32 `json:"rowLimits,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The output stream name.
	StreamName *string `json:"streamName,omitempty"`
}

// Response body structure of data flow query for data preview, statistics or expression preview.
type DataFlowDebugQueryResponse struct {
	// The run ID of data flow debug session.
	RunID *string `json:"runId,omitempty"`
}

// Data flow debug resource.
type DataFlowDebugResource struct {
	SubResourceDebugResource
	// Data flow properties.
	Properties DataFlowClassification `json:"properties,omitempty"`
}

// Response body structure of data flow result for data preview, statistics or expression preview.
type DataFlowDebugResultResponse struct {
	// The result data of data preview, statistics or expression preview.
	Data *string `json:"data,omitempty"`

	// The run status of data preview, statistics or expression preview.
	Status *string `json:"status,omitempty"`
}

// DataFlowDebugSessionAddDataFlowOptions contains the optional parameters for the DataFlowDebugSession.AddDataFlow method.
type DataFlowDebugSessionAddDataFlowOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionCreateDataFlowDebugSessionOptions contains the optional parameters for the DataFlowDebugSession.CreateDataFlowDebugSession method.
type DataFlowDebugSessionCreateDataFlowDebugSessionOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionDeleteDataFlowDebugSessionOptions contains the optional parameters for the DataFlowDebugSession.DeleteDataFlowDebugSession method.
type DataFlowDebugSessionDeleteDataFlowDebugSessionOptions struct {
	// placeholder for future optional parameters
}

// DataFlowDebugSessionExecuteCommandOptions contains the optional parameters for the DataFlowDebugSession.ExecuteCommand method.
type DataFlowDebugSessionExecuteCommandOptions struct {
	// placeholder for future optional parameters
}

// Data flow debug session info.
type DataFlowDebugSessionInfo struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Compute type of the cluster.
	ComputeType *string `json:"computeType,omitempty"`

	// Core count of the cluster.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// The name of the data flow.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// Attached integration runtime name of data flow debug session.
	IntegrationRuntimeName *string `json:"integrationRuntimeName,omitempty"`

	// Last activity time of data flow debug session.
	LastActivityTime *string `json:"lastActivityTime,omitempty"`

	// Node count of the cluster. (deprecated property)
	NodeCount *int32 `json:"nodeCount,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Start time of data flow debug session.
	StartTime *string `json:"startTime,omitempty"`

	// Compute type of the cluster.
	TimeToLiveInMinutes *int32 `json:"timeToLiveInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugSessionInfo.
func (d DataFlowDebugSessionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ComputeType != nil {
		objectMap["computeType"] = d.ComputeType
	}
	if d.CoreCount != nil {
		objectMap["coreCount"] = d.CoreCount
	}
	if d.DataFlowName != nil {
		objectMap["dataFlowName"] = d.DataFlowName
	}
	if d.IntegrationRuntimeName != nil {
		objectMap["integrationRuntimeName"] = d.IntegrationRuntimeName
	}
	if d.LastActivityTime != nil {
		objectMap["lastActivityTime"] = d.LastActivityTime
	}
	if d.NodeCount != nil {
		objectMap["nodeCount"] = d.NodeCount
	}
	if d.SessionID != nil {
		objectMap["sessionId"] = d.SessionID
	}
	if d.StartTime != nil {
		objectMap["startTime"] = d.StartTime
	}
	if d.TimeToLiveInMinutes != nil {
		objectMap["timeToLiveInMinutes"] = d.TimeToLiveInMinutes
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugSessionInfo.
func (d *DataFlowDebugSessionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			if val != nil {
				err = json.Unmarshal(*val, &d.ComputeType)
			}
			delete(rawMsg, key)
		case "coreCount":
			if val != nil {
				err = json.Unmarshal(*val, &d.CoreCount)
			}
			delete(rawMsg, key)
		case "dataFlowName":
			if val != nil {
				err = json.Unmarshal(*val, &d.DataFlowName)
			}
			delete(rawMsg, key)
		case "integrationRuntimeName":
			if val != nil {
				err = json.Unmarshal(*val, &d.IntegrationRuntimeName)
			}
			delete(rawMsg, key)
		case "lastActivityTime":
			if val != nil {
				err = json.Unmarshal(*val, &d.LastActivityTime)
			}
			delete(rawMsg, key)
		case "nodeCount":
			if val != nil {
				err = json.Unmarshal(*val, &d.NodeCount)
			}
			delete(rawMsg, key)
		case "sessionId":
			if val != nil {
				err = json.Unmarshal(*val, &d.SessionID)
			}
			delete(rawMsg, key)
		case "startTime":
			if val != nil {
				err = json.Unmarshal(*val, &d.StartTime)
			}
			delete(rawMsg, key)
		case "timeToLiveInMinutes":
			if val != nil {
				err = json.Unmarshal(*val, &d.TimeToLiveInMinutes)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceOptions contains the optional parameters for the DataFlowDebugSession.QueryDataFlowDebugSessionsByWorkspace
// method.
type DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// Request body structure for data flow statistics.
type DataFlowDebugStatisticsRequest struct {
	// List of column names.
	Columns *[]string `json:"columns,omitempty"`

	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The output stream name.
	StreamName *string `json:"streamName,omitempty"`
}

// DataFlowDeleteDataFlowOptions contains the optional parameters for the DataFlow.DeleteDataFlow method.
type DataFlowDeleteDataFlowOptions struct {
	// placeholder for future optional parameters
}

// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
type DataFlowFolder struct {
	// The name of the folder that this data flow is in.
	Name *string `json:"name,omitempty"`
}

// DataFlowGetDataFlowOptions contains the optional parameters for the DataFlow.GetDataFlow method.
type DataFlowGetDataFlowOptions struct {
	// ETag of the data flow entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will
	// be returned.
	IfNoneMatch *string
}

// DataFlowGetDataFlowsByWorkspaceOptions contains the optional parameters for the DataFlow.GetDataFlowsByWorkspace method.
type DataFlowGetDataFlowsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// A list of data flow resources.
type DataFlowListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of data flows.
	Value *[]DataFlowResource `json:"value,omitempty"`
}

// DataFlowListResponseResponse is the response envelope for operations that return a DataFlowListResponse type.
type DataFlowListResponseResponse struct {
	// A list of data flow resources.
	DataFlowListResponse *DataFlowListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Data flow reference type.
type DataFlowReference struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Reference data flow parameters from dataset.
	DatasetParameters *interface{} `json:"datasetParameters,omitempty"`

	// Reference data flow name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Data flow reference type.
	Type *DataFlowReferenceType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowReference.
func (d DataFlowReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DatasetParameters != nil {
		objectMap["datasetParameters"] = d.DatasetParameters
	}
	if d.ReferenceName != nil {
		objectMap["referenceName"] = d.ReferenceName
	}
	if d.Type != nil {
		objectMap["type"] = d.Type
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowReference.
func (d *DataFlowReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasetParameters":
			if val != nil {
				err = json.Unmarshal(*val, &d.DatasetParameters)
			}
			delete(rawMsg, key)
		case "referenceName":
			if val != nil {
				err = json.Unmarshal(*val, &d.ReferenceName)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Data flow resource type.
type DataFlowResource struct {
	AzureEntityResource
	// Data flow properties.
	Properties DataFlowClassification `json:"properties,omitempty"`
}

// DataFlowResourcePollerResponse is the response envelope for operations that asynchronously return a DataFlowResource type.
type DataFlowResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*DataFlowResourceResponse, error)

	// Poller contains an initialized poller.
	Poller DataFlowResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowResourceResponse is the response envelope for operations that return a DataFlowResource type.
type DataFlowResourceResponse struct {
	// Data flow resource type.
	DataFlowResource *DataFlowResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Transformation for data flow sink.
type DataFlowSink struct {
	Transformation
	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`
}

// Transformation for data flow source.
type DataFlowSource struct {
	Transformation
	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`
}

// Definition of data flow source setting for debug.
type DataFlowSourceSetting struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Defines the row limit of data flow source in debug.
	RowLimit *int32 `json:"rowLimit,omitempty"`

	// The data flow source name.
	SourceName *string `json:"sourceName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowSourceSetting.
func (d DataFlowSourceSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.RowLimit != nil {
		objectMap["rowLimit"] = d.RowLimit
	}
	if d.SourceName != nil {
		objectMap["sourceName"] = d.SourceName
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowSourceSetting.
func (d *DataFlowSourceSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rowLimit":
			if val != nil {
				err = json.Unmarshal(*val, &d.RowLimit)
			}
			delete(rawMsg, key)
		case "sourceName":
			if val != nil {
				err = json.Unmarshal(*val, &d.SourceName)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Staging info for execute data flow activity.
type DataFlowStagingInfo struct {
	// Folder path for staging blob.
	FolderPath *string `json:"folderPath,omitempty"`

	// Staging linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`
}

// DataFlowsRenameOptions contains the optional parameters for the DataFlows.Rename method.
type DataFlowsRenameOptions struct {
	// placeholder for future optional parameters
}

// Data Lake Analytics U-SQL activity.
type DataLakeAnalyticsUsqlActivity struct {
	ExecutionActivity
	// Data Lake Analytics U-SQL activity properties.
	TypeProperties *DataLakeAnalyticsUsqlActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsUsqlActivity.
func (d DataLakeAnalyticsUsqlActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DataLakeAnalyticsU-SQL")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsUsqlActivity.
func (d *DataLakeAnalyticsUsqlActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.ExecutionActivity.unmarshalInternal(rawMsg)
}

// DataLakeAnalyticsU-SQL activity properties.
type DataLakeAnalyticsUsqlActivityTypeProperties struct {
	// Compilation mode of U-SQL. Must be one of these values : Semantic, Full and SingleBox. Type: string (or Expression with resultType string).
	CompilationMode *interface{} `json:"compilationMode,omitempty"`

	// The maximum number of nodes simultaneously used to run the job. Default value is 1. Type: integer (or Expression with resultType integer), minimum: 1.
	DegreeOfParallelism *interface{} `json:"degreeOfParallelism,omitempty"`

	// Parameters for U-SQL job request.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Determines which jobs out of all that are queued should be selected to run first. The lower the number, the higher the priority. Default value is 1000.
	// Type: integer (or Expression with resultType
	// integer), minimum: 1.
	Priority *interface{} `json:"priority,omitempty"`

	// Runtime version of the U-SQL engine to use. Type: string (or Expression with resultType string).
	RuntimeVersion *interface{} `json:"runtimeVersion,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Case-sensitive path to folder that contains the U-SQL script. Type: string (or Expression with resultType string).
	ScriptPath *interface{} `json:"scriptPath,omitempty"`
}

// Details of the data lake storage account associated with the workspace
type DataLakeStorageAccountDetails struct {
	// Account URL
	AccountURL *string `json:"accountUrl,omitempty"`

	// Filesystem name
	Filesystem *string `json:"filesystem,omitempty"`
}

// DatabricksNotebook activity.
type DatabricksNotebookActivity struct {
	ExecutionActivity
	// Databricks Notebook activity properties.
	TypeProperties *DatabricksNotebookActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksNotebookActivity.
func (d DatabricksNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DatabricksNotebook")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksNotebookActivity.
func (d *DatabricksNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Databricks notebook activity properties.
type DatabricksNotebookActivityTypeProperties struct {
	// Base parameters to be used for each run of this job.If the notebook takes a parameter that is not specified, the default value from the notebook will
	// be used.
	BaseParameters *map[string]interface{} `json:"baseParameters,omitempty"`

	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries *[]map[string]interface{} `json:"libraries,omitempty"`

	// The absolute path of the notebook to be run in the Databricks Workspace. This path must begin with a slash. Type: string (or Expression with resultType
	// string).
	NotebookPath *interface{} `json:"notebookPath,omitempty"`
}

// DatabricksSparkJar activity.
type DatabricksSparkJarActivity struct {
	ExecutionActivity
	// Databricks SparkJar activity properties.
	TypeProperties *DatabricksSparkJarActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkJarActivity.
func (d DatabricksSparkJarActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DatabricksSparkJar")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkJarActivity.
func (d *DatabricksSparkJarActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Databricks SparkJar activity properties.
type DatabricksSparkJarActivityTypeProperties struct {
	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries *[]map[string]interface{} `json:"libraries,omitempty"`

	// The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. Type: string (or Expression
	// with resultType string).
	MainClassName *interface{} `json:"mainClassName,omitempty"`

	// Parameters that will be passed to the main method.
	Parameters *[]interface{} `json:"parameters,omitempty"`
}

// DatabricksSparkPython activity.
type DatabricksSparkPythonActivity struct {
	ExecutionActivity
	// Databricks SparkPython activity properties.
	TypeProperties *DatabricksSparkPythonActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkPythonActivity.
func (d DatabricksSparkPythonActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DatabricksSparkPython")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkPythonActivity.
func (d *DatabricksSparkPythonActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Databricks SparkPython activity properties.
type DatabricksSparkPythonActivityTypeProperties struct {
	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries *[]map[string]interface{} `json:"libraries,omitempty"`

	// Command line parameters that will be passed to the Python file.
	Parameters *[]interface{} `json:"parameters,omitempty"`

	// The URI of the Python file to be executed. DBFS paths are supported. Type: string (or Expression with resultType string).
	PythonFile *interface{} `json:"pythonFile,omitempty"`
}

// DatasetClassification provides polymorphic access to related types.
// Call the interface's GetDataset() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Dataset, *AmazonMWSObjectDataset, *AmazonRedshiftTableDataset, *AvroDataset, *AzureDataExplorerTableDataset, *AzureMariaDBTableDataset,
// - *AzureMySqlTableDataset, *AzurePostgreSqlTableDataset, *AzureSearchIndexDataset, *AzureSqlDWTableDataset, *AzureSqlMITableDataset,
// - *AzureSqlTableDataset, *AzureTableDataset, *BinaryDataset, *CassandraTableDataset, *CommonDataServiceForAppsEntityDataset,
// - *ConcurObjectDataset, *CosmosDbMongoDbApiCollectionDataset, *CosmosDbSqlApiCollectionDataset, *CouchbaseTableDataset,
// - *CustomDataset, *Db2TableDataset, *DelimitedTextDataset, *DocumentDbCollectionDataset, *DrillTableDataset, *DynamicsAXResourceDataset,
// - *DynamicsCrmEntityDataset, *DynamicsEntityDataset, *EloquaObjectDataset, *GoogleAdWordsObjectDataset, *GoogleBigQueryObjectDataset,
// - *GreenplumTableDataset, *HBaseObjectDataset, *HiveObjectDataset, *HubspotObjectDataset, *ImpalaObjectDataset, *InformixTableDataset,
// - *JiraObjectDataset, *JsonDataset, *MagentoObjectDataset, *MariaDBTableDataset, *MarketoObjectDataset, *MicrosoftAccessTableDataset,
// - *MongoDbCollectionDataset, *MongoDbV2CollectionDataset, *MySqlTableDataset, *NetezzaTableDataset, *ODataResourceDataset,
// - *OdbcTableDataset, *Office365Dataset, *OracleServiceCloudObjectDataset, *OracleTableDataset, *OrcDataset, *ParquetDataset,
// - *PaypalObjectDataset, *PhoenixObjectDataset, *PostgreSqlTableDataset, *PrestoObjectDataset, *QuickBooksObjectDataset,
// - *RelationalTableDataset, *ResponsysObjectDataset, *RestResourceDataset, *SalesforceMarketingCloudObjectDataset, *SalesforceObjectDataset,
// - *SalesforceServiceCloudObjectDataset, *SapBwCubeDataset, *SapCloudForCustomerResourceDataset, *SapEccResourceDataset,
// - *SapHanaTableDataset, *SapOpenHubTableDataset, *SapTableResourceDataset, *ServiceNowObjectDataset, *ShopifyObjectDataset,
// - *SparkObjectDataset, *SqlServerTableDataset, *SquareObjectDataset, *SybaseTableDataset, *TeradataTableDataset, *VerticaTableDataset,
// - *WebTableDataset, *XeroObjectDataset, *ZohoObjectDataset
type DatasetClassification interface {
	// GetDataset() returns the Dataset content of the underlying type.
	GetDataset() *Dataset
}

// The Azure Data Factory nested object which identifies data within different data stores, such as tables, files, folders, and documents.
type Dataset struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Parameters for dataset.
	Parameters *map[string]ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType: DatasetSchemaDataElement.
	Schema *interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure *interface{} `json:"structure,omitempty"`

	// Type of dataset.
	Type *string `json:"type,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type Dataset.
func (d *Dataset) GetDataset() *Dataset { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type Dataset.
func (d *Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d Dataset) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.Annotations != nil {
		objectMap["annotations"] = d.Annotations
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.Folder != nil {
		objectMap["folder"] = d.Folder
	}
	if d.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = d.LinkedServiceName
	}
	if d.Parameters != nil {
		objectMap["parameters"] = d.Parameters
	}
	if d.Schema != nil {
		objectMap["schema"] = d.Schema
	}
	if d.Structure != nil {
		objectMap["structure"] = d.Structure
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (d *Dataset) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &d.Annotations)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &d.Description)
			}
			delete(rawMsg, key)
		case "folder":
			if val != nil {
				err = json.Unmarshal(*val, &d.Folder)
			}
			delete(rawMsg, key)
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &d.LinkedServiceName)
			}
			delete(rawMsg, key)
		case "parameters":
			if val != nil {
				err = json.Unmarshal(*val, &d.Parameters)
			}
			delete(rawMsg, key)
		case "schema":
			if val != nil {
				err = json.Unmarshal(*val, &d.Schema)
			}
			delete(rawMsg, key)
		case "structure":
			if val != nil {
				err = json.Unmarshal(*val, &d.Structure)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The BZip2 compression method used on a dataset.
type DatasetBZip2Compression struct {
	DatasetCompression
}

// MarshalJSON implements the json.Marshaller interface for type DatasetBZip2Compression.
func (d DatasetBZip2Compression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("BZip2")
	return json.Marshal(objectMap)
}

// DatasetCompressionClassification provides polymorphic access to related types.
// Call the interface's GetDatasetCompression() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DatasetCompression, *DatasetBZip2Compression, *DatasetDeflateCompression, *DatasetGZipCompression, *DatasetZipDeflateCompression
type DatasetCompressionClassification interface {
	// GetDatasetCompression() returns the DatasetCompression content of the underlying type.
	GetDatasetCompression() *DatasetCompression
}

// The compression method used on a dataset.
type DatasetCompression struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Type of dataset compression.
	Type *string `json:"type,omitempty"`
}

// GetDatasetCompression implements the DatasetCompressionClassification interface for type DatasetCompression.
func (d *DatasetCompression) GetDatasetCompression() *DatasetCompression { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetCompression.
func (d *DatasetCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DatasetCompression) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	d.Type = &discValue
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (d *DatasetCompression) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetCreateOrUpdateDatasetOptions contains the optional parameters for the Dataset.CreateOrUpdateDataset method.
type DatasetCreateOrUpdateDatasetOptions struct {
	// ETag of the dataset entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// Columns that define the structure of the dataset.
type DatasetDataElement struct {
	// Name of the column. Type: string (or Expression with resultType string).
	Name *interface{} `json:"name,omitempty"`

	// Type of the column. Type: string (or Expression with resultType string).
	Type *interface{} `json:"type,omitempty"`
}

// Dataset debug resource.
type DatasetDebugResource struct {
	SubResourceDebugResource
	// Dataset properties.
	Properties DatasetClassification `json:"properties,omitempty"`
}

// The Deflate compression method used on a dataset.
type DatasetDeflateCompression struct {
	DatasetCompression
	// The Deflate compression level.
	Level *DatasetCompressionLevel `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetDeflateCompression.
func (d DatasetDeflateCompression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("Deflate")
	if d.Level != nil {
		objectMap["level"] = d.Level
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetDeflateCompression.
func (d *DatasetDeflateCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			if val != nil {
				err = json.Unmarshal(*val, &d.Level)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.DatasetCompression.unmarshalInternal(rawMsg)
}

// DatasetDeleteDatasetOptions contains the optional parameters for the Dataset.DeleteDataset method.
type DatasetDeleteDatasetOptions struct {
	// placeholder for future optional parameters
}

// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
type DatasetFolder struct {
	// The name of the folder that this Dataset is in.
	Name *string `json:"name,omitempty"`
}

// The GZip compression method used on a dataset.
type DatasetGZipCompression struct {
	DatasetCompression
	// The GZip compression level.
	Level *DatasetCompressionLevel `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetGZipCompression.
func (d DatasetGZipCompression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("GZip")
	if d.Level != nil {
		objectMap["level"] = d.Level
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetGZipCompression.
func (d *DatasetGZipCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			if val != nil {
				err = json.Unmarshal(*val, &d.Level)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.DatasetCompression.unmarshalInternal(rawMsg)
}

// DatasetGetDatasetOptions contains the optional parameters for the Dataset.GetDataset method.
type DatasetGetDatasetOptions struct {
	// ETag of the dataset entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will
	// be returned.
	IfNoneMatch *string
}

// DatasetGetDatasetsByWorkspaceOptions contains the optional parameters for the Dataset.GetDatasetsByWorkspace method.
type DatasetGetDatasetsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// A list of dataset resources.
type DatasetListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of datasets.
	Value *[]DatasetResource `json:"value,omitempty"`
}

// DatasetListResponseResponse is the response envelope for operations that return a DatasetListResponse type.
type DatasetListResponseResponse struct {
	// A list of dataset resources.
	DatasetListResponse *DatasetListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetLocationClassification provides polymorphic access to related types.
// Call the interface's GetDatasetLocation() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DatasetLocation, *AmazonS3Location, *AzureBlobFSLocation, *AzureBlobStorageLocation, *AzureDataLakeStoreLocation, *AzureFileStorageLocation,
// - *FileServerLocation, *FtpServerLocation, *GoogleCloudStorageLocation, *HdfsLocation, *HttpServerLocation, *SftpLocation
type DatasetLocationClassification interface {
	// GetDatasetLocation() returns the DatasetLocation content of the underlying type.
	GetDatasetLocation() *DatasetLocation
}

// Dataset location.
type DatasetLocation struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName *interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath *interface{} `json:"folderPath,omitempty"`

	// Type of dataset storage location.
	Type *string `json:"type,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type DatasetLocation.
func (d *DatasetLocation) GetDatasetLocation() *DatasetLocation { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetLocation.
func (d *DatasetLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DatasetLocation) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.FileName != nil {
		objectMap["fileName"] = d.FileName
	}
	if d.FolderPath != nil {
		objectMap["folderPath"] = d.FolderPath
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (d *DatasetLocation) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			if val != nil {
				err = json.Unmarshal(*val, &d.FileName)
			}
			delete(rawMsg, key)
		case "folderPath":
			if val != nil {
				err = json.Unmarshal(*val, &d.FolderPath)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Dataset reference type.
type DatasetReference struct {
	// Arguments for dataset.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Reference dataset name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Dataset reference type.
	Type *DatasetReferenceType `json:"type,omitempty"`
}

// Dataset resource type.
type DatasetResource struct {
	AzureEntityResource
	// Dataset properties.
	Properties DatasetClassification `json:"properties,omitempty"`
}

// DatasetResourcePollerResponse is the response envelope for operations that asynchronously return a DatasetResource type.
type DatasetResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*DatasetResourceResponse, error)

	// Poller contains an initialized poller.
	Poller DatasetResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetResourceResponse is the response envelope for operations that return a DatasetResource type.
type DatasetResourceResponse struct {
	// Dataset resource type.
	DatasetResource *DatasetResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Columns that define the physical type schema of the dataset.
type DatasetSchemaDataElement struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Name of the schema column. Type: string (or Expression with resultType string).
	Name *interface{} `json:"name,omitempty"`

	// Type of the schema column. Type: string (or Expression with resultType string).
	Type *interface{} `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetSchemaDataElement.
func (d DatasetSchemaDataElement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.Name != nil {
		objectMap["name"] = d.Name
	}
	if d.Type != nil {
		objectMap["type"] = d.Type
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetSchemaDataElement.
func (d *DatasetSchemaDataElement) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &d.Name)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatasetStorageFormatClassification provides polymorphic access to related types.
// Call the interface's GetDatasetStorageFormat() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DatasetStorageFormat, *AvroFormat, *JsonFormat, *OrcFormat, *ParquetFormat, *TextFormat
type DatasetStorageFormatClassification interface {
	// GetDatasetStorageFormat() returns the DatasetStorageFormat content of the underlying type.
	GetDatasetStorageFormat() *DatasetStorageFormat
}

// The format definition of a storage.
type DatasetStorageFormat struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Deserializer. Type: string (or Expression with resultType string).
	Deserializer *interface{} `json:"deserializer,omitempty"`

	// Serializer. Type: string (or Expression with resultType string).
	Serializer *interface{} `json:"serializer,omitempty"`

	// Type of dataset storage format.
	Type *string `json:"type,omitempty"`
}

// GetDatasetStorageFormat implements the DatasetStorageFormatClassification interface for type DatasetStorageFormat.
func (d *DatasetStorageFormat) GetDatasetStorageFormat() *DatasetStorageFormat { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetStorageFormat.
func (d *DatasetStorageFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DatasetStorageFormat) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.Deserializer != nil {
		objectMap["deserializer"] = d.Deserializer
	}
	if d.Serializer != nil {
		objectMap["serializer"] = d.Serializer
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (d *DatasetStorageFormat) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "deserializer":
			if val != nil {
				err = json.Unmarshal(*val, &d.Deserializer)
			}
			delete(rawMsg, key)
		case "serializer":
			if val != nil {
				err = json.Unmarshal(*val, &d.Serializer)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The ZipDeflate compression method used on a dataset.
type DatasetZipDeflateCompression struct {
	DatasetCompression
	// The ZipDeflate compression level.
	Level *DatasetCompressionLevel `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetZipDeflateCompression.
func (d DatasetZipDeflateCompression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("ZipDeflate")
	if d.Level != nil {
		objectMap["level"] = d.Level
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetZipDeflateCompression.
func (d *DatasetZipDeflateCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			if val != nil {
				err = json.Unmarshal(*val, &d.Level)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.DatasetCompression.unmarshalInternal(rawMsg)
}

// DatasetsRenameOptions contains the optional parameters for the Datasets.Rename method.
type DatasetsRenameOptions struct {
	// placeholder for future optional parameters
}

// Linked service for DB2 data source.
type Db2LinkedService struct {
	LinkedService
	// DB2 linked service properties.
	TypeProperties *Db2LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Db2LinkedService.
func (d Db2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("Db2")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedService.
func (d *Db2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.LinkedService.unmarshalInternal(rawMsg)
}

// DB2 linked service properties.
type Db2LinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *Db2AuthenticationType `json:"authenticationType,omitempty"`

	// Certificate Common Name when TLS is enabled. Type: string (or Expression with resultType string).
	CertificateCommonName *interface{} `json:"certificateCommonName,omitempty"`

	// Database name for connection. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Under where packages are created when querying database. Type: string (or Expression with resultType string).
	PackageCollection *interface{} `json:"packageCollection,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedServiceTypeProperties.
func (d *Db2LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &d.AuthenticationType)
			}
			delete(rawMsg, key)
		case "certificateCommonName":
			if val != nil {
				err = json.Unmarshal(*val, &d.CertificateCommonName)
			}
			delete(rawMsg, key)
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &d.Database)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "packageCollection":
			if val != nil {
				err = json.Unmarshal(*val, &d.PackageCollection)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				d.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &d.Server)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &d.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for Db2 databases.
type Db2Source struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Db2Source.
func (d Db2Source) MarshalJSON() ([]byte, error) {
	objectMap := d.TabularSource.marshalInternal("Db2Source")
	if d.Query != nil {
		objectMap["query"] = d.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2Source.
func (d *Db2Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &d.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.TabularSource.unmarshalInternal(rawMsg)
}

// The Db2 table dataset.
type Db2TableDataset struct {
	Dataset
	// Db2 table dataset properties.
	TypeProperties *Db2TableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Db2TableDataset.
func (d Db2TableDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("Db2Table")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2TableDataset.
func (d *Db2TableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// Db2 table dataset properties.
type Db2TableDatasetTypeProperties struct {
	// The Db2 schema name. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The Db2 table name. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Delete activity.
type DeleteActivity struct {
	ExecutionActivity
	// Delete activity properties.
	TypeProperties *DeleteActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeleteActivity.
func (d DeleteActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("Delete")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteActivity.
func (d *DeleteActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Delete activity properties.
type DeleteActivityTypeProperties struct {
	// Delete activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Whether to record detailed logs of delete-activity execution. Default value is false. Type: boolean (or Expression with resultType boolean).
	EnableLogging *interface{} `json:"enableLogging,omitempty"`

	// Log storage settings customer need to provide when enableLogging is true.
	LogStorageSettings *LogStorageSettings `json:"logStorageSettings,omitempty"`

	// The max concurrent connections to connect data source at the same time.
	MaxConcurrentConnections *int32 `json:"maxConcurrentConnections,omitempty"`

	// If true, files or sub-folders under current folder path will be deleted recursively. Default is false. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`
}

// Request body structure for deleting data flow debug session.
type DeleteDataFlowDebugSessionRequest struct {
	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// Delimited text dataset.
type DelimitedTextDataset struct {
	Dataset
	// Delimited text dataset properties.
	TypeProperties *DelimitedTextDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextDataset.
func (d DelimitedTextDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DelimitedText")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDataset.
func (d *DelimitedTextDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// DelimitedText dataset properties.
type DelimitedTextDatasetTypeProperties struct {
	// The column delimiter. Type: string (or Expression with resultType string).
	ColumnDelimiter  *interface{}                   `json:"columnDelimiter,omitempty"`
	CompressionCodec *DelimitedTextCompressionCodec `json:"compressionCodec,omitempty"`

	// The data compression method used for DelimitedText.
	CompressionLevel *DatasetCompressionLevel `json:"compressionLevel,omitempty"`

	// The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the name column
	// of the table in the following link to set
	// supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
	EncodingName *interface{} `json:"encodingName,omitempty"`

	// The escape character. Type: string (or Expression with resultType string).
	EscapeChar *interface{} `json:"escapeChar,omitempty"`

	// When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default
	// value is false. Type: boolean (or Expression
	// with resultType boolean).
	FirstRowAsHeader *interface{} `json:"firstRowAsHeader,omitempty"`

	// The location of the delimited text storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue *interface{} `json:"nullValue,omitempty"`

	// The quote character. Type: string (or Expression with resultType string).
	QuoteChar *interface{} `json:"quoteChar,omitempty"`

	// The row delimiter. Type: string (or Expression with resultType string).
	RowDelimiter *interface{} `json:"rowDelimiter,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDatasetTypeProperties.
func (d *DelimitedTextDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			if val != nil {
				err = json.Unmarshal(*val, &d.ColumnDelimiter)
			}
			delete(rawMsg, key)
		case "compressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &d.CompressionCodec)
			}
			delete(rawMsg, key)
		case "compressionLevel":
			if val != nil {
				err = json.Unmarshal(*val, &d.CompressionLevel)
			}
			delete(rawMsg, key)
		case "encodingName":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncodingName)
			}
			delete(rawMsg, key)
		case "escapeChar":
			if val != nil {
				err = json.Unmarshal(*val, &d.EscapeChar)
			}
			delete(rawMsg, key)
		case "firstRowAsHeader":
			if val != nil {
				err = json.Unmarshal(*val, &d.FirstRowAsHeader)
			}
			delete(rawMsg, key)
		case "location":
			if val != nil {
				d.Location, err = unmarshalDatasetLocationClassification(*val)
			}
			delete(rawMsg, key)
		case "nullValue":
			if val != nil {
				err = json.Unmarshal(*val, &d.NullValue)
			}
			delete(rawMsg, key)
		case "quoteChar":
			if val != nil {
				err = json.Unmarshal(*val, &d.QuoteChar)
			}
			delete(rawMsg, key)
		case "rowDelimiter":
			if val != nil {
				err = json.Unmarshal(*val, &d.RowDelimiter)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Delimited text read settings.
type DelimitedTextReadSettings struct {
	FormatReadSettings
	// Indicates the number of non-empty rows to skip when reading data from input files. Type: integer (or Expression with resultType integer).
	SkipLineCount *interface{} `json:"skipLineCount,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextReadSettings.
func (d DelimitedTextReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := d.FormatReadSettings.marshalInternal("DelimitedTextReadSettings")
	if d.SkipLineCount != nil {
		objectMap["skipLineCount"] = d.SkipLineCount
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextReadSettings.
func (d *DelimitedTextReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "skipLineCount":
			if val != nil {
				err = json.Unmarshal(*val, &d.SkipLineCount)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.FormatReadSettings.unmarshalInternal(rawMsg)
}

// A copy activity DelimitedText sink.
type DelimitedTextSink struct {
	CopySink
	// DelimitedText format settings.
	FormatSettings *DelimitedTextWriteSettings `json:"formatSettings,omitempty"`

	// DelimitedText store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextSink.
func (d DelimitedTextSink) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySink.marshalInternal("DelimitedTextSink")
	if d.FormatSettings != nil {
		objectMap["formatSettings"] = d.FormatSettings
	}
	if d.StoreSettings != nil {
		objectMap["storeSettings"] = d.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextSink.
func (d *DelimitedTextSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "formatSettings":
			if val != nil {
				err = json.Unmarshal(*val, &d.FormatSettings)
			}
			delete(rawMsg, key)
		case "storeSettings":
			if val != nil {
				d.StoreSettings, err = unmarshalStoreWriteSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity DelimitedText source.
type DelimitedTextSource struct {
	CopySource
	// DelimitedText format settings.
	FormatSettings *DelimitedTextReadSettings `json:"formatSettings,omitempty"`

	// DelimitedText store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextSource.
func (d DelimitedTextSource) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySource.marshalInternal("DelimitedTextSource")
	if d.FormatSettings != nil {
		objectMap["formatSettings"] = d.FormatSettings
	}
	if d.StoreSettings != nil {
		objectMap["storeSettings"] = d.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextSource.
func (d *DelimitedTextSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "formatSettings":
			if val != nil {
				err = json.Unmarshal(*val, &d.FormatSettings)
			}
			delete(rawMsg, key)
		case "storeSettings":
			if val != nil {
				d.StoreSettings, err = unmarshalStoreReadSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySource.unmarshalInternal(rawMsg)
}

// Delimited text write settings.
type DelimitedTextWriteSettings struct {
	FormatWriteSettings
	// The file extension used to create the files. Type: string (or Expression with resultType string).
	FileExtension *interface{} `json:"fileExtension,omitempty"`

	// Indicates whether string values should always be enclosed with quotes. Type: boolean (or Expression with resultType boolean).
	QuoteAllText *interface{} `json:"quoteAllText,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextWriteSettings.
func (d DelimitedTextWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := d.FormatWriteSettings.marshalInternal("DelimitedTextWriteSettings")
	if d.FileExtension != nil {
		objectMap["fileExtension"] = d.FileExtension
	}
	if d.QuoteAllText != nil {
		objectMap["quoteAllText"] = d.QuoteAllText
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextWriteSettings.
func (d *DelimitedTextWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileExtension":
			if val != nil {
				err = json.Unmarshal(*val, &d.FileExtension)
			}
			delete(rawMsg, key)
		case "quoteAllText":
			if val != nil {
				err = json.Unmarshal(*val, &d.QuoteAllText)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.FormatWriteSettings.unmarshalInternal(rawMsg)
}

// DependencyReferenceClassification provides polymorphic access to related types.
// Call the interface's GetDependencyReference() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DependencyReference, *SelfDependencyTumblingWindowTriggerReference, *TriggerDependencyReference, *TumblingWindowTriggerDependencyReference
type DependencyReferenceClassification interface {
	// GetDependencyReference() returns the DependencyReference content of the underlying type.
	GetDependencyReference() *DependencyReference
}

// Referenced dependency.
type DependencyReference struct {
	// The type of dependency reference.
	Type *string `json:"type,omitempty"`
}

// GetDependencyReference implements the DependencyReferenceClassification interface for type DependencyReference.
func (d *DependencyReference) GetDependencyReference() *DependencyReference { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DependencyReference.
func (d *DependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DependencyReference) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	d.Type = &discValue
	objectMap["type"] = d.Type
	return objectMap
}

func (d *DependencyReference) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Distcp settings.
type DistcpSettings struct {
	// Specifies the Distcp options. Type: string (or Expression with resultType string).
	DistcpOptions *interface{} `json:"distcpOptions,omitempty"`

	// Specifies the Yarn ResourceManager endpoint. Type: string (or Expression with resultType string).
	ResourceManagerEndpoint *interface{} `json:"resourceManagerEndpoint,omitempty"`

	// Specifies an existing folder path which will be used to store temp Distcp command script. The script file is generated by ADF and will be removed after
	// Copy job finished. Type: string (or Expression
	// with resultType string).
	TempScriptPath *interface{} `json:"tempScriptPath,omitempty"`
}

// Microsoft Azure Document Database Collection dataset.
type DocumentDbCollectionDataset struct {
	Dataset
	// DocumentDB Collection dataset properties.
	TypeProperties *DocumentDbCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionDataset.
func (d DocumentDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DocumentDbCollection")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionDataset.
func (d *DocumentDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// DocumentDB Collection dataset properties.
type DocumentDbCollectionDatasetTypeProperties struct {
	// Document Database collection name. Type: string (or Expression with resultType string).
	CollectionName *interface{} `json:"collectionName,omitempty"`
}

// A copy activity Document Database Collection sink.
type DocumentDbCollectionSink struct {
	CopySink
	// Nested properties separator. Default is . (dot). Type: string (or Expression with resultType string).
	NestingSeparator *interface{} `json:"nestingSeparator,omitempty"`

	// Describes how to write data to Azure Cosmos DB. Type: string (or Expression with resultType string). Allowed values: insert and upsert.
	WriteBehavior *interface{} `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionSink.
func (d DocumentDbCollectionSink) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySink.marshalInternal("DocumentDbCollectionSink")
	if d.NestingSeparator != nil {
		objectMap["nestingSeparator"] = d.NestingSeparator
	}
	if d.WriteBehavior != nil {
		objectMap["writeBehavior"] = d.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionSink.
func (d *DocumentDbCollectionSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nestingSeparator":
			if val != nil {
				err = json.Unmarshal(*val, &d.NestingSeparator)
			}
			delete(rawMsg, key)
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &d.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Document Database Collection source.
type DocumentDbCollectionSource struct {
	CopySource
	// Nested properties separator. Type: string (or Expression with resultType string).
	NestingSeparator *interface{} `json:"nestingSeparator,omitempty"`

	// Documents query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout *interface{} `json:"queryTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionSource.
func (d DocumentDbCollectionSource) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySource.marshalInternal("DocumentDbCollectionSource")
	if d.NestingSeparator != nil {
		objectMap["nestingSeparator"] = d.NestingSeparator
	}
	if d.Query != nil {
		objectMap["query"] = d.Query
	}
	if d.QueryTimeout != nil {
		objectMap["queryTimeout"] = d.QueryTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionSource.
func (d *DocumentDbCollectionSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nestingSeparator":
			if val != nil {
				err = json.Unmarshal(*val, &d.NestingSeparator)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &d.Query)
			}
			delete(rawMsg, key)
		case "queryTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &d.QueryTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySource.unmarshalInternal(rawMsg)
}

// Drill Dataset Properties
type DrillDatasetTypeProperties struct {
	// The schema name of the Drill. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Drill. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Drill server linked service.
type DrillLinkedService struct {
	LinkedService
	// Drill server linked service properties.
	TypeProperties *DrillLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DrillLinkedService.
func (d DrillLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("Drill")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillLinkedService.
func (d *DrillLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.LinkedService.unmarshalInternal(rawMsg)
}

// Drill server linked service properties.
type DrillLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// A copy activity Drill server source.
type DrillSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DrillSource.
func (d DrillSource) MarshalJSON() ([]byte, error) {
	objectMap := d.TabularSource.marshalInternal("DrillSource")
	if d.Query != nil {
		objectMap["query"] = d.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillSource.
func (d *DrillSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &d.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.TabularSource.unmarshalInternal(rawMsg)
}

// Drill server dataset.
type DrillTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *DrillDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DrillTableDataset.
func (d DrillTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DrillTable")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillTableDataset.
func (d *DrillTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// Default value.
type DwCopyCommandDefaultValue struct {
	// Column name. Type: object (or Expression with resultType string).
	ColumnName *interface{} `json:"columnName,omitempty"`

	// The default value of the column. Type: object (or Expression with resultType string).
	DefaultValue *interface{} `json:"defaultValue,omitempty"`
}

// DW Copy Command settings.
type DwCopyCommandSettings struct {
	// Additional options directly passed to SQL DW in Copy Command. Type: key value pairs (value should be string type) (or Expression with resultType object).
	// Example: "additionalOptions": { "MAXERRORS":
	// "1000", "DATEFORMAT": "'ymd'" }
	AdditionalOptions *map[string]string `json:"additionalOptions,omitempty"`

	// Specifies the default values for each target column in SQL DW. The default values in the property overwrite the DEFAULT constraint set in the DB, and
	// identity column cannot have a default value. Type:
	// array of objects (or Expression with resultType array of objects).
	DefaultValues *[]DwCopyCommandDefaultValue `json:"defaultValues,omitempty"`
}

// Dynamics AX linked service.
type DynamicsAxLinkedService struct {
	LinkedService
	// Dynamics AX linked service properties.
	TypeProperties *DynamicsAxLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAxLinkedService.
func (d DynamicsAxLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("DynamicsAX")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxLinkedService.
func (d *DynamicsAxLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.LinkedService.unmarshalInternal(rawMsg)
}

// Dynamics AX linked service properties.
type DynamicsAxLinkedServiceTypeProperties struct {
	// Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
	AadResourceID *interface{} `json:"aadResourceId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specify the application's client ID. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference a secret stored in Azure Key Vault.
	// Type: string (or Expression with resultType
	// string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by hovering the mouse in the top-right corner
	// of the Azure portal. Type: string (or
	// Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
	URL *interface{} `json:"url,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxLinkedServiceTypeProperties.
func (d *DynamicsAxLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			if val != nil {
				err = json.Unmarshal(*val, &d.AadResourceID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				d.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &d.Tenant)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &d.URL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The path of the Dynamics AX OData entity.
type DynamicsAxResourceDataset struct {
	Dataset
	// Dynamics AX OData resource dataset properties.
	TypeProperties *DynamicsAxResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAxResourceDataset.
func (d DynamicsAxResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DynamicsAXResource")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxResourceDataset.
func (d *DynamicsAxResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// Dynamics AX OData resource dataset properties.
type DynamicsAxResourceDatasetTypeProperties struct {
	// The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// A copy activity Dynamics AX source.
type DynamicsAxSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAxSource.
func (d DynamicsAxSource) MarshalJSON() ([]byte, error) {
	objectMap := d.TabularSource.marshalInternal("DynamicsAXSource")
	if d.Query != nil {
		objectMap["query"] = d.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxSource.
func (d *DynamicsAxSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &d.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.TabularSource.unmarshalInternal(rawMsg)
}

// The Dynamics CRM entity dataset.
type DynamicsCrmEntityDataset struct {
	Dataset
	// Dynamics CRM entity dataset properties.
	TypeProperties *DynamicsCrmEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmEntityDataset.
func (d DynamicsCrmEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DynamicsCrmEntity")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmEntityDataset.
func (d *DynamicsCrmEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// Dynamics CRM entity dataset properties.
type DynamicsCrmEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName *interface{} `json:"entityName,omitempty"`
}

// Dynamics CRM linked service.
type DynamicsCrmLinkedService struct {
	LinkedService
	// Dynamics CRM linked service properties.
	TypeProperties *DynamicsCrmLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmLinkedService.
func (d DynamicsCrmLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("DynamicsCrm")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedService.
func (d *DynamicsCrmLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.LinkedService.unmarshalInternal(rawMsg)
}

// Dynamics CRM linked service properties.
type DynamicsCrmLinkedServiceTypeProperties struct {
	// The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal'
	// for Server-To-Server authentication in online
	// scenario. Type: string (or Expression with resultType string).
	AuthenticationType *DynamicsAuthenticationType `json:"authenticationType,omitempty"`

	// The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics CRM on-premises with Ifd. Type:
	// string (or Expression with resultType string).
	DeploymentType *DynamicsDeploymentType `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Type: string (or Expression with
	// resultType string).
	HostName *interface{} `json:"hostName,omitempty"`

	// The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there are more than one Dynamics
	// CRM instances associated with the user. Type:
	// string (or Expression with resultType string).
	OrganizationName *interface{} `json:"organizationName,omitempty"`

	// Password to access the Dynamics CRM instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression
	// with resultType integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential
	// can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate.
	// Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType *DynamicsServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType
	// string).
	ServiceURI *interface{} `json:"serviceUri,omitempty"`

	// User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedServiceTypeProperties.
func (d *DynamicsCrmLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &d.AuthenticationType)
			}
			delete(rawMsg, key)
		case "deploymentType":
			if val != nil {
				err = json.Unmarshal(*val, &d.DeploymentType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "hostName":
			if val != nil {
				err = json.Unmarshal(*val, &d.HostName)
			}
			delete(rawMsg, key)
		case "organizationName":
			if val != nil {
				err = json.Unmarshal(*val, &d.OrganizationName)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				d.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &d.Port)
			}
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			if val != nil {
				d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalCredentialType)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "serviceUri":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServiceURI)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &d.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Dynamics CRM sink.
type DynamicsCrmSink struct {
	CopySink
	// The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
	AlternateKeyName *interface{} `json:"alternateKeyName,omitempty"`

	// The flag indicating whether to ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or
	// Expression with resultType boolean).
	IgnoreNullValues *interface{} `json:"ignoreNullValues,omitempty"`

	// The write behavior for the operation.
	WriteBehavior *DynamicsSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmSink.
func (d DynamicsCrmSink) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySink.marshalInternal("DynamicsCrmSink")
	if d.AlternateKeyName != nil {
		objectMap["alternateKeyName"] = d.AlternateKeyName
	}
	if d.IgnoreNullValues != nil {
		objectMap["ignoreNullValues"] = d.IgnoreNullValues
	}
	if d.WriteBehavior != nil {
		objectMap["writeBehavior"] = d.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmSink.
func (d *DynamicsCrmSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			if val != nil {
				err = json.Unmarshal(*val, &d.AlternateKeyName)
			}
			delete(rawMsg, key)
		case "ignoreNullValues":
			if val != nil {
				err = json.Unmarshal(*val, &d.IgnoreNullValues)
			}
			delete(rawMsg, key)
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &d.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Dynamics CRM source.
type DynamicsCrmSource struct {
	CopySource
	// FetchXML is a proprietary query language that is used in Microsoft Dynamics CRM (online & on-premises). Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmSource.
func (d DynamicsCrmSource) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySource.marshalInternal("DynamicsCrmSource")
	if d.Query != nil {
		objectMap["query"] = d.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmSource.
func (d *DynamicsCrmSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &d.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySource.unmarshalInternal(rawMsg)
}

// The Dynamics entity dataset.
type DynamicsEntityDataset struct {
	Dataset
	// Dynamics entity dataset properties.
	TypeProperties *DynamicsEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsEntityDataset.
func (d DynamicsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DynamicsEntity")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsEntityDataset.
func (d *DynamicsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.Dataset.unmarshalInternal(rawMsg)
}

// Dynamics entity dataset properties.
type DynamicsEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName *interface{} `json:"entityName,omitempty"`
}

// Dynamics linked service.
type DynamicsLinkedService struct {
	LinkedService
	// Dynamics linked service properties.
	TypeProperties *DynamicsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsLinkedService.
func (d DynamicsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("Dynamics")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedService.
func (d *DynamicsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.LinkedService.unmarshalInternal(rawMsg)
}

// Dynamics linked service properties.
type DynamicsLinkedServiceTypeProperties struct {
	// The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal'
	// for Server-To-Server authentication in online
	// scenario. Type: string (or Expression with resultType string).
	AuthenticationType *DynamicsAuthenticationType `json:"authenticationType,omitempty"`

	// The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises with Ifd. Type: string (or
	// Expression with resultType string).
	DeploymentType *DynamicsDeploymentType `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type: string (or Expression with resultType
	// string).
	HostName *string `json:"hostName,omitempty"`

	// The organization name of the Dynamics instance. The property is required for on-prem and required for online when there are more than one Dynamics instances
	// associated with the user. Type: string (or
	// Expression with resultType string).
	OrganizationName *string `json:"organizationName,omitempty"`

	// Password to access the Dynamics instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443. Type: integer (or Expression
	// with resultType integer), minimum: 0.
	Port *string `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey', servicePrincipalCredential
	// can be SecureString or
	// AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret, 'ServicePrincipalCert' for certificate.
	// Type: string (or Expression with
	// resultType string).
	ServicePrincipalCredentialType *DynamicsServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string (or Expression with resultType
	// string).
	ServiceURI *string `json:"serviceUri,omitempty"`

	// User name to access the Dynamics instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedServiceTypeProperties.
func (d *DynamicsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &d.AuthenticationType)
			}
			delete(rawMsg, key)
		case "deploymentType":
			if val != nil {
				err = json.Unmarshal(*val, &d.DeploymentType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "hostName":
			if val != nil {
				err = json.Unmarshal(*val, &d.HostName)
			}
			delete(rawMsg, key)
		case "organizationName":
			if val != nil {
				err = json.Unmarshal(*val, &d.OrganizationName)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				d.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &d.Port)
			}
			delete(rawMsg, key)
		case "servicePrincipalCredential":
			if val != nil {
				d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalCredentialType)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "serviceUri":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServiceURI)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &d.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Dynamics sink.
type DynamicsSink struct {
	CopySink
	// The logical name of the alternate key which will be used when upserting records. Type: string (or Expression with resultType string).
	AlternateKeyName *interface{} `json:"alternateKeyName,omitempty"`

	// The flag indicating whether ignore null values from input dataset (except key fields) during write operation. Default is false. Type: boolean (or Expression
	// with resultType boolean).
	IgnoreNullValues *interface{} `json:"ignoreNullValues,omitempty"`

	// The write behavior for the operation.
	WriteBehavior *DynamicsSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsSink.
func (d DynamicsSink) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySink.marshalInternal("DynamicsSink")
	if d.AlternateKeyName != nil {
		objectMap["alternateKeyName"] = d.AlternateKeyName
	}
	if d.IgnoreNullValues != nil {
		objectMap["ignoreNullValues"] = d.IgnoreNullValues
	}
	if d.WriteBehavior != nil {
		objectMap["writeBehavior"] = d.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsSink.
func (d *DynamicsSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alternateKeyName":
			if val != nil {
				err = json.Unmarshal(*val, &d.AlternateKeyName)
			}
			delete(rawMsg, key)
		case "ignoreNullValues":
			if val != nil {
				err = json.Unmarshal(*val, &d.IgnoreNullValues)
			}
			delete(rawMsg, key)
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &d.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Dynamics source.
type DynamicsSource struct {
	CopySource
	// FetchXML is a proprietary query language that is used in Microsoft Dynamics (online & on-premises). Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsSource.
func (d DynamicsSource) MarshalJSON() ([]byte, error) {
	objectMap := d.CopySource.marshalInternal("DynamicsSource")
	if d.Query != nil {
		objectMap["query"] = d.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsSource.
func (d *DynamicsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &d.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return d.CopySource.unmarshalInternal(rawMsg)
}

// Eloqua server linked service.
type EloquaLinkedService struct {
	LinkedService
	// Eloqua server linked service properties.
	TypeProperties *EloquaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EloquaLinkedService.
func (e EloquaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := e.LinkedService.marshalInternal("Eloqua")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedService.
func (e *EloquaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.LinkedService.unmarshalInternal(rawMsg)
}

// Eloqua server linked service properties.
type EloquaLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Eloqua server. (i.e. eloqua.example.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedServiceTypeProperties.
func (e *EloquaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &e.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &e.Endpoint)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				e.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &e.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &e.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &e.UsePeerVerification)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &e.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Eloqua server dataset.
type EloquaObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EloquaObjectDataset.
func (e EloquaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := e.Dataset.marshalInternal("EloquaObject")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaObjectDataset.
func (e *EloquaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Eloqua server source.
type EloquaSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EloquaSource.
func (e EloquaSource) MarshalJSON() ([]byte, error) {
	objectMap := e.TabularSource.marshalInternal("EloquaSource")
	if e.Query != nil {
		objectMap["query"] = e.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaSource.
func (e *EloquaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &e.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.TabularSource.unmarshalInternal(rawMsg)
}

// Details of the encryption associated with the workspace
type EncryptionDetails struct {
	// Customer Managed Key Details
	Cmk *CustomerManagedKeyDetails `json:"cmk,omitempty"`

	// Double Encryption enabled
	DoubleEncryptionEnabled *bool `json:"doubleEncryptionEnabled,omitempty" azure:"ro"`
}

// The entity reference.
type EntityReference struct {
	// The name of this referenced entity.
	ReferenceName *string `json:"referenceName,omitempty"`

	// The type of this referenced entity.
	Type *IntegrationRuntimeEntityReferenceType `json:"type,omitempty"`
}

// The resource management error additional info.
type ErrorAdditionalInfo struct {
	// The additional info.
	Info *interface{} `json:"info,omitempty" azure:"ro"`

	// The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// Contains details when the response code indicates an error.
type ErrorContract struct {
	// The error details.
	InnerError *ErrorResponse `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorContract.
func (e ErrorContract) Error() string {
	msg := ""
	if e.InnerError != nil {
		msg += fmt.Sprintf("InnerError: %v\n", *e.InnerError)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response
// format.)
type ErrorResponse struct {
	// The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// The error details.
	Details *[]ErrorResponse `json:"details,omitempty" azure:"ro"`

	// The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// Request body structure for data flow expression preview.
type EvaluateDataFlowExpressionRequest struct {
	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The expression for preview.
	Expression *string `json:"expression,omitempty"`

	// The row limit for preview request.
	RowLimits *int32 `json:"rowLimits,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The output stream name.
	StreamName *string `json:"streamName,omitempty"`
}

// Execute data flow activity.
type ExecuteDataFlowActivity struct {
	ExecutionActivity
	// Execute data flow activity properties.
	TypeProperties *ExecuteDataFlowActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteDataFlowActivity.
func (e ExecuteDataFlowActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.ExecutionActivity.marshalInternal("ExecuteDataFlow")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteDataFlowActivity.
func (e *ExecuteDataFlowActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Execute data flow activity properties.
type ExecuteDataFlowActivityTypeProperties struct {
	// Compute properties for data flow activity.
	Compute *ExecuteDataFlowActivityTypePropertiesCompute `json:"compute,omitempty"`

	// Data flow reference.
	DataFlow *DataFlowReference `json:"dataFlow,omitempty"`

	// The integration runtime reference.
	IntegrationRuntime *IntegrationRuntimeReference `json:"integrationRuntime,omitempty"`

	// Staging info for execute data flow activity.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`
}

// Compute properties for data flow activity.
type ExecuteDataFlowActivityTypePropertiesCompute struct {
	// Compute type of the cluster which will execute data flow job.
	ComputeType *DataFlowComputeType `json:"computeType,omitempty"`

	// Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
	CoreCount *int32 `json:"coreCount,omitempty"`
}

// Execute pipeline activity.
type ExecutePipelineActivity struct {
	Activity
	// Execute pipeline activity properties.
	TypeProperties *ExecutePipelineActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivity.
func (e ExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.Activity.marshalInternal("ExecutePipeline")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePipelineActivity.
func (e *ExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.Activity.unmarshalInternal(rawMsg)
}

// Execute pipeline activity properties.
type ExecutePipelineActivityTypeProperties struct {
	// Pipeline parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Pipeline reference.
	Pipeline *PipelineReference `json:"pipeline,omitempty"`

	// Defines whether activity execution will wait for the dependent pipeline execution to finish. Default is false.
	WaitOnCompletion *bool `json:"waitOnCompletion,omitempty"`
}

// Execute SSIS package activity.
type ExecuteSsisPackageActivity struct {
	ExecutionActivity
	// Execute SSIS package activity properties.
	TypeProperties *ExecuteSsisPackageActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteSsisPackageActivity.
func (e ExecuteSsisPackageActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.ExecutionActivity.marshalInternal("ExecuteSSISPackage")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteSsisPackageActivity.
func (e *ExecuteSsisPackageActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Execute SSIS package activity properties.
type ExecuteSsisPackageActivityTypeProperties struct {
	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// The environment path to execute the SSIS package. Type: string (or Expression with resultType string).
	EnvironmentPath *interface{} `json:"environmentPath,omitempty"`

	// The package execution credential.
	ExecutionCredential *SsisExecutionCredential `json:"executionCredential,omitempty"`

	// SSIS package execution log location.
	LogLocation *SsisLogLocation `json:"logLocation,omitempty"`

	// The logging level of SSIS package execution. Type: string (or Expression with resultType string).
	LoggingLevel *interface{} `json:"loggingLevel,omitempty"`

	// The package level connection managers to execute the SSIS package.
	PackageConnectionManagers *map[string]interface{} `json:"packageConnectionManagers,omitempty"`

	// SSIS package location.
	PackageLocation *SsisPackageLocation `json:"packageLocation,omitempty"`

	// The package level parameters to execute the SSIS package.
	PackageParameters *map[string]SsisExecutionParameter `json:"packageParameters,omitempty"`

	// The project level connection managers to execute the SSIS package.
	ProjectConnectionManagers *map[string]interface{} `json:"projectConnectionManagers,omitempty"`

	// The project level parameters to execute the SSIS package.
	ProjectParameters *map[string]SsisExecutionParameter `json:"projectParameters,omitempty"`

	// The property overrides to execute the SSIS package.
	PropertyOverrides *map[string]SsisPropertyOverride `json:"propertyOverrides,omitempty"`

	// Specifies the runtime to execute SSIS package. The value should be "x86" or "x64". Type: string (or Expression with resultType string).
	Runtime *interface{} `json:"runtime,omitempty"`
}

// ExecutionActivityClassification provides polymorphic access to related types.
// Call the interface's GetExecutionActivity() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ExecutionActivity, *AzureDataExplorerCommandActivity, *AzureFunctionActivity, *AzureMLBatchExecutionActivity, *AzureMLExecutePipelineActivity,
// - *AzureMLUpdateResourceActivity, *CopyActivity, *CustomActivity, *DataLakeAnalyticsUsqlActivity, *DatabricksNotebookActivity,
// - *DatabricksSparkJarActivity, *DatabricksSparkPythonActivity, *DeleteActivity, *ExecuteDataFlowActivity, *ExecuteSsisPackageActivity,
// - *GetMetadataActivity, *HDInsightHiveActivity, *HDInsightMapReduceActivity, *HDInsightPigActivity, *HDInsightSparkActivity,
// - *HDInsightStreamingActivity, *LookupActivity, *SqlServerStoredProcedureActivity, *WebActivity
type ExecutionActivityClassification interface {
	ActivityClassification
	// GetExecutionActivity() returns the ExecutionActivity content of the underlying type.
	GetExecutionActivity() *ExecutionActivity
}

// Base class for all execution activities.
type ExecutionActivity struct {
	Activity
	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type ExecutionActivity.
func (e *ExecutionActivity) GetExecutionActivity() *ExecutionActivity { return e }

// MarshalJSON implements the json.Marshaller interface for type ExecutionActivity.
func (e ExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.marshalInternal("Execution")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutionActivity.
func (e *ExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return e.unmarshalInternal(rawMsg)
}

func (e ExecutionActivity) marshalInternal(discValue string) map[string]interface{} {
	objectMap := e.Activity.marshalInternal(discValue)
	if e.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = e.LinkedServiceName
	}
	if e.Policy != nil {
		objectMap["policy"] = e.Policy
	}
	return objectMap
}

func (e *ExecutionActivity) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &e.LinkedServiceName)
			}
			delete(rawMsg, key)
		case "policy":
			if val != nil {
				err = json.Unmarshal(*val, &e.Policy)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return e.Activity.unmarshalInternal(rawMsg)
}

// The exposure control request.
type ExposureControlRequest struct {
	// The feature name.
	FeatureName *string `json:"featureName,omitempty"`

	// The feature type.
	FeatureType *string `json:"featureType,omitempty"`
}

// The exposure control response.
type ExposureControlResponse struct {
	// The feature name.
	FeatureName *string `json:"featureName,omitempty" azure:"ro"`

	// The feature value.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// Azure Synapse expression definition.
type Expression struct {
	// Expression type.
	Type *ExpressionType `json:"type,omitempty"`

	// Expression value.
	Value *string `json:"value,omitempty"`
}

// File system linked service.
type FileServerLinkedService struct {
	LinkedService
	// File system linked service properties.
	TypeProperties *FileServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLinkedService.
func (f FileServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := f.LinkedService.marshalInternal("FileServer")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedService.
func (f *FileServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.LinkedService.unmarshalInternal(rawMsg)
}

// File system linked service properties.
type FileServerLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name of the server. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password to logon the server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User ID to logon the server. Type: string (or Expression with resultType string).
	UserID *interface{} `json:"userId,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedServiceTypeProperties.
func (f *FileServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &f.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &f.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				f.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userId":
			if val != nil {
				err = json.Unmarshal(*val, &f.UserID)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of file server dataset.
type FileServerLocation struct {
	DatasetLocation
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLocation.
func (f FileServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := f.DatasetLocation.marshalInternal("FileServerLocation")
	return json.Marshal(objectMap)
}

// File server read settings.
type FileServerReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// FileServer wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// FileServer wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileServerReadSettings.
func (f FileServerReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := f.StoreReadSettings.marshalInternal("FileServerReadSettings")
	if f.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = f.EnablePartitionDiscovery
	}
	if f.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = f.ModifiedDatetimeEnd
	}
	if f.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = f.ModifiedDatetimeStart
	}
	if f.Recursive != nil {
		objectMap["recursive"] = f.Recursive
	}
	if f.WildcardFileName != nil {
		objectMap["wildcardFileName"] = f.WildcardFileName
	}
	if f.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = f.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerReadSettings.
func (f *FileServerReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &f.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &f.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &f.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &f.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &f.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &f.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.StoreReadSettings.unmarshalInternal(rawMsg)
}

// File server write settings.
type FileServerWriteSettings struct {
	StoreWriteSettings
}

// MarshalJSON implements the json.Marshaller interface for type FileServerWriteSettings.
func (f FileServerWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := f.StoreWriteSettings.marshalInternal("FileServerWriteSettings")
	return json.Marshal(objectMap)
}

// A copy activity file system sink.
type FileSystemSink struct {
	CopySink
	// The type of copy behavior for copy sink.
	CopyBehavior *interface{} `json:"copyBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemSink.
func (f FileSystemSink) MarshalJSON() ([]byte, error) {
	objectMap := f.CopySink.marshalInternal("FileSystemSink")
	if f.CopyBehavior != nil {
		objectMap["copyBehavior"] = f.CopyBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemSink.
func (f *FileSystemSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &f.CopyBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity file system source.
type FileSystemSource struct {
	CopySource
	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileSystemSource.
func (f FileSystemSource) MarshalJSON() ([]byte, error) {
	objectMap := f.CopySource.marshalInternal("FileSystemSource")
	if f.Recursive != nil {
		objectMap["recursive"] = f.Recursive
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileSystemSource.
func (f *FileSystemSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &f.Recursive)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.CopySource.unmarshalInternal(rawMsg)
}

// Filter and return results from input array based on the conditions.
type FilterActivity struct {
	Activity
	// Filter activity properties.
	TypeProperties *FilterActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FilterActivity.
func (f FilterActivity) MarshalJSON() ([]byte, error) {
	objectMap := f.Activity.marshalInternal("Filter")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FilterActivity.
func (f *FilterActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.Activity.unmarshalInternal(rawMsg)
}

// Filter activity properties.
type FilterActivityTypeProperties struct {
	// Condition to be used for filtering the input.
	Condition *Expression `json:"condition,omitempty"`

	// Input array on which filter should be applied.
	Items *Expression `json:"items,omitempty"`
}

// This activity is used for iterating over a collection and execute given activities.
type ForEachActivity struct {
	Activity
	// ForEach activity properties.
	TypeProperties *ForEachActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ForEachActivity.
func (f ForEachActivity) MarshalJSON() ([]byte, error) {
	objectMap := f.Activity.marshalInternal("ForEach")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivity.
func (f *ForEachActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.Activity.unmarshalInternal(rawMsg)
}

// ForEach activity properties.
type ForEachActivityTypeProperties struct {
	// List of activities to execute .
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// Batch count to be used for controlling the number of parallel execution (when isSequential is set to false).
	BatchCount *int32 `json:"batchCount,omitempty"`

	// Should the loop be executed in sequence or in parallel (max 50)
	IsSequential *bool `json:"isSequential,omitempty"`

	// Collection to iterate.
	Items *Expression `json:"items,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivityTypeProperties.
func (f *ForEachActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				f.Activities, err = unmarshalActivityClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "batchCount":
			if val != nil {
				err = json.Unmarshal(*val, &f.BatchCount)
			}
			delete(rawMsg, key)
		case "isSequential":
			if val != nil {
				err = json.Unmarshal(*val, &f.IsSequential)
			}
			delete(rawMsg, key)
		case "items":
			if val != nil {
				err = json.Unmarshal(*val, &f.Items)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FormatReadSettingsClassification provides polymorphic access to related types.
// Call the interface's GetFormatReadSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FormatReadSettings, *DelimitedTextReadSettings
type FormatReadSettingsClassification interface {
	// GetFormatReadSettings() returns the FormatReadSettings content of the underlying type.
	GetFormatReadSettings() *FormatReadSettings
}

// Format read settings.
type FormatReadSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The read setting type.
	Type *string `json:"type,omitempty"`
}

// GetFormatReadSettings implements the FormatReadSettingsClassification interface for type FormatReadSettings.
func (f *FormatReadSettings) GetFormatReadSettings() *FormatReadSettings { return f }

// UnmarshalJSON implements the json.Unmarshaller interface for type FormatReadSettings.
func (f *FormatReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return f.unmarshalInternal(rawMsg)
}

func (f FormatReadSettings) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	f.Type = &discValue
	objectMap["type"] = f.Type
	if f.AdditionalProperties != nil {
		for key, val := range *f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (f *FormatReadSettings) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &f.Type)
			}
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*f.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FormatWriteSettingsClassification provides polymorphic access to related types.
// Call the interface's GetFormatWriteSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FormatWriteSettings, *AvroWriteSettings, *DelimitedTextWriteSettings, *JsonWriteSettings
type FormatWriteSettingsClassification interface {
	// GetFormatWriteSettings() returns the FormatWriteSettings content of the underlying type.
	GetFormatWriteSettings() *FormatWriteSettings
}

// Format write settings.
type FormatWriteSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The write setting type.
	Type *string `json:"type,omitempty"`
}

// GetFormatWriteSettings implements the FormatWriteSettingsClassification interface for type FormatWriteSettings.
func (f *FormatWriteSettings) GetFormatWriteSettings() *FormatWriteSettings { return f }

// UnmarshalJSON implements the json.Unmarshaller interface for type FormatWriteSettings.
func (f *FormatWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return f.unmarshalInternal(rawMsg)
}

func (f FormatWriteSettings) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	f.Type = &discValue
	objectMap["type"] = f.Type
	if f.AdditionalProperties != nil {
		for key, val := range *f.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (f *FormatWriteSettings) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &f.Type)
			}
			delete(rawMsg, key)
		default:
			if f.AdditionalProperties == nil {
				f.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*f.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Ftp read settings.
type FtpReadSettings struct {
	StoreReadSettings
	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Specify whether to use binary transfer mode for FTP stores.
	UseBinaryTransfer *bool `json:"useBinaryTransfer,omitempty"`

	// Ftp wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// Ftp wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FtpReadSettings.
func (f FtpReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := f.StoreReadSettings.marshalInternal("FtpReadSettings")
	if f.Recursive != nil {
		objectMap["recursive"] = f.Recursive
	}
	if f.UseBinaryTransfer != nil {
		objectMap["useBinaryTransfer"] = f.UseBinaryTransfer
	}
	if f.WildcardFileName != nil {
		objectMap["wildcardFileName"] = f.WildcardFileName
	}
	if f.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = f.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpReadSettings.
func (f *FtpReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &f.Recursive)
			}
			delete(rawMsg, key)
		case "useBinaryTransfer":
			if val != nil {
				err = json.Unmarshal(*val, &f.UseBinaryTransfer)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &f.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &f.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.StoreReadSettings.unmarshalInternal(rawMsg)
}

// A FTP server Linked Service.
type FtpServerLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *FtpServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLinkedService.
func (f FtpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := f.LinkedService.marshalInternal("FtpServer")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedService.
func (f *FtpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return f.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to this linked service type.
type FtpServerLinkedServiceTypeProperties struct {
	// The authentication type to be used to connect to the FTP server.
	AuthenticationType *FtpAuthenticationType `json:"authenticationType,omitempty"`

	// If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType
	// boolean).
	EnableServerCertificateValidation *interface{} `json:"enableServerCertificateValidation,omitempty"`

	// If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType boolean).
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name of the FTP server. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password to logon the FTP server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression with resultType integer),
	// minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// Username to logon the FTP server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedServiceTypeProperties.
func (f *FtpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &f.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			if val != nil {
				err = json.Unmarshal(*val, &f.EnableServerCertificateValidation)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &f.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &f.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &f.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				f.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &f.Port)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &f.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of ftp server dataset.
type FtpServerLocation struct {
	DatasetLocation
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLocation.
func (f FtpServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := f.DatasetLocation.marshalInternal("FtpServerLocation")
	return json.Marshal(objectMap)
}

// Properties specific to this dataset type.
type GenericDatasetTypeProperties struct {
	// The table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Activity to get metadata of dataset
type GetMetadataActivity struct {
	ExecutionActivity
	// GetMetadata activity properties.
	TypeProperties *GetMetadataActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetMetadataActivity.
func (g GetMetadataActivity) MarshalJSON() ([]byte, error) {
	objectMap := g.ExecutionActivity.marshalInternal("GetMetadata")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetMetadataActivity.
func (g *GetMetadataActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.ExecutionActivity.unmarshalInternal(rawMsg)
}

// GetMetadata activity properties.
type GetMetadataActivityTypeProperties struct {
	// GetMetadata activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Fields of metadata to get from dataset.
	FieldList *[]interface{} `json:"fieldList,omitempty"`
}

// The request payload of get SSIS object metadata.
type GetSsisObjectMetadataRequest struct {
	// Metadata path.
	MetadataPath *string `json:"metadataPath,omitempty"`
}

// Google AdWords service linked service.
type GoogleAdWordsLinkedService struct {
	LinkedService
	// Google AdWords service linked service properties.
	TypeProperties *GoogleAdWordsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsLinkedService.
func (g GoogleAdWordsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("GoogleAdWords")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedService.
func (g *GoogleAdWordsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.LinkedService.unmarshalInternal(rawMsg)
}

// Google AdWords service linked service properties.
type GoogleAdWordsLinkedServiceTypeProperties struct {
	// The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
	AuthenticationType *GoogleAdWordsAuthenticationType `json:"authenticationType,omitempty"`

	// The Client customer ID of the AdWords account that you want to fetch report data for.
	ClientCustomerID *interface{} `json:"clientCustomerID,omitempty"`

	// The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret of the google application used to acquire the refresh token.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The developer token associated with the manager account that you use to grant access to the AdWords API.
	DeveloperToken SecretBaseClassification `json:"developerToken,omitempty"`

	// The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
	Email *interface{} `json:"email,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
	KeyFilePath *interface{} `json:"keyFilePath,omitempty"`

	// The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedServiceTypeProperties.
func (g *GoogleAdWordsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &g.AuthenticationType)
			}
			delete(rawMsg, key)
		case "clientCustomerID":
			if val != nil {
				err = json.Unmarshal(*val, &g.ClientCustomerID)
			}
			delete(rawMsg, key)
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &g.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				g.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "developerToken":
			if val != nil {
				g.DeveloperToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "email":
			if val != nil {
				err = json.Unmarshal(*val, &g.Email)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &g.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "keyFilePath":
			if val != nil {
				err = json.Unmarshal(*val, &g.KeyFilePath)
			}
			delete(rawMsg, key)
		case "refreshToken":
			if val != nil {
				g.RefreshToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &g.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &g.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Google AdWords service dataset.
type GoogleAdWordsObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsObjectDataset.
func (g GoogleAdWordsObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := g.Dataset.marshalInternal("GoogleAdWordsObject")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsObjectDataset.
func (g *GoogleAdWordsObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Google AdWords service source.
type GoogleAdWordsSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsSource.
func (g GoogleAdWordsSource) MarshalJSON() ([]byte, error) {
	objectMap := g.TabularSource.marshalInternal("GoogleAdWordsSource")
	if g.Query != nil {
		objectMap["query"] = g.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsSource.
func (g *GoogleAdWordsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &g.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.TabularSource.unmarshalInternal(rawMsg)
}

// Google BigQuery Dataset Properties
type GoogleBigQueryDatasetTypeProperties struct {
	// The database name of the Google BigQuery. Type: string (or Expression with resultType string).
	Dataset *interface{} `json:"dataset,omitempty"`

	// The table name of the Google BigQuery. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using database + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Google BigQuery service linked service.
type GoogleBigQueryLinkedService struct {
	LinkedService
	// Google BigQuery service linked service properties.
	TypeProperties *GoogleBigQueryLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryLinkedService.
func (g GoogleBigQueryLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("GoogleBigQuery")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedService.
func (g *GoogleBigQueryLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.LinkedService.unmarshalInternal(rawMsg)
}

// Google BigQuery service linked service properties.
type GoogleBigQueryLinkedServiceTypeProperties struct {
	// A comma-separated list of public BigQuery projects to access.
	AdditionalProjects *interface{} `json:"additionalProjects,omitempty"`

	// The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
	AuthenticationType *GoogleBigQueryAuthenticationType `json:"authenticationType,omitempty"`

	// The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret of the google application used to acquire the refresh token.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
	Email *interface{} `json:"email,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The full path to the .p12 key file that is used to authenticate the service account email address and can only be used on self-hosted IR.
	KeyFilePath *interface{} `json:"keyFilePath,omitempty"`

	// The default BigQuery project to query against.
	Project *interface{} `json:"project,omitempty"`

	// The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine BigQuery data with data from
	// Google Drive. The default value is false.
	RequestGoogleDriveScope *interface{} `json:"requestGoogleDriveScope,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedServiceTypeProperties.
func (g *GoogleBigQueryLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProjects":
			if val != nil {
				err = json.Unmarshal(*val, &g.AdditionalProjects)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &g.AuthenticationType)
			}
			delete(rawMsg, key)
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &g.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				g.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "email":
			if val != nil {
				err = json.Unmarshal(*val, &g.Email)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &g.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "keyFilePath":
			if val != nil {
				err = json.Unmarshal(*val, &g.KeyFilePath)
			}
			delete(rawMsg, key)
		case "project":
			if val != nil {
				err = json.Unmarshal(*val, &g.Project)
			}
			delete(rawMsg, key)
		case "refreshToken":
			if val != nil {
				g.RefreshToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "requestGoogleDriveScope":
			if val != nil {
				err = json.Unmarshal(*val, &g.RequestGoogleDriveScope)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &g.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &g.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Google BigQuery service dataset.
type GoogleBigQueryObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GoogleBigQueryDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryObjectDataset.
func (g GoogleBigQueryObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := g.Dataset.marshalInternal("GoogleBigQueryObject")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryObjectDataset.
func (g *GoogleBigQueryObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Google BigQuery service source.
type GoogleBigQuerySource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQuerySource.
func (g GoogleBigQuerySource) MarshalJSON() ([]byte, error) {
	objectMap := g.TabularSource.marshalInternal("GoogleBigQuerySource")
	if g.Query != nil {
		objectMap["query"] = g.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQuerySource.
func (g *GoogleBigQuerySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &g.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.TabularSource.unmarshalInternal(rawMsg)
}

// Linked service for Google Cloud Storage.
type GoogleCloudStorageLinkedService struct {
	LinkedService
	// Google Cloud Storage linked service properties.
	TypeProperties *GoogleCloudStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLinkedService.
func (g GoogleCloudStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("GoogleCloudStorage")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedService.
func (g *GoogleCloudStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.LinkedService.unmarshalInternal(rawMsg)
}

// Google Cloud Storage linked service properties.
type GoogleCloudStorageLinkedServiceTypeProperties struct {
	// The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
	AccessKeyID *interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change it only if you want to try
	// a different service endpoint or want to switch
	// between https and http. Type: string (or Expression with resultType string).
	ServiceURL *interface{} `json:"serviceUrl,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedServiceTypeProperties.
func (g *GoogleCloudStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			if val != nil {
				err = json.Unmarshal(*val, &g.AccessKeyID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &g.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "secretAccessKey":
			if val != nil {
				g.SecretAccessKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "serviceUrl":
			if val != nil {
				err = json.Unmarshal(*val, &g.ServiceURL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of Google Cloud Storage dataset.
type GoogleCloudStorageLocation struct {
	DatasetLocation
	// Specify the bucketName of Google Cloud Storage. Type: string (or Expression with resultType string)
	BucketName *interface{} `json:"bucketName,omitempty"`

	// Specify the version of Google Cloud Storage. Type: string (or Expression with resultType string).
	Version *interface{} `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLocation.
func (g GoogleCloudStorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := g.DatasetLocation.marshalInternal("GoogleCloudStorageLocation")
	if g.BucketName != nil {
		objectMap["bucketName"] = g.BucketName
	}
	if g.Version != nil {
		objectMap["version"] = g.Version
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLocation.
func (g *GoogleCloudStorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bucketName":
			if val != nil {
				err = json.Unmarshal(*val, &g.BucketName)
			}
			delete(rawMsg, key)
		case "version":
			if val != nil {
				err = json.Unmarshal(*val, &g.Version)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.DatasetLocation.unmarshalInternal(rawMsg)
}

// Google Cloud Storage read settings.
type GoogleCloudStorageReadSettings struct {
	StoreReadSettings
	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// The prefix filter for the Google Cloud Storage object name. Type: string (or Expression with resultType string).
	Prefix *interface{} `json:"prefix,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Google Cloud Storage wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// Google Cloud Storage wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageReadSettings.
func (g GoogleCloudStorageReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := g.StoreReadSettings.marshalInternal("GoogleCloudStorageReadSettings")
	if g.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = g.EnablePartitionDiscovery
	}
	if g.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = g.ModifiedDatetimeEnd
	}
	if g.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = g.ModifiedDatetimeStart
	}
	if g.Prefix != nil {
		objectMap["prefix"] = g.Prefix
	}
	if g.Recursive != nil {
		objectMap["recursive"] = g.Recursive
	}
	if g.WildcardFileName != nil {
		objectMap["wildcardFileName"] = g.WildcardFileName
	}
	if g.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = g.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageReadSettings.
func (g *GoogleCloudStorageReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &g.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &g.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &g.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "prefix":
			if val != nil {
				err = json.Unmarshal(*val, &g.Prefix)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &g.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &g.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &g.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.StoreReadSettings.unmarshalInternal(rawMsg)
}

// Greenplum Dataset Properties
type GreenplumDatasetTypeProperties struct {
	// The schema name of Greenplum. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of Greenplum. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Greenplum Database linked service.
type GreenplumLinkedService struct {
	LinkedService
	// Greenplum Database linked service properties.
	TypeProperties *GreenplumLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumLinkedService.
func (g GreenplumLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("Greenplum")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumLinkedService.
func (g *GreenplumLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.LinkedService.unmarshalInternal(rawMsg)
}

// Greenplum Database linked service properties.
type GreenplumLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// A copy activity Greenplum Database source.
type GreenplumSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumSource.
func (g GreenplumSource) MarshalJSON() ([]byte, error) {
	objectMap := g.TabularSource.marshalInternal("GreenplumSource")
	if g.Query != nil {
		objectMap["query"] = g.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumSource.
func (g *GreenplumSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &g.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.TabularSource.unmarshalInternal(rawMsg)
}

// Greenplum Database dataset.
type GreenplumTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GreenplumDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumTableDataset.
func (g GreenplumTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := g.Dataset.marshalInternal("GreenplumTable")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumTableDataset.
func (g *GreenplumTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return g.Dataset.unmarshalInternal(rawMsg)
}

// HBase server linked service.
type HBaseLinkedService struct {
	LinkedService
	// HBase server linked service properties.
	TypeProperties *HBaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HBaseLinkedService.
func (h HBaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HBase")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedService.
func (h *HBaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// HBase server linked service properties.
type HBaseLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication mechanism to use to connect to the HBase server.
	AuthenticationType *HBaseAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// The IP address or host name of the HBase server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
	Port *interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// The user name used to connect to the HBase instance.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedServiceTypeProperties.
func (h *HBaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowHostNameCnMismatch)
			}
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.HTTPPath)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &h.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &h.Port)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &h.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HBase server dataset.
type HBaseObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HBaseObjectDataset.
func (h HBaseObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := h.Dataset.marshalInternal("HBaseObject")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseObjectDataset.
func (h *HBaseObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity HBase server source.
type HBaseSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HBaseSource.
func (h HBaseSource) MarshalJSON() ([]byte, error) {
	objectMap := h.TabularSource.marshalInternal("HBaseSource")
	if h.Query != nil {
		objectMap["query"] = h.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseSource.
func (h *HBaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &h.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.TabularSource.unmarshalInternal(rawMsg)
}

// Linked service for an HTTP source.
type HTTPLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *HTTPLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPLinkedService.
func (h HTTPLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HttpServer")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedService.
func (h *HTTPLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to this linked service type.
type HTTPLinkedServiceTypeProperties struct {
	// The authentication type to be used to connect to the HTTP server.
	AuthenticationType *HTTPAuthenticationType `json:"authenticationType,omitempty"`

	// Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with ClientCertificate authentication,
	// either CertThumbprint or
	// EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
	CertThumbprint *interface{} `json:"certThumbprint,omitempty"`

	// Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication, either CertThumbprint
	// or EmbeddedCertData/Password should be
	// specified. Type: string (or Expression with resultType string).
	EmbeddedCertData *interface{} `json:"embeddedCertData,omitempty"`

	// If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType boolean).
	EnableServerCertificateValidation *interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`

	// User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedServiceTypeProperties.
func (h *HTTPLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
			delete(rawMsg, key)
		case "certThumbprint":
			if val != nil {
				err = json.Unmarshal(*val, &h.CertThumbprint)
			}
			delete(rawMsg, key)
		case "embeddedCertData":
			if val != nil {
				err = json.Unmarshal(*val, &h.EmbeddedCertData)
			}
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnableServerCertificateValidation)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &h.URL)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &h.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPPollerResponse contains the asynchronous HTTP response from the call to the service endpoint.
type HTTPPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*http.Response, error)

	// Poller contains an initialized poller.
	Poller HTTPPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Sftp read settings.
type HTTPReadSettings struct {
	StoreReadSettings
	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders *interface{} `json:"additionalHeaders,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody *interface{} `json:"requestBody,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod *interface{} `json:"requestMethod,omitempty"`

	// Specifies the timeout for a HTTP client to get HTTP response from HTTP server.
	RequestTimeout *interface{} `json:"requestTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPReadSettings.
func (h HTTPReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := h.StoreReadSettings.marshalInternal("HttpReadSettings")
	if h.AdditionalHeaders != nil {
		objectMap["additionalHeaders"] = h.AdditionalHeaders
	}
	if h.RequestBody != nil {
		objectMap["requestBody"] = h.RequestBody
	}
	if h.RequestMethod != nil {
		objectMap["requestMethod"] = h.RequestMethod
	}
	if h.RequestTimeout != nil {
		objectMap["requestTimeout"] = h.RequestTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPReadSettings.
func (h *HTTPReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			if val != nil {
				err = json.Unmarshal(*val, &h.AdditionalHeaders)
			}
			delete(rawMsg, key)
		case "requestBody":
			if val != nil {
				err = json.Unmarshal(*val, &h.RequestBody)
			}
			delete(rawMsg, key)
		case "requestMethod":
			if val != nil {
				err = json.Unmarshal(*val, &h.RequestMethod)
			}
			delete(rawMsg, key)
		case "requestTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &h.RequestTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.StoreReadSettings.unmarshalInternal(rawMsg)
}

// The location of http server.
type HTTPServerLocation struct {
	DatasetLocation
	// Specify the relativeUrl of http server. Type: string (or Expression with resultType string)
	RelativeURL *interface{} `json:"relativeUrl,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPServerLocation.
func (h HTTPServerLocation) MarshalJSON() ([]byte, error) {
	objectMap := h.DatasetLocation.marshalInternal("HttpServerLocation")
	if h.RelativeURL != nil {
		objectMap["relativeUrl"] = h.RelativeURL
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPServerLocation.
func (h *HTTPServerLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "relativeUrl":
			if val != nil {
				err = json.Unmarshal(*val, &h.RelativeURL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.DatasetLocation.unmarshalInternal(rawMsg)
}

// A copy activity source for an HTTP file.
type HTTPSource struct {
	CopySource
	// Specifies the timeout for a HTTP client to get HTTP response from HTTP server. The default value is equivalent to System.Net.HttpWebRequest.Timeout.
	// Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout *interface{} `json:"httpRequestTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPSource.
func (h HTTPSource) MarshalJSON() ([]byte, error) {
	objectMap := h.CopySource.marshalInternal("HttpSource")
	if h.HTTPRequestTimeout != nil {
		objectMap["httpRequestTimeout"] = h.HTTPRequestTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPSource.
func (h *HTTPSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "httpRequestTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &h.HTTPRequestTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.CopySource.unmarshalInternal(rawMsg)
}

// HDInsight Hive activity type.
type HdInsightHiveActivity struct {
	ExecutionActivity
	// HDInsight Hive activity properties.
	TypeProperties *HdInsightHiveActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightHiveActivity.
func (h HdInsightHiveActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightHive")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightHiveActivity.
func (h *HdInsightHiveActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.ExecutionActivity.unmarshalInternal(rawMsg)
}

// HDInsight Hive activity properties.
type HdInsightHiveActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for Hive job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Query timeout value (in minutes). Effective when the HDInsight cluster is with ESP (Enterprise Security Package)
	QueryTimeout *int32 `json:"queryTimeout,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Script path. Type: string (or Expression with resultType string).
	ScriptPath *interface{} `json:"scriptPath,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`

	// User specified arguments under hivevar namespace.
	Variables *[]interface{} `json:"variables,omitempty"`
}

// HDInsight linked service.
type HdInsightLinkedService struct {
	LinkedService
	// HDInsight linked service properties.
	TypeProperties *HdInsightLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightLinkedService.
func (h HdInsightLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HDInsight")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightLinkedService.
func (h *HdInsightLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// HDInsight linked service properties.
type HdInsightLinkedServiceTypeProperties struct {
	// HDInsight cluster URI. Type: string (or Expression with resultType string).
	ClusterURI *interface{} `json:"clusterUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType string).
	FileSystem *interface{} `json:"fileSystem,omitempty"`

	// A reference to the Azure SQL linked service that points to the HCatalog database.
	HcatalogLinkedServiceName *LinkedServiceReference `json:"hcatalogLinkedServiceName,omitempty"`

	// Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
	IsEspEnabled *interface{} `json:"isEspEnabled,omitempty"`

	// The Azure Storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// HDInsight cluster password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// HDInsight cluster user name. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// HDInsight MapReduce activity type.
type HdInsightMapReduceActivity struct {
	ExecutionActivity
	// HDInsight MapReduce activity properties.
	TypeProperties *HdInsightMapReduceActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightMapReduceActivity.
func (h HdInsightMapReduceActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightMapReduce")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightMapReduceActivity.
func (h *HdInsightMapReduceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.ExecutionActivity.unmarshalInternal(rawMsg)
}

// HDInsight MapReduce activity properties.
type HdInsightMapReduceActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// Class name. Type: string (or Expression with resultType string).
	ClassName *interface{} `json:"className,omitempty"`

	// Allows user to specify defines for the MapReduce job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Jar path. Type: string (or Expression with resultType string).
	JarFilePath *interface{} `json:"jarFilePath,omitempty"`

	// Jar libs.
	JarLibs *[]interface{} `json:"jarLibs,omitempty"`

	// Jar linked service reference.
	JarLinkedService *LinkedServiceReference `json:"jarLinkedService,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// HDInsight ondemand linked service.
type HdInsightOnDemandLinkedService struct {
	LinkedService
	// HDInsight ondemand linked service properties.
	TypeProperties *HdInsightOnDemandLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightOnDemandLinkedService.
func (h HdInsightOnDemandLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HDInsightOnDemand")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightOnDemandLinkedService.
func (h *HdInsightOnDemandLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// HDInsight ondemand linked service properties.
type HdInsightOnDemandLinkedServiceTypeProperties struct {
	// Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them on your behalf.
	AdditionalLinkedServiceNames *[]LinkedServiceReference `json:"additionalLinkedServiceNames,omitempty"`

	// The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
	ClusterNamePrefix *interface{} `json:"clusterNamePrefix,omitempty"`

	// The password to access the cluster.
	ClusterPassword SecretBaseClassification `json:"clusterPassword,omitempty"`

	// The resource group where the cluster belongs. Type: string (or Expression with resultType string).
	ClusterResourceGroup *interface{} `json:"clusterResourceGroup,omitempty"`

	// The password to SSH remotely connect cluster’s node (for Linux).
	ClusterSSHPassword SecretBaseClassification `json:"clusterSshPassword,omitempty"`

	// The username to SSH remotely connect to cluster’s node (for Linux). Type: string (or Expression with resultType string).
	ClusterSSHUserName *interface{} `json:"clusterSshUserName,omitempty"`

	// Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType string).
	ClusterSize *interface{} `json:"clusterSize,omitempty"`

	// The cluster type. Type: string (or Expression with resultType string).
	ClusterType *interface{} `json:"clusterType,omitempty"`

	// The username to access the cluster. Type: string (or Expression with resultType string).
	ClusterUserName *interface{} `json:"clusterUserName,omitempty"`

	// Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
	CoreConfiguration *interface{} `json:"coreConfiguration,omitempty"`

	// Specifies the size of the data node for the HDInsight cluster.
	DataNodeSize *interface{} `json:"dataNodeSize,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
	HBaseConfiguration *interface{} `json:"hBaseConfiguration,omitempty"`

	// The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by using the Azure SQL database
	// as the metastore.
	HcatalogLinkedServiceName *LinkedServiceReference `json:"hcatalogLinkedServiceName,omitempty"`

	// Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
	HdfsConfiguration *interface{} `json:"hdfsConfiguration,omitempty"`

	// Specifies the size of the head node for the HDInsight cluster.
	HeadNodeSize *interface{} `json:"headNodeSize,omitempty"`

	// Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
	HiveConfiguration *interface{} `json:"hiveConfiguration,omitempty"`

	// The customer’s subscription to host the cluster. Type: string (or Expression with resultType string).
	HostSubscriptionID *interface{} `json:"hostSubscriptionId,omitempty"`

	// Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
	MapReduceConfiguration *interface{} `json:"mapReduceConfiguration,omitempty"`

	// Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
	OozieConfiguration *interface{} `json:"oozieConfiguration,omitempty"`

	// Custom script actions to run on HDI ondemand cluster once it's up. Please refer to
	// https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
	ScriptActions *[]ScriptAction `json:"scriptActions,omitempty"`

	// The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key for the service principal id.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
	SparkVersion *interface{} `json:"sparkVersion,omitempty"`

	// Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
	StormConfiguration *interface{} `json:"stormConfiguration,omitempty"`

	// The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type: string (or Expression with resultType
	// string).
	SubnetName *interface{} `json:"subnetName,omitempty"`

	// The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster stays alive after completion of an activity
	// run if there are no other active jobs in the
	// cluster. The minimum value is 5 mins. Type: string (or Expression with resultType string).
	TimeToLive *interface{} `json:"timeToLive,omitempty"`

	// Version of the HDInsight cluster. Type: string (or Expression with resultType string).
	Version *interface{} `json:"version,omitempty"`

	// The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with resultType string).
	VirtualNetworkID *interface{} `json:"virtualNetworkId,omitempty"`

	// Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
	YarnConfiguration *interface{} `json:"yarnConfiguration,omitempty"`

	// Specifies the size of the Zoo Keeper node for the HDInsight cluster.
	ZookeeperNodeSize *interface{} `json:"zookeeperNodeSize,omitempty"`
}

// HDInsight Pig activity type.
type HdInsightPigActivity struct {
	ExecutionActivity
	// HDInsight Pig activity properties.
	TypeProperties *HdInsightPigActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightPigActivity.
func (h HdInsightPigActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightPig")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightPigActivity.
func (h *HdInsightPigActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.ExecutionActivity.unmarshalInternal(rawMsg)
}

// HDInsight Pig activity properties.
type HdInsightPigActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity. Type: array (or Expression with resultType array).
	Arguments *interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for Pig job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Script path. Type: string (or Expression with resultType string).
	ScriptPath *interface{} `json:"scriptPath,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// HDInsight Spark activity.
type HdInsightSparkActivity struct {
	ExecutionActivity
	// HDInsight spark activity properties.
	TypeProperties *HdInsightSparkActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightSparkActivity.
func (h HdInsightSparkActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightSpark")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightSparkActivity.
func (h *HdInsightSparkActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.ExecutionActivity.unmarshalInternal(rawMsg)
}

// HDInsight spark activity properties.
type HdInsightSparkActivityTypeProperties struct {
	// The user-specified arguments to HDInsightSparkActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// The application's Java/Spark main class.
	ClassName *string `json:"className,omitempty"`

	// The relative path to the root folder of the code/package to be executed. Type: string (or Expression with resultType string).
	EntryFilePath *interface{} `json:"entryFilePath,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// The user to impersonate that will execute the job. Type: string (or Expression with resultType string).
	ProxyUser *interface{} `json:"proxyUser,omitempty"`

	// The root path in 'sparkJobLinkedService' for all the job’s files. Type: string (or Expression with resultType string).
	RootPath *interface{} `json:"rootPath,omitempty"`

	// Spark configuration property.
	SparkConfig *map[string]interface{} `json:"sparkConfig,omitempty"`

	// The storage linked service for uploading the entry file and dependencies, and for receiving logs.
	SparkJobLinkedService *LinkedServiceReference `json:"sparkJobLinkedService,omitempty"`
}

// HDInsight streaming activity type.
type HdInsightStreamingActivity struct {
	ExecutionActivity
	// HDInsight streaming activity properties.
	TypeProperties *HdInsightStreamingActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightStreamingActivity.
func (h HdInsightStreamingActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightStreaming")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightStreamingActivity.
func (h *HdInsightStreamingActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.ExecutionActivity.unmarshalInternal(rawMsg)
}

// HDInsight streaming activity properties.
type HdInsightStreamingActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// Combiner executable name. Type: string (or Expression with resultType string).
	Combiner *interface{} `json:"combiner,omitempty"`

	// Command line environment values.
	CommandEnvironment *[]interface{} `json:"commandEnvironment,omitempty"`

	// Allows user to specify defines for streaming job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Linked service reference where the files are located.
	FileLinkedService *LinkedServiceReference `json:"fileLinkedService,omitempty"`

	// Paths to streaming job files. Can be directories.
	FilePaths *[]interface{} `json:"filePaths,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Input blob path. Type: string (or Expression with resultType string).
	Input *interface{} `json:"input,omitempty"`

	// Mapper executable name. Type: string (or Expression with resultType string).
	Mapper *interface{} `json:"mapper,omitempty"`

	// Output blob path. Type: string (or Expression with resultType string).
	Output *interface{} `json:"output,omitempty"`

	// Reducer executable name. Type: string (or Expression with resultType string).
	Reducer *interface{} `json:"reducer,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// Hadoop Distributed File System (HDFS) linked service.
type HdfsLinkedService struct {
	LinkedService
	// HDFS linked service properties.
	TypeProperties *HdfsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLinkedService.
func (h HdfsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("Hdfs")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedService.
func (h *HdfsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// HDFS linked service properties.
type HdfsLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Windows authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`

	// User name for Windows authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedServiceTypeProperties.
func (h *HdfsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &h.URL)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &h.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The location of HDFS.
type HdfsLocation struct {
	DatasetLocation
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLocation.
func (h HdfsLocation) MarshalJSON() ([]byte, error) {
	objectMap := h.DatasetLocation.marshalInternal("HdfsLocation")
	return json.Marshal(objectMap)
}

// HDFS read settings.
type HdfsReadSettings struct {
	StoreReadSettings
	// Specifies Distcp-related settings.
	DistcpSettings *DistcpSettings `json:"distcpSettings,omitempty"`

	// Indicates whether to enable partition discovery.
	EnablePartitionDiscovery *bool `json:"enablePartitionDiscovery,omitempty"`

	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// HDFS wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// HDFS wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdfsReadSettings.
func (h HdfsReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := h.StoreReadSettings.marshalInternal("HdfsReadSettings")
	if h.DistcpSettings != nil {
		objectMap["distcpSettings"] = h.DistcpSettings
	}
	if h.EnablePartitionDiscovery != nil {
		objectMap["enablePartitionDiscovery"] = h.EnablePartitionDiscovery
	}
	if h.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = h.ModifiedDatetimeEnd
	}
	if h.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = h.ModifiedDatetimeStart
	}
	if h.Recursive != nil {
		objectMap["recursive"] = h.Recursive
	}
	if h.WildcardFileName != nil {
		objectMap["wildcardFileName"] = h.WildcardFileName
	}
	if h.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = h.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsReadSettings.
func (h *HdfsReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distcpSettings":
			if val != nil {
				err = json.Unmarshal(*val, &h.DistcpSettings)
			}
			delete(rawMsg, key)
		case "enablePartitionDiscovery":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnablePartitionDiscovery)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &h.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &h.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &h.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &h.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.StoreReadSettings.unmarshalInternal(rawMsg)
}

// A copy activity HDFS source.
type HdfsSource struct {
	CopySource
	// Specifies Distcp-related settings.
	DistcpSettings *DistcpSettings `json:"distcpSettings,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdfsSource.
func (h HdfsSource) MarshalJSON() ([]byte, error) {
	objectMap := h.CopySource.marshalInternal("HdfsSource")
	if h.DistcpSettings != nil {
		objectMap["distcpSettings"] = h.DistcpSettings
	}
	if h.Recursive != nil {
		objectMap["recursive"] = h.Recursive
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsSource.
func (h *HdfsSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distcpSettings":
			if val != nil {
				err = json.Unmarshal(*val, &h.DistcpSettings)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &h.Recursive)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.CopySource.unmarshalInternal(rawMsg)
}

// Hive Properties
type HiveDatasetTypeProperties struct {
	// The schema name of the Hive. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Hive. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Hive Server linked service.
type HiveLinkedService struct {
	LinkedService
	// Hive Server linked service properties.
	TypeProperties *HiveLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveLinkedService.
func (h HiveLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("Hive")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedService.
func (h *HiveLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// Hive Server linked service properties.
type HiveLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication method used to access the Hive server.
	AuthenticationType *HiveAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Hive server.
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode is enable).
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the Username field
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Hive server uses to listen for client connections.
	Port *interface{} `json:"port,omitempty"`

	// The type of Hive server.
	ServerType *HiveServerType `json:"serverType,omitempty"`

	// true to indicate using the ZooKeeper service, false not.
	ServiceDiscoveryMode *interface{} `json:"serviceDiscoveryMode,omitempty"`

	// The transport protocol to use in the Thrift layer.
	ThriftTransportProtocol *HiveThriftTransportProtocol `json:"thriftTransportProtocol,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
	UseNativeQuery *interface{} `json:"useNativeQuery,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name that you use to access Hive Server.
	Username *interface{} `json:"username,omitempty"`

	// The namespace on ZooKeeper under which Hive Server 2 nodes are added.
	ZooKeeperNameSpace *interface{} `json:"zooKeeperNameSpace,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedServiceTypeProperties.
func (h *HiveLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowHostNameCnMismatch)
			}
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.HTTPPath)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &h.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &h.Port)
			}
			delete(rawMsg, key)
		case "serverType":
			if val != nil {
				err = json.Unmarshal(*val, &h.ServerType)
			}
			delete(rawMsg, key)
		case "serviceDiscoveryMode":
			if val != nil {
				err = json.Unmarshal(*val, &h.ServiceDiscoveryMode)
			}
			delete(rawMsg, key)
		case "thriftTransportProtocol":
			if val != nil {
				err = json.Unmarshal(*val, &h.ThriftTransportProtocol)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useNativeQuery":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseNativeQuery)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &h.Username)
			}
			delete(rawMsg, key)
		case "zooKeeperNameSpace":
			if val != nil {
				err = json.Unmarshal(*val, &h.ZooKeeperNameSpace)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Hive Server dataset.
type HiveObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *HiveDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveObjectDataset.
func (h HiveObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := h.Dataset.marshalInternal("HiveObject")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveObjectDataset.
func (h *HiveObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Hive Server source.
type HiveSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveSource.
func (h HiveSource) MarshalJSON() ([]byte, error) {
	objectMap := h.TabularSource.marshalInternal("HiveSource")
	if h.Query != nil {
		objectMap["query"] = h.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveSource.
func (h *HiveSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &h.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.TabularSource.unmarshalInternal(rawMsg)
}

// Hubspot Service linked service.
type HubspotLinkedService struct {
	LinkedService
	// Hubspot Service linked service properties.
	TypeProperties *HubspotLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HubspotLinkedService.
func (h HubspotLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("Hubspot")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedService.
func (h *HubspotLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.LinkedService.unmarshalInternal(rawMsg)
}

// Hubspot Service linked service properties.
type HubspotLinkedServiceTypeProperties struct {
	// The access token obtained when initially authenticating your OAuth integration.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The client ID associated with your Hubspot application.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with your Hubspot application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The refresh token obtained when initially authenticating your OAuth integration.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedServiceTypeProperties.
func (h *HubspotLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				h.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				h.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "refreshToken":
			if val != nil {
				h.RefreshToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &h.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Hubspot Service dataset.
type HubspotObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HubspotObjectDataset.
func (h HubspotObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := h.Dataset.marshalInternal("HubspotObject")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotObjectDataset.
func (h *HubspotObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Hubspot Service source.
type HubspotSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HubspotSource.
func (h HubspotSource) MarshalJSON() ([]byte, error) {
	objectMap := h.TabularSource.marshalInternal("HubspotSource")
	if h.Query != nil {
		objectMap["query"] = h.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotSource.
func (h *HubspotSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &h.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return h.TabularSource.unmarshalInternal(rawMsg)
}

// This activity evaluates a boolean expression and executes either the activities under the ifTrueActivities property or the ifFalseActivities property
// depending on the result of the expression.
type IfConditionActivity struct {
	Activity
	// IfCondition activity properties.
	TypeProperties *IfConditionActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IfConditionActivity.
func (i IfConditionActivity) MarshalJSON() ([]byte, error) {
	objectMap := i.Activity.marshalInternal("IfCondition")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivity.
func (i *IfConditionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.Activity.unmarshalInternal(rawMsg)
}

// IfCondition activity properties.
type IfConditionActivityTypeProperties struct {
	// An expression that would evaluate to Boolean. This is used to determine the block of activities (ifTrueActivities or ifFalseActivities) that will be
	// executed.
	Expression *Expression `json:"expression,omitempty"`

	// List of activities to execute if expression is evaluated to false. This is an optional property and if not provided, the activity will exit without any
	// action.
	IfFalseActivities *[]ActivityClassification `json:"ifFalseActivities,omitempty"`

	// List of activities to execute if expression is evaluated to true. This is an optional property and if not provided, the activity will exit without any
	// action.
	IfTrueActivities *[]ActivityClassification `json:"ifTrueActivities,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivityTypeProperties.
func (i *IfConditionActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expression":
			if val != nil {
				err = json.Unmarshal(*val, &i.Expression)
			}
			delete(rawMsg, key)
		case "ifFalseActivities":
			if val != nil {
				i.IfFalseActivities, err = unmarshalActivityClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "ifTrueActivities":
			if val != nil {
				i.IfTrueActivities, err = unmarshalActivityClassificationArray(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Impala Dataset Properties
type ImpalaDatasetTypeProperties struct {
	// The schema name of the Impala. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Impala. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Impala server linked service.
type ImpalaLinkedService struct {
	LinkedService
	// Impala server linked service properties.
	TypeProperties *ImpalaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaLinkedService.
func (i ImpalaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := i.LinkedService.marshalInternal("Impala")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedService.
func (i *ImpalaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.LinkedService.unmarshalInternal(rawMsg)
}

// Impala server linked service properties.
type ImpalaLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication type to use.
	AuthenticationType *ImpalaAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The IP address or host name of the Impala server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name when using UsernameAndPassword.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
	Port *interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedServiceTypeProperties.
func (i *ImpalaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &i.AllowHostNameCnMismatch)
			}
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &i.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &i.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &i.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &i.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &i.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				i.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &i.Port)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &i.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &i.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &i.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Impala server dataset.
type ImpalaObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *ImpalaDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaObjectDataset.
func (i ImpalaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := i.Dataset.marshalInternal("ImpalaObject")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaObjectDataset.
func (i *ImpalaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Impala server source.
type ImpalaSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaSource.
func (i ImpalaSource) MarshalJSON() ([]byte, error) {
	objectMap := i.TabularSource.marshalInternal("ImpalaSource")
	if i.Query != nil {
		objectMap["query"] = i.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaSource.
func (i *ImpalaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &i.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.TabularSource.unmarshalInternal(rawMsg)
}

// Informix linked service.
type InformixLinkedService struct {
	LinkedService
	// Informix linked service properties.
	TypeProperties *InformixLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixLinkedService.
func (i InformixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := i.LinkedService.marshalInternal("Informix")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedService.
func (i *InformixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.LinkedService.unmarshalInternal(rawMsg)
}

// Informix linked service properties.
type InformixLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with
	// resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedServiceTypeProperties.
func (i *InformixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &i.AuthenticationType)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &i.ConnectionString)
			}
			delete(rawMsg, key)
		case "credential":
			if val != nil {
				i.Credential, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &i.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				i.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &i.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Informix sink.
type InformixSink struct {
	CopySink
	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixSink.
func (i InformixSink) MarshalJSON() ([]byte, error) {
	objectMap := i.CopySink.marshalInternal("InformixSink")
	if i.PreCopyScript != nil {
		objectMap["preCopyScript"] = i.PreCopyScript
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixSink.
func (i *InformixSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &i.PreCopyScript)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity source for Informix.
type InformixSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixSource.
func (i InformixSource) MarshalJSON() ([]byte, error) {
	objectMap := i.TabularSource.marshalInternal("InformixSource")
	if i.Query != nil {
		objectMap["query"] = i.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixSource.
func (i *InformixSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &i.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.TabularSource.unmarshalInternal(rawMsg)
}

// The Informix table dataset.
type InformixTableDataset struct {
	Dataset
	// Informix table dataset properties.
	TypeProperties *InformixTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixTableDataset.
func (i InformixTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := i.Dataset.marshalInternal("InformixTable")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixTableDataset.
func (i *InformixTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return i.Dataset.unmarshalInternal(rawMsg)
}

// Informix table dataset properties.
type InformixTableDatasetTypeProperties struct {
	// The Informix table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// IntegrationRuntimeClassification provides polymorphic access to related types.
// Call the interface's GetIntegrationRuntime() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *IntegrationRuntime, *ManagedIntegrationRuntime, *SelfHostedIntegrationRuntime
type IntegrationRuntimeClassification interface {
	// GetIntegrationRuntime() returns the IntegrationRuntime content of the underlying type.
	GetIntegrationRuntime() *IntegrationRuntime
}

// Azure Synapse nested object which serves as a compute resource for activities.
type IntegrationRuntime struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Integration runtime description.
	Description *string `json:"description,omitempty"`

	// Type of integration runtime.
	Type *IntegrationRuntimeType `json:"type,omitempty"`
}

// GetIntegrationRuntime implements the IntegrationRuntimeClassification interface for type IntegrationRuntime.
func (i *IntegrationRuntime) GetIntegrationRuntime() *IntegrationRuntime { return i }

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntime.
func (i *IntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return i.unmarshalInternal(rawMsg)
}

func (i IntegrationRuntime) marshalInternal(discValue IntegrationRuntimeType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if i.Description != nil {
		objectMap["description"] = i.Description
	}
	i.Type = &discValue
	objectMap["type"] = i.Type
	if i.AdditionalProperties != nil {
		for key, val := range *i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (i *IntegrationRuntime) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &i.Description)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &i.Type)
			}
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*i.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The compute resource properties for managed integration runtime.
type IntegrationRuntimeComputeProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Data flow properties for managed integration runtime.
	DataFlowProperties *IntegrationRuntimeDataFlowProperties `json:"dataFlowProperties,omitempty"`

	// The location for managed integration runtime. The supported regions could be found on https://docs.microsoft.com/en-us/azure/data-factory/data-factory-data-movement-activities
	Location *string `json:"location,omitempty"`

	// Maximum parallel executions count per node for managed integration runtime.
	MaxParallelExecutionsPerNode *int32 `json:"maxParallelExecutionsPerNode,omitempty"`

	// The node size requirement to managed integration runtime.
	NodeSize *string `json:"nodeSize,omitempty"`

	// The required number of nodes for managed integration runtime.
	NumberOfNodes *int32 `json:"numberOfNodes,omitempty"`

	// VNet properties for managed integration runtime.
	VNetProperties *IntegrationRuntimeVNetProperties `json:"vNetProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeComputeProperties.
func (i IntegrationRuntimeComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.DataFlowProperties != nil {
		objectMap["dataFlowProperties"] = i.DataFlowProperties
	}
	if i.Location != nil {
		objectMap["location"] = i.Location
	}
	if i.MaxParallelExecutionsPerNode != nil {
		objectMap["maxParallelExecutionsPerNode"] = i.MaxParallelExecutionsPerNode
	}
	if i.NodeSize != nil {
		objectMap["nodeSize"] = i.NodeSize
	}
	if i.NumberOfNodes != nil {
		objectMap["numberOfNodes"] = i.NumberOfNodes
	}
	if i.VNetProperties != nil {
		objectMap["vNetProperties"] = i.VNetProperties
	}
	if i.AdditionalProperties != nil {
		for key, val := range *i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeComputeProperties.
func (i *IntegrationRuntimeComputeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlowProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.DataFlowProperties)
			}
			delete(rawMsg, key)
		case "location":
			if val != nil {
				err = json.Unmarshal(*val, &i.Location)
			}
			delete(rawMsg, key)
		case "maxParallelExecutionsPerNode":
			if val != nil {
				err = json.Unmarshal(*val, &i.MaxParallelExecutionsPerNode)
			}
			delete(rawMsg, key)
		case "nodeSize":
			if val != nil {
				err = json.Unmarshal(*val, &i.NodeSize)
			}
			delete(rawMsg, key)
		case "numberOfNodes":
			if val != nil {
				err = json.Unmarshal(*val, &i.NumberOfNodes)
			}
			delete(rawMsg, key)
		case "vNetProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.VNetProperties)
			}
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*i.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Custom setup script properties for a managed dedicated integration runtime.
type IntegrationRuntimeCustomSetupScriptProperties struct {
	// The URI of the Azure blob container that contains the custom setup script.
	BlobContainerURI *string `json:"blobContainerUri,omitempty"`

	// The SAS token of the Azure blob container.
	SasToken *SecureString `json:"sasToken,omitempty"`
}

// Data flow properties for managed integration runtime.
type IntegrationRuntimeDataFlowProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Compute type of the cluster which will execute data flow job.
	ComputeType *DataFlowComputeType `json:"computeType,omitempty"`

	// Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// Time to live (in minutes) setting of the cluster which will execute data flow job.
	TimeToLive *int32 `json:"timeToLive,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i IntegrationRuntimeDataFlowProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.ComputeType != nil {
		objectMap["computeType"] = i.ComputeType
	}
	if i.CoreCount != nil {
		objectMap["coreCount"] = i.CoreCount
	}
	if i.TimeToLive != nil {
		objectMap["timeToLive"] = i.TimeToLive
	}
	if i.AdditionalProperties != nil {
		for key, val := range *i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeDataFlowProperties.
func (i *IntegrationRuntimeDataFlowProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			if val != nil {
				err = json.Unmarshal(*val, &i.ComputeType)
			}
			delete(rawMsg, key)
		case "coreCount":
			if val != nil {
				err = json.Unmarshal(*val, &i.CoreCount)
			}
			delete(rawMsg, key)
		case "timeToLive":
			if val != nil {
				err = json.Unmarshal(*val, &i.TimeToLive)
			}
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*i.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Data proxy properties for a managed dedicated integration runtime.
type IntegrationRuntimeDataProxyProperties struct {
	// The self-hosted integration runtime reference.
	ConnectVia *EntityReference `json:"connectVia,omitempty"`

	// The path to contain the staged data in the Blob storage.
	Path *string `json:"path,omitempty"`

	// The staging linked service reference.
	StagingLinkedService *EntityReference `json:"stagingLinkedService,omitempty"`
}

// A list of integration runtime resources.
type IntegrationRuntimeListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of integration runtimes.
	Value *[]IntegrationRuntimeResource `json:"value,omitempty"`
}

// IntegrationRuntimeListResponseResponse is the response envelope for operations that return a IntegrationRuntimeListResponse type.
type IntegrationRuntimeListResponseResponse struct {
	// A list of integration runtime resources.
	IntegrationRuntimeListResponse *IntegrationRuntimeListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Integration runtime reference type.
type IntegrationRuntimeReference struct {
	// Arguments for integration runtime.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Reference integration runtime name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Type of integration runtime.
	Type *IntegrationRuntimeReferenceType `json:"type,omitempty"`
}

// Integration runtime resource type.
type IntegrationRuntimeResource struct {
	AzureEntityResource
	// Integration runtime properties.
	Properties IntegrationRuntimeClassification `json:"properties,omitempty"`
}

// IntegrationRuntimeResourceResponse is the response envelope for operations that return a IntegrationRuntimeResource type.
type IntegrationRuntimeResourceResponse struct {
	// Integration runtime resource type.
	IntegrationRuntimeResource *IntegrationRuntimeResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Catalog information for managed dedicated integration runtime.
type IntegrationRuntimeSsisCatalogInfo struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The password of the administrator user account of the catalog database.
	CatalogAdminPassword *SecureString `json:"catalogAdminPassword,omitempty"`

	// The administrator user name of catalog database.
	CatalogAdminUserName *string `json:"catalogAdminUserName,omitempty"`

	// The pricing tier for the catalog database. The valid values could be found in https://azure.microsoft.com/en-us/pricing/details/sql-database/
	CatalogPricingTier *IntegrationRuntimeSsisCatalogPricingTier `json:"catalogPricingTier,omitempty"`

	// The catalog database server URL.
	CatalogServerEndpoint *string `json:"catalogServerEndpoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i IntegrationRuntimeSsisCatalogInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.CatalogAdminPassword != nil {
		objectMap["catalogAdminPassword"] = i.CatalogAdminPassword
	}
	if i.CatalogAdminUserName != nil {
		objectMap["catalogAdminUserName"] = i.CatalogAdminUserName
	}
	if i.CatalogPricingTier != nil {
		objectMap["catalogPricingTier"] = i.CatalogPricingTier
	}
	if i.CatalogServerEndpoint != nil {
		objectMap["catalogServerEndpoint"] = i.CatalogServerEndpoint
	}
	if i.AdditionalProperties != nil {
		for key, val := range *i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisCatalogInfo.
func (i *IntegrationRuntimeSsisCatalogInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogAdminPassword":
			if val != nil {
				err = json.Unmarshal(*val, &i.CatalogAdminPassword)
			}
			delete(rawMsg, key)
		case "catalogAdminUserName":
			if val != nil {
				err = json.Unmarshal(*val, &i.CatalogAdminUserName)
			}
			delete(rawMsg, key)
		case "catalogPricingTier":
			if val != nil {
				err = json.Unmarshal(*val, &i.CatalogPricingTier)
			}
			delete(rawMsg, key)
		case "catalogServerEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &i.CatalogServerEndpoint)
			}
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*i.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SSIS properties for managed integration runtime.
type IntegrationRuntimeSsisProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Catalog information for managed dedicated integration runtime.
	CatalogInfo *IntegrationRuntimeSsisCatalogInfo `json:"catalogInfo,omitempty"`

	// Custom setup script properties for a managed dedicated integration runtime.
	CustomSetupScriptProperties *IntegrationRuntimeCustomSetupScriptProperties `json:"customSetupScriptProperties,omitempty"`

	// Data proxy properties for a managed dedicated integration runtime.
	DataProxyProperties *IntegrationRuntimeDataProxyProperties `json:"dataProxyProperties,omitempty"`

	// The edition for the SSIS Integration Runtime
	Edition *IntegrationRuntimeEdition `json:"edition,omitempty"`

	// Custom setup without script properties for a SSIS integration runtime.
	ExpressCustomSetupProperties *[]CustomSetupBaseClassification `json:"expressCustomSetupProperties,omitempty"`

	// License type for bringing your own license scenario.
	LicenseType *IntegrationRuntimeLicenseType `json:"licenseType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeSsisProperties.
func (i IntegrationRuntimeSsisProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.CatalogInfo != nil {
		objectMap["catalogInfo"] = i.CatalogInfo
	}
	if i.CustomSetupScriptProperties != nil {
		objectMap["customSetupScriptProperties"] = i.CustomSetupScriptProperties
	}
	if i.DataProxyProperties != nil {
		objectMap["dataProxyProperties"] = i.DataProxyProperties
	}
	if i.Edition != nil {
		objectMap["edition"] = i.Edition
	}
	if i.ExpressCustomSetupProperties != nil {
		objectMap["expressCustomSetupProperties"] = i.ExpressCustomSetupProperties
	}
	if i.LicenseType != nil {
		objectMap["licenseType"] = i.LicenseType
	}
	if i.AdditionalProperties != nil {
		for key, val := range *i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeSsisProperties.
func (i *IntegrationRuntimeSsisProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "catalogInfo":
			if val != nil {
				err = json.Unmarshal(*val, &i.CatalogInfo)
			}
			delete(rawMsg, key)
		case "customSetupScriptProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.CustomSetupScriptProperties)
			}
			delete(rawMsg, key)
		case "dataProxyProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.DataProxyProperties)
			}
			delete(rawMsg, key)
		case "edition":
			if val != nil {
				err = json.Unmarshal(*val, &i.Edition)
			}
			delete(rawMsg, key)
		case "expressCustomSetupProperties":
			if val != nil {
				i.ExpressCustomSetupProperties, err = unmarshalCustomSetupBaseClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "licenseType":
			if val != nil {
				err = json.Unmarshal(*val, &i.LicenseType)
			}
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*i.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VNet properties for managed integration runtime.
type IntegrationRuntimeVNetProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Resource IDs of the public IP addresses that this integration runtime will use.
	PublicIPs *[]string `json:"publicIPs,omitempty"`

	// The name of the subnet this integration runtime will join.
	Subnet *string `json:"subnet,omitempty"`

	// The ID of the VNet that this integration runtime will join.
	VNetID *string `json:"vNetId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeVNetProperties.
func (i IntegrationRuntimeVNetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.PublicIPs != nil {
		objectMap["publicIPs"] = i.PublicIPs
	}
	if i.Subnet != nil {
		objectMap["subnet"] = i.Subnet
	}
	if i.VNetID != nil {
		objectMap["vNetId"] = i.VNetID
	}
	if i.AdditionalProperties != nil {
		for key, val := range *i.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IntegrationRuntimeVNetProperties.
func (i *IntegrationRuntimeVNetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "publicIPs":
			if val != nil {
				err = json.Unmarshal(*val, &i.PublicIPs)
			}
			delete(rawMsg, key)
		case "subnet":
			if val != nil {
				err = json.Unmarshal(*val, &i.Subnet)
			}
			delete(rawMsg, key)
		case "vNetId":
			if val != nil {
				err = json.Unmarshal(*val, &i.VNetID)
			}
			delete(rawMsg, key)
		default:
			if i.AdditionalProperties == nil {
				i.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*i.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimesGetOptions contains the optional parameters for the IntegrationRuntimes.Get method.
type IntegrationRuntimesGetOptions struct {
	// placeholder for future optional parameters
}

// IntegrationRuntimesListOptions contains the optional parameters for the IntegrationRuntimes.List method.
type IntegrationRuntimesListOptions struct {
	// placeholder for future optional parameters
}

// Json dataset.
type JSONDataset struct {
	Dataset
	// Json dataset properties.
	TypeProperties *JSONDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONDataset.
func (j JSONDataset) MarshalJSON() ([]byte, error) {
	objectMap := j.Dataset.marshalInternal("Json")
	if j.TypeProperties != nil {
		objectMap["typeProperties"] = j.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDataset.
func (j *JSONDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &j.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.Dataset.unmarshalInternal(rawMsg)
}

// Json dataset properties.
type JSONDatasetTypeProperties struct {
	// The data compression method used for the json dataset.
	Compression DatasetCompressionClassification `json:"compression,omitempty"`

	// The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another Unicode encoding. Refer to the
	// name column of the table in the following link to
	// set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
	EncodingName *interface{} `json:"encodingName,omitempty"`

	// The location of the json data storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDatasetTypeProperties.
func (j *JSONDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			if val != nil {
				j.Compression, err = unmarshalDatasetCompressionClassification(*val)
			}
			delete(rawMsg, key)
		case "encodingName":
			if val != nil {
				err = json.Unmarshal(*val, &j.EncodingName)
			}
			delete(rawMsg, key)
		case "location":
			if val != nil {
				j.Location, err = unmarshalDatasetLocationClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The data stored in JSON format.
type JSONFormat struct {
	DatasetStorageFormat
	// The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode
	// encoding. The full list of supported values can be
	// found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression
	// with resultType string).
	EncodingName *interface{} `json:"encodingName,omitempty"`

	// File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
	FilePattern *JSONFormatFilePattern `json:"filePattern,omitempty"`

	// The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
	JSONNodeReference *interface{} `json:"jsonNodeReference,omitempty"`

	// The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with
	// "$"; for fields inside the array chosen by
	// jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression
	// with resultType object).
	JSONPathDefinition *interface{} `json:"jsonPathDefinition,omitempty"`

	// The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
	NestingSeparator *interface{} `json:"nestingSeparator,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONFormat.
func (j JSONFormat) MarshalJSON() ([]byte, error) {
	objectMap := j.DatasetStorageFormat.marshalInternal("JsonFormat")
	if j.EncodingName != nil {
		objectMap["encodingName"] = j.EncodingName
	}
	if j.FilePattern != nil {
		objectMap["filePattern"] = j.FilePattern
	}
	if j.JSONNodeReference != nil {
		objectMap["jsonNodeReference"] = j.JSONNodeReference
	}
	if j.JSONPathDefinition != nil {
		objectMap["jsonPathDefinition"] = j.JSONPathDefinition
	}
	if j.NestingSeparator != nil {
		objectMap["nestingSeparator"] = j.NestingSeparator
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONFormat.
func (j *JSONFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encodingName":
			if val != nil {
				err = json.Unmarshal(*val, &j.EncodingName)
			}
			delete(rawMsg, key)
		case "filePattern":
			if val != nil {
				err = json.Unmarshal(*val, &j.FilePattern)
			}
			delete(rawMsg, key)
		case "jsonNodeReference":
			if val != nil {
				err = json.Unmarshal(*val, &j.JSONNodeReference)
			}
			delete(rawMsg, key)
		case "jsonPathDefinition":
			if val != nil {
				err = json.Unmarshal(*val, &j.JSONPathDefinition)
			}
			delete(rawMsg, key)
		case "nestingSeparator":
			if val != nil {
				err = json.Unmarshal(*val, &j.NestingSeparator)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.DatasetStorageFormat.unmarshalInternal(rawMsg)
}

// A copy activity Json sink.
type JSONSink struct {
	CopySink
	// Json format settings.
	FormatSettings *JSONWriteSettings `json:"formatSettings,omitempty"`

	// Json store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONSink.
func (j JSONSink) MarshalJSON() ([]byte, error) {
	objectMap := j.CopySink.marshalInternal("JsonSink")
	if j.FormatSettings != nil {
		objectMap["formatSettings"] = j.FormatSettings
	}
	if j.StoreSettings != nil {
		objectMap["storeSettings"] = j.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSink.
func (j *JSONSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "formatSettings":
			if val != nil {
				err = json.Unmarshal(*val, &j.FormatSettings)
			}
			delete(rawMsg, key)
		case "storeSettings":
			if val != nil {
				j.StoreSettings, err = unmarshalStoreWriteSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Json source.
type JSONSource struct {
	CopySource
	// Json store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONSource.
func (j JSONSource) MarshalJSON() ([]byte, error) {
	objectMap := j.CopySource.marshalInternal("JsonSource")
	if j.StoreSettings != nil {
		objectMap["storeSettings"] = j.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONSource.
func (j *JSONSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				j.StoreSettings, err = unmarshalStoreReadSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.CopySource.unmarshalInternal(rawMsg)
}

// Json write settings.
type JSONWriteSettings struct {
	FormatWriteSettings
	// File pattern of JSON. This setting controls the way a collection of JSON objects will be treated. The default value is 'setOfObjects'. It is case-sensitive.
	FilePattern *JSONWriteFilePattern `json:"filePattern,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONWriteSettings.
func (j JSONWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := j.FormatWriteSettings.marshalInternal("JsonWriteSettings")
	if j.FilePattern != nil {
		objectMap["filePattern"] = j.FilePattern
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONWriteSettings.
func (j *JSONWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filePattern":
			if val != nil {
				err = json.Unmarshal(*val, &j.FilePattern)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.FormatWriteSettings.unmarshalInternal(rawMsg)
}

// Jira Service linked service.
type JiraLinkedService struct {
	LinkedService
	// Jira Service linked service properties.
	TypeProperties *JiraLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JiraLinkedService.
func (j JiraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := j.LinkedService.marshalInternal("Jira")
	if j.TypeProperties != nil {
		objectMap["typeProperties"] = j.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedService.
func (j *JiraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &j.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.LinkedService.unmarshalInternal(rawMsg)
}

// Jira Service linked service properties.
type JiraLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The IP address or host name of the Jira service. (e.g. jira.example.com)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the username field.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through HTTPS, or 8080 if connecting
	// through HTTP.
	Port *interface{} `json:"port,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name that you use to access Jira Service.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedServiceTypeProperties.
func (j *JiraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &j.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &j.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				j.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &j.Port)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &j.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &j.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &j.UsePeerVerification)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &j.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Jira Service dataset.
type JiraObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JiraObjectDataset.
func (j JiraObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := j.Dataset.marshalInternal("JiraObject")
	if j.TypeProperties != nil {
		objectMap["typeProperties"] = j.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraObjectDataset.
func (j *JiraObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &j.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Jira Service source.
type JiraSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JiraSource.
func (j JiraSource) MarshalJSON() ([]byte, error) {
	objectMap := j.TabularSource.marshalInternal("JiraSource")
	if j.Query != nil {
		objectMap["query"] = j.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraSource.
func (j *JiraSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &j.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return j.TabularSource.unmarshalInternal(rawMsg)
}

// Library/package information of a Big Data pool powered by Apache Spark
type LibraryInfo struct {
	// Storage blob container name.
	ContainerName *string `json:"containerName,omitempty"`

	// Name of the library.
	Name *string `json:"name,omitempty"`

	// Storage blob path of library.
	Path *string `json:"path,omitempty"`

	// Type of the library.
	Type *string `json:"type,omitempty"`

	// The last update time of the library.
	UploadedTimestamp *time.Time `json:"uploadedTimestamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LibraryInfo.
func (l LibraryInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if l.ContainerName != nil {
		objectMap["containerName"] = l.ContainerName
	}
	if l.Name != nil {
		objectMap["name"] = l.Name
	}
	if l.Path != nil {
		objectMap["path"] = l.Path
	}
	if l.Type != nil {
		objectMap["type"] = l.Type
	}
	if l.UploadedTimestamp != nil {
		objectMap["uploadedTimestamp"] = (*timeRFC3339)(l.UploadedTimestamp)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LibraryInfo.
func (l *LibraryInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerName":
			if val != nil {
				err = json.Unmarshal(*val, &l.ContainerName)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &l.Name)
			}
			delete(rawMsg, key)
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &l.Path)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &l.Type)
			}
			delete(rawMsg, key)
		case "uploadedTimestamp":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				l.UploadedTimestamp = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Library requirements for a Big Data pool powered by Apache Spark
type LibraryRequirements struct {
	// The library requirements.
	Content *string `json:"content,omitempty"`

	// The filename of the library requirements file.
	Filename *string `json:"filename,omitempty"`

	// The last update time of the library requirements file.
	Time *time.Time `json:"time,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LibraryRequirements.
func (l LibraryRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if l.Content != nil {
		objectMap["content"] = l.Content
	}
	if l.Filename != nil {
		objectMap["filename"] = l.Filename
	}
	if l.Time != nil {
		objectMap["time"] = (*timeRFC3339)(l.Time)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LibraryRequirements.
func (l *LibraryRequirements) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			if val != nil {
				err = json.Unmarshal(*val, &l.Content)
			}
			delete(rawMsg, key)
		case "filename":
			if val != nil {
				err = json.Unmarshal(*val, &l.Filename)
			}
			delete(rawMsg, key)
		case "time":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				l.Time = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The key authorization type integration runtime.
type LinkedIntegrationRuntimeKeyAuthorization struct {
	LinkedIntegrationRuntimeType
	// The key used for authorization.
	Key *SecureString `json:"key,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l LinkedIntegrationRuntimeKeyAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := l.LinkedIntegrationRuntimeType.marshalInternal("Key")
	if l.Key != nil {
		objectMap["key"] = l.Key
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeKeyAuthorization.
func (l *LinkedIntegrationRuntimeKeyAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
			if val != nil {
				err = json.Unmarshal(*val, &l.Key)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return l.LinkedIntegrationRuntimeType.unmarshalInternal(rawMsg)
}

// The role based access control (RBAC) authorization type integration runtime.
type LinkedIntegrationRuntimeRbacAuthorization struct {
	LinkedIntegrationRuntimeType
	// The resource identifier of the integration runtime to be shared.
	ResourceID *string `json:"resourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l LinkedIntegrationRuntimeRbacAuthorization) MarshalJSON() ([]byte, error) {
	objectMap := l.LinkedIntegrationRuntimeType.marshalInternal("RBAC")
	if l.ResourceID != nil {
		objectMap["resourceId"] = l.ResourceID
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeRbacAuthorization.
func (l *LinkedIntegrationRuntimeRbacAuthorization) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
			if val != nil {
				err = json.Unmarshal(*val, &l.ResourceID)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return l.LinkedIntegrationRuntimeType.unmarshalInternal(rawMsg)
}

// LinkedIntegrationRuntimeTypeClassification provides polymorphic access to related types.
// Call the interface's GetLinkedIntegrationRuntimeType() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *LinkedIntegrationRuntimeType, *LinkedIntegrationRuntimeKeyAuthorization, *LinkedIntegrationRuntimeRbacAuthorization
type LinkedIntegrationRuntimeTypeClassification interface {
	// GetLinkedIntegrationRuntimeType() returns the LinkedIntegrationRuntimeType content of the underlying type.
	GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType
}

// The base definition of a linked integration runtime.
type LinkedIntegrationRuntimeType struct {
	// The authorization type for integration runtime sharing.
	AuthorizationType *string `json:"authorizationType,omitempty"`
}

// GetLinkedIntegrationRuntimeType implements the LinkedIntegrationRuntimeTypeClassification interface for type LinkedIntegrationRuntimeType.
func (l *LinkedIntegrationRuntimeType) GetLinkedIntegrationRuntimeType() *LinkedIntegrationRuntimeType {
	return l
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedIntegrationRuntimeType.
func (l *LinkedIntegrationRuntimeType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return l.unmarshalInternal(rawMsg)
}

func (l LinkedIntegrationRuntimeType) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	l.AuthorizationType = &discValue
	objectMap["authorizationType"] = l.AuthorizationType
	return objectMap
}

func (l *LinkedIntegrationRuntimeType) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationType":
			if val != nil {
				err = json.Unmarshal(*val, &l.AuthorizationType)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedServiceClassification provides polymorphic access to related types.
// Call the interface's GetLinkedService() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *LinkedService, *AmazonMWSLinkedService, *AmazonRedshiftLinkedService, *AmazonS3LinkedService, *AzureBatchLinkedService,
// - *AzureBlobFSLinkedService, *AzureBlobStorageLinkedService, *AzureDataExplorerLinkedService, *AzureDataLakeAnalyticsLinkedService,
// - *AzureDataLakeStoreLinkedService, *AzureDatabricksLinkedService, *AzureFileStorageLinkedService, *AzureFunctionLinkedService,
// - *AzureKeyVaultLinkedService, *AzureMLLinkedService, *AzureMLServiceLinkedService, *AzureMariaDBLinkedService, *AzureMySqlLinkedService,
// - *AzurePostgreSqlLinkedService, *AzureSearchLinkedService, *AzureSqlDWLinkedService, *AzureSqlDatabaseLinkedService, *AzureSqlMILinkedService,
// - *AzureStorageLinkedService, *AzureTableStorageLinkedService, *CassandraLinkedService, *CommonDataServiceForAppsLinkedService,
// - *ConcurLinkedService, *CosmosDbLinkedService, *CosmosDbMongoDbApiLinkedService, *CouchbaseLinkedService, *CustomDataSourceLinkedService,
// - *Db2LinkedService, *DrillLinkedService, *DynamicsLinkedService, *DynamicsAXLinkedService, *DynamicsCrmLinkedService,
// - *EloquaLinkedService, *FileServerLinkedService, *FtpServerLinkedService, *GoogleAdWordsLinkedService, *GoogleBigQueryLinkedService,
// - *GoogleCloudStorageLinkedService, *GreenplumLinkedService, *HBaseLinkedService, *HDInsightLinkedService, *HDInsightOnDemandLinkedService,
// - *HdfsLinkedService, *HiveLinkedService, *HttpLinkedService, *HubspotLinkedService, *ImpalaLinkedService, *InformixLinkedService,
// - *JiraLinkedService, *MagentoLinkedService, *MariaDBLinkedService, *MarketoLinkedService, *MicrosoftAccessLinkedService,
// - *MongoDbLinkedService, *MongoDbV2LinkedService, *MySqlLinkedService, *NetezzaLinkedService, *ODataLinkedService, *OdbcLinkedService,
// - *Office365LinkedService, *OracleLinkedService, *OracleServiceCloudLinkedService, *PaypalLinkedService, *PhoenixLinkedService,
// - *PostgreSqlLinkedService, *PrestoLinkedService, *QuickBooksLinkedService, *ResponsysLinkedService, *RestServiceLinkedService,
// - *SalesforceLinkedService, *SalesforceMarketingCloudLinkedService, *SalesforceServiceCloudLinkedService, *SapBWLinkedService,
// - *SapCloudForCustomerLinkedService, *SapEccLinkedService, *SapHanaLinkedService, *SapOpenHubLinkedService, *SapTableLinkedService,
// - *ServiceNowLinkedService, *SftpServerLinkedService, *ShopifyLinkedService, *SparkLinkedService, *SqlServerLinkedService,
// - *SquareLinkedService, *SybaseLinkedService, *TeradataLinkedService, *VerticaLinkedService, *WebLinkedService, *XeroLinkedService,
// - *ZohoLinkedService
type LinkedServiceClassification interface {
	// GetLinkedService() returns the LinkedService content of the underlying type.
	GetLinkedService() *LinkedService
}

// The Azure Synapse nested object which contains the information and credential which can be used to connect with related store or compute resource.
type LinkedService struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters *map[string]ParameterSpecification `json:"parameters,omitempty"`

	// Type of linked service.
	Type *string `json:"type,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type LinkedService.
func (l *LinkedService) GetLinkedService() *LinkedService { return l }

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedService.
func (l *LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return l.unmarshalInternal(rawMsg)
}

func (l LinkedService) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if l.Annotations != nil {
		objectMap["annotations"] = l.Annotations
	}
	if l.ConnectVia != nil {
		objectMap["connectVia"] = l.ConnectVia
	}
	if l.Description != nil {
		objectMap["description"] = l.Description
	}
	if l.Parameters != nil {
		objectMap["parameters"] = l.Parameters
	}
	l.Type = &discValue
	objectMap["type"] = l.Type
	if l.AdditionalProperties != nil {
		for key, val := range *l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (l *LinkedService) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &l.Annotations)
			}
			delete(rawMsg, key)
		case "connectVia":
			if val != nil {
				err = json.Unmarshal(*val, &l.ConnectVia)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &l.Description)
			}
			delete(rawMsg, key)
		case "parameters":
			if val != nil {
				err = json.Unmarshal(*val, &l.Parameters)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &l.Type)
			}
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*l.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinkedServiceCreateOrUpdateLinkedServiceOptions contains the optional parameters for the LinkedService.CreateOrUpdateLinkedService method.
type LinkedServiceCreateOrUpdateLinkedServiceOptions struct {
	// ETag of the linkedService entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// Linked service debug resource.
type LinkedServiceDebugResource struct {
	SubResourceDebugResource
	// Properties of linked service.
	Properties LinkedServiceClassification `json:"properties,omitempty"`
}

// LinkedServiceDeleteLinkedServiceOptions contains the optional parameters for the LinkedService.DeleteLinkedService method.
type LinkedServiceDeleteLinkedServiceOptions struct {
	// placeholder for future optional parameters
}

// LinkedServiceGetLinkedServiceOptions contains the optional parameters for the LinkedService.GetLinkedService method.
type LinkedServiceGetLinkedServiceOptions struct {
	// ETag of the linked service entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content
	// will be returned.
	IfNoneMatch *string
}

// LinkedServiceGetLinkedServicesByWorkspaceOptions contains the optional parameters for the LinkedService.GetLinkedServicesByWorkspace method.
type LinkedServiceGetLinkedServicesByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// A list of linked service resources.
type LinkedServiceListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of linked services.
	Value *[]LinkedServiceResource `json:"value,omitempty"`
}

// LinkedServiceListResponseResponse is the response envelope for operations that return a LinkedServiceListResponse type.
type LinkedServiceListResponseResponse struct {
	// A list of linked service resources.
	LinkedServiceListResponse *LinkedServiceListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Linked service reference type.
type LinkedServiceReference struct {
	// Arguments for LinkedService.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Reference LinkedService name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Linked service reference type.
	Type *Type `json:"type,omitempty"`
}

// Linked service resource type.
type LinkedServiceResource struct {
	AzureEntityResource
	// Properties of linked service.
	Properties LinkedServiceClassification `json:"properties,omitempty"`
}

// LinkedServiceResourcePollerResponse is the response envelope for operations that asynchronously return a LinkedServiceResource type.
type LinkedServiceResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*LinkedServiceResourceResponse, error)

	// Poller contains an initialized poller.
	Poller LinkedServiceResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServiceResourceResponse is the response envelope for operations that return a LinkedServiceResource type.
type LinkedServiceResourceResponse struct {
	// Linked service resource type.
	LinkedServiceResource *LinkedServiceResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServicesRenameOptions contains the optional parameters for the LinkedServices.Rename method.
type LinkedServicesRenameOptions struct {
	// placeholder for future optional parameters
}

// Log storage settings.
type LogStorageSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Log storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LogStorageSettings.
func (l LogStorageSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if l.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = l.LinkedServiceName
	}
	if l.Path != nil {
		objectMap["path"] = l.Path
	}
	if l.AdditionalProperties != nil {
		for key, val := range *l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogStorageSettings.
func (l *LogStorageSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &l.LinkedServiceName)
			}
			delete(rawMsg, key)
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &l.Path)
			}
			delete(rawMsg, key)
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*l.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Lookup activity.
type LookupActivity struct {
	ExecutionActivity
	// Lookup activity properties.
	TypeProperties *LookupActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LookupActivity.
func (l LookupActivity) MarshalJSON() ([]byte, error) {
	objectMap := l.ExecutionActivity.marshalInternal("Lookup")
	if l.TypeProperties != nil {
		objectMap["typeProperties"] = l.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivity.
func (l *LookupActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &l.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return l.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Lookup activity properties.
type LookupActivityTypeProperties struct {
	// Lookup activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Whether to return first row or all rows. Default value is true. Type: boolean (or Expression with resultType boolean).
	FirstRowOnly *interface{} `json:"firstRowOnly,omitempty"`

	// Dataset-specific source properties, same as copy activity source.
	Source CopySourceClassification `json:"source,omitempty"`
}

// Magento server linked service.
type MagentoLinkedService struct {
	LinkedService
	// Magento server linked service properties.
	TypeProperties *MagentoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MagentoLinkedService.
func (m MagentoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("Magento")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedService.
func (m *MagentoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// Magento server linked service properties.
type MagentoLinkedServiceTypeProperties struct {
	// The access token from Magento.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
	Host *interface{} `json:"host,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedServiceTypeProperties.
func (m *MagentoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				m.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &m.Host)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Magento server dataset.
type MagentoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MagentoObjectDataset.
func (m MagentoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MagentoObject")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoObjectDataset.
func (m *MagentoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Magento server source.
type MagentoSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MagentoSource.
func (m MagentoSource) MarshalJSON() ([]byte, error) {
	objectMap := m.TabularSource.marshalInternal("MagentoSource")
	if m.Query != nil {
		objectMap["query"] = m.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoSource.
func (m *MagentoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &m.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.TabularSource.unmarshalInternal(rawMsg)
}

// The workspace managed identity
type ManagedIDentity struct {
	// The principal ID of the workspace managed identity
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// The tenant ID of the workspace managed identity
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// The type of managed identity for the workspace
	Type *ResourceIDentityType `json:"type,omitempty"`
}

// Managed integration runtime, including managed elastic and managed dedicated integration runtimes.
type ManagedIntegrationRuntime struct {
	IntegrationRuntime
	// Integration runtime state, only valid for managed dedicated integration runtime.
	State *IntegrationRuntimeState `json:"state,omitempty" azure:"ro"`

	// Managed integration runtime properties.
	TypeProperties *ManagedIntegrationRuntimeTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagedIntegrationRuntime.
func (m ManagedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := m.IntegrationRuntime.marshalInternal(IntegrationRuntimeTypeManaged)
	if m.State != nil {
		objectMap["state"] = m.State
	}
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedIntegrationRuntime.
func (m *ManagedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "state":
			if val != nil {
				err = json.Unmarshal(*val, &m.State)
			}
			delete(rawMsg, key)
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.IntegrationRuntime.unmarshalInternal(rawMsg)
}

// Managed integration runtime type properties.
type ManagedIntegrationRuntimeTypeProperties struct {
	// The compute resource for managed integration runtime.
	ComputeProperties *IntegrationRuntimeComputeProperties `json:"computeProperties,omitempty"`

	// SSIS properties for managed integration runtime.
	SsisProperties *IntegrationRuntimeSsisProperties `json:"ssisProperties,omitempty"`
}

// Managed Virtual Network Settings
type ManagedVirtualNetworkSettings struct {
	// Allowed Aad Tenant Ids For Linking
	AllowedAadTenantIDsForLinking *[]string `json:"allowedAadTenantIdsForLinking,omitempty"`

	// Linked Access Check On Target Resource
	LinkedAccessCheckOnTargetResource *bool `json:"linkedAccessCheckOnTargetResource,omitempty"`

	// Prevent Data Exfiltration
	PreventDataExfiltration *bool `json:"preventDataExfiltration,omitempty"`
}

// Mapping data flow.
type MappingDataFlow struct {
	DataFlow
	// Mapping data flow type properties.
	TypeProperties *MappingDataFlowTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MappingDataFlow.
func (m MappingDataFlow) MarshalJSON() ([]byte, error) {
	objectMap := m.DataFlow.marshalInternal("MappingDataFlow")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MappingDataFlow.
func (m *MappingDataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.DataFlow.unmarshalInternal(rawMsg)
}

// Mapping data flow type properties.
type MappingDataFlowTypeProperties struct {
	// DataFlow script.
	Script *string `json:"script,omitempty"`

	// List of sinks in data flow.
	Sinks *[]DataFlowSink `json:"sinks,omitempty"`

	// List of sources in data flow.
	Sources *[]DataFlowSource `json:"sources,omitempty"`

	// List of transformations in data flow.
	Transformations *[]Transformation `json:"transformations,omitempty"`
}

// MariaDB server linked service.
type MariaDbLinkedService struct {
	LinkedService
	// MariaDB server linked service properties.
	TypeProperties *MariaDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MariaDbLinkedService.
func (m MariaDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MariaDB")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDbLinkedService.
func (m *MariaDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// MariaDB server linked service properties.
type MariaDbLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// A copy activity MariaDB server source.
type MariaDbSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MariaDbSource.
func (m MariaDbSource) MarshalJSON() ([]byte, error) {
	objectMap := m.TabularSource.marshalInternal("MariaDBSource")
	if m.Query != nil {
		objectMap["query"] = m.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDbSource.
func (m *MariaDbSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &m.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.TabularSource.unmarshalInternal(rawMsg)
}

// MariaDB server dataset.
type MariaDbTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MariaDbTableDataset.
func (m MariaDbTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MariaDBTable")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDbTableDataset.
func (m *MariaDbTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// Marketo server linked service.
type MarketoLinkedService struct {
	LinkedService
	// Marketo server linked service properties.
	TypeProperties *MarketoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketoLinkedService.
func (m MarketoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("Marketo")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedService.
func (m *MarketoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// Marketo server linked service properties.
type MarketoLinkedServiceTypeProperties struct {
	// The client Id of your Marketo service.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret of your Marketo service.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedServiceTypeProperties.
func (m *MarketoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &m.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				m.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &m.Endpoint)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Marketo server dataset.
type MarketoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketoObjectDataset.
func (m MarketoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MarketoObject")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoObjectDataset.
func (m *MarketoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Marketo server source.
type MarketoSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketoSource.
func (m MarketoSource) MarshalJSON() ([]byte, error) {
	objectMap := m.TabularSource.marshalInternal("MarketoSource")
	if m.Query != nil {
		objectMap["query"] = m.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoSource.
func (m *MarketoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &m.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.TabularSource.unmarshalInternal(rawMsg)
}

// Microsoft Access linked service.
type MicrosoftAccessLinkedService struct {
	LinkedService
	// Microsoft Access linked service properties.
	TypeProperties *MicrosoftAccessLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessLinkedService.
func (m MicrosoftAccessLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MicrosoftAccess")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedService.
func (m *MicrosoftAccessLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// Microsoft Access linked service properties.
type MicrosoftAccessLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression
	// with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedServiceTypeProperties.
func (m *MicrosoftAccessLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &m.AuthenticationType)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &m.ConnectionString)
			}
			delete(rawMsg, key)
		case "credential":
			if val != nil {
				m.Credential, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				m.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &m.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Microsoft Access sink.
type MicrosoftAccessSink struct {
	CopySink
	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessSink.
func (m MicrosoftAccessSink) MarshalJSON() ([]byte, error) {
	objectMap := m.CopySink.marshalInternal("MicrosoftAccessSink")
	if m.PreCopyScript != nil {
		objectMap["preCopyScript"] = m.PreCopyScript
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessSink.
func (m *MicrosoftAccessSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &m.PreCopyScript)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity source for Microsoft Access.
type MicrosoftAccessSource struct {
	CopySource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessSource.
func (m MicrosoftAccessSource) MarshalJSON() ([]byte, error) {
	objectMap := m.CopySource.marshalInternal("MicrosoftAccessSource")
	if m.Query != nil {
		objectMap["query"] = m.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessSource.
func (m *MicrosoftAccessSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &m.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.CopySource.unmarshalInternal(rawMsg)
}

// The Microsoft Access table dataset.
type MicrosoftAccessTableDataset struct {
	Dataset
	// Microsoft Access table dataset properties.
	TypeProperties *MicrosoftAccessTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessTableDataset.
func (m MicrosoftAccessTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MicrosoftAccessTable")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessTableDataset.
func (m *MicrosoftAccessTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// Microsoft Access table dataset properties.
type MicrosoftAccessTableDatasetTypeProperties struct {
	// The Microsoft Access table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// The MongoDB database dataset.
type MongoDbCollectionDataset struct {
	Dataset
	// MongoDB database dataset properties.
	TypeProperties *MongoDbCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionDataset.
func (m MongoDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MongoDbCollection")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCollectionDataset.
func (m *MongoDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// MongoDB database dataset properties.
type MongoDbCollectionDatasetTypeProperties struct {
	// The table name of the MongoDB database. Type: string (or Expression with resultType string).
	CollectionName *interface{} `json:"collectionName,omitempty"`
}

// Cursor methods for Mongodb query
type MongoDbCursorMethodsProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Specifies the maximum number of documents the server returns. limit() is analogous to the LIMIT statement in a SQL database. Type: integer (or Expression
	// with resultType integer).
	Limit *interface{} `json:"limit,omitempty"`

	// Specifies the fields to return in the documents that match the query filter. To return all fields in the matching documents, omit this parameter. Type:
	// string (or Expression with resultType string).
	Project *interface{} `json:"project,omitempty"`

	// Specifies the how many documents skipped and where MongoDB begins returning results. This approach may be useful in implementing paginated results. Type:
	// integer (or Expression with resultType
	// integer).
	Skip *interface{} `json:"skip,omitempty"`

	// Specifies the order in which the query returns matching documents. Type: string (or Expression with resultType string). Type: string (or Expression with
	// resultType string).
	Sort *interface{} `json:"sort,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCursorMethodsProperties.
func (m MongoDbCursorMethodsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if m.Limit != nil {
		objectMap["limit"] = m.Limit
	}
	if m.Project != nil {
		objectMap["project"] = m.Project
	}
	if m.Skip != nil {
		objectMap["skip"] = m.Skip
	}
	if m.Sort != nil {
		objectMap["sort"] = m.Sort
	}
	if m.AdditionalProperties != nil {
		for key, val := range *m.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCursorMethodsProperties.
func (m *MongoDbCursorMethodsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "limit":
			if val != nil {
				err = json.Unmarshal(*val, &m.Limit)
			}
			delete(rawMsg, key)
		case "project":
			if val != nil {
				err = json.Unmarshal(*val, &m.Project)
			}
			delete(rawMsg, key)
		case "skip":
			if val != nil {
				err = json.Unmarshal(*val, &m.Skip)
			}
			delete(rawMsg, key)
		case "sort":
			if val != nil {
				err = json.Unmarshal(*val, &m.Sort)
			}
			delete(rawMsg, key)
		default:
			if m.AdditionalProperties == nil {
				m.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*m.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Linked service for MongoDb data source.
type MongoDbLinkedService struct {
	LinkedService
	// MongoDB linked service properties.
	TypeProperties *MongoDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbLinkedService.
func (m MongoDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MongoDb")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedService.
func (m *MongoDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// MongoDB linked service properties.
type MongoDbLinkedServiceTypeProperties struct {
	// Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression with resultType boolean).
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Database to verify the username and password. Type: string (or Expression with resultType string).
	AuthSource *interface{} `json:"authSource,omitempty"`

	// The authentication type to be used to connect to the MongoDB database.
	AuthenticationType *MongoDbAuthenticationType `json:"authenticationType,omitempty"`

	// The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
	DatabaseName *interface{} `json:"databaseName,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or Expression with resultType boolean).
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer (or Expression with resultType
	// integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedServiceTypeProperties.
func (m *MongoDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &m.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authSource":
			if val != nil {
				err = json.Unmarshal(*val, &m.AuthSource)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &m.AuthenticationType)
			}
			delete(rawMsg, key)
		case "databaseName":
			if val != nil {
				err = json.Unmarshal(*val, &m.DatabaseName)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &m.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				m.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &m.Port)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &m.Server)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &m.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for a MongoDB database.
type MongoDbSource struct {
	CopySource
	// Database query. Should be a SQL-92 query expression. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbSource.
func (m MongoDbSource) MarshalJSON() ([]byte, error) {
	objectMap := m.CopySource.marshalInternal("MongoDbSource")
	if m.Query != nil {
		objectMap["query"] = m.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbSource.
func (m *MongoDbSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &m.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.CopySource.unmarshalInternal(rawMsg)
}

// The MongoDB database dataset.
type MongoDbV2CollectionDataset struct {
	Dataset
	// MongoDB database dataset properties.
	TypeProperties *MongoDbV2CollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2CollectionDataset.
func (m MongoDbV2CollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MongoDbV2Collection")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2CollectionDataset.
func (m *MongoDbV2CollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// MongoDB database dataset properties.
type MongoDbV2CollectionDatasetTypeProperties struct {
	// The collection name of the MongoDB database. Type: string (or Expression with resultType string).
	Collection *interface{} `json:"collection,omitempty"`
}

// Linked service for MongoDB data source.
type MongoDbV2LinkedService struct {
	LinkedService
	// MongoDB linked service properties.
	TypeProperties *MongoDbV2LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2LinkedService.
func (m MongoDbV2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MongoDbV2")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2LinkedService.
func (m *MongoDbV2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// MongoDB linked service properties.
type MongoDbV2LinkedServiceTypeProperties struct {
	// The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`
}

// A copy activity source for a MongoDB database.
type MongoDbV2Source struct {
	CopySource
	// Specifies the number of documents to return in each batch of the response from MongoDB instance. In most cases, modifying the batch size will not affect
	// the user or the application. This property's
	// main purpose is to avoid hit the limitation of response size. Type: integer (or Expression with resultType integer).
	BatchSize *interface{} `json:"batchSize,omitempty"`

	// Cursor methods for Mongodb query
	CursorMethods *MongoDbCursorMethodsProperties `json:"cursorMethods,omitempty"`

	// Specifies selection filter using query operators. To return all documents in a collection, omit this parameter or pass an empty document ({}). Type:
	// string (or Expression with resultType string).
	Filter *interface{} `json:"filter,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout *interface{} `json:"queryTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2Source.
func (m MongoDbV2Source) MarshalJSON() ([]byte, error) {
	objectMap := m.CopySource.marshalInternal("MongoDbV2Source")
	if m.BatchSize != nil {
		objectMap["batchSize"] = m.BatchSize
	}
	if m.CursorMethods != nil {
		objectMap["cursorMethods"] = m.CursorMethods
	}
	if m.Filter != nil {
		objectMap["filter"] = m.Filter
	}
	if m.QueryTimeout != nil {
		objectMap["queryTimeout"] = m.QueryTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2Source.
func (m *MongoDbV2Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSize":
			if val != nil {
				err = json.Unmarshal(*val, &m.BatchSize)
			}
			delete(rawMsg, key)
		case "cursorMethods":
			if val != nil {
				err = json.Unmarshal(*val, &m.CursorMethods)
			}
			delete(rawMsg, key)
		case "filter":
			if val != nil {
				err = json.Unmarshal(*val, &m.Filter)
			}
			delete(rawMsg, key)
		case "queryTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &m.QueryTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.CopySource.unmarshalInternal(rawMsg)
}

// MultiplePipelineTriggerClassification provides polymorphic access to related types.
// Call the interface's GetMultiplePipelineTrigger() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MultiplePipelineTrigger, *BlobEventsTrigger, *BlobTrigger, *ScheduleTrigger
type MultiplePipelineTriggerClassification interface {
	TriggerClassification
	// GetMultiplePipelineTrigger() returns the MultiplePipelineTrigger content of the underlying type.
	GetMultiplePipelineTrigger() *MultiplePipelineTrigger
}

// Base class for all triggers that support one to many model for trigger to pipeline.
type MultiplePipelineTrigger struct {
	Trigger
	// Pipelines that need to be started.
	Pipelines *[]TriggerPipelineReference `json:"pipelines,omitempty"`
}

// GetMultiplePipelineTrigger implements the MultiplePipelineTriggerClassification interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) GetMultiplePipelineTrigger() *MultiplePipelineTrigger { return m }

// MarshalJSON implements the json.Marshaller interface for type MultiplePipelineTrigger.
func (m MultiplePipelineTrigger) MarshalJSON() ([]byte, error) {
	objectMap := m.marshalInternal("MultiplePipelineTrigger")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MultiplePipelineTrigger) marshalInternal(discValue string) map[string]interface{} {
	objectMap := m.Trigger.marshalInternal(discValue)
	if m.Pipelines != nil {
		objectMap["pipelines"] = m.Pipelines
	}
	return objectMap
}

func (m *MultiplePipelineTrigger) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pipelines":
			if val != nil {
				err = json.Unmarshal(*val, &m.Pipelines)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Trigger.unmarshalInternal(rawMsg)
}

// Linked service for MySQL data source.
type MySQLLinkedService struct {
	LinkedService
	// MySQL linked service properties.
	TypeProperties *MySQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MySQLLinkedService.
func (m MySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MySql")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLLinkedService.
func (m *MySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.LinkedService.unmarshalInternal(rawMsg)
}

// MySQL linked service properties.
type MySQLLinkedServiceTypeProperties struct {
	// The connection string.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// A copy activity source for MySQL databases.
type MySQLSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MySQLSource.
func (m MySQLSource) MarshalJSON() ([]byte, error) {
	objectMap := m.TabularSource.marshalInternal("MySqlSource")
	if m.Query != nil {
		objectMap["query"] = m.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLSource.
func (m *MySQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &m.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.TabularSource.unmarshalInternal(rawMsg)
}

// The MySQL table dataset.
type MySQLTableDataset struct {
	Dataset
	// MySQL table dataset properties.
	TypeProperties *MySQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MySQLTableDataset.
func (m MySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MySqlTable")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLTableDataset.
func (m *MySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return m.Dataset.unmarshalInternal(rawMsg)
}

// MySql table dataset properties.
type MySQLTableDatasetTypeProperties struct {
	// The MySQL table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Netezza linked service.
type NetezzaLinkedService struct {
	LinkedService
	// Netezza linked service properties.
	TypeProperties *NetezzaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaLinkedService.
func (n NetezzaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := n.LinkedService.marshalInternal("Netezza")
	if n.TypeProperties != nil {
		objectMap["typeProperties"] = n.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaLinkedService.
func (n *NetezzaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &n.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return n.LinkedService.unmarshalInternal(rawMsg)
}

// Netezza linked service properties.
type NetezzaLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// The settings that will be leveraged for Netezza source partitioning.
type NetezzaPartitionSettings struct {
	// The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
	PartitionColumnName *interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionLowerBound *interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionUpperBound *interface{} `json:"partitionUpperBound,omitempty"`
}

// A copy activity Netezza source.
type NetezzaSource struct {
	TabularSource
	// The partition mechanism that will be used for Netezza read in parallel.
	PartitionOption *NetezzaPartitionOption `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Netezza source partitioning.
	PartitionSettings *NetezzaPartitionSettings `json:"partitionSettings,omitempty"`

	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaSource.
func (n NetezzaSource) MarshalJSON() ([]byte, error) {
	objectMap := n.TabularSource.marshalInternal("NetezzaSource")
	if n.PartitionOption != nil {
		objectMap["partitionOption"] = n.PartitionOption
	}
	if n.PartitionSettings != nil {
		objectMap["partitionSettings"] = n.PartitionSettings
	}
	if n.Query != nil {
		objectMap["query"] = n.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaSource.
func (n *NetezzaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionOption":
			if val != nil {
				err = json.Unmarshal(*val, &n.PartitionOption)
			}
			delete(rawMsg, key)
		case "partitionSettings":
			if val != nil {
				err = json.Unmarshal(*val, &n.PartitionSettings)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &n.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return n.TabularSource.unmarshalInternal(rawMsg)
}

// Netezza dataset.
type NetezzaTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *NetezzaTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaTableDataset.
func (n NetezzaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := n.Dataset.marshalInternal("NetezzaTable")
	if n.TypeProperties != nil {
		objectMap["typeProperties"] = n.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaTableDataset.
func (n *NetezzaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &n.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return n.Dataset.unmarshalInternal(rawMsg)
}

// Netezza dataset properties.
type NetezzaTableDatasetTypeProperties struct {
	// The schema name of the Netezza. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Netezza. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Notebook.
type Notebook struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Big data pool reference.
	BigDataPool *BigDataPoolReference `json:"bigDataPool,omitempty"`

	// Array of cells of the current notebook.
	Cells *[]NotebookCell `json:"cells,omitempty"`

	// The description of the notebook.
	Description *string `json:"description,omitempty"`

	// Notebook root-level metadata.
	Metadata *NotebookMetadata `json:"metadata,omitempty"`

	// Notebook format (major number). Incremented between backwards incompatible changes to the notebook format.
	Nbformat *int32 `json:"nbformat,omitempty"`

	// Notebook format (minor number). Incremented for backward compatible changes to the notebook format.
	NbformatMinor *int32 `json:"nbformat_minor,omitempty"`

	// Session properties.
	SessionProperties *NotebookSessionProperties `json:"sessionProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Notebook.
func (n Notebook) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.BigDataPool != nil {
		objectMap["bigDataPool"] = n.BigDataPool
	}
	if n.Cells != nil {
		objectMap["cells"] = n.Cells
	}
	if n.Description != nil {
		objectMap["description"] = n.Description
	}
	if n.Metadata != nil {
		objectMap["metadata"] = n.Metadata
	}
	if n.Nbformat != nil {
		objectMap["nbformat"] = n.Nbformat
	}
	if n.NbformatMinor != nil {
		objectMap["nbformat_minor"] = n.NbformatMinor
	}
	if n.SessionProperties != nil {
		objectMap["sessionProperties"] = n.SessionProperties
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Notebook.
func (n *Notebook) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bigDataPool":
			if val != nil {
				err = json.Unmarshal(*val, &n.BigDataPool)
			}
			delete(rawMsg, key)
		case "cells":
			if val != nil {
				err = json.Unmarshal(*val, &n.Cells)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &n.Description)
			}
			delete(rawMsg, key)
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &n.Metadata)
			}
			delete(rawMsg, key)
		case "nbformat":
			if val != nil {
				err = json.Unmarshal(*val, &n.Nbformat)
			}
			delete(rawMsg, key)
		case "nbformat_minor":
			if val != nil {
				err = json.Unmarshal(*val, &n.NbformatMinor)
			}
			delete(rawMsg, key)
		case "sessionProperties":
			if val != nil {
				err = json.Unmarshal(*val, &n.SessionProperties)
			}
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Notebook cell.
type NotebookCell struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Attachments associated with the cell.
	Attachments *interface{} `json:"attachments,omitempty"`

	// String identifying the type of cell.
	CellType *string `json:"cell_type,omitempty"`

	// Cell-level metadata.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Cell-level output items.
	Outputs *[]NotebookCellOutputItem `json:"outputs,omitempty"`

	// Contents of the cell, represented as an array of lines.
	Source *[]string `json:"source,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookCell.
func (n NotebookCell) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.Attachments != nil {
		objectMap["attachments"] = n.Attachments
	}
	if n.CellType != nil {
		objectMap["cell_type"] = n.CellType
	}
	if n.Metadata != nil {
		objectMap["metadata"] = n.Metadata
	}
	if n.Outputs != nil {
		objectMap["outputs"] = n.Outputs
	}
	if n.Source != nil {
		objectMap["source"] = n.Source
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookCell.
func (n *NotebookCell) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attachments":
			if val != nil {
				err = json.Unmarshal(*val, &n.Attachments)
			}
			delete(rawMsg, key)
		case "cell_type":
			if val != nil {
				err = json.Unmarshal(*val, &n.CellType)
			}
			delete(rawMsg, key)
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &n.Metadata)
			}
			delete(rawMsg, key)
		case "outputs":
			if val != nil {
				err = json.Unmarshal(*val, &n.Outputs)
			}
			delete(rawMsg, key)
		case "source":
			if val != nil {
				err = json.Unmarshal(*val, &n.Source)
			}
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// An item of the notebook cell execution output.
type NotebookCellOutputItem struct {
	// Output data. Use MIME type as key, and content as value.
	Data *interface{} `json:"data,omitempty"`

	// Execution sequence number.
	ExecutionCount *int32 `json:"execution_count,omitempty"`

	// Metadata for the output item.
	Metadata *interface{} `json:"metadata,omitempty"`

	// For output_type=stream, determines the name of stream (stdout / stderr).
	Name *string `json:"name,omitempty"`

	// Execution, display, or stream outputs.
	OutputType *CellOutputType `json:"output_type,omitempty"`

	// For output_type=stream, the stream's text output, represented as a string or an array of strings.
	Text *interface{} `json:"text,omitempty"`
}

// NotebookCreateOrUpdateNotebookOptions contains the optional parameters for the Notebook.CreateOrUpdateNotebook method.
type NotebookCreateOrUpdateNotebookOptions struct {
	// ETag of the Note book entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// NotebookDeleteNotebookOptions contains the optional parameters for the Notebook.DeleteNotebook method.
type NotebookDeleteNotebookOptions struct {
	// placeholder for future optional parameters
}

// NotebookGetNotebookOptions contains the optional parameters for the Notebook.GetNotebook method.
type NotebookGetNotebookOptions struct {
	// ETag of the Notebook entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will
	// be returned.
	IfNoneMatch *string
}

// NotebookGetNotebookSummaryByWorkSpaceOptions contains the optional parameters for the Notebook.GetNotebookSummaryByWorkSpace method.
type NotebookGetNotebookSummaryByWorkSpaceOptions struct {
	// placeholder for future optional parameters
}

// NotebookGetNotebooksByWorkspaceOptions contains the optional parameters for the Notebook.GetNotebooksByWorkspace method.
type NotebookGetNotebooksByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// Kernel information.
type NotebookKernelSpec struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Name to display in UI.
	DisplayName *string `json:"display_name,omitempty"`

	// Name of the kernel specification.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookKernelSpec.
func (n NotebookKernelSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.DisplayName != nil {
		objectMap["display_name"] = n.DisplayName
	}
	if n.Name != nil {
		objectMap["name"] = n.Name
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookKernelSpec.
func (n *NotebookKernelSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "display_name":
			if val != nil {
				err = json.Unmarshal(*val, &n.DisplayName)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &n.Name)
			}
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Language info.
type NotebookLanguageInfo struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The codemirror mode to use for code in this language.
	CodemirrorMode *string `json:"codemirror_mode,omitempty"`

	// The programming language which this kernel runs.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookLanguageInfo.
func (n NotebookLanguageInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.CodemirrorMode != nil {
		objectMap["codemirror_mode"] = n.CodemirrorMode
	}
	if n.Name != nil {
		objectMap["name"] = n.Name
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookLanguageInfo.
func (n *NotebookLanguageInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codemirror_mode":
			if val != nil {
				err = json.Unmarshal(*val, &n.CodemirrorMode)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &n.Name)
			}
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A list of Notebook resources.
type NotebookListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of Notebooks.
	Value *[]NotebookResource `json:"value,omitempty"`
}

// NotebookListResponseResponse is the response envelope for operations that return a NotebookListResponse type.
type NotebookListResponseResponse struct {
	// A list of Notebook resources.
	NotebookListResponse *NotebookListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Notebook root-level metadata.
type NotebookMetadata struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Kernel information.
	Kernelspec *NotebookKernelSpec `json:"kernelspec,omitempty"`

	// Language info.
	LanguageInfo *NotebookLanguageInfo `json:"language_info,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookMetadata.
func (n NotebookMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.Kernelspec != nil {
		objectMap["kernelspec"] = n.Kernelspec
	}
	if n.LanguageInfo != nil {
		objectMap["language_info"] = n.LanguageInfo
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookMetadata.
func (n *NotebookMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelspec":
			if val != nil {
				err = json.Unmarshal(*val, &n.Kernelspec)
			}
			delete(rawMsg, key)
		case "language_info":
			if val != nil {
				err = json.Unmarshal(*val, &n.LanguageInfo)
			}
			delete(rawMsg, key)
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Notebook resource type.
type NotebookResource struct {
	// Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties of Notebook.
	Properties *Notebook `json:"properties,omitempty"`

	// The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// NotebookResourcePollerResponse is the response envelope for operations that asynchronously return a NotebookResource type.
type NotebookResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*NotebookResourceResponse, error)

	// Poller contains an initialized poller.
	Poller NotebookResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookResourceResponse is the response envelope for operations that return a NotebookResource type.
type NotebookResourceResponse struct {
	// Notebook resource type.
	NotebookResource *NotebookResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Session properties.
type NotebookSessionProperties struct {
	// Number of cores to use for the driver.
	DriverCores *int32 `json:"driverCores,omitempty"`

	// Amount of memory to use for the driver process.
	DriverMemory *string `json:"driverMemory,omitempty"`

	// Number of cores to use for each executor.
	ExecutorCores *int32 `json:"executorCores,omitempty"`

	// Amount of memory to use per executor process.
	ExecutorMemory *string `json:"executorMemory,omitempty"`

	// Number of executors to launch for this session.
	NumExecutors *int32 `json:"numExecutors,omitempty"`
}

// NotebooksRenameOptions contains the optional parameters for the Notebooks.Rename method.
type NotebooksRenameOptions struct {
	// placeholder for future optional parameters
}

// Open Data Protocol (OData) linked service.
type ODataLinkedService struct {
	LinkedService
	// OData linked service properties.
	TypeProperties *ODataLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataLinkedService.
func (o ODataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("OData")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedService.
func (o *ODataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.LinkedService.unmarshalInternal(rawMsg)
}

// OData linked service properties.
type ODataLinkedServiceTypeProperties struct {
	// Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
	AadResourceID *interface{} `json:"aadResourceId,omitempty"`

	// Specify the credential type (key or cert) is used for service principal.
	AadServicePrincipalCredentialType *ODataAadServicePrincipalCredentialType `json:"aadServicePrincipalCredentialType,omitempty"`

	// Type of authentication used to connect to the OData service.
	AuthenticationType *ODataAuthenticationType `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password of the OData service.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
	ServicePrincipalEmbeddedCert SecretBaseClassification `json:"servicePrincipalEmbeddedCert,omitempty"`

	// Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalEmbeddedCertPassword SecretBaseClassification `json:"servicePrincipalEmbeddedCertPassword,omitempty"`

	// Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The URL of the OData service endpoint. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`

	// User name of the OData service. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedServiceTypeProperties.
func (o *ODataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			if val != nil {
				err = json.Unmarshal(*val, &o.AadResourceID)
			}
			delete(rawMsg, key)
		case "aadServicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &o.AadServicePrincipalCredentialType)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &o.AuthenticationType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				o.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalEmbeddedCert":
			if val != nil {
				o.ServicePrincipalEmbeddedCert, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalEmbeddedCertPassword":
			if val != nil {
				o.ServicePrincipalEmbeddedCertPassword, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &o.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &o.Tenant)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &o.URL)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &o.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Open Data Protocol (OData) resource dataset.
type ODataResourceDataset struct {
	Dataset
	// OData dataset properties.
	TypeProperties *ODataResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataResourceDataset.
func (o ODataResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("ODataResource")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataResourceDataset.
func (o *ODataResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.Dataset.unmarshalInternal(rawMsg)
}

// OData dataset properties.
type ODataResourceDatasetTypeProperties struct {
	// The OData resource path. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// A copy activity source for OData source.
type ODataSource struct {
	CopySource
	// OData query. For example, "$top=1". Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataSource.
func (o ODataSource) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySource.marshalInternal("ODataSource")
	if o.Query != nil {
		objectMap["query"] = o.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataSource.
func (o *ODataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &o.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySource.unmarshalInternal(rawMsg)
}

// Open Database Connectivity (ODBC) linked service.
type OdbcLinkedService struct {
	LinkedService
	// ODBC linked service properties.
	TypeProperties *OdbcLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcLinkedService.
func (o OdbcLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("Odbc")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedService.
func (o *OdbcLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.LinkedService.unmarshalInternal(rawMsg)
}

// ODBC linked service properties.
type OdbcLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with resultType
	// string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedServiceTypeProperties.
func (o *OdbcLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &o.AuthenticationType)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &o.ConnectionString)
			}
			delete(rawMsg, key)
		case "credential":
			if val != nil {
				o.Credential, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				o.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &o.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity ODBC sink.
type OdbcSink struct {
	CopySink
	// A query to execute before starting the copy. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcSink.
func (o OdbcSink) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySink.marshalInternal("OdbcSink")
	if o.PreCopyScript != nil {
		objectMap["preCopyScript"] = o.PreCopyScript
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcSink.
func (o *OdbcSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &o.PreCopyScript)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity source for ODBC databases.
type OdbcSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcSource.
func (o OdbcSource) MarshalJSON() ([]byte, error) {
	objectMap := o.TabularSource.marshalInternal("OdbcSource")
	if o.Query != nil {
		objectMap["query"] = o.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcSource.
func (o *OdbcSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &o.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.TabularSource.unmarshalInternal(rawMsg)
}

// The ODBC table dataset.
type OdbcTableDataset struct {
	Dataset
	// ODBC table dataset properties.
	TypeProperties *OdbcTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcTableDataset.
func (o OdbcTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("OdbcTable")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcTableDataset.
func (o *OdbcTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.Dataset.unmarshalInternal(rawMsg)
}

// ODBC table dataset properties.
type OdbcTableDatasetTypeProperties struct {
	// The ODBC table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// The Office365 account.
type Office365Dataset struct {
	Dataset
	// Office365 dataset properties.
	TypeProperties *Office365DatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Office365Dataset.
func (o Office365Dataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("Office365Table")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Dataset.
func (o *Office365Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.Dataset.unmarshalInternal(rawMsg)
}

// Office365 dataset properties.
type Office365DatasetTypeProperties struct {
	// A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression with resultType string).
	Predicate *interface{} `json:"predicate,omitempty"`

	// Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Office365 linked service.
type Office365LinkedService struct {
	LinkedService
	// Office365 linked service properties.
	TypeProperties *Office365LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Office365LinkedService.
func (o Office365LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("Office365")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedService.
func (o *Office365LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.LinkedService.unmarshalInternal(rawMsg)
}

// Office365 linked service properties.
type Office365LinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
	Office365TenantID *interface{} `json:"office365TenantId,omitempty"`

	// Specify the application's client ID. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the application's key.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression with resultType string).
	ServicePrincipalTenantID *interface{} `json:"servicePrincipalTenantId,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedServiceTypeProperties.
func (o *Office365LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "office365TenantId":
			if val != nil {
				err = json.Unmarshal(*val, &o.Office365TenantID)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &o.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalTenantId":
			if val != nil {
				err = json.Unmarshal(*val, &o.ServicePrincipalTenantID)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for an Office 365 service.
type Office365Source struct {
	CopySource
	// The groups containing all the users. Type: array of strings (or Expression with resultType array of strings).
	AllowedGroups *interface{} `json:"allowedGroups,omitempty"`

	// The Column to apply the and . Type: string (or Expression with resultType string).
	DateFilterColumn *interface{} `json:"dateFilterColumn,omitempty"`

	// End time of the requested range for this dataset. Type: string (or Expression with resultType string).
	EndTime *interface{} `json:"endTime,omitempty"`

	// The columns to be read out from the Office 365 table. Type: array of objects (or Expression with resultType array of objects). Example: [ { "name": "Id"
	// }, { "name": "CreatedDateTime" } ]
	OutputColumns *interface{} `json:"outputColumns,omitempty"`

	// Start time of the requested range for this dataset. Type: string (or Expression with resultType string).
	StartTime *interface{} `json:"startTime,omitempty"`

	// The user scope uri. Type: string (or Expression with resultType string).
	UserScopeFilterURI *interface{} `json:"userScopeFilterUri,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Office365Source.
func (o Office365Source) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySource.marshalInternal("Office365Source")
	if o.AllowedGroups != nil {
		objectMap["allowedGroups"] = o.AllowedGroups
	}
	if o.DateFilterColumn != nil {
		objectMap["dateFilterColumn"] = o.DateFilterColumn
	}
	if o.EndTime != nil {
		objectMap["endTime"] = o.EndTime
	}
	if o.OutputColumns != nil {
		objectMap["outputColumns"] = o.OutputColumns
	}
	if o.StartTime != nil {
		objectMap["startTime"] = o.StartTime
	}
	if o.UserScopeFilterURI != nil {
		objectMap["userScopeFilterUri"] = o.UserScopeFilterURI
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Source.
func (o *Office365Source) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowedGroups":
			if val != nil {
				err = json.Unmarshal(*val, &o.AllowedGroups)
			}
			delete(rawMsg, key)
		case "dateFilterColumn":
			if val != nil {
				err = json.Unmarshal(*val, &o.DateFilterColumn)
			}
			delete(rawMsg, key)
		case "endTime":
			if val != nil {
				err = json.Unmarshal(*val, &o.EndTime)
			}
			delete(rawMsg, key)
		case "outputColumns":
			if val != nil {
				err = json.Unmarshal(*val, &o.OutputColumns)
			}
			delete(rawMsg, key)
		case "startTime":
			if val != nil {
				err = json.Unmarshal(*val, &o.StartTime)
			}
			delete(rawMsg, key)
		case "userScopeFilterUri":
			if val != nil {
				err = json.Unmarshal(*val, &o.UserScopeFilterURI)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySource.unmarshalInternal(rawMsg)
}

// Oracle database.
type OracleLinkedService struct {
	LinkedService
	// Oracle database linked service properties.
	TypeProperties *OracleLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleLinkedService.
func (o OracleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("Oracle")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleLinkedService.
func (o *OracleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.LinkedService.unmarshalInternal(rawMsg)
}

// Oracle database linked service properties.
type OracleLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// The settings that will be leveraged for Oracle source partitioning.
type OraclePartitionSettings struct {
	// The name of the column in integer type that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
	PartitionColumnName *interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionLowerBound *interface{} `json:"partitionLowerBound,omitempty"`

	// Names of the physical partitions of Oracle table.
	PartitionNames *interface{} `json:"partitionNames,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionUpperBound *interface{} `json:"partitionUpperBound,omitempty"`
}

// Oracle Service Cloud linked service.
type OracleServiceCloudLinkedService struct {
	LinkedService
	// Oracle Service Cloud linked service properties.
	TypeProperties *OracleServiceCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudLinkedService.
func (o OracleServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("OracleServiceCloud")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedService.
func (o *OracleServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.LinkedService.unmarshalInternal(rawMsg)
}

// Oracle Service Cloud linked service properties.
type OracleServiceCloudLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Oracle Service Cloud instance.
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the username key.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true. Type: boolean (or Expression with
	// resultType boolean).
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name that you use to access Oracle Service Cloud server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedServiceTypeProperties.
func (o *OracleServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &o.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				o.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &o.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &o.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &o.UsePeerVerification)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &o.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Oracle Service Cloud dataset.
type OracleServiceCloudObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudObjectDataset.
func (o OracleServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("OracleServiceCloudObject")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudObjectDataset.
func (o *OracleServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Oracle Service Cloud source.
type OracleServiceCloudSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudSource.
func (o OracleServiceCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := o.TabularSource.marshalInternal("OracleServiceCloudSource")
	if o.Query != nil {
		objectMap["query"] = o.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudSource.
func (o *OracleServiceCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &o.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.TabularSource.unmarshalInternal(rawMsg)
}

// A copy activity Oracle sink.
type OracleSink struct {
	CopySink
	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleSink.
func (o OracleSink) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySink.marshalInternal("OracleSink")
	if o.PreCopyScript != nil {
		objectMap["preCopyScript"] = o.PreCopyScript
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSink.
func (o *OracleSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &o.PreCopyScript)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Oracle source.
type OracleSource struct {
	CopySource
	// Oracle reader query. Type: string (or Expression with resultType string).
	OracleReaderQuery *interface{} `json:"oracleReaderQuery,omitempty"`

	// The partition mechanism that will be used for Oracle read in parallel.
	PartitionOption *OraclePartitionOption `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for Oracle source partitioning.
	PartitionSettings *OraclePartitionSettings `json:"partitionSettings,omitempty"`

	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout *interface{} `json:"queryTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleSource.
func (o OracleSource) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySource.marshalInternal("OracleSource")
	if o.OracleReaderQuery != nil {
		objectMap["oracleReaderQuery"] = o.OracleReaderQuery
	}
	if o.PartitionOption != nil {
		objectMap["partitionOption"] = o.PartitionOption
	}
	if o.PartitionSettings != nil {
		objectMap["partitionSettings"] = o.PartitionSettings
	}
	if o.QueryTimeout != nil {
		objectMap["queryTimeout"] = o.QueryTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleSource.
func (o *OracleSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "oracleReaderQuery":
			if val != nil {
				err = json.Unmarshal(*val, &o.OracleReaderQuery)
			}
			delete(rawMsg, key)
		case "partitionOption":
			if val != nil {
				err = json.Unmarshal(*val, &o.PartitionOption)
			}
			delete(rawMsg, key)
		case "partitionSettings":
			if val != nil {
				err = json.Unmarshal(*val, &o.PartitionSettings)
			}
			delete(rawMsg, key)
		case "queryTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &o.QueryTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySource.unmarshalInternal(rawMsg)
}

// The on-premises Oracle database dataset.
type OracleTableDataset struct {
	Dataset
	// On-premises Oracle dataset properties.
	TypeProperties *OracleTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleTableDataset.
func (o OracleTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("OracleTable")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleTableDataset.
func (o *OracleTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.Dataset.unmarshalInternal(rawMsg)
}

// On-premises Oracle dataset properties.
type OracleTableDatasetTypeProperties struct {
	// The schema name of the on-premises Oracle database. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// ORC dataset.
type OrcDataset struct {
	Dataset
	// ORC dataset properties.
	TypeProperties *OrcDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OrcDataset.
func (o OrcDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("Orc")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDataset.
func (o *OrcDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.Dataset.unmarshalInternal(rawMsg)
}

// ORC dataset properties.
type OrcDatasetTypeProperties struct {
	// The location of the ORC data storage.
	Location            DatasetLocationClassification `json:"location,omitempty"`
	OrcCompressionCodec *OrcCompressionCodec          `json:"orcCompressionCodec,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDatasetTypeProperties.
func (o *OrcDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			if val != nil {
				o.Location, err = unmarshalDatasetLocationClassification(*val)
			}
			delete(rawMsg, key)
		case "orcCompressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &o.OrcCompressionCodec)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The data stored in Optimized Row Columnar (ORC) format.
type OrcFormat struct {
	DatasetStorageFormat
}

// MarshalJSON implements the json.Marshaller interface for type OrcFormat.
func (o OrcFormat) MarshalJSON() ([]byte, error) {
	objectMap := o.DatasetStorageFormat.marshalInternal("OrcFormat")
	return json.Marshal(objectMap)
}

// A copy activity ORC sink.
type OrcSink struct {
	CopySink
	// ORC store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OrcSink.
func (o OrcSink) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySink.marshalInternal("OrcSink")
	if o.StoreSettings != nil {
		objectMap["storeSettings"] = o.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcSink.
func (o *OrcSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				o.StoreSettings, err = unmarshalStoreWriteSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity ORC source.
type OrcSource struct {
	CopySource
	// ORC store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OrcSource.
func (o OrcSource) MarshalJSON() ([]byte, error) {
	objectMap := o.CopySource.marshalInternal("OrcSource")
	if o.StoreSettings != nil {
		objectMap["storeSettings"] = o.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcSource.
func (o *OrcSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				o.StoreSettings, err = unmarshalStoreReadSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return o.CopySource.unmarshalInternal(rawMsg)
}

// Definition of a single parameter for an entity.
type ParameterSpecification struct {
	// Default value of parameter.
	DefaultValue *interface{} `json:"defaultValue,omitempty"`

	// Parameter type.
	Type *ParameterType `json:"type,omitempty"`
}

// Parquet dataset.
type ParquetDataset struct {
	Dataset
	// Parquet dataset properties.
	TypeProperties *ParquetDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParquetDataset.
func (p ParquetDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("Parquet")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDataset.
func (p *ParquetDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.Dataset.unmarshalInternal(rawMsg)
}

// Parquet dataset properties.
type ParquetDatasetTypeProperties struct {
	CompressionCodec *ParquetCompressionCodec `json:"compressionCodec,omitempty"`

	// The location of the parquet storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDatasetTypeProperties.
func (p *ParquetDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &p.CompressionCodec)
			}
			delete(rawMsg, key)
		case "location":
			if val != nil {
				p.Location, err = unmarshalDatasetLocationClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The data stored in Parquet format.
type ParquetFormat struct {
	DatasetStorageFormat
}

// MarshalJSON implements the json.Marshaller interface for type ParquetFormat.
func (p ParquetFormat) MarshalJSON() ([]byte, error) {
	objectMap := p.DatasetStorageFormat.marshalInternal("ParquetFormat")
	return json.Marshal(objectMap)
}

// A copy activity Parquet sink.
type ParquetSink struct {
	CopySink
	// Parquet store settings.
	StoreSettings StoreWriteSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSink.
func (p ParquetSink) MarshalJSON() ([]byte, error) {
	objectMap := p.CopySink.marshalInternal("ParquetSink")
	if p.StoreSettings != nil {
		objectMap["storeSettings"] = p.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSink.
func (p *ParquetSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				p.StoreSettings, err = unmarshalStoreWriteSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Parquet source.
type ParquetSource struct {
	CopySource
	// Parquet store settings.
	StoreSettings StoreReadSettingsClassification `json:"storeSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParquetSource.
func (p ParquetSource) MarshalJSON() ([]byte, error) {
	objectMap := p.CopySource.marshalInternal("ParquetSource")
	if p.StoreSettings != nil {
		objectMap["storeSettings"] = p.StoreSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetSource.
func (p *ParquetSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeSettings":
			if val != nil {
				p.StoreSettings, err = unmarshalStoreReadSettingsClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.CopySource.unmarshalInternal(rawMsg)
}

// Paypal Service linked service.
type PaypalLinkedService struct {
	LinkedService
	// Paypal Service linked service properties.
	TypeProperties *PaypalLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaypalLinkedService.
func (p PaypalLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("Paypal")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedService.
func (p *PaypalLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.LinkedService.unmarshalInternal(rawMsg)
}

// Paypal Service linked service properties.
type PaypalLinkedServiceTypeProperties struct {
	// The client ID associated with your PayPal application.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with your PayPal application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the PayPal instance. (i.e. api.sandbox.paypal.com)
	Host *interface{} `json:"host,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedServiceTypeProperties.
func (p *PaypalLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &p.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				p.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &p.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &p.Host)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &p.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Paypal Service dataset.
type PaypalObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaypalObjectDataset.
func (p PaypalObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PaypalObject")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalObjectDataset.
func (p *PaypalObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Paypal Service source.
type PaypalSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaypalSource.
func (p PaypalSource) MarshalJSON() ([]byte, error) {
	objectMap := p.TabularSource.marshalInternal("PaypalSource")
	if p.Query != nil {
		objectMap["query"] = p.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalSource.
func (p *PaypalSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &p.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.TabularSource.unmarshalInternal(rawMsg)
}

// Phoenix Dataset Properties
type PhoenixDatasetTypeProperties struct {
	// The schema name of the Phoenix. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Phoenix. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Phoenix server linked service.
type PhoenixLinkedService struct {
	LinkedService
	// Phoenix server linked service properties.
	TypeProperties *PhoenixLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixLinkedService.
func (p PhoenixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("Phoenix")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedService.
func (p *PhoenixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.LinkedService.unmarshalInternal(rawMsg)
}

// Phoenix server linked service properties.
type PhoenixLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication mechanism used to connect to the Phoenix server.
	AuthenticationType *PhoenixAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix if using WindowsAzureHDInsightService.
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
	Port *interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to connect to the Phoenix server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedServiceTypeProperties.
func (p *PhoenixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowHostNameCnMismatch)
			}
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &p.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &p.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &p.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &p.HTTPPath)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &p.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				p.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &p.Port)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &p.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &p.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Phoenix server dataset.
type PhoenixObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *PhoenixDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixObjectDataset.
func (p PhoenixObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PhoenixObject")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixObjectDataset.
func (p *PhoenixObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Phoenix server source.
type PhoenixSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixSource.
func (p PhoenixSource) MarshalJSON() ([]byte, error) {
	objectMap := p.TabularSource.marshalInternal("PhoenixSource")
	if p.Query != nil {
		objectMap["query"] = p.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixSource.
func (p *PhoenixSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &p.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.TabularSource.unmarshalInternal(rawMsg)
}

// A workspace pipeline.
type Pipeline struct {
	// List of activities in pipeline.
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// List of tags that can be used for describing the Pipeline.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// The max number of concurrent runs for the pipeline.
	Concurrency *int32 `json:"concurrency,omitempty"`

	// The description of the pipeline.
	Description *string `json:"description,omitempty"`

	// The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
	Folder *PipelineFolder `json:"folder,omitempty"`

	// List of parameters for pipeline.
	Parameters *map[string]ParameterSpecification `json:"parameters,omitempty"`

	// Dimensions emitted by Pipeline.
	RunDimensions *map[string]interface{} `json:"runDimensions,omitempty"`

	// List of variables for pipeline.
	Variables *map[string]VariableSpecification `json:"variables,omitempty"`
}

// PipelineCreateOrUpdatePipelineOptions contains the optional parameters for the Pipeline.CreateOrUpdatePipeline method.
type PipelineCreateOrUpdatePipelineOptions struct {
	// ETag of the pipeline entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// PipelineCreatePipelineRunOptions contains the optional parameters for the Pipeline.CreatePipelineRun method.
type PipelineCreatePipelineRunOptions struct {
	// Recovery mode flag. If recovery mode is set to true, the specified referenced pipeline run and the new run will be grouped under the same groupId.
	IsRecovery *bool
	// Parameters of the pipeline run. These parameters will be used only if the runId is not specified.
	Parameters *map[string]interface{}
	// The pipeline run identifier. If run ID is specified the parameters of the specified run will be used to create a new run.
	ReferencePipelineRunId *string
	// In recovery mode, the rerun will start from this activity. If not specified, all activities will run.
	StartActivityName *string
}

// PipelineDeletePipelineOptions contains the optional parameters for the Pipeline.DeletePipeline method.
type PipelineDeletePipelineOptions struct {
	// placeholder for future optional parameters
}

// The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
type PipelineFolder struct {
	// The name of the folder that this Pipeline is in.
	Name *string `json:"name,omitempty"`
}

// PipelineGetPipelineOptions contains the optional parameters for the Pipeline.GetPipeline method.
type PipelineGetPipelineOptions struct {
	// ETag of the pipeline entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will
	// be returned.
	IfNoneMatch *string
}

// PipelineGetPipelinesByWorkspaceOptions contains the optional parameters for the Pipeline.GetPipelinesByWorkspace method.
type PipelineGetPipelinesByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// A list of pipeline resources.
type PipelineListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of pipelines.
	Value *[]PipelineResource `json:"value,omitempty"`
}

// PipelineListResponseResponse is the response envelope for operations that return a PipelineListResponse type.
type PipelineListResponseResponse struct {
	// A list of pipeline resources.
	PipelineListResponse *PipelineListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Pipeline reference type.
type PipelineReference struct {
	// Reference name.
	Name *string `json:"name,omitempty"`

	// Reference pipeline name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Pipeline reference type.
	Type *PipelineReferenceType `json:"type,omitempty"`
}

// Pipeline resource type.
type PipelineResource struct {
	AzureEntityResource
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Properties of the pipeline.
	Properties *Pipeline `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineResource.
func (p PipelineResource) MarshalJSON() ([]byte, error) {
	objectMap := p.AzureEntityResource.marshalInternal()
	if p.Properties != nil {
		objectMap["properties"] = p.Properties
	}
	if p.AdditionalProperties != nil {
		for key, val := range *p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineResource.
func (p *PipelineResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				err = json.Unmarshal(*val, &p.Properties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.AzureEntityResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		if p.AdditionalProperties == nil {
			p.AdditionalProperties = &map[string]interface{}{}
		}
		if val != nil {
			var aux interface{}
			err = json.Unmarshal(*val, &aux)
			(*p.AdditionalProperties)[key] = aux
		}
		delete(rawMsg, key)
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineResourcePollerResponse is the response envelope for operations that asynchronously return a PipelineResource type.
type PipelineResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*PipelineResourceResponse, error)

	// Poller contains an initialized poller.
	Poller PipelineResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineResourceResponse is the response envelope for operations that return a PipelineResource type.
type PipelineResourceResponse struct {
	// Pipeline resource type.
	PipelineResource *PipelineResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Information about a pipeline run.
type PipelineRun struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The duration of a pipeline run.
	DurationInMS *int32 `json:"durationInMs,omitempty" azure:"ro"`

	// Entity that started the pipeline run.
	InvokedBy *PipelineRunInvokedBy `json:"invokedBy,omitempty" azure:"ro"`

	// Indicates if the recovered pipeline run is the latest in its group.
	IsLatest *bool `json:"isLatest,omitempty" azure:"ro"`

	// The last updated timestamp for the pipeline run event in ISO8601 format.
	LastUpdated *time.Time `json:"lastUpdated,omitempty" azure:"ro"`

	// The message from a pipeline run.
	Message *string `json:"message,omitempty" azure:"ro"`

	// The full or partial list of parameter name, value pair used in the pipeline run.
	Parameters *map[string]string `json:"parameters,omitempty" azure:"ro"`

	// The pipeline name.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// The end time of a pipeline run in ISO8601 format.
	RunEnd *time.Time `json:"runEnd,omitempty" azure:"ro"`

	// Identifier that correlates all the recovery runs of a pipeline run.
	RunGroupID *string `json:"runGroupId,omitempty" azure:"ro"`

	// Identifier of a run.
	RunID *string `json:"runId,omitempty" azure:"ro"`

	// The start time of a pipeline run in ISO8601 format.
	RunStart *time.Time `json:"runStart,omitempty" azure:"ro"`

	// The status of a pipeline run.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRun.
func (p PipelineRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.DurationInMS != nil {
		objectMap["durationInMs"] = p.DurationInMS
	}
	if p.InvokedBy != nil {
		objectMap["invokedBy"] = p.InvokedBy
	}
	if p.IsLatest != nil {
		objectMap["isLatest"] = p.IsLatest
	}
	if p.LastUpdated != nil {
		objectMap["lastUpdated"] = (*timeRFC3339)(p.LastUpdated)
	}
	if p.Message != nil {
		objectMap["message"] = p.Message
	}
	if p.Parameters != nil {
		objectMap["parameters"] = p.Parameters
	}
	if p.PipelineName != nil {
		objectMap["pipelineName"] = p.PipelineName
	}
	if p.RunEnd != nil {
		objectMap["runEnd"] = (*timeRFC3339)(p.RunEnd)
	}
	if p.RunGroupID != nil {
		objectMap["runGroupId"] = p.RunGroupID
	}
	if p.RunID != nil {
		objectMap["runId"] = p.RunID
	}
	if p.RunStart != nil {
		objectMap["runStart"] = (*timeRFC3339)(p.RunStart)
	}
	if p.Status != nil {
		objectMap["status"] = p.Status
	}
	if p.AdditionalProperties != nil {
		for key, val := range *p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRun.
func (p *PipelineRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "durationInMs":
			if val != nil {
				err = json.Unmarshal(*val, &p.DurationInMS)
			}
			delete(rawMsg, key)
		case "invokedBy":
			if val != nil {
				err = json.Unmarshal(*val, &p.InvokedBy)
			}
			delete(rawMsg, key)
		case "isLatest":
			if val != nil {
				err = json.Unmarshal(*val, &p.IsLatest)
			}
			delete(rawMsg, key)
		case "lastUpdated":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				p.LastUpdated = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "message":
			if val != nil {
				err = json.Unmarshal(*val, &p.Message)
			}
			delete(rawMsg, key)
		case "parameters":
			if val != nil {
				err = json.Unmarshal(*val, &p.Parameters)
			}
			delete(rawMsg, key)
		case "pipelineName":
			if val != nil {
				err = json.Unmarshal(*val, &p.PipelineName)
			}
			delete(rawMsg, key)
		case "runEnd":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				p.RunEnd = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "runGroupId":
			if val != nil {
				err = json.Unmarshal(*val, &p.RunGroupID)
			}
			delete(rawMsg, key)
		case "runId":
			if val != nil {
				err = json.Unmarshal(*val, &p.RunID)
			}
			delete(rawMsg, key)
		case "runStart":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				p.RunStart = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "status":
			if val != nil {
				err = json.Unmarshal(*val, &p.Status)
			}
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*p.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineRunCancelPipelineRunOptions contains the optional parameters for the PipelineRun.CancelPipelineRun method.
type PipelineRunCancelPipelineRunOptions struct {
	// If true, cancel all the Child pipelines that are triggered by the current pipeline.
	IsRecursive *bool
}

// PipelineRunGetPipelineRunOptions contains the optional parameters for the PipelineRun.GetPipelineRun method.
type PipelineRunGetPipelineRunOptions struct {
	// placeholder for future optional parameters
}

// Provides entity name and id that started the pipeline run.
type PipelineRunInvokedBy struct {
	// The ID of the entity that started the run.
	ID *string `json:"id,omitempty" azure:"ro"`

	// The type of the entity that started the run.
	InvokedByType *string `json:"invokedByType,omitempty" azure:"ro"`

	// Name of the entity that started the pipeline run.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// PipelineRunQueryActivityRunsOptions contains the optional parameters for the PipelineRun.QueryActivityRuns method.
type PipelineRunQueryActivityRunsOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunQueryPipelineRunsByWorkspaceOptions contains the optional parameters for the PipelineRun.QueryPipelineRunsByWorkspace method.
type PipelineRunQueryPipelineRunsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// PipelineRunResponse is the response envelope for operations that return a PipelineRun type.
type PipelineRunResponse struct {
	// Information about a pipeline run.
	PipelineRun *PipelineRun

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// A list pipeline runs.
type PipelineRunsQueryResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of pipeline runs.
	Value *[]PipelineRun `json:"value,omitempty"`
}

// PipelineRunsQueryResponseResponse is the response envelope for operations that return a PipelineRunsQueryResponse type.
type PipelineRunsQueryResponseResponse struct {
	// A list pipeline runs.
	PipelineRunsQueryResponse *PipelineRunsQueryResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelinesRenameOptions contains the optional parameters for the Pipelines.Rename method.
type PipelinesRenameOptions struct {
	// placeholder for future optional parameters
}

// PolyBase settings.
type PolybaseSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Determines the number of rows to attempt to retrieve before the PolyBase recalculates the percentage of rejected rows. Type: integer (or Expression with
	// resultType integer), minimum: 0.
	RejectSampleValue *interface{} `json:"rejectSampleValue,omitempty"`

	// Reject type.
	RejectType *PolybaseSettingsRejectType `json:"rejectType,omitempty"`

	// Specifies the value or the percentage of rows that can be rejected before the query fails. Type: number (or Expression with resultType number), minimum:
	// 0.
	RejectValue *interface{} `json:"rejectValue,omitempty"`

	// Specifies how to handle missing values in delimited text files when PolyBase retrieves data from the text file. Type: boolean (or Expression with resultType
	// boolean).
	UseTypeDefault *interface{} `json:"useTypeDefault,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PolybaseSettings.
func (p PolybaseSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.RejectSampleValue != nil {
		objectMap["rejectSampleValue"] = p.RejectSampleValue
	}
	if p.RejectType != nil {
		objectMap["rejectType"] = p.RejectType
	}
	if p.RejectValue != nil {
		objectMap["rejectValue"] = p.RejectValue
	}
	if p.UseTypeDefault != nil {
		objectMap["useTypeDefault"] = p.UseTypeDefault
	}
	if p.AdditionalProperties != nil {
		for key, val := range *p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolybaseSettings.
func (p *PolybaseSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rejectSampleValue":
			if val != nil {
				err = json.Unmarshal(*val, &p.RejectSampleValue)
			}
			delete(rawMsg, key)
		case "rejectType":
			if val != nil {
				err = json.Unmarshal(*val, &p.RejectType)
			}
			delete(rawMsg, key)
		case "rejectValue":
			if val != nil {
				err = json.Unmarshal(*val, &p.RejectValue)
			}
			delete(rawMsg, key)
		case "useTypeDefault":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseTypeDefault)
			}
			delete(rawMsg, key)
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*p.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Linked service for PostgreSQL data source.
type PostgreSQLLinkedService struct {
	LinkedService
	// PostgreSQL linked service properties.
	TypeProperties *PostgreSQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLLinkedService.
func (p PostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("PostgreSql")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLLinkedService.
func (p *PostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.LinkedService.unmarshalInternal(rawMsg)
}

// PostgreSQL linked service properties.
type PostgreSQLLinkedServiceTypeProperties struct {
	// The connection string.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// A copy activity source for PostgreSQL databases.
type PostgreSQLSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLSource.
func (p PostgreSQLSource) MarshalJSON() ([]byte, error) {
	objectMap := p.TabularSource.marshalInternal("PostgreSqlSource")
	if p.Query != nil {
		objectMap["query"] = p.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLSource.
func (p *PostgreSQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &p.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.TabularSource.unmarshalInternal(rawMsg)
}

// The PostgreSQL table dataset.
type PostgreSQLTableDataset struct {
	Dataset
	// PostgreSQL table dataset properties.
	TypeProperties *PostgreSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLTableDataset.
func (p PostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PostgreSqlTable")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLTableDataset.
func (p *PostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.Dataset.unmarshalInternal(rawMsg)
}

// PostgreSQL table dataset properties.
type PostgreSQLTableDatasetTypeProperties struct {
	// The PostgreSQL schema name. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The PostgreSQL table name. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Presto Dataset Properties
type PrestoDatasetTypeProperties struct {
	// The schema name of the Presto. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Presto. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Presto server linked service.
type PrestoLinkedService struct {
	LinkedService
	// Presto server linked service properties.
	TypeProperties *PrestoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrestoLinkedService.
func (p PrestoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("Presto")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedService.
func (p *PrestoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.LinkedService.unmarshalInternal(rawMsg)
}

// Presto server linked service properties.
type PrestoLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication mechanism used to connect to the Presto server.
	AuthenticationType *PrestoAuthenticationType `json:"authenticationType,omitempty"`

	// The catalog context for all request against the server.
	Catalog *interface{} `json:"catalog,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The IP address or host name of the Presto server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
	Port *interface{} `json:"port,omitempty"`

	// The version of the Presto server. (i.e. 0.148-t)
	ServerVersion *interface{} `json:"serverVersion,omitempty"`

	// The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database. The default value is the system
	// time zone.
	TimeZoneID *interface{} `json:"timeZoneID,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to connect to the Presto server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedServiceTypeProperties.
func (p *PrestoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowHostNameCnMismatch)
			}
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &p.AuthenticationType)
			}
			delete(rawMsg, key)
		case "catalog":
			if val != nil {
				err = json.Unmarshal(*val, &p.Catalog)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &p.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &p.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &p.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				p.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &p.Port)
			}
			delete(rawMsg, key)
		case "serverVersion":
			if val != nil {
				err = json.Unmarshal(*val, &p.ServerVersion)
			}
			delete(rawMsg, key)
		case "timeZoneID":
			if val != nil {
				err = json.Unmarshal(*val, &p.TimeZoneID)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &p.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &p.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Presto server dataset.
type PrestoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *PrestoDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrestoObjectDataset.
func (p PrestoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PrestoObject")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoObjectDataset.
func (p *PrestoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Presto server source.
type PrestoSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrestoSource.
func (p PrestoSource) MarshalJSON() ([]byte, error) {
	objectMap := p.TabularSource.marshalInternal("PrestoSource")
	if p.Query != nil {
		objectMap["query"] = p.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoSource.
func (p *PrestoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &p.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return p.TabularSource.unmarshalInternal(rawMsg)
}

// Private endpoint details
type PrivateEndpoint struct {
	// Resource id of the private endpoint.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// A private endpoint connection
type PrivateEndpointConnection struct {
	Resource
	// Private endpoint connection properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// Properties of a private endpoint connection.
type PrivateEndpointConnectionProperties struct {
	// The private endpoint which the connection belongs to.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// Connection state of the private endpoint connection.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// Provisioning state of the private endpoint connection.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// Connection state details of the private endpoint
type PrivateLinkServiceConnectionState struct {
	// The actions required for private link service connection.
	ActionsRequired *string `json:"actionsRequired,omitempty" azure:"ro"`

	// The private link service connection description.
	Description *string `json:"description,omitempty"`

	// The private link service connection status.
	Status *string `json:"status,omitempty"`
}

// The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location
type ProxyResource struct {
	Resource
}

// A list of active debug sessions.
type QueryDataFlowDebugSessionsResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// Array with all active debug sessions.
	Value *[]DataFlowDebugSessionInfo `json:"value,omitempty"`
}

// QueryDataFlowDebugSessionsResponseResponse is the response envelope for operations that return a QueryDataFlowDebugSessionsResponse type.
type QueryDataFlowDebugSessionsResponseResponse struct {
	// A list of active debug sessions.
	QueryDataFlowDebugSessionsResponse *QueryDataFlowDebugSessionsResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// QuickBooks server linked service.
type QuickBooksLinkedService struct {
	LinkedService
	// QuickBooks server linked service properties.
	TypeProperties *QuickBooksLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksLinkedService.
func (q QuickBooksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := q.LinkedService.marshalInternal("QuickBooks")
	if q.TypeProperties != nil {
		objectMap["typeProperties"] = q.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedService.
func (q *QuickBooksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &q.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return q.LinkedService.unmarshalInternal(rawMsg)
}

// QuickBooks server linked service properties.
type QuickBooksLinkedServiceTypeProperties struct {
	// The access token for OAuth 1.0 authentication.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The access token secret for OAuth 1.0 authentication.
	AccessTokenSecret SecretBaseClassification `json:"accessTokenSecret,omitempty"`

	// The company ID of the QuickBooks company to authorize.
	CompanyID *interface{} `json:"companyId,omitempty"`

	// The consumer key for OAuth 1.0 authentication.
	ConsumerKey *interface{} `json:"consumerKey,omitempty"`

	// The consumer secret for OAuth 1.0 authentication.
	ConsumerSecret SecretBaseClassification `json:"consumerSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedServiceTypeProperties.
func (q *QuickBooksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				q.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "accessTokenSecret":
			if val != nil {
				q.AccessTokenSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "companyId":
			if val != nil {
				err = json.Unmarshal(*val, &q.CompanyID)
			}
			delete(rawMsg, key)
		case "consumerKey":
			if val != nil {
				err = json.Unmarshal(*val, &q.ConsumerKey)
			}
			delete(rawMsg, key)
		case "consumerSecret":
			if val != nil {
				q.ConsumerSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &q.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &q.Endpoint)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &q.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QuickBooks server dataset.
type QuickBooksObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksObjectDataset.
func (q QuickBooksObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := q.Dataset.marshalInternal("QuickBooksObject")
	if q.TypeProperties != nil {
		objectMap["typeProperties"] = q.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksObjectDataset.
func (q *QuickBooksObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &q.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return q.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity QuickBooks server source.
type QuickBooksSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksSource.
func (q QuickBooksSource) MarshalJSON() ([]byte, error) {
	objectMap := q.TabularSource.marshalInternal("QuickBooksSource")
	if q.Query != nil {
		objectMap["query"] = q.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksSource.
func (q *QuickBooksSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &q.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return q.TabularSource.unmarshalInternal(rawMsg)
}

// The recurrence schedule.
type RecurrenceSchedule struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The hours.
	Hours *[]int32 `json:"hours,omitempty"`

	// The minutes.
	Minutes *[]int32 `json:"minutes,omitempty"`

	// The month days.
	MonthDays *[]int32 `json:"monthDays,omitempty"`

	// The monthly occurrences.
	MonthlyOccurrences *[]RecurrenceScheduleOccurrence `json:"monthlyOccurrences,omitempty"`

	// The days of the week.
	WeekDays *[]DayOfWeek `json:"weekDays,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecurrenceSchedule.
func (r RecurrenceSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Hours != nil {
		objectMap["hours"] = r.Hours
	}
	if r.Minutes != nil {
		objectMap["minutes"] = r.Minutes
	}
	if r.MonthDays != nil {
		objectMap["monthDays"] = r.MonthDays
	}
	if r.MonthlyOccurrences != nil {
		objectMap["monthlyOccurrences"] = r.MonthlyOccurrences
	}
	if r.WeekDays != nil {
		objectMap["weekDays"] = r.WeekDays
	}
	if r.AdditionalProperties != nil {
		for key, val := range *r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecurrenceSchedule.
func (r *RecurrenceSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hours":
			if val != nil {
				err = json.Unmarshal(*val, &r.Hours)
			}
			delete(rawMsg, key)
		case "minutes":
			if val != nil {
				err = json.Unmarshal(*val, &r.Minutes)
			}
			delete(rawMsg, key)
		case "monthDays":
			if val != nil {
				err = json.Unmarshal(*val, &r.MonthDays)
			}
			delete(rawMsg, key)
		case "monthlyOccurrences":
			if val != nil {
				err = json.Unmarshal(*val, &r.MonthlyOccurrences)
			}
			delete(rawMsg, key)
		case "weekDays":
			if val != nil {
				err = json.Unmarshal(*val, &r.WeekDays)
			}
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*r.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The recurrence schedule occurrence.
type RecurrenceScheduleOccurrence struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The day of the week.
	Day *DayOfWeek `json:"day,omitempty"`

	// The occurrence.
	Occurrence *int32 `json:"occurrence,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RecurrenceScheduleOccurrence.
func (r RecurrenceScheduleOccurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Day != nil {
		objectMap["day"] = r.Day
	}
	if r.Occurrence != nil {
		objectMap["occurrence"] = r.Occurrence
	}
	if r.AdditionalProperties != nil {
		for key, val := range *r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecurrenceScheduleOccurrence.
func (r *RecurrenceScheduleOccurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "day":
			if val != nil {
				err = json.Unmarshal(*val, &r.Day)
			}
			delete(rawMsg, key)
		case "occurrence":
			if val != nil {
				err = json.Unmarshal(*val, &r.Occurrence)
			}
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*r.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Redirect incompatible row settings
type RedirectIncompatibleRowSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Name of the Azure Storage, Storage SAS, or Azure Data Lake Store linked service used for redirecting incompatible row. Must be specified if redirectIncompatibleRowSettings
	// is specified. Type: string
	// (or Expression with resultType string).
	LinkedServiceName *interface{} `json:"linkedServiceName,omitempty"`

	// The path for storing the redirect incompatible row data. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedirectIncompatibleRowSettings.
func (r RedirectIncompatibleRowSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = r.LinkedServiceName
	}
	if r.Path != nil {
		objectMap["path"] = r.Path
	}
	if r.AdditionalProperties != nil {
		for key, val := range *r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedirectIncompatibleRowSettings.
func (r *RedirectIncompatibleRowSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &r.LinkedServiceName)
			}
			delete(rawMsg, key)
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &r.Path)
			}
			delete(rawMsg, key)
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*r.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Amazon S3 settings needed for the interim Amazon S3 when copying from Amazon Redshift with unload. With this, data from Amazon Redshift source will
// be unloaded into S3 first and then copied into
// the targeted sink from the interim S3.
type RedshiftUnloadSettings struct {
	// The bucket of the interim Amazon S3 which will be used to store the unloaded data from Amazon Redshift source. The bucket must be in the same region
	// as the Amazon Redshift source. Type: string (or
	// Expression with resultType string).
	BucketName *interface{} `json:"bucketName,omitempty"`

	// The name of the Amazon S3 linked service which will be used for the unload operation when copying from the Amazon Redshift source.
	S3LinkedServiceName *LinkedServiceReference `json:"s3LinkedServiceName,omitempty"`
}

// A copy activity source for various relational databases.
type RelationalSource struct {
	CopySource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RelationalSource.
func (r RelationalSource) MarshalJSON() ([]byte, error) {
	objectMap := r.CopySource.marshalInternal("RelationalSource")
	if r.Query != nil {
		objectMap["query"] = r.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalSource.
func (r *RelationalSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &r.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.CopySource.unmarshalInternal(rawMsg)
}

// The relational table dataset.
type RelationalTableDataset struct {
	Dataset
	// Relational table dataset properties.
	TypeProperties *RelationalTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RelationalTableDataset.
func (r RelationalTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := r.Dataset.marshalInternal("RelationalTable")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalTableDataset.
func (r *RelationalTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.Dataset.unmarshalInternal(rawMsg)
}

// Relational table dataset properties.
type RelationalTableDatasetTypeProperties struct {
	// The relational table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// A list of rerun triggers.
type RerunTriggerListResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// List of rerun triggers.
	Value *[]RerunTriggerResource `json:"value,omitempty"`
}

// RerunTrigger resource type.
type RerunTriggerResource struct {
	AzureEntityResource
	// Properties of the rerun trigger.
	Properties *RerunTumblingWindowTrigger `json:"properties,omitempty"`
}

// Trigger that schedules pipeline reruns for all fixed time interval windows from a requested start time to requested end time.
type RerunTumblingWindowTrigger struct {
	Trigger
	// Rerun Trigger properties.
	TypeProperties *RerunTumblingWindowTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTrigger.
func (r RerunTumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := r.Trigger.marshalInternal("RerunTumblingWindowTrigger")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTrigger.
func (r *RerunTumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.Trigger.unmarshalInternal(rawMsg)
}

// Rerun tumbling window trigger Parameters.
type RerunTumblingWindowTriggerActionParameters struct {
	// The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The max number of parallel time windows (ready for execution) for which a rerun is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTriggerActionParameters.
func (r RerunTumblingWindowTriggerActionParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.EndTime != nil {
		objectMap["endTime"] = (*timeRFC3339)(r.EndTime)
	}
	if r.MaxConcurrency != nil {
		objectMap["maxConcurrency"] = r.MaxConcurrency
	}
	if r.StartTime != nil {
		objectMap["startTime"] = (*timeRFC3339)(r.StartTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTriggerActionParameters.
func (r *RerunTumblingWindowTriggerActionParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.EndTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "maxConcurrency":
			if val != nil {
				err = json.Unmarshal(*val, &r.MaxConcurrency)
			}
			delete(rawMsg, key)
		case "startTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.StartTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Rerun Trigger properties.
type RerunTumblingWindowTriggerTypeProperties struct {
	// The max number of parallel time windows (ready for execution) for which a rerun is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// The parent trigger reference.
	ParentTrigger *interface{} `json:"parentTrigger,omitempty"`

	// The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
	RequestedEndTime *time.Time `json:"requestedEndTime,omitempty"`

	// The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
	RequestedStartTime *time.Time `json:"requestedStartTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r RerunTumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.MaxConcurrency != nil {
		objectMap["maxConcurrency"] = r.MaxConcurrency
	}
	if r.ParentTrigger != nil {
		objectMap["parentTrigger"] = r.ParentTrigger
	}
	if r.RequestedEndTime != nil {
		objectMap["requestedEndTime"] = (*timeRFC3339)(r.RequestedEndTime)
	}
	if r.RequestedStartTime != nil {
		objectMap["requestedStartTime"] = (*timeRFC3339)(r.RequestedStartTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r *RerunTumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxConcurrency":
			if val != nil {
				err = json.Unmarshal(*val, &r.MaxConcurrency)
			}
			delete(rawMsg, key)
		case "parentTrigger":
			if val != nil {
				err = json.Unmarshal(*val, &r.ParentTrigger)
			}
			delete(rawMsg, key)
		case "requestedEndTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.RequestedEndTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "requestedStartTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.RequestedStartTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty" azure:"ro"`
}

func (r Resource) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	if r.ID != nil {
		objectMap["id"] = r.ID
	}
	if r.Name != nil {
		objectMap["name"] = r.Name
	}
	if r.Type != nil {
		objectMap["type"] = r.Type
	}
	return objectMap
}

func (r *Resource) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			if val != nil {
				err = json.Unmarshal(*val, &r.ID)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &r.Name)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &r.Type)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Responsys linked service.
type ResponsysLinkedService struct {
	LinkedService
	// Responsys linked service properties.
	TypeProperties *ResponsysLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysLinkedService.
func (r ResponsysLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := r.LinkedService.marshalInternal("Responsys")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedService.
func (r *ResponsysLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.LinkedService.unmarshalInternal(rawMsg)
}

// Responsys linked service properties.
type ResponsysLinkedServiceTypeProperties struct {
	// The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Responsys server.
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true. Type: boolean (or Expression with
	// resultType boolean).
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedServiceTypeProperties.
func (r *ResponsysLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &r.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				r.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &r.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &r.Endpoint)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &r.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &r.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &r.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Responsys dataset.
type ResponsysObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysObjectDataset.
func (r ResponsysObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := r.Dataset.marshalInternal("ResponsysObject")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysObjectDataset.
func (r *ResponsysObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Responsys source.
type ResponsysSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysSource.
func (r ResponsysSource) MarshalJSON() ([]byte, error) {
	objectMap := r.TabularSource.marshalInternal("ResponsysSource")
	if r.Query != nil {
		objectMap["query"] = r.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysSource.
func (r *ResponsysSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &r.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.TabularSource.unmarshalInternal(rawMsg)
}

// A Rest service dataset.
type RestResourceDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *RestResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestResourceDataset.
func (r RestResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := r.Dataset.marshalInternal("RestResource")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestResourceDataset.
func (r *RestResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.Dataset.unmarshalInternal(rawMsg)
}

// Properties specific to this dataset type.
type RestResourceDatasetTypeProperties struct {
	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders *interface{} `json:"additionalHeaders,omitempty"`

	// The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
	PaginationRules *interface{} `json:"paginationRules,omitempty"`

	// The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
	RelativeURL *interface{} `json:"relativeUrl,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody *interface{} `json:"requestBody,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod *interface{} `json:"requestMethod,omitempty"`
}

// Rest Service linked service.
type RestServiceLinkedService struct {
	LinkedService
	// Rest Service linked service properties.
	TypeProperties *RestServiceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestServiceLinkedService.
func (r RestServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := r.LinkedService.marshalInternal("RestService")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedService.
func (r *RestServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.LinkedService.unmarshalInternal(rawMsg)
}

// Rest Service linked service properties.
type RestServiceLinkedServiceTypeProperties struct {
	// The resource you are requesting authorization to use.
	AadResourceID *interface{} `json:"aadResourceId,omitempty"`

	// Type of authentication used to connect to the REST service.
	AuthenticationType *RestServiceAuthenticationType `json:"authenticationType,omitempty"`

	// Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	EnableServerCertificateValidation *interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password used in Basic authentication type.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The application's client ID used in AadServicePrincipal authentication type.
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The application's key used in AadServicePrincipal authentication type.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application resides.
	Tenant *interface{} `json:"tenant,omitempty"`

	// The base URL of the REST service.
	URL *interface{} `json:"url,omitempty"`

	// The user name used in Basic authentication type.
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedServiceTypeProperties.
func (r *RestServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			if val != nil {
				err = json.Unmarshal(*val, &r.AadResourceID)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &r.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableServerCertificateValidation":
			if val != nil {
				err = json.Unmarshal(*val, &r.EnableServerCertificateValidation)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &r.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				r.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &r.ServicePrincipalID)
			}
			delete(rawMsg, key)
		case "servicePrincipalKey":
			if val != nil {
				r.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &r.Tenant)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &r.URL)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &r.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Rest service source.
type RestSource struct {
	CopySource
	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders *interface{} `json:"additionalHeaders,omitempty"`

	// The timeout (TimeSpan) to get an HTTP response. It is the timeout to get a response, not the timeout to read response data. Default value: 00:01:40.
	// Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	HTTPRequestTimeout *interface{} `json:"httpRequestTimeout,omitempty"`

	// The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
	PaginationRules *interface{} `json:"paginationRules,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody *interface{} `json:"requestBody,omitempty"`

	// The time to await before sending next page request.
	RequestInterval *interface{} `json:"requestInterval,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod *interface{} `json:"requestMethod,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestSource.
func (r RestSource) MarshalJSON() ([]byte, error) {
	objectMap := r.CopySource.marshalInternal("RestSource")
	if r.AdditionalHeaders != nil {
		objectMap["additionalHeaders"] = r.AdditionalHeaders
	}
	if r.HTTPRequestTimeout != nil {
		objectMap["httpRequestTimeout"] = r.HTTPRequestTimeout
	}
	if r.PaginationRules != nil {
		objectMap["paginationRules"] = r.PaginationRules
	}
	if r.RequestBody != nil {
		objectMap["requestBody"] = r.RequestBody
	}
	if r.RequestInterval != nil {
		objectMap["requestInterval"] = r.RequestInterval
	}
	if r.RequestMethod != nil {
		objectMap["requestMethod"] = r.RequestMethod
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestSource.
func (r *RestSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalHeaders":
			if val != nil {
				err = json.Unmarshal(*val, &r.AdditionalHeaders)
			}
			delete(rawMsg, key)
		case "httpRequestTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &r.HTTPRequestTimeout)
			}
			delete(rawMsg, key)
		case "paginationRules":
			if val != nil {
				err = json.Unmarshal(*val, &r.PaginationRules)
			}
			delete(rawMsg, key)
		case "requestBody":
			if val != nil {
				err = json.Unmarshal(*val, &r.RequestBody)
			}
			delete(rawMsg, key)
		case "requestInterval":
			if val != nil {
				err = json.Unmarshal(*val, &r.RequestInterval)
			}
			delete(rawMsg, key)
		case "requestMethod":
			if val != nil {
				err = json.Unmarshal(*val, &r.RequestMethod)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return r.CopySource.unmarshalInternal(rawMsg)
}

// Execution policy for an activity.
type RetryPolicy struct {
	// Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
	Count *interface{} `json:"count,omitempty"`

	// Interval between retries in seconds. Default is 30.
	IntervalInSeconds *int32 `json:"intervalInSeconds,omitempty"`
}

// Query parameters for listing runs.
type RunFilterParameters struct {
	// The continuation token for getting the next page of results. Null for first page.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of filters.
	Filters *[]RunQueryFilter `json:"filters,omitempty"`

	// The time at or after which the run event was updated in 'ISO 8601' format.
	LastUpdatedAfter *time.Time `json:"lastUpdatedAfter,omitempty"`

	// The time at or before which the run event was updated in 'ISO 8601' format.
	LastUpdatedBefore *time.Time `json:"lastUpdatedBefore,omitempty"`

	// List of OrderBy option.
	OrderBy *[]RunQueryOrderBy `json:"orderBy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunFilterParameters.
func (r RunFilterParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.ContinuationToken != nil {
		objectMap["continuationToken"] = r.ContinuationToken
	}
	if r.Filters != nil {
		objectMap["filters"] = r.Filters
	}
	if r.LastUpdatedAfter != nil {
		objectMap["lastUpdatedAfter"] = (*timeRFC3339)(r.LastUpdatedAfter)
	}
	if r.LastUpdatedBefore != nil {
		objectMap["lastUpdatedBefore"] = (*timeRFC3339)(r.LastUpdatedBefore)
	}
	if r.OrderBy != nil {
		objectMap["orderBy"] = r.OrderBy
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunFilterParameters.
func (r *RunFilterParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "continuationToken":
			if val != nil {
				err = json.Unmarshal(*val, &r.ContinuationToken)
			}
			delete(rawMsg, key)
		case "filters":
			if val != nil {
				err = json.Unmarshal(*val, &r.Filters)
			}
			delete(rawMsg, key)
		case "lastUpdatedAfter":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.LastUpdatedAfter = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "lastUpdatedBefore":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				r.LastUpdatedBefore = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "orderBy":
			if val != nil {
				err = json.Unmarshal(*val, &r.OrderBy)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Query filter option for listing runs.
type RunQueryFilter struct {
	// Parameter name to be used for filter. The allowed operands to query pipeline runs are PipelineName, RunStart, RunEnd and Status; to query activity runs
	// are ActivityName, ActivityRunStart,
	// ActivityRunEnd, ActivityType and Status, and to query trigger runs are TriggerName, TriggerRunTimestamp and Status.
	Operand *RunQueryFilterOperand `json:"operand,omitempty"`

	// Operator to be used for filter.
	Operator *RunQueryFilterOperator `json:"operator,omitempty"`

	// List of filter values.
	Values *[]string `json:"values,omitempty"`
}

// An object to provide order by options for listing runs.
type RunQueryOrderBy struct {
	// Sorting order of the parameter.
	Order *RunQueryOrder `json:"order,omitempty"`

	// Parameter name to be used for order by. The allowed parameters to order by for pipeline runs are PipelineName, RunStart, RunEnd and Status; for activity
	// runs are ActivityName, ActivityRunStart,
	// ActivityRunEnd and Status; for trigger runs are TriggerName, TriggerRunTimestamp and Status.
	OrderBy *RunQueryOrderByField `json:"orderBy,omitempty"`
}

// SQL pool SKU
type SKU struct {
	// If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`

	// The SKU name
	Name *string `json:"name,omitempty"`

	// The service tier
	Tier *string `json:"tier,omitempty"`
}

// The connection used to execute the SQL script.
type SQLConnection struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The identifier of the connection.
	Name *string `json:"name,omitempty"`

	// The type of the connection.
	Type *SQLConnectionType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLConnection.
func (s SQLConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	if s.Type != nil {
		objectMap["type"] = s.Type
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLConnection.
func (s *SQLConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &s.Name)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity SQL Data Warehouse sink.
type SQLDwSink struct {
	CopySink
	// Indicates to use Copy Command to copy data into SQL Data Warehouse. Type: boolean (or Expression with resultType boolean).
	AllowCopyCommand *interface{} `json:"allowCopyCommand,omitempty"`

	// Indicates to use PolyBase to copy data into SQL Data Warehouse when applicable. Type: boolean (or Expression with resultType boolean).
	AllowPolyBase *interface{} `json:"allowPolyBase,omitempty"`

	// Specifies Copy Command related settings when allowCopyCommand is true.
	CopyCommandSettings *DwCopyCommandSettings `json:"copyCommandSettings,omitempty"`

	// Specifies PolyBase-related settings when allowPolyBase is true.
	PolyBaseSettings *PolybaseSettings `json:"polyBaseSettings,omitempty"`

	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
	TableOption *interface{} `json:"tableOption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLDwSink.
func (s SQLDwSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SqlDWSink")
	if s.AllowCopyCommand != nil {
		objectMap["allowCopyCommand"] = s.AllowCopyCommand
	}
	if s.AllowPolyBase != nil {
		objectMap["allowPolyBase"] = s.AllowPolyBase
	}
	if s.CopyCommandSettings != nil {
		objectMap["copyCommandSettings"] = s.CopyCommandSettings
	}
	if s.PolyBaseSettings != nil {
		objectMap["polyBaseSettings"] = s.PolyBaseSettings
	}
	if s.PreCopyScript != nil {
		objectMap["preCopyScript"] = s.PreCopyScript
	}
	if s.TableOption != nil {
		objectMap["tableOption"] = s.TableOption
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDwSink.
func (s *SQLDwSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowCopyCommand":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowCopyCommand)
			}
			delete(rawMsg, key)
		case "allowPolyBase":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowPolyBase)
			}
			delete(rawMsg, key)
		case "copyCommandSettings":
			if val != nil {
				err = json.Unmarshal(*val, &s.CopyCommandSettings)
			}
			delete(rawMsg, key)
		case "polyBaseSettings":
			if val != nil {
				err = json.Unmarshal(*val, &s.PolyBaseSettings)
			}
			delete(rawMsg, key)
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &s.PreCopyScript)
			}
			delete(rawMsg, key)
		case "tableOption":
			if val != nil {
				err = json.Unmarshal(*val, &s.TableOption)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity SQL Data Warehouse source.
type SQLDwSource struct {
	TabularSource
	// SQL Data Warehouse reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery *interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Data Warehouse source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with
	// resultType string).
	SQLReaderStoredProcedureName *interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}". Type: object (or Expression with resultType
	// object), itemType: StoredProcedureParameter.
	StoredProcedureParameters *interface{} `json:"storedProcedureParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLDwSource.
func (s SQLDwSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SqlDWSource")
	if s.SQLReaderQuery != nil {
		objectMap["sqlReaderQuery"] = s.SQLReaderQuery
	}
	if s.SQLReaderStoredProcedureName != nil {
		objectMap["sqlReaderStoredProcedureName"] = s.SQLReaderStoredProcedureName
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLDwSource.
func (s *SQLDwSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sqlReaderQuery":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderQuery)
			}
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderStoredProcedureName)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// A copy activity Azure SQL Managed Instance sink.
type SQLMiSink struct {
	CopySink
	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName *interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType *interface{} `json:"sqlWriterTableType,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName *interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
	TableOption *interface{} `json:"tableOption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLMiSink.
func (s SQLMiSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SqlMISink")
	if s.PreCopyScript != nil {
		objectMap["preCopyScript"] = s.PreCopyScript
	}
	if s.SQLWriterStoredProcedureName != nil {
		objectMap["sqlWriterStoredProcedureName"] = s.SQLWriterStoredProcedureName
	}
	if s.SQLWriterTableType != nil {
		objectMap["sqlWriterTableType"] = s.SQLWriterTableType
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	if s.StoredProcedureTableTypeParameterName != nil {
		objectMap["storedProcedureTableTypeParameterName"] = s.StoredProcedureTableTypeParameterName
	}
	if s.TableOption != nil {
		objectMap["tableOption"] = s.TableOption
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMiSink.
func (s *SQLMiSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &s.PreCopyScript)
			}
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLWriterStoredProcedureName)
			}
			delete(rawMsg, key)
		case "sqlWriterTableType":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLWriterTableType)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureTableTypeParameterName)
			}
			delete(rawMsg, key)
		case "tableOption":
			if val != nil {
				err = json.Unmarshal(*val, &s.TableOption)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Azure SQL Managed Instance source.
type SQLMiSource struct {
	TabularSource
	// Which additional types to produce.
	ProduceAdditionalTypes *interface{} `json:"produceAdditionalTypes,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery *interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a Azure SQL Managed Instance source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression
	// with resultType string).
	SQLReaderStoredProcedureName *interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLMiSource.
func (s SQLMiSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SqlMISource")
	if s.ProduceAdditionalTypes != nil {
		objectMap["produceAdditionalTypes"] = s.ProduceAdditionalTypes
	}
	if s.SQLReaderQuery != nil {
		objectMap["sqlReaderQuery"] = s.SQLReaderQuery
	}
	if s.SQLReaderStoredProcedureName != nil {
		objectMap["sqlReaderStoredProcedureName"] = s.SQLReaderStoredProcedureName
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLMiSource.
func (s *SQLMiSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "produceAdditionalTypes":
			if val != nil {
				err = json.Unmarshal(*val, &s.ProduceAdditionalTypes)
			}
			delete(rawMsg, key)
		case "sqlReaderQuery":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderQuery)
			}
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderStoredProcedureName)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// A SQL Analytics pool
type SQLPool struct {
	TrackedResource
	// SQL pool properties
	Properties *SQLPoolResourceProperties `json:"properties,omitempty"`

	// SQL pool SKU
	SKU *SKU `json:"sku,omitempty"`
}

// List of SQL pools
type SQLPoolInfoListResult struct {
	// Link to the next page of results
	NextLink *string `json:"nextLink,omitempty"`

	// List of SQL pools
	Value *[]SQLPool `json:"value,omitempty"`
}

// SQLPoolInfoListResultResponse is the response envelope for operations that return a SQLPoolInfoListResult type.
type SQLPoolInfoListResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// List of SQL pools
	SQLPoolInfoListResult *SQLPoolInfoListResult
}

// SQL pool reference type.
type SQLPoolReference struct {
	// Reference SQL pool name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// SQL pool reference type.
	Type *SQLPoolReferenceType `json:"type,omitempty"`
}

// Properties of a SQL Analytics pool
type SQLPoolResourceProperties struct {
	// Collation mode
	Collation *string `json:"collation,omitempty"`

	// What is this?
	CreateMode *string `json:"createMode,omitempty"`

	// Date the SQL pool was created
	CreationDate *time.Time `json:"creationDate,omitempty"`

	// Maximum size in bytes
	MaxSizeBytes *int64 `json:"maxSizeBytes,omitempty"`

	// Resource state
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Backup database to restore from
	RecoverableDatabaseID *string `json:"recoverableDatabaseId,omitempty"`

	// Snapshot time to restore
	RestorePointInTime *time.Time `json:"restorePointInTime,omitempty"`

	// Source database to create from
	SourceDatabaseID *string `json:"sourceDatabaseId,omitempty"`

	// Resource status
	Status *string `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolResourceProperties.
func (s SQLPoolResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Collation != nil {
		objectMap["collation"] = s.Collation
	}
	if s.CreateMode != nil {
		objectMap["createMode"] = s.CreateMode
	}
	if s.CreationDate != nil {
		objectMap["creationDate"] = (*timeRFC3339)(s.CreationDate)
	}
	if s.MaxSizeBytes != nil {
		objectMap["maxSizeBytes"] = s.MaxSizeBytes
	}
	if s.ProvisioningState != nil {
		objectMap["provisioningState"] = s.ProvisioningState
	}
	if s.RecoverableDatabaseID != nil {
		objectMap["recoverableDatabaseId"] = s.RecoverableDatabaseID
	}
	if s.RestorePointInTime != nil {
		objectMap["restorePointInTime"] = (*timeRFC3339)(s.RestorePointInTime)
	}
	if s.SourceDatabaseID != nil {
		objectMap["sourceDatabaseId"] = s.SourceDatabaseID
	}
	if s.Status != nil {
		objectMap["status"] = s.Status
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolResourceProperties.
func (s *SQLPoolResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collation":
			if val != nil {
				err = json.Unmarshal(*val, &s.Collation)
			}
			delete(rawMsg, key)
		case "createMode":
			if val != nil {
				err = json.Unmarshal(*val, &s.CreateMode)
			}
			delete(rawMsg, key)
		case "creationDate":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.CreationDate = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "maxSizeBytes":
			if val != nil {
				err = json.Unmarshal(*val, &s.MaxSizeBytes)
			}
			delete(rawMsg, key)
		case "provisioningState":
			if val != nil {
				err = json.Unmarshal(*val, &s.ProvisioningState)
			}
			delete(rawMsg, key)
		case "recoverableDatabaseId":
			if val != nil {
				err = json.Unmarshal(*val, &s.RecoverableDatabaseID)
			}
			delete(rawMsg, key)
		case "restorePointInTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.RestorePointInTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "sourceDatabaseId":
			if val != nil {
				err = json.Unmarshal(*val, &s.SourceDatabaseID)
			}
			delete(rawMsg, key)
		case "status":
			if val != nil {
				err = json.Unmarshal(*val, &s.Status)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLPoolResponse is the response envelope for operations that return a SQLPool type.
type SQLPoolResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A SQL Analytics pool
	SQLPool *SQLPool
}

// Execute SQL pool stored procedure activity.
type SQLPoolStoredProcedureActivity struct {
	Activity
	// SQL pool stored procedure reference.
	SQLPool *SQLPoolReference `json:"sqlPool,omitempty"`

	// Execute SQL pool stored procedure activity properties.
	TypeProperties *SQLPoolStoredProcedureActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolStoredProcedureActivity.
func (s SQLPoolStoredProcedureActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SqlPoolStoredProcedure")
	if s.SQLPool != nil {
		objectMap["sqlPool"] = s.SQLPool
	}
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolStoredProcedureActivity.
func (s *SQLPoolStoredProcedureActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sqlPool":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLPool)
			}
			delete(rawMsg, key)
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Activity.unmarshalInternal(rawMsg)
}

// SQL stored procedure activity properties.
type SQLPoolStoredProcedureActivityTypeProperties struct {
	// Stored procedure name. Type: string (or Expression with resultType string).
	StoredProcedureName *interface{} `json:"storedProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// SQLPoolsGetOptions contains the optional parameters for the SQLPools.Get method.
type SQLPoolsGetOptions struct {
	// placeholder for future optional parameters
}

// SQLPoolsListOptions contains the optional parameters for the SQLPools.List method.
type SQLPoolsListOptions struct {
	// placeholder for future optional parameters
}

// SQL script.
type SQLScript struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The content of the SQL script.
	Content *SQLScriptContent `json:"content,omitempty"`

	// The description of the SQL script.
	Description *string `json:"description,omitempty"`

	// The type of the SQL script.
	Type *SQLScriptType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLScript.
func (s SQLScript) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Content != nil {
		objectMap["content"] = s.Content
	}
	if s.Description != nil {
		objectMap["description"] = s.Description
	}
	if s.Type != nil {
		objectMap["type"] = s.Type
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLScript.
func (s *SQLScript) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			if val != nil {
				err = json.Unmarshal(*val, &s.Content)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &s.Description)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The content of the SQL script.
type SQLScriptContent struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The connection used to execute the SQL script.
	CurrentConnection *SQLConnection `json:"currentConnection,omitempty"`

	// The metadata of the SQL script.
	Metadata *SQLScriptMetadata `json:"metadata,omitempty"`

	// SQL query to execute.
	Query *string `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLScriptContent.
func (s SQLScriptContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.CurrentConnection != nil {
		objectMap["currentConnection"] = s.CurrentConnection
	}
	if s.Metadata != nil {
		objectMap["metadata"] = s.Metadata
	}
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLScriptContent.
func (s *SQLScriptContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentConnection":
			if val != nil {
				err = json.Unmarshal(*val, &s.CurrentConnection)
			}
			delete(rawMsg, key)
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &s.Metadata)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLScriptCreateOrUpdateSQLScriptOptions contains the optional parameters for the SQLScript.CreateOrUpdateSQLScript method.
type SQLScriptCreateOrUpdateSQLScriptOptions struct {
	// ETag of the SQL script entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// SQLScriptDeleteSQLScriptOptions contains the optional parameters for the SQLScript.DeleteSQLScript method.
type SQLScriptDeleteSQLScriptOptions struct {
	// placeholder for future optional parameters
}

// SQLScriptGetSQLScriptOptions contains the optional parameters for the SQLScript.GetSQLScript method.
type SQLScriptGetSQLScriptOptions struct {
	// ETag of the sql compute entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content
	// will be returned.
	IfNoneMatch *string
}

// SQLScriptGetSQLScriptsByWorkspaceOptions contains the optional parameters for the SQLScript.GetSQLScriptsByWorkspace method.
type SQLScriptGetSQLScriptsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// The metadata of the SQL script.
type SQLScriptMetadata struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The language of the SQL script.
	Language *string `json:"language,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLScriptMetadata.
func (s SQLScriptMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Language != nil {
		objectMap["language"] = s.Language
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLScriptMetadata.
func (s *SQLScriptMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Sql Script resource type.
type SQLScriptResource struct {
	// Resource Etag.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties of sql script.
	Properties *SQLScript `json:"properties,omitempty"`

	// The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// SQLScriptResourceResponse is the response envelope for operations that return a SQLScriptResource type.
type SQLScriptResourceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Sql Script resource type.
	SQLScriptResource *SQLScriptResource
}

// A list of sql scripts resources.
type SQLScriptsListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of sql scripts.
	Value *[]SQLScriptResource `json:"value,omitempty"`
}

// SQLScriptsListResponseResponse is the response envelope for operations that return a SQLScriptsListResponse type.
type SQLScriptsListResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of sql scripts resources.
	SQLScriptsListResponse *SQLScriptsListResponse
}

// SQLScriptsRenameOptions contains the optional parameters for the SQLScripts.Rename method.
type SQLScriptsRenameOptions struct {
	// placeholder for future optional parameters
}

// SQL Server linked service.
type SQLServerLinkedService struct {
	LinkedService
	// SQL Server linked service properties.
	TypeProperties *SQLServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLinkedService.
func (s SQLServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SqlServer")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedService.
func (s *SQLServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// SQL Server linked service properties.
type SQLServerLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The on-premises Windows authentication password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedServiceTypeProperties.
func (s *SQLServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &s.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity SQL server sink.
type SQLServerSink struct {
	CopySink
	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName *interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType *interface{} `json:"sqlWriterTableType,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName *interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
	TableOption *interface{} `json:"tableOption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSink.
func (s SQLServerSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SqlServerSink")
	if s.PreCopyScript != nil {
		objectMap["preCopyScript"] = s.PreCopyScript
	}
	if s.SQLWriterStoredProcedureName != nil {
		objectMap["sqlWriterStoredProcedureName"] = s.SQLWriterStoredProcedureName
	}
	if s.SQLWriterTableType != nil {
		objectMap["sqlWriterTableType"] = s.SQLWriterTableType
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	if s.StoredProcedureTableTypeParameterName != nil {
		objectMap["storedProcedureTableTypeParameterName"] = s.StoredProcedureTableTypeParameterName
	}
	if s.TableOption != nil {
		objectMap["tableOption"] = s.TableOption
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSink.
func (s *SQLServerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &s.PreCopyScript)
			}
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLWriterStoredProcedureName)
			}
			delete(rawMsg, key)
		case "sqlWriterTableType":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLWriterTableType)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureTableTypeParameterName)
			}
			delete(rawMsg, key)
		case "tableOption":
			if val != nil {
				err = json.Unmarshal(*val, &s.TableOption)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity SQL server source.
type SQLServerSource struct {
	TabularSource
	// Which additional types to produce.
	ProduceAdditionalTypes *interface{} `json:"produceAdditionalTypes,omitempty"`

	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery *interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType
	// string).
	SQLReaderStoredProcedureName *interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSource.
func (s SQLServerSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SqlServerSource")
	if s.ProduceAdditionalTypes != nil {
		objectMap["produceAdditionalTypes"] = s.ProduceAdditionalTypes
	}
	if s.SQLReaderQuery != nil {
		objectMap["sqlReaderQuery"] = s.SQLReaderQuery
	}
	if s.SQLReaderStoredProcedureName != nil {
		objectMap["sqlReaderStoredProcedureName"] = s.SQLReaderStoredProcedureName
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerSource.
func (s *SQLServerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "produceAdditionalTypes":
			if val != nil {
				err = json.Unmarshal(*val, &s.ProduceAdditionalTypes)
			}
			delete(rawMsg, key)
		case "sqlReaderQuery":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderQuery)
			}
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderStoredProcedureName)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// SQL stored procedure activity type.
type SQLServerStoredProcedureActivity struct {
	ExecutionActivity
	// SQL stored procedure activity properties.
	TypeProperties *SQLServerStoredProcedureActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerStoredProcedureActivity.
func (s SQLServerStoredProcedureActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.ExecutionActivity.marshalInternal("SqlServerStoredProcedure")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerStoredProcedureActivity.
func (s *SQLServerStoredProcedureActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.ExecutionActivity.unmarshalInternal(rawMsg)
}

// SQL stored procedure activity properties.
type SQLServerStoredProcedureActivityTypeProperties struct {
	// Stored procedure name. Type: string (or Expression with resultType string).
	StoredProcedureName *interface{} `json:"storedProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// The on-premises SQL Server dataset.
type SQLServerTableDataset struct {
	Dataset
	// On-premises SQL Server dataset properties.
	TypeProperties *SQLServerTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerTableDataset.
func (s SQLServerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SqlServerTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerTableDataset.
func (s *SQLServerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// On-premises SQL Server dataset properties.
type SQLServerTableDatasetTypeProperties struct {
	// The schema name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// A copy activity SQL sink.
type SQLSink struct {
	CopySink
	// SQL pre-copy script. Type: string (or Expression with resultType string).
	PreCopyScript *interface{} `json:"preCopyScript,omitempty"`

	// SQL writer stored procedure name. Type: string (or Expression with resultType string).
	SQLWriterStoredProcedureName *interface{} `json:"sqlWriterStoredProcedureName,omitempty"`

	// SQL writer table type. Type: string (or Expression with resultType string).
	SQLWriterTableType *interface{} `json:"sqlWriterTableType,omitempty"`

	// SQL stored procedure parameters.
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`

	// The stored procedure parameter name of the table type. Type: string (or Expression with resultType string).
	StoredProcedureTableTypeParameterName *interface{} `json:"storedProcedureTableTypeParameterName,omitempty"`

	// The option to handle sink table, such as autoCreate. For now only 'autoCreate' value is supported. Type: string (or Expression with resultType string).
	TableOption *interface{} `json:"tableOption,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLSink.
func (s SQLSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SqlSink")
	if s.PreCopyScript != nil {
		objectMap["preCopyScript"] = s.PreCopyScript
	}
	if s.SQLWriterStoredProcedureName != nil {
		objectMap["sqlWriterStoredProcedureName"] = s.SQLWriterStoredProcedureName
	}
	if s.SQLWriterTableType != nil {
		objectMap["sqlWriterTableType"] = s.SQLWriterTableType
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	if s.StoredProcedureTableTypeParameterName != nil {
		objectMap["storedProcedureTableTypeParameterName"] = s.StoredProcedureTableTypeParameterName
	}
	if s.TableOption != nil {
		objectMap["tableOption"] = s.TableOption
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLSink.
func (s *SQLSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "preCopyScript":
			if val != nil {
				err = json.Unmarshal(*val, &s.PreCopyScript)
			}
			delete(rawMsg, key)
		case "sqlWriterStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLWriterStoredProcedureName)
			}
			delete(rawMsg, key)
		case "sqlWriterTableType":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLWriterTableType)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		case "storedProcedureTableTypeParameterName":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureTableTypeParameterName)
			}
			delete(rawMsg, key)
		case "tableOption":
			if val != nil {
				err = json.Unmarshal(*val, &s.TableOption)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity SQL source.
type SQLSource struct {
	TabularSource
	// SQL reader query. Type: string (or Expression with resultType string).
	SQLReaderQuery *interface{} `json:"sqlReaderQuery,omitempty"`

	// Name of the stored procedure for a SQL Database source. This cannot be used at the same time as SqlReaderQuery. Type: string (or Expression with resultType
	// string).
	SQLReaderStoredProcedureName *interface{} `json:"sqlReaderStoredProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLSource.
func (s SQLSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SqlSource")
	if s.SQLReaderQuery != nil {
		objectMap["sqlReaderQuery"] = s.SQLReaderQuery
	}
	if s.SQLReaderStoredProcedureName != nil {
		objectMap["sqlReaderStoredProcedureName"] = s.SQLReaderStoredProcedureName
	}
	if s.StoredProcedureParameters != nil {
		objectMap["storedProcedureParameters"] = s.StoredProcedureParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLSource.
func (s *SQLSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sqlReaderQuery":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderQuery)
			}
			delete(rawMsg, key)
		case "sqlReaderStoredProcedureName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLReaderStoredProcedureName)
			}
			delete(rawMsg, key)
		case "storedProcedureParameters":
			if val != nil {
				err = json.Unmarshal(*val, &s.StoredProcedureParameters)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Linked service for Salesforce.
type SalesforceLinkedService struct {
	LinkedService
	// Salesforce linked service properties.
	TypeProperties *SalesforceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceLinkedService.
func (s SalesforceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Salesforce")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedService.
func (s *SalesforceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Salesforce linked service properties.
type SalesforceLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'. To copy
	// data from custom domain, specify, for example,
	// 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
	EnvironmentURL *interface{} `json:"environmentUrl,omitempty"`

	// The password for Basic authentication of the Salesforce instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The security token is required to remotely access Salesforce instance.
	SecurityToken SecretBaseClassification `json:"securityToken,omitempty"`

	// The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedServiceTypeProperties.
func (s *SalesforceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "environmentUrl":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnvironmentURL)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "securityToken":
			if val != nil {
				s.SecurityToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Salesforce Marketing Cloud linked service.
type SalesforceMarketingCloudLinkedService struct {
	LinkedService
	// Salesforce Marketing Cloud linked service properties.
	TypeProperties *SalesforceMarketingCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudLinkedService.
func (s SalesforceMarketingCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SalesforceMarketingCloud")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedService.
func (s *SalesforceMarketingCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Salesforce Marketing Cloud linked service properties.
type SalesforceMarketingCloudLinkedServiceTypeProperties struct {
	// The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType boolean).
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true. Type: boolean (or Expression with
	// resultType boolean).
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedServiceTypeProperties.
func (s *SalesforceMarketingCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				s.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Salesforce Marketing Cloud dataset.
type SalesforceMarketingCloudObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s SalesforceMarketingCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SalesforceMarketingCloudObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s *SalesforceMarketingCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Salesforce Marketing Cloud source.
type SalesforceMarketingCloudSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudSource.
func (s SalesforceMarketingCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SalesforceMarketingCloudSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudSource.
func (s *SalesforceMarketingCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// The Salesforce object dataset.
type SalesforceObjectDataset struct {
	Dataset
	// Salesforce object dataset properties.
	TypeProperties *SalesforceObjectDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceObjectDataset.
func (s SalesforceObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SalesforceObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceObjectDataset.
func (s *SalesforceObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// Salesforce object dataset properties.
type SalesforceObjectDatasetTypeProperties struct {
	// The Salesforce object API name. Type: string (or Expression with resultType string).
	ObjectAPIName *interface{} `json:"objectApiName,omitempty"`
}

// Linked service for Salesforce Service Cloud.
type SalesforceServiceCloudLinkedService struct {
	LinkedService
	// Salesforce Service Cloud linked service properties.
	TypeProperties *SalesforceServiceCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudLinkedService.
func (s SalesforceServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SalesforceServiceCloud")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedService.
func (s *SalesforceServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Salesforce Service Cloud linked service properties.
type SalesforceServiceCloudLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'.
	// To copy data from custom domain, specify, for
	// example, 'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
	EnvironmentURL *interface{} `json:"environmentUrl,omitempty"`

	// Extended properties appended to the connection string. Type: string (or Expression with resultType string).
	ExtendedProperties *interface{} `json:"extendedProperties,omitempty"`

	// The password for Basic authentication of the Salesforce instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The security token is required to remotely access Salesforce instance.
	SecurityToken SecretBaseClassification `json:"securityToken,omitempty"`

	// The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedServiceTypeProperties.
func (s *SalesforceServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "environmentUrl":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnvironmentURL)
			}
			delete(rawMsg, key)
		case "extendedProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExtendedProperties)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "securityToken":
			if val != nil {
				s.SecurityToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Salesforce Service Cloud object dataset.
type SalesforceServiceCloudObjectDataset struct {
	Dataset
	// Salesforce Service Cloud object dataset properties.
	TypeProperties *SalesforceServiceCloudObjectDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudObjectDataset.
func (s SalesforceServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SalesforceServiceCloudObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudObjectDataset.
func (s *SalesforceServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// Salesforce Service Cloud object dataset properties.
type SalesforceServiceCloudObjectDatasetTypeProperties struct {
	// The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
	ObjectAPIName *interface{} `json:"objectApiName,omitempty"`
}

// A copy activity Salesforce Service Cloud sink.
type SalesforceServiceCloudSink struct {
	CopySink
	// The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with resultType string).
	ExternalIDFieldName *interface{} `json:"externalIdFieldName,omitempty"`

	// The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation. Default value is false. If set
	// it to true, it means ADF will leave the data in
	// the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert operation, versus ADF will update
	// the data in the destination object to NULL when
	// doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType boolean).
	IgnoreNullValues *interface{} `json:"ignoreNullValues,omitempty"`

	// The write behavior for the operation. Default is Insert.
	WriteBehavior *SalesforceSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudSink.
func (s SalesforceServiceCloudSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SalesforceServiceCloudSink")
	if s.ExternalIDFieldName != nil {
		objectMap["externalIdFieldName"] = s.ExternalIDFieldName
	}
	if s.IgnoreNullValues != nil {
		objectMap["ignoreNullValues"] = s.IgnoreNullValues
	}
	if s.WriteBehavior != nil {
		objectMap["writeBehavior"] = s.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudSink.
func (s *SalesforceServiceCloudSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "externalIdFieldName":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExternalIDFieldName)
			}
			delete(rawMsg, key)
		case "ignoreNullValues":
			if val != nil {
				err = json.Unmarshal(*val, &s.IgnoreNullValues)
			}
			delete(rawMsg, key)
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &s.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Salesforce Service Cloud source.
type SalesforceServiceCloudSource struct {
	CopySource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`

	// The read behavior for the operation. Default is Query.
	ReadBehavior *SalesforceSourceReadBehavior `json:"readBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudSource.
func (s SalesforceServiceCloudSource) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySource.marshalInternal("SalesforceServiceCloudSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	if s.ReadBehavior != nil {
		objectMap["readBehavior"] = s.ReadBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudSource.
func (s *SalesforceServiceCloudSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		case "readBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &s.ReadBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySource.unmarshalInternal(rawMsg)
}

// A copy activity Salesforce sink.
type SalesforceSink struct {
	CopySink
	// The name of the external ID field for upsert operation. Default value is 'Id' column. Type: string (or Expression with resultType string).
	ExternalIDFieldName *interface{} `json:"externalIdFieldName,omitempty"`

	// The flag indicating whether or not to ignore null values from input dataset (except key fields) during write operation. Default value is false. If set
	// it to true, it means ADF will leave the data in
	// the destination object unchanged when doing upsert/update operation and insert defined default value when doing insert operation, versus ADF will update
	// the data in the destination object to NULL when
	// doing upsert/update operation and insert NULL value when doing insert operation. Type: boolean (or Expression with resultType boolean).
	IgnoreNullValues *interface{} `json:"ignoreNullValues,omitempty"`

	// The write behavior for the operation. Default is Insert.
	WriteBehavior *SalesforceSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceSink.
func (s SalesforceSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SalesforceSink")
	if s.ExternalIDFieldName != nil {
		objectMap["externalIdFieldName"] = s.ExternalIDFieldName
	}
	if s.IgnoreNullValues != nil {
		objectMap["ignoreNullValues"] = s.IgnoreNullValues
	}
	if s.WriteBehavior != nil {
		objectMap["writeBehavior"] = s.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceSink.
func (s *SalesforceSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "externalIdFieldName":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExternalIDFieldName)
			}
			delete(rawMsg, key)
		case "ignoreNullValues":
			if val != nil {
				err = json.Unmarshal(*val, &s.IgnoreNullValues)
			}
			delete(rawMsg, key)
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &s.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity Salesforce source.
type SalesforceSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`

	// The read behavior for the operation. Default is Query.
	ReadBehavior *SalesforceSourceReadBehavior `json:"readBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceSource.
func (s SalesforceSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SalesforceSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	if s.ReadBehavior != nil {
		objectMap["readBehavior"] = s.ReadBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceSource.
func (s *SalesforceSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		case "readBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &s.ReadBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// The SAP BW cube dataset.
type SapBwCubeDataset struct {
	Dataset
}

// MarshalJSON implements the json.Marshaller interface for type SapBwCubeDataset.
func (s SapBwCubeDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapBwCube")
	return json.Marshal(objectMap)
}

// SAP Business Warehouse Linked Service.
type SapBwLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SapBwLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapBwLinkedService.
func (s SapBwLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapBW")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwLinkedService.
func (s *SapBwLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to this linked service type.
type SapBwLinkedServiceTypeProperties struct {
	// Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type: string (or Expression with resultType
	// string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password to access the SAP BW server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP BW instance. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with resultType string).
	SystemNumber *interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP BW server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwLinkedServiceTypeProperties.
func (s *SapBwLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
			delete(rawMsg, key)
		case "systemNumber":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemNumber)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for SapBW server via MDX.
type SapBwSource struct {
	TabularSource
	// MDX query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapBwSource.
func (s SapBwSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SapBwSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwSource.
func (s *SapBwSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Linked service for SAP Cloud for Customer.
type SapCloudForCustomerLinkedService struct {
	LinkedService
	// SAP Cloud for Customer linked service properties.
	TypeProperties *SapCloudForCustomerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerLinkedService.
func (s SapCloudForCustomerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapCloudForCustomer")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedService.
func (s *SapCloudForCustomerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// SAP Cloud for Customer linked service properties.
type SapCloudForCustomerLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential
	// or username/password must be provided. Type:
	// string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type: string (or Expression with
	// resultType string).
	URL *interface{} `json:"url,omitempty"`

	// The username for Basic authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedServiceTypeProperties.
func (s *SapCloudForCustomerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &s.URL)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The path of the SAP Cloud for Customer OData entity.
type SapCloudForCustomerResourceDataset struct {
	Dataset
	// SAP Cloud For Customer OData resource dataset properties.
	TypeProperties *SapCloudForCustomerResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerResourceDataset.
func (s SapCloudForCustomerResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapCloudForCustomerResource")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerResourceDataset.
func (s *SapCloudForCustomerResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// Sap Cloud For Customer OData resource dataset properties.
type SapCloudForCustomerResourceDatasetTypeProperties struct {
	// The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// A copy activity SAP Cloud for Customer sink.
type SapCloudForCustomerSink struct {
	CopySink
	// The write behavior for the operation. Default is 'Insert'.
	WriteBehavior *SapCloudForCustomerSinkWriteBehavior `json:"writeBehavior,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerSink.
func (s SapCloudForCustomerSink) MarshalJSON() ([]byte, error) {
	objectMap := s.CopySink.marshalInternal("SapCloudForCustomerSink")
	if s.WriteBehavior != nil {
		objectMap["writeBehavior"] = s.WriteBehavior
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerSink.
func (s *SapCloudForCustomerSink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "writeBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &s.WriteBehavior)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.CopySink.unmarshalInternal(rawMsg)
}

// A copy activity source for SAP Cloud for Customer source.
type SapCloudForCustomerSource struct {
	TabularSource
	// SAP Cloud for Customer OData query. For example, "$top=1". Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerSource.
func (s SapCloudForCustomerSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SapCloudForCustomerSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerSource.
func (s *SapCloudForCustomerSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Linked service for SAP ERP Central Component(SAP ECC).
type SapEccLinkedService struct {
	LinkedService
	// SAP ECC linked service properties.
	TypeProperties *SapEccLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapEccLinkedService.
func (s SapEccLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapEcc")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedService.
func (s *SapEccLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// SAP ECC linked service properties.
type SapEccLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Either encryptedCredential
	// or username/password must be provided. Type:
	// string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression with resultType string).
	URL *string `json:"url,omitempty"`

	// The username for Basic authentication. Type: string (or Expression with resultType string).
	Username *string `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedServiceTypeProperties.
func (s *SapEccLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &s.URL)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The path of the SAP ECC OData entity.
type SapEccResourceDataset struct {
	Dataset
	// SAP ECC OData resource dataset properties.
	TypeProperties *SapEccResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapEccResourceDataset.
func (s SapEccResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapEccResource")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccResourceDataset.
func (s *SapEccResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// Sap ECC OData resource dataset properties.
type SapEccResourceDatasetTypeProperties struct {
	// The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// A copy activity source for SAP ECC source.
type SapEccSource struct {
	TabularSource
	// SAP ECC OData query. For example, "$top=1". Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapEccSource.
func (s SapEccSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SapEccSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccSource.
func (s *SapEccSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// SAP HANA Linked Service.
type SapHanaLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SapHanaLinkedServiceProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaLinkedService.
func (s SapHanaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapHana")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedService.
func (s *SapHanaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to this linked service type.
type SapHanaLinkedServiceProperties struct {
	// The authentication type to be used to connect to the SAP HANA server.
	AuthenticationType *SapHanaAuthenticationType `json:"authenticationType,omitempty"`

	// SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password to access the SAP HANA server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP HANA server. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username to access the SAP HANA server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedServiceProperties.
func (s *SapHanaLinkedServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &s.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The settings that will be leveraged for SAP HANA source partitioning.
type SapHanaPartitionSettings struct {
	// The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
	PartitionColumnName *interface{} `json:"partitionColumnName,omitempty"`
}

// A copy activity source for SAP HANA source.
type SapHanaSource struct {
	TabularSource
	// The packet size of data read from SAP HANA. Type: integer(or Expression with resultType integer).
	PacketSize *interface{} `json:"packetSize,omitempty"`

	// The partition mechanism that will be used for SAP HANA read in parallel.
	PartitionOption *SapHanaPartitionOption `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for SAP HANA source partitioning.
	PartitionSettings *SapHanaPartitionSettings `json:"partitionSettings,omitempty"`

	// SAP HANA Sql query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaSource.
func (s SapHanaSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SapHanaSource")
	if s.PacketSize != nil {
		objectMap["packetSize"] = s.PacketSize
	}
	if s.PartitionOption != nil {
		objectMap["partitionOption"] = s.PartitionOption
	}
	if s.PartitionSettings != nil {
		objectMap["partitionSettings"] = s.PartitionSettings
	}
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaSource.
func (s *SapHanaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "packetSize":
			if val != nil {
				err = json.Unmarshal(*val, &s.PacketSize)
			}
			delete(rawMsg, key)
		case "partitionOption":
			if val != nil {
				err = json.Unmarshal(*val, &s.PartitionOption)
			}
			delete(rawMsg, key)
		case "partitionSettings":
			if val != nil {
				err = json.Unmarshal(*val, &s.PartitionSettings)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// SAP HANA Table properties.
type SapHanaTableDataset struct {
	Dataset
	// SAP HANA Table properties.
	TypeProperties *SapHanaTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaTableDataset.
func (s SapHanaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapHanaTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaTableDataset.
func (s *SapHanaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// SAP HANA Table properties.
type SapHanaTableDatasetTypeProperties struct {
	// The schema name of SAP HANA. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of SAP HANA. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`
}

// SAP Business Warehouse Open Hub Destination Linked Service.
type SapOpenHubLinkedService struct {
	LinkedService
	// Properties specific to SAP Business Warehouse Open Hub Destination linked service type.
	TypeProperties *SapOpenHubLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubLinkedService.
func (s SapOpenHubLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapOpenHub")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedService.
func (s *SapOpenHubLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to SAP Business Warehouse Open Hub Destination linked service type.
type SapOpenHubLinkedServiceTypeProperties struct {
	// Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number represented as a string) Type:
	// string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression with resultType string).
	Language *interface{} `json:"language,omitempty"`

	// Password to access the SAP BW server where the open hub destination is located.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented as a string.) Type: string
	// (or Expression with resultType string).
	SystemNumber *interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedServiceTypeProperties.
func (s *SapOpenHubLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
			delete(rawMsg, key)
		case "systemNumber":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemNumber)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for SAP Business Warehouse Open Hub Destination source.
type SapOpenHubSource struct {
	TabularSource
	// The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value
	// is 0. Type: integer (or Expression with
	// resultType integer ).
	BaseRequestID *interface{} `json:"baseRequestId,omitempty"`

	// Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
	ExcludeLastRequest *interface{} `json:"excludeLastRequest,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubSource.
func (s SapOpenHubSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SapOpenHubSource")
	if s.BaseRequestID != nil {
		objectMap["baseRequestId"] = s.BaseRequestID
	}
	if s.ExcludeLastRequest != nil {
		objectMap["excludeLastRequest"] = s.ExcludeLastRequest
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubSource.
func (s *SapOpenHubSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseRequestId":
			if val != nil {
				err = json.Unmarshal(*val, &s.BaseRequestID)
			}
			delete(rawMsg, key)
		case "excludeLastRequest":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExcludeLastRequest)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Sap Business Warehouse Open Hub Destination Table properties.
type SapOpenHubTableDataset struct {
	Dataset
	// Sap Business Warehouse Open Hub Destination Table properties.
	TypeProperties *SapOpenHubTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubTableDataset.
func (s SapOpenHubTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapOpenHubTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubTableDataset.
func (s *SapOpenHubTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// Sap Business Warehouse Open Hub Destination Table properties.
type SapOpenHubTableDatasetTypeProperties struct {
	// The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will be retrieved. The default value
	// is 0. Type: integer (or Expression with
	// resultType integer ).
	BaseRequestID *interface{} `json:"baseRequestId,omitempty"`

	// Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType boolean).
	ExcludeLastRequest *interface{} `json:"excludeLastRequest,omitempty"`

	// The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with resultType string).
	OpenHubDestinationName *interface{} `json:"openHubDestinationName,omitempty"`
}

// SAP Table Linked Service.
type SapTableLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SapTableLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapTableLinkedService.
func (s SapTableLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedService.
func (s *SapTableLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to this linked service type.
type SapTableLinkedServiceTypeProperties struct {
	// Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented as a string) Type: string (or
	// Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType string).
	Language *interface{} `json:"language,omitempty"`

	// The Logon Group for the SAP System. Type: string (or Expression with resultType string).
	LogonGroup *interface{} `json:"logonGroup,omitempty"`

	// The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
	MessageServer *interface{} `json:"messageServer,omitempty"`

	// The service name or port number of the Message Server. Type: string (or Expression with resultType string).
	MessageServerService *interface{} `json:"messageServerService,omitempty"`

	// Password to access the SAP server where the table is located.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// External security product's library to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	SncLibraryPath *interface{} `json:"sncLibraryPath,omitempty"`

	// SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string (or Expression with resultType
	// string).
	SncMode *interface{} `json:"sncMode,omitempty"`

	// Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	SncMyName *interface{} `json:"sncMyName,omitempty"`

	// Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	SncPartnerName *interface{} `json:"sncPartnerName,omitempty"`

	// SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
	SncQop *interface{} `json:"sncQop,omitempty"`

	// SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
	SystemID *interface{} `json:"systemId,omitempty"`

	// System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression
	// with resultType string).
	SystemNumber *interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedServiceTypeProperties.
func (s *SapTableLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
			delete(rawMsg, key)
		case "logonGroup":
			if val != nil {
				err = json.Unmarshal(*val, &s.LogonGroup)
			}
			delete(rawMsg, key)
		case "messageServer":
			if val != nil {
				err = json.Unmarshal(*val, &s.MessageServer)
			}
			delete(rawMsg, key)
		case "messageServerService":
			if val != nil {
				err = json.Unmarshal(*val, &s.MessageServerService)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
			delete(rawMsg, key)
		case "sncLibraryPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncLibraryPath)
			}
			delete(rawMsg, key)
		case "sncMode":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncMode)
			}
			delete(rawMsg, key)
		case "sncMyName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncMyName)
			}
			delete(rawMsg, key)
		case "sncPartnerName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncPartnerName)
			}
			delete(rawMsg, key)
		case "sncQop":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncQop)
			}
			delete(rawMsg, key)
		case "systemId":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemID)
			}
			delete(rawMsg, key)
		case "systemNumber":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemNumber)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The settings that will be leveraged for SAP table source partitioning.
type SapTablePartitionSettings struct {
	// The maximum value of partitions the table will be split into. Type: integer (or Expression with resultType string).
	MaxPartitionsNumber *interface{} `json:"maxPartitionsNumber,omitempty"`

	// The name of the column that will be used for proceeding range partitioning. Type: string (or Expression with resultType string).
	PartitionColumnName *interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionLowerBound *interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionUpperBound *interface{} `json:"partitionUpperBound,omitempty"`
}

// SAP Table Resource properties.
type SapTableResourceDataset struct {
	Dataset
	// SAP Table Resource properties.
	TypeProperties *SapTableResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapTableResourceDataset.
func (s SapTableResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapTableResource")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableResourceDataset.
func (s *SapTableResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// SAP Table Resource properties.
type SapTableResourceDatasetTypeProperties struct {
	// The name of the SAP Table. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// A copy activity source for SAP Table source.
type SapTableSource struct {
	TabularSource
	// Specifies the maximum number of rows that will be retrieved at a time when retrieving data from SAP Table. Type: integer (or Expression with resultType
	// integer).
	BatchSize *interface{} `json:"batchSize,omitempty"`

	// Specifies the custom RFC function module that will be used to read data from SAP Table. Type: string (or Expression with resultType string).
	CustomRFCReadTableFunctionModule *interface{} `json:"customRfcReadTableFunctionModule,omitempty"`

	// The partition mechanism that will be used for SAP table read in parallel.
	PartitionOption *SapTablePartitionOption `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for SAP table source partitioning.
	PartitionSettings *SapTablePartitionSettings `json:"partitionSettings,omitempty"`

	// The fields of the SAP table that will be retrieved. For example, column0, column1. Type: string (or Expression with resultType string).
	RFCTableFields *interface{} `json:"rfcTableFields,omitempty"`

	// The options for the filtering of the SAP Table. For example, COLUMN0 EQ SOME VALUE. Type: string (or Expression with resultType string).
	RFCTableOptions *interface{} `json:"rfcTableOptions,omitempty"`

	// The number of rows to be retrieved. Type: integer(or Expression with resultType integer).
	RowCount *interface{} `json:"rowCount,omitempty"`

	// The number of rows that will be skipped. Type: integer (or Expression with resultType integer).
	RowSkips *interface{} `json:"rowSkips,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapTableSource.
func (s SapTableSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SapTableSource")
	if s.BatchSize != nil {
		objectMap["batchSize"] = s.BatchSize
	}
	if s.CustomRFCReadTableFunctionModule != nil {
		objectMap["customRfcReadTableFunctionModule"] = s.CustomRFCReadTableFunctionModule
	}
	if s.PartitionOption != nil {
		objectMap["partitionOption"] = s.PartitionOption
	}
	if s.PartitionSettings != nil {
		objectMap["partitionSettings"] = s.PartitionSettings
	}
	if s.RFCTableFields != nil {
		objectMap["rfcTableFields"] = s.RFCTableFields
	}
	if s.RFCTableOptions != nil {
		objectMap["rfcTableOptions"] = s.RFCTableOptions
	}
	if s.RowCount != nil {
		objectMap["rowCount"] = s.RowCount
	}
	if s.RowSkips != nil {
		objectMap["rowSkips"] = s.RowSkips
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableSource.
func (s *SapTableSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSize":
			if val != nil {
				err = json.Unmarshal(*val, &s.BatchSize)
			}
			delete(rawMsg, key)
		case "customRfcReadTableFunctionModule":
			if val != nil {
				err = json.Unmarshal(*val, &s.CustomRFCReadTableFunctionModule)
			}
			delete(rawMsg, key)
		case "partitionOption":
			if val != nil {
				err = json.Unmarshal(*val, &s.PartitionOption)
			}
			delete(rawMsg, key)
		case "partitionSettings":
			if val != nil {
				err = json.Unmarshal(*val, &s.PartitionSettings)
			}
			delete(rawMsg, key)
		case "rfcTableFields":
			if val != nil {
				err = json.Unmarshal(*val, &s.RFCTableFields)
			}
			delete(rawMsg, key)
		case "rfcTableOptions":
			if val != nil {
				err = json.Unmarshal(*val, &s.RFCTableOptions)
			}
			delete(rawMsg, key)
		case "rowCount":
			if val != nil {
				err = json.Unmarshal(*val, &s.RowCount)
			}
			delete(rawMsg, key)
		case "rowSkips":
			if val != nil {
				err = json.Unmarshal(*val, &s.RowSkips)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Trigger that creates pipeline runs periodically, on schedule.
type ScheduleTrigger struct {
	MultiplePipelineTrigger
	// Schedule Trigger properties.
	TypeProperties *ScheduleTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTrigger.
func (s ScheduleTrigger) MarshalJSON() ([]byte, error) {
	objectMap := s.MultiplePipelineTrigger.marshalInternal("ScheduleTrigger")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTrigger.
func (s *ScheduleTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.MultiplePipelineTrigger.unmarshalInternal(rawMsg)
}

// The workflow trigger recurrence.
type ScheduleTriggerRecurrence struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The end time.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The frequency.
	Frequency *RecurrenceFrequency `json:"frequency,omitempty"`

	// The interval.
	Interval *int32 `json:"interval,omitempty"`

	// The recurrence schedule.
	Schedule *RecurrenceSchedule `json:"schedule,omitempty"`

	// The start time.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The time zone.
	TimeZone *string `json:"timeZone,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleTriggerRecurrence.
func (s ScheduleTriggerRecurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.EndTime != nil {
		objectMap["endTime"] = (*timeRFC3339)(s.EndTime)
	}
	if s.Frequency != nil {
		objectMap["frequency"] = s.Frequency
	}
	if s.Interval != nil {
		objectMap["interval"] = s.Interval
	}
	if s.Schedule != nil {
		objectMap["schedule"] = s.Schedule
	}
	if s.StartTime != nil {
		objectMap["startTime"] = (*timeRFC3339)(s.StartTime)
	}
	if s.TimeZone != nil {
		objectMap["timeZone"] = s.TimeZone
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleTriggerRecurrence.
func (s *ScheduleTriggerRecurrence) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.EndTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "frequency":
			if val != nil {
				err = json.Unmarshal(*val, &s.Frequency)
			}
			delete(rawMsg, key)
		case "interval":
			if val != nil {
				err = json.Unmarshal(*val, &s.Interval)
			}
			delete(rawMsg, key)
		case "schedule":
			if val != nil {
				err = json.Unmarshal(*val, &s.Schedule)
			}
			delete(rawMsg, key)
		case "startTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.StartTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "timeZone":
			if val != nil {
				err = json.Unmarshal(*val, &s.TimeZone)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Schedule Trigger properties.
type ScheduleTriggerTypeProperties struct {
	// Recurrence schedule configuration.
	Recurrence *ScheduleTriggerRecurrence `json:"recurrence,omitempty"`
}

// Custom script action to run on HDI ondemand cluster once it's up.
type ScriptAction struct {
	// The user provided name of the script action.
	Name *string `json:"name,omitempty"`

	// The parameters for the script action.
	Parameters *string `json:"parameters,omitempty"`

	// The node types on which the script action should be executed.
	Roles *HdiNodeTypes `json:"roles,omitempty"`

	// The URI for the script action.
	URI *string `json:"uri,omitempty"`
}

// SecretBaseClassification provides polymorphic access to related types.
// Call the interface's GetSecretBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *SecretBase, *AzureKeyVaultSecretReference, *SecureString
type SecretBaseClassification interface {
	// GetSecretBase() returns the SecretBase content of the underlying type.
	GetSecretBase() *SecretBase
}

// The base definition of a secret type.
type SecretBase struct {
	// Type of the secret.
	Type *string `json:"type,omitempty"`
}

// GetSecretBase implements the SecretBaseClassification interface for type SecretBase.
func (s *SecretBase) GetSecretBase() *SecretBase { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretBase.
func (s *SecretBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s SecretBase) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	s.Type = &discValue
	objectMap["type"] = s.Type
	return objectMap
}

func (s *SecretBase) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Synapse secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
type SecureString struct {
	SecretBase
	// Value of secure string.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecureString.
func (s SecureString) MarshalJSON() ([]byte, error) {
	objectMap := s.SecretBase.marshalInternal("SecureString")
	if s.Value != nil {
		objectMap["value"] = s.Value
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecureString.
func (s *SecureString) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			if val != nil {
				err = json.Unmarshal(*val, &s.Value)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.SecretBase.unmarshalInternal(rawMsg)
}

// Self referenced tumbling window trigger dependency.
type SelfDependencyTumblingWindowTriggerReference struct {
	DependencyReference
	// Timespan applied to the start time of a tumbling window when evaluating dependency.
	Offset *string `json:"offset,omitempty"`

	// The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
	Size *string `json:"size,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfDependencyTumblingWindowTriggerReference.
func (s SelfDependencyTumblingWindowTriggerReference) MarshalJSON() ([]byte, error) {
	objectMap := s.DependencyReference.marshalInternal("SelfDependencyTumblingWindowTriggerReference")
	if s.Offset != nil {
		objectMap["offset"] = s.Offset
	}
	if s.Size != nil {
		objectMap["size"] = s.Size
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfDependencyTumblingWindowTriggerReference.
func (s *SelfDependencyTumblingWindowTriggerReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "offset":
			if val != nil {
				err = json.Unmarshal(*val, &s.Offset)
			}
			delete(rawMsg, key)
		case "size":
			if val != nil {
				err = json.Unmarshal(*val, &s.Size)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.DependencyReference.unmarshalInternal(rawMsg)
}

// Self-hosted integration runtime.
type SelfHostedIntegrationRuntime struct {
	IntegrationRuntime
	// When this property is not null, means this is a linked integration runtime. The property is used to access original integration runtime.
	TypeProperties *SelfHostedIntegrationRuntimeTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SelfHostedIntegrationRuntime.
func (s SelfHostedIntegrationRuntime) MarshalJSON() ([]byte, error) {
	objectMap := s.IntegrationRuntime.marshalInternal(IntegrationRuntimeTypeSelfHosted)
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntime.
func (s *SelfHostedIntegrationRuntime) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.IntegrationRuntime.unmarshalInternal(rawMsg)
}

// The self-hosted integration runtime properties.
type SelfHostedIntegrationRuntimeTypeProperties struct {
	// Linked integration runtime type from data factory
	LinkedInfo LinkedIntegrationRuntimeTypeClassification `json:"linkedInfo,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SelfHostedIntegrationRuntimeTypeProperties.
func (s *SelfHostedIntegrationRuntimeTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedInfo":
			if val != nil {
				s.LinkedInfo, err = unmarshalLinkedIntegrationRuntimeTypeClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNow server linked service.
type ServiceNowLinkedService struct {
	LinkedService
	// ServiceNow server linked service properties.
	TypeProperties *ServiceNowLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowLinkedService.
func (s ServiceNowLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("ServiceNow")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedService.
func (s *ServiceNowLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// ServiceNow server linked service properties.
type ServiceNowLinkedServiceTypeProperties struct {
	// The authentication type to use.
	AuthenticationType *ServiceNowAuthenticationType `json:"authenticationType,omitempty"`

	// The client id for OAuth2 authentication.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret for OAuth2 authentication.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the ServiceNow server. (i.e. .service-now.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The password corresponding to the user name for Basic and OAuth2 authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedServiceTypeProperties.
func (s *ServiceNowLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
			delete(rawMsg, key)
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				s.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &s.Endpoint)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNow server dataset.
type ServiceNowObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowObjectDataset.
func (s ServiceNowObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("ServiceNowObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowObjectDataset.
func (s *ServiceNowObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity ServiceNow server source.
type ServiceNowSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowSource.
func (s ServiceNowSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("ServiceNowSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowSource.
func (s *ServiceNowSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Set value for a Variable.
type SetVariableActivity struct {
	Activity
	// Set Variable activity properties.
	TypeProperties *SetVariableActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SetVariableActivity.
func (s SetVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SetVariable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SetVariableActivity.
func (s *SetVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Activity.unmarshalInternal(rawMsg)
}

// SetVariable activity properties.
type SetVariableActivityTypeProperties struct {
	// Value to be set. Could be a static value or Expression
	Value *interface{} `json:"value,omitempty"`

	// Name of the variable whose value needs to be set.
	VariableName *string `json:"variableName,omitempty"`
}

// The location of SFTP dataset.
type SftpLocation struct {
	DatasetLocation
}

// MarshalJSON implements the json.Marshaller interface for type SftpLocation.
func (s SftpLocation) MarshalJSON() ([]byte, error) {
	objectMap := s.DatasetLocation.marshalInternal("SftpLocation")
	return json.Marshal(objectMap)
}

// Sftp read settings.
type SftpReadSettings struct {
	StoreReadSettings
	// The end of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeEnd *interface{} `json:"modifiedDatetimeEnd,omitempty"`

	// The start of file's modified datetime. Type: string (or Expression with resultType string).
	ModifiedDatetimeStart *interface{} `json:"modifiedDatetimeStart,omitempty"`

	// If true, files under the folder path will be read recursively. Default is true. Type: boolean (or Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`

	// Sftp wildcardFileName. Type: string (or Expression with resultType string).
	WildcardFileName *interface{} `json:"wildcardFileName,omitempty"`

	// Sftp wildcardFolderPath. Type: string (or Expression with resultType string).
	WildcardFolderPath *interface{} `json:"wildcardFolderPath,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SftpReadSettings.
func (s SftpReadSettings) MarshalJSON() ([]byte, error) {
	objectMap := s.StoreReadSettings.marshalInternal("SftpReadSettings")
	if s.ModifiedDatetimeEnd != nil {
		objectMap["modifiedDatetimeEnd"] = s.ModifiedDatetimeEnd
	}
	if s.ModifiedDatetimeStart != nil {
		objectMap["modifiedDatetimeStart"] = s.ModifiedDatetimeStart
	}
	if s.Recursive != nil {
		objectMap["recursive"] = s.Recursive
	}
	if s.WildcardFileName != nil {
		objectMap["wildcardFileName"] = s.WildcardFileName
	}
	if s.WildcardFolderPath != nil {
		objectMap["wildcardFolderPath"] = s.WildcardFolderPath
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpReadSettings.
func (s *SftpReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "modifiedDatetimeEnd":
			if val != nil {
				err = json.Unmarshal(*val, &s.ModifiedDatetimeEnd)
			}
			delete(rawMsg, key)
		case "modifiedDatetimeStart":
			if val != nil {
				err = json.Unmarshal(*val, &s.ModifiedDatetimeStart)
			}
			delete(rawMsg, key)
		case "recursive":
			if val != nil {
				err = json.Unmarshal(*val, &s.Recursive)
			}
			delete(rawMsg, key)
		case "wildcardFileName":
			if val != nil {
				err = json.Unmarshal(*val, &s.WildcardFileName)
			}
			delete(rawMsg, key)
		case "wildcardFolderPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.WildcardFolderPath)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.StoreReadSettings.unmarshalInternal(rawMsg)
}

// A linked service for an SSH File Transfer Protocol (SFTP) server.
type SftpServerLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SftpServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SftpServerLinkedService.
func (s SftpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Sftp")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedService.
func (s *SftpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Properties specific to this linked service type.
type SftpServerLinkedServiceTypeProperties struct {
	// The authentication type to be used to connect to the FTP server.
	AuthenticationType *SftpAuthenticationType `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The SFTP server host name. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified. Type: string (or Expression
	// with resultType string).
	HostKeyFingerprint *interface{} `json:"hostKeyFingerprint,omitempty"`

	// The password to decrypt the SSH private key if the SSH private key is encrypted.
	PassPhrase SecretBaseClassification `json:"passPhrase,omitempty"`

	// Password to logon the SFTP server for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or Expression with resultType integer),
	// minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath
	// or PrivateKeyContent should be specified. SSH
	// private key should be OpenSSH format.
	PrivateKeyContent SecretBaseClassification `json:"privateKeyContent,omitempty"`

	// The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with SshPublicKey authentication,
	// either PrivateKeyPath or PrivateKeyContent should
	// be specified. SSH private key should be OpenSSH format. Type: string (or Expression with resultType string).
	PrivateKeyPath *interface{} `json:"privateKeyPath,omitempty"`

	// If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
	SkipHostKeyValidation *interface{} `json:"skipHostKeyValidation,omitempty"`

	// The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedServiceTypeProperties.
func (s *SftpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
			delete(rawMsg, key)
		case "hostKeyFingerprint":
			if val != nil {
				err = json.Unmarshal(*val, &s.HostKeyFingerprint)
			}
			delete(rawMsg, key)
		case "passPhrase":
			if val != nil {
				s.PassPhrase, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &s.Port)
			}
			delete(rawMsg, key)
		case "privateKeyContent":
			if val != nil {
				s.PrivateKeyContent, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "privateKeyPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.PrivateKeyPath)
			}
			delete(rawMsg, key)
		case "skipHostKeyValidation":
			if val != nil {
				err = json.Unmarshal(*val, &s.SkipHostKeyValidation)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Sftp write settings.
type SftpWriteSettings struct {
	StoreWriteSettings
	// Specifies the timeout for writing each chunk to SFTP server. Default value: 01:00:00 (one hour). Type: string (or Expression with resultType string).
	OperationTimeout *interface{} `json:"operationTimeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SftpWriteSettings.
func (s SftpWriteSettings) MarshalJSON() ([]byte, error) {
	objectMap := s.StoreWriteSettings.marshalInternal("SftpWriteSettings")
	if s.OperationTimeout != nil {
		objectMap["operationTimeout"] = s.OperationTimeout
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpWriteSettings.
func (s *SftpWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "operationTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &s.OperationTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.StoreWriteSettings.unmarshalInternal(rawMsg)
}

// Shopify Service linked service.
type ShopifyLinkedService struct {
	LinkedService
	// Shopify Service linked service properties.
	TypeProperties *ShopifyLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyLinkedService.
func (s ShopifyLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Shopify")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedService.
func (s *ShopifyLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Shopify Service linked service properties.
type ShopifyLinkedServiceTypeProperties struct {
	// The API access token that can be used to access Shopify’s data. The token won't expire if it is offline mode.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
	Host *interface{} `json:"host,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedServiceTypeProperties.
func (s *ShopifyLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				s.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Shopify Service dataset.
type ShopifyObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyObjectDataset.
func (s ShopifyObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("ShopifyObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyObjectDataset.
func (s *ShopifyObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Shopify Service source.
type ShopifySource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShopifySource.
func (s ShopifySource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("ShopifySource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifySource.
func (s *ShopifySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

type SparkBatchJob struct {
	// The application id of this session
	AppID *string `json:"appId,omitempty"`

	// The detailed application info.
	AppInfo *map[string]string `json:"appInfo,omitempty"`

	// The artifact identifier.
	ArtifactID *string `json:"artifactId,omitempty"`

	// The error information.
	Errors *[]SparkServiceError `json:"errorInfo,omitempty"`

	// The session Id.
	ID *int32 `json:"id,omitempty"`

	// The job type.
	JobType  *SparkJobType       `json:"jobType,omitempty"`
	LivyInfo *SparkBatchJobState `json:"livyInfo,omitempty"`

	// The log lines.
	LogLines *[]string `json:"log,omitempty"`

	// The batch name.
	Name *string `json:"name,omitempty"`

	// The plugin information.
	Plugin *SparkServicePlugin `json:"pluginInfo,omitempty"`

	// The Spark batch job result.
	Result *SparkBatchJobResultType `json:"result,omitempty"`

	// The scheduler information.
	Scheduler *SparkScheduler `json:"schedulerInfo,omitempty"`

	// The Spark pool name.
	SparkPoolName *string `json:"sparkPoolName,omitempty"`

	// The batch state
	State *string `json:"state,omitempty"`

	// The submitter identifier.
	SubmitterID *string `json:"submitterId,omitempty"`

	// The submitter name.
	SubmitterName *string `json:"submitterName,omitempty"`

	// The tags.
	Tags *map[string]string `json:"tags,omitempty"`

	// The workspace name.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

// SparkBatchJobPollerResponse is the response envelope for operations that asynchronously return a SparkBatchJob type.
type SparkBatchJobPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*SparkBatchJobResponse, error)

	// Poller contains an initialized poller.
	Poller SparkBatchJobPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkBatchJobResponse is the response envelope for operations that return a SparkBatchJob type.
type SparkBatchJobResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse   *http.Response
	SparkBatchJob *SparkBatchJob
}

type SparkBatchJobState struct {
	// the Spark job state.
	CurrentState *string `json:"currentState,omitempty"`

	// time that at which "dead" livy state was first seen.
	DeadAt             *time.Time    `json:"deadAt,omitempty"`
	JobCreationRequest *SparkRequest `json:"jobCreationRequest,omitempty"`

	// the time that at which "not_started" livy state was first seen.
	NotStartedAt *time.Time `json:"notStartedAt,omitempty"`

	// the time that at which "recovering" livy state was first seen.
	RecoveringAt *time.Time `json:"recoveringAt,omitempty"`

	// the time that at which "running" livy state was first seen.
	RunningAt *time.Time `json:"runningAt,omitempty"`

	// the time that at which "starting" livy state was first seen.
	StartingAt *time.Time `json:"startingAt,omitempty"`

	// the time that at which "success" livy state was first seen.
	SuccessAt *time.Time `json:"successAt,omitempty"`

	// the time that at which "killed" livy state was first seen.
	TerminatedAt *time.Time `json:"killedAt,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkBatchJobState.
func (s SparkBatchJobState) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.CurrentState != nil {
		objectMap["currentState"] = s.CurrentState
	}
	if s.DeadAt != nil {
		objectMap["deadAt"] = (*timeRFC3339)(s.DeadAt)
	}
	if s.JobCreationRequest != nil {
		objectMap["jobCreationRequest"] = s.JobCreationRequest
	}
	if s.NotStartedAt != nil {
		objectMap["notStartedAt"] = (*timeRFC3339)(s.NotStartedAt)
	}
	if s.RecoveringAt != nil {
		objectMap["recoveringAt"] = (*timeRFC3339)(s.RecoveringAt)
	}
	if s.RunningAt != nil {
		objectMap["runningAt"] = (*timeRFC3339)(s.RunningAt)
	}
	if s.StartingAt != nil {
		objectMap["startingAt"] = (*timeRFC3339)(s.StartingAt)
	}
	if s.SuccessAt != nil {
		objectMap["successAt"] = (*timeRFC3339)(s.SuccessAt)
	}
	if s.TerminatedAt != nil {
		objectMap["killedAt"] = (*timeRFC3339)(s.TerminatedAt)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkBatchJobState.
func (s *SparkBatchJobState) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentState":
			if val != nil {
				err = json.Unmarshal(*val, &s.CurrentState)
			}
			delete(rawMsg, key)
		case "deadAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.DeadAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "jobCreationRequest":
			if val != nil {
				err = json.Unmarshal(*val, &s.JobCreationRequest)
			}
			delete(rawMsg, key)
		case "notStartedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.NotStartedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "recoveringAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.RecoveringAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "runningAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.RunningAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "startingAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.StartingAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "successAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.SuccessAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "killedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.TerminatedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Spark Properties
type SparkDatasetTypeProperties struct {
	// The schema name of the Spark. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Spark. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Spark job definition.
type SparkJobDefinition struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The description of the Spark job definition.
	Description *string `json:"description,omitempty"`

	// The properties of the Spark job.
	JobProperties *SparkJobProperties `json:"jobProperties,omitempty"`

	// The language of the Spark application.
	Language *string `json:"language,omitempty"`

	// The required Spark version of the application.
	RequiredSparkVersion *string `json:"requiredSparkVersion,omitempty"`

	// Big data pool reference.
	TargetBigDataPool *BigDataPoolReference `json:"targetBigDataPool,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkJobDefinition.
func (s SparkJobDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Description != nil {
		objectMap["description"] = s.Description
	}
	if s.JobProperties != nil {
		objectMap["jobProperties"] = s.JobProperties
	}
	if s.Language != nil {
		objectMap["language"] = s.Language
	}
	if s.RequiredSparkVersion != nil {
		objectMap["requiredSparkVersion"] = s.RequiredSparkVersion
	}
	if s.TargetBigDataPool != nil {
		objectMap["targetBigDataPool"] = s.TargetBigDataPool
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkJobDefinition.
func (s *SparkJobDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &s.Description)
			}
			delete(rawMsg, key)
		case "jobProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.JobProperties)
			}
			delete(rawMsg, key)
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
			delete(rawMsg, key)
		case "requiredSparkVersion":
			if val != nil {
				err = json.Unmarshal(*val, &s.RequiredSparkVersion)
			}
			delete(rawMsg, key)
		case "targetBigDataPool":
			if val != nil {
				err = json.Unmarshal(*val, &s.TargetBigDataPool)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkJobDefinitionCreateOrUpdateSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.CreateOrUpdateSparkJobDefinition
// method.
type SparkJobDefinitionCreateOrUpdateSparkJobDefinitionOptions struct {
	// ETag of the Spark Job Definition entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional
	// update.
	IfMatch *string
}

// SparkJobDefinitionDebugSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.DebugSparkJobDefinition method.
type SparkJobDefinitionDebugSparkJobDefinitionOptions struct {
	// placeholder for future optional parameters
}

// SparkJobDefinitionDeleteSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.DeleteSparkJobDefinition method.
type SparkJobDefinitionDeleteSparkJobDefinitionOptions struct {
	// placeholder for future optional parameters
}

// SparkJobDefinitionExecuteSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.ExecuteSparkJobDefinition method.
type SparkJobDefinitionExecuteSparkJobDefinitionOptions struct {
	// placeholder for future optional parameters
}

// SparkJobDefinitionGetSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.GetSparkJobDefinition method.
type SparkJobDefinitionGetSparkJobDefinitionOptions struct {
	// ETag of the Spark Job Definition entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no
	// content will be returned.
	IfNoneMatch *string
}

// SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceOptions contains the optional parameters for the SparkJobDefinition.GetSparkJobDefinitionsByWorkspace
// method.
type SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// Spark job definition resource type.
type SparkJobDefinitionResource struct {
	AzureEntityResource
	// Properties of spark job definition.
	Properties *SparkJobDefinition `json:"properties,omitempty"`
}

// SparkJobDefinitionResourceResponse is the response envelope for operations that return a SparkJobDefinitionResource type.
type SparkJobDefinitionResourceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Spark job definition resource type.
	SparkJobDefinitionResource *SparkJobDefinitionResource
}

// A list of spark job definitions resources.
type SparkJobDefinitionsListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of spark job definitions.
	Value *[]SparkJobDefinitionResource `json:"value,omitempty"`
}

// SparkJobDefinitionsListResponseResponse is the response envelope for operations that return a SparkJobDefinitionsListResponse type.
type SparkJobDefinitionsListResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of spark job definitions resources.
	SparkJobDefinitionsListResponse *SparkJobDefinitionsListResponse
}

// SparkJobDefinitionsRenameOptions contains the optional parameters for the SparkJobDefinitions.Rename method.
type SparkJobDefinitionsRenameOptions struct {
	// placeholder for future optional parameters
}

// The properties of the Spark job.
type SparkJobProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Archives to be used in this job.
	Archives *[]string `json:"archives,omitempty"`

	// Command line arguments for the application.
	Args *[]string `json:"args,omitempty"`

	// Main class for Java/Scala application.
	ClassName *string `json:"className,omitempty"`

	// Spark configuration properties.
	Conf *interface{} `json:"conf,omitempty"`

	// Number of cores to use for the driver.
	DriverCores *int32 `json:"driverCores,omitempty"`

	// Amount of memory to use for the driver process.
	DriverMemory *string `json:"driverMemory,omitempty"`

	// Number of cores to use for each executor.
	ExecutorCores *int32 `json:"executorCores,omitempty"`

	// Amount of memory to use per executor process.
	ExecutorMemory *string `json:"executorMemory,omitempty"`

	// File containing the application to execute.
	File *string `json:"file,omitempty"`

	// files to be used in this job.
	Files *[]string `json:"files,omitempty"`

	// Jars to be used in this job.
	Jars *[]string `json:"jars,omitempty"`

	// The name of the job.
	Name *string `json:"name,omitempty"`

	// Number of executors to launch for this job.
	NumExecutors *int32 `json:"numExecutors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkJobProperties.
func (s SparkJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Archives != nil {
		objectMap["archives"] = s.Archives
	}
	if s.Args != nil {
		objectMap["args"] = s.Args
	}
	if s.ClassName != nil {
		objectMap["className"] = s.ClassName
	}
	if s.Conf != nil {
		objectMap["conf"] = s.Conf
	}
	if s.DriverCores != nil {
		objectMap["driverCores"] = s.DriverCores
	}
	if s.DriverMemory != nil {
		objectMap["driverMemory"] = s.DriverMemory
	}
	if s.ExecutorCores != nil {
		objectMap["executorCores"] = s.ExecutorCores
	}
	if s.ExecutorMemory != nil {
		objectMap["executorMemory"] = s.ExecutorMemory
	}
	if s.File != nil {
		objectMap["file"] = s.File
	}
	if s.Files != nil {
		objectMap["files"] = s.Files
	}
	if s.Jars != nil {
		objectMap["jars"] = s.Jars
	}
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	if s.NumExecutors != nil {
		objectMap["numExecutors"] = s.NumExecutors
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkJobProperties.
func (s *SparkJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "archives":
			if val != nil {
				err = json.Unmarshal(*val, &s.Archives)
			}
			delete(rawMsg, key)
		case "args":
			if val != nil {
				err = json.Unmarshal(*val, &s.Args)
			}
			delete(rawMsg, key)
		case "className":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClassName)
			}
			delete(rawMsg, key)
		case "conf":
			if val != nil {
				err = json.Unmarshal(*val, &s.Conf)
			}
			delete(rawMsg, key)
		case "driverCores":
			if val != nil {
				err = json.Unmarshal(*val, &s.DriverCores)
			}
			delete(rawMsg, key)
		case "driverMemory":
			if val != nil {
				err = json.Unmarshal(*val, &s.DriverMemory)
			}
			delete(rawMsg, key)
		case "executorCores":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExecutorCores)
			}
			delete(rawMsg, key)
		case "executorMemory":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExecutorMemory)
			}
			delete(rawMsg, key)
		case "file":
			if val != nil {
				err = json.Unmarshal(*val, &s.File)
			}
			delete(rawMsg, key)
		case "files":
			if val != nil {
				err = json.Unmarshal(*val, &s.Files)
			}
			delete(rawMsg, key)
		case "jars":
			if val != nil {
				err = json.Unmarshal(*val, &s.Jars)
			}
			delete(rawMsg, key)
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &s.Name)
			}
			delete(rawMsg, key)
		case "numExecutors":
			if val != nil {
				err = json.Unmarshal(*val, &s.NumExecutors)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Spark Server linked service.
type SparkLinkedService struct {
	LinkedService
	// Spark Server linked service properties.
	TypeProperties *SparkLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkLinkedService.
func (s SparkLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Spark")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedService.
func (s *SparkLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Spark Server linked service properties.
type SparkLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication method used to access the Spark server.
	AuthenticationType *SparkAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Spark server.
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// IP address or host name of the Spark server
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the Username field
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Spark server uses to listen for client connections.
	Port *interface{} `json:"port,omitempty"`

	// The type of Spark server.
	ServerType *SparkServerType `json:"serverType,omitempty"`

	// The transport protocol to use in the Thrift layer.
	ThriftTransportProtocol *SparkThriftTransportProtocol `json:"thriftTransportProtocol,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This property can only be set when
	// using SSL on self-hosted IR. The default value
	// is the cacerts.pem file installed with the IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name that you use to access Spark Server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedServiceTypeProperties.
func (s *SparkLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowHostNameCnMismatch)
			}
			delete(rawMsg, key)
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowSelfSignedServerCert)
			}
			delete(rawMsg, key)
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
			delete(rawMsg, key)
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnableSsl)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.HTTPPath)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &s.Port)
			}
			delete(rawMsg, key)
		case "serverType":
			if val != nil {
				err = json.Unmarshal(*val, &s.ServerType)
			}
			delete(rawMsg, key)
		case "thriftTransportProtocol":
			if val != nil {
				err = json.Unmarshal(*val, &s.ThriftTransportProtocol)
			}
			delete(rawMsg, key)
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.TrustedCertPath)
			}
			delete(rawMsg, key)
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseSystemTrustStore)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Spark Server dataset.
type SparkObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *SparkDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkObjectDataset.
func (s SparkObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SparkObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkObjectDataset.
func (s *SparkObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

type SparkRequest struct {
	Archives  *[]string `json:"archives,omitempty"`
	Arguments *[]string `json:"args,omitempty"`
	ClassName *string   `json:"className,omitempty"`

	// Dictionary of
	Configuration  *map[string]string `json:"conf,omitempty"`
	DriverCores    *int32             `json:"driverCores,omitempty"`
	DriverMemory   *string            `json:"driverMemory,omitempty"`
	ExecutorCores  *int32             `json:"executorCores,omitempty"`
	ExecutorCount  *int32             `json:"numExecutors,omitempty"`
	ExecutorMemory *string            `json:"executorMemory,omitempty"`
	File           *string            `json:"file,omitempty"`
	Files          *[]string          `json:"files,omitempty"`
	Jars           *[]string          `json:"jars,omitempty"`
	Name           *string            `json:"name,omitempty"`
	PythonFiles    *[]string          `json:"pyFiles,omitempty"`
}

type SparkScheduler struct {
	CancellationRequestedAt *time.Time             `json:"cancellationRequestedAt,omitempty"`
	CurrentState            *SchedulerCurrentState `json:"currentState,omitempty"`
	EndedAt                 *time.Time             `json:"endedAt,omitempty"`
	ScheduledAt             *time.Time             `json:"scheduledAt,omitempty"`
	SubmittedAt             *time.Time             `json:"submittedAt,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkScheduler.
func (s SparkScheduler) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.CancellationRequestedAt != nil {
		objectMap["cancellationRequestedAt"] = (*timeRFC3339)(s.CancellationRequestedAt)
	}
	if s.CurrentState != nil {
		objectMap["currentState"] = s.CurrentState
	}
	if s.EndedAt != nil {
		objectMap["endedAt"] = (*timeRFC3339)(s.EndedAt)
	}
	if s.ScheduledAt != nil {
		objectMap["scheduledAt"] = (*timeRFC3339)(s.ScheduledAt)
	}
	if s.SubmittedAt != nil {
		objectMap["submittedAt"] = (*timeRFC3339)(s.SubmittedAt)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkScheduler.
func (s *SparkScheduler) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cancellationRequestedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.CancellationRequestedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "currentState":
			if val != nil {
				err = json.Unmarshal(*val, &s.CurrentState)
			}
			delete(rawMsg, key)
		case "endedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.EndedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "scheduledAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.ScheduledAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "submittedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.SubmittedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type SparkServiceError struct {
	ErrorCode *string           `json:"errorCode,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Source    *SparkErrorSource `json:"source,omitempty"`
}

type SparkServicePlugin struct {
	CleanupStartedAt             *time.Time          `json:"cleanupStartedAt,omitempty"`
	CurrentState                 *PluginCurrentState `json:"currentState,omitempty"`
	MonitoringStartedAt          *time.Time          `json:"monitoringStartedAt,omitempty"`
	PreparationStartedAt         *time.Time          `json:"preparationStartedAt,omitempty"`
	ResourceAcquisitionStartedAt *time.Time          `json:"resourceAcquisitionStartedAt,omitempty"`
	SubmissionStartedAt          *time.Time          `json:"submissionStartedAt,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkServicePlugin.
func (s SparkServicePlugin) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.CleanupStartedAt != nil {
		objectMap["cleanupStartedAt"] = (*timeRFC3339)(s.CleanupStartedAt)
	}
	if s.CurrentState != nil {
		objectMap["currentState"] = s.CurrentState
	}
	if s.MonitoringStartedAt != nil {
		objectMap["monitoringStartedAt"] = (*timeRFC3339)(s.MonitoringStartedAt)
	}
	if s.PreparationStartedAt != nil {
		objectMap["preparationStartedAt"] = (*timeRFC3339)(s.PreparationStartedAt)
	}
	if s.ResourceAcquisitionStartedAt != nil {
		objectMap["resourceAcquisitionStartedAt"] = (*timeRFC3339)(s.ResourceAcquisitionStartedAt)
	}
	if s.SubmissionStartedAt != nil {
		objectMap["submissionStartedAt"] = (*timeRFC3339)(s.SubmissionStartedAt)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkServicePlugin.
func (s *SparkServicePlugin) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cleanupStartedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.CleanupStartedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "currentState":
			if val != nil {
				err = json.Unmarshal(*val, &s.CurrentState)
			}
			delete(rawMsg, key)
		case "monitoringStartedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.MonitoringStartedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "preparationStartedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.PreparationStartedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "resourceAcquisitionStartedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.ResourceAcquisitionStartedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "submissionStartedAt":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				s.SubmissionStartedAt = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity Spark Server source.
type SparkSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkSource.
func (s SparkSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SparkSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkSource.
func (s *SparkSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// Square Service linked service.
type SquareLinkedService struct {
	LinkedService
	// Square Service linked service properties.
	TypeProperties *SquareLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SquareLinkedService.
func (s SquareLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Square")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedService.
func (s *SquareLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Square Service linked service properties.
type SquareLinkedServiceTypeProperties struct {
	// The client ID associated with your Square application.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with your Square application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Square instance. (i.e. mystore.mysquare.com)
	Host *interface{} `json:"host,omitempty"`

	// The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
	RedirectURI *interface{} `json:"redirectUri,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedServiceTypeProperties.
func (s *SquareLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
			delete(rawMsg, key)
		case "clientSecret":
			if val != nil {
				s.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
			delete(rawMsg, key)
		case "redirectUri":
			if val != nil {
				err = json.Unmarshal(*val, &s.RedirectURI)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Square Service dataset.
type SquareObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SquareObjectDataset.
func (s SquareObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SquareObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareObjectDataset.
func (s *SquareObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Square Service source.
type SquareSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SquareSource.
func (s SquareSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SquareSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareSource.
func (s *SquareSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// SSIS access credential.
type SsisAccessCredential struct {
	// Domain for windows authentication.
	Domain *interface{} `json:"domain,omitempty"`

	// Password for windows authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// UseName for windows authentication.
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisAccessCredential.
func (s *SsisAccessCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			if val != nil {
				err = json.Unmarshal(*val, &s.Domain)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SSIS embedded child package.
type SsisChildPackage struct {
	// Content for embedded child package. Type: string (or Expression with resultType string).
	PackageContent *interface{} `json:"packageContent,omitempty"`

	// Last modified date for embedded child package.
	PackageLastModifiedDate *string `json:"packageLastModifiedDate,omitempty"`

	// Name for embedded child package.
	PackageName *string `json:"packageName,omitempty"`

	// Path for embedded child package. Type: string (or Expression with resultType string).
	PackagePath *interface{} `json:"packagePath,omitempty"`
}

// SSIS package execution credential.
type SsisExecutionCredential struct {
	// Domain for windows authentication.
	Domain *interface{} `json:"domain,omitempty"`

	// Password for windows authentication.
	Password *SecureString `json:"password,omitempty"`

	// UseName for windows authentication.
	UserName *interface{} `json:"userName,omitempty"`
}

// SSIS execution parameter.
type SsisExecutionParameter struct {
	// SSIS package execution parameter value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// SSIS package execution log location
type SsisLogLocation struct {
	// The SSIS package execution log path. Type: string (or Expression with resultType string).
	LogPath *interface{} `json:"logPath,omitempty"`

	// The type of SSIS log location.
	Type *SsisLogLocationType `json:"type,omitempty"`

	// SSIS package execution log location properties.
	TypeProperties *SsisLogLocationTypeProperties `json:"typeProperties,omitempty"`
}

// SSIS package execution log location properties.
type SsisLogLocationTypeProperties struct {
	// The package execution log access credential.
	AccessCredential *SsisAccessCredential `json:"accessCredential,omitempty"`

	// Specifies the interval to refresh log. The default interval is 5 minutes. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	LogRefreshInterval *interface{} `json:"logRefreshInterval,omitempty"`
}

// The status of the operation.
type SsisObjectMetadataStatusResponse struct {
	// The operation error message.
	Error *string `json:"error,omitempty"`

	// The operation name.
	Name *string `json:"name,omitempty"`

	// The operation properties.
	Properties *string `json:"properties,omitempty"`

	// The status of the operation.
	Status *string `json:"status,omitempty"`
}

// SSIS package location.
type SsisPackageLocation struct {
	// The SSIS package path. Type: string (or Expression with resultType string).
	PackagePath *interface{} `json:"packagePath,omitempty"`

	// The type of SSIS package location.
	Type *SsisPackageLocationType `json:"type,omitempty"`

	// SSIS package location properties.
	TypeProperties *SsisPackageLocationTypeProperties `json:"typeProperties,omitempty"`
}

// SSIS package location properties.
type SsisPackageLocationTypeProperties struct {
	// The package access credential.
	AccessCredential *SsisAccessCredential `json:"accessCredential,omitempty"`

	// The embedded child package list.
	ChildPackages *[]SsisChildPackage `json:"childPackages,omitempty"`

	// The configuration file of the package execution. Type: string (or Expression with resultType string).
	ConfigurationPath *interface{} `json:"configurationPath,omitempty"`

	// The embedded package content. Type: string (or Expression with resultType string).
	PackageContent *interface{} `json:"packageContent,omitempty"`

	// The embedded package last modified date.
	PackageLastModifiedDate *string `json:"packageLastModifiedDate,omitempty"`

	// The package name.
	PackageName *string `json:"packageName,omitempty"`

	// Password of the package.
	PackagePassword SecretBaseClassification `json:"packagePassword,omitempty"`
}

// SSIS property override.
type SsisPropertyOverride struct {
	// Whether SSIS package property override value is sensitive data. Value will be encrypted in SSISDB if it is true
	IsSensitive *bool `json:"isSensitive,omitempty"`

	// SSIS package property override value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// Staging settings.
type StagingSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Specifies whether to use compression when copying data via an interim staging. Default value is false. Type: boolean (or Expression with resultType boolean).
	EnableCompression *interface{} `json:"enableCompression,omitempty"`

	// Staging linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The path to storage for storing the interim data. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StagingSettings.
func (s StagingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.EnableCompression != nil {
		objectMap["enableCompression"] = s.EnableCompression
	}
	if s.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = s.LinkedServiceName
	}
	if s.Path != nil {
		objectMap["path"] = s.Path
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StagingSettings.
func (s *StagingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableCompression":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnableCompression)
			}
			delete(rawMsg, key)
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &s.LinkedServiceName)
			}
			delete(rawMsg, key)
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &s.Path)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Request body structure for starting data flow debug session.
type StartDataFlowDebugSessionRequest struct {
	// Data flow instance.
	DataFlow *DataFlowResource `json:"dataFlow,omitempty"`

	// List of datasets.
	Datasets *[]DatasetResource `json:"datasets,omitempty"`

	// Data flow debug settings.
	DebugSettings *interface{} `json:"debugSettings,omitempty"`

	// The type of new Databricks cluster.
	IncrementalDebug *bool `json:"incrementalDebug,omitempty"`

	// List of linked services.
	LinkedServices *[]LinkedServiceResource `json:"linkedServices,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Staging info for debug session.
	Staging *interface{} `json:"staging,omitempty"`
}

// Response body structure for starting data flow debug session.
type StartDataFlowDebugSessionResponse struct {
	// The ID of data flow debug job version.
	JobVersion *string `json:"jobVersion,omitempty"`
}

// StoreReadSettingsClassification provides polymorphic access to related types.
// Call the interface's GetStoreReadSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *StoreReadSettings, *AmazonS3ReadSettings, *AzureBlobFSReadSettings, *AzureBlobStorageReadSettings, *AzureDataLakeStoreReadSettings,
// - *AzureFileStorageReadSettings, *FileServerReadSettings, *FtpReadSettings, *GoogleCloudStorageReadSettings, *HdfsReadSettings,
// - *HttpReadSettings, *SftpReadSettings
type StoreReadSettingsClassification interface {
	// GetStoreReadSettings() returns the StoreReadSettings content of the underlying type.
	GetStoreReadSettings() *StoreReadSettings
}

// Connector read setting.
type StoreReadSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections *interface{} `json:"maxConcurrentConnections,omitempty"`

	// The read setting type.
	Type *string `json:"type,omitempty"`
}

// GetStoreReadSettings implements the StoreReadSettingsClassification interface for type StoreReadSettings.
func (s *StoreReadSettings) GetStoreReadSettings() *StoreReadSettings { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type StoreReadSettings.
func (s *StoreReadSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s StoreReadSettings) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if s.MaxConcurrentConnections != nil {
		objectMap["maxConcurrentConnections"] = s.MaxConcurrentConnections
	}
	s.Type = &discValue
	objectMap["type"] = s.Type
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (s *StoreReadSettings) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxConcurrentConnections":
			if val != nil {
				err = json.Unmarshal(*val, &s.MaxConcurrentConnections)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StoreWriteSettingsClassification provides polymorphic access to related types.
// Call the interface's GetStoreWriteSettings() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *StoreWriteSettings, *AzureBlobFSWriteSettings, *AzureBlobStorageWriteSettings, *AzureDataLakeStoreWriteSettings, *FileServerWriteSettings,
// - *SftpWriteSettings
type StoreWriteSettingsClassification interface {
	// GetStoreWriteSettings() returns the StoreWriteSettings content of the underlying type.
	GetStoreWriteSettings() *StoreWriteSettings
}

// Connector write settings.
type StoreWriteSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The type of copy behavior for copy sink.
	CopyBehavior *interface{} `json:"copyBehavior,omitempty"`

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections *interface{} `json:"maxConcurrentConnections,omitempty"`

	// The write setting type.
	Type *string `json:"type,omitempty"`
}

// GetStoreWriteSettings implements the StoreWriteSettingsClassification interface for type StoreWriteSettings.
func (s *StoreWriteSettings) GetStoreWriteSettings() *StoreWriteSettings { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type StoreWriteSettings.
func (s *StoreWriteSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s StoreWriteSettings) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if s.CopyBehavior != nil {
		objectMap["copyBehavior"] = s.CopyBehavior
	}
	if s.MaxConcurrentConnections != nil {
		objectMap["maxConcurrentConnections"] = s.MaxConcurrentConnections
	}
	s.Type = &discValue
	objectMap["type"] = s.Type
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (s *StoreWriteSettings) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyBehavior":
			if val != nil {
				err = json.Unmarshal(*val, &s.CopyBehavior)
			}
			delete(rawMsg, key)
		case "maxConcurrentConnections":
			if val != nil {
				err = json.Unmarshal(*val, &s.MaxConcurrentConnections)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
			delete(rawMsg, key)
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQL stored procedure parameter.
type StoredProcedureParameter struct {
	// Stored procedure parameter type.
	Type *StoredProcedureParameterType `json:"type,omitempty"`

	// Stored procedure parameter value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// Azure Synapse nested resource, which belongs to a workspace.
type SubResource struct {
	AzureEntityResource
}

// Azure Synapse nested debug resource.
type SubResourceDebugResource struct {
	// The resource name.
	Name *string `json:"name,omitempty"`
}

func (s SubResourceDebugResource) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	return objectMap
}

func (s *SubResourceDebugResource) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &s.Name)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// This activity evaluates an expression and executes activities under the cases property that correspond to the expression evaluation expected in the equals
// property.
type SwitchActivity struct {
	Activity
	// Switch activity properties.
	TypeProperties *SwitchActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SwitchActivity.
func (s SwitchActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("Switch")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivity.
func (s *SwitchActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Activity.unmarshalInternal(rawMsg)
}

// Switch activity properties.
type SwitchActivityTypeProperties struct {
	// List of cases that correspond to expected values of the 'on' property. This is an optional property and if not provided, the activity will execute activities
	// provided in defaultActivities.
	Cases *[]SwitchCase `json:"cases,omitempty"`

	// List of activities to execute if no case condition is satisfied. This is an optional property and if not provided, the activity will exit without any
	// action.
	DefaultActivities *[]ActivityClassification `json:"defaultActivities,omitempty"`

	// An expression that would evaluate to a string or integer. This is used to determine the block of activities in cases that will be executed.
	On *Expression `json:"on,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivityTypeProperties.
func (s *SwitchActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cases":
			if val != nil {
				err = json.Unmarshal(*val, &s.Cases)
			}
			delete(rawMsg, key)
		case "defaultActivities":
			if val != nil {
				s.DefaultActivities, err = unmarshalActivityClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "on":
			if val != nil {
				err = json.Unmarshal(*val, &s.On)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Switch cases with have a value and corresponding activities.
type SwitchCase struct {
	// List of activities to execute for satisfied case condition.
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// Expected value that satisfies the expression result of the 'on' property.
	Value *string `json:"value,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchCase.
func (s *SwitchCase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				s.Activities, err = unmarshalActivityClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "value":
			if val != nil {
				err = json.Unmarshal(*val, &s.Value)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Linked service for Sybase data source.
type SybaseLinkedService struct {
	LinkedService
	// Sybase linked service properties.
	TypeProperties *SybaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SybaseLinkedService.
func (s SybaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Sybase")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedService.
func (s *SybaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.LinkedService.unmarshalInternal(rawMsg)
}

// Sybase linked service properties.
type SybaseLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *SybaseAuthenticationType `json:"authenticationType,omitempty"`

	// Database name for connection. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Schema name for connection. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedServiceTypeProperties.
func (s *SybaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
			delete(rawMsg, key)
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &s.Database)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "schema":
			if val != nil {
				err = json.Unmarshal(*val, &s.Schema)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for Sybase databases.
type SybaseSource struct {
	TabularSource
	// Database query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SybaseSource.
func (s SybaseSource) MarshalJSON() ([]byte, error) {
	objectMap := s.TabularSource.marshalInternal("SybaseSource")
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseSource.
func (s *SybaseSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.TabularSource.unmarshalInternal(rawMsg)
}

// The Sybase table dataset.
type SybaseTableDataset struct {
	Dataset
	// Sybase table dataset properties.
	TypeProperties *SybaseTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SybaseTableDataset.
func (s SybaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SybaseTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseTableDataset.
func (s *SybaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Dataset.unmarshalInternal(rawMsg)
}

// Sybase table dataset properties.
type SybaseTableDatasetTypeProperties struct {
	// The Sybase table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Execute Synapse notebook activity.
type SynapseNotebookActivity struct {
	Activity
	// Execute Synapse notebook activity properties.
	TypeProperties *SynapseNotebookActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SynapseNotebookActivity.
func (s SynapseNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SynapseNotebook")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseNotebookActivity.
func (s *SynapseNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Activity.unmarshalInternal(rawMsg)
}

// Execute Synapse notebook activity properties.
type SynapseNotebookActivityTypeProperties struct {
	// Synapse notebook reference.
	Notebook *SynapseNotebookReference `json:"notebook,omitempty"`

	// Notebook parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`
}

// Synapse notebook reference type.
type SynapseNotebookReference struct {
	// Reference notebook name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Synapse notebook reference type.
	Type *NotebookReferenceType `json:"type,omitempty"`
}

// Execute spark job activity properties.
type SynapseSparkJobActivityTypeProperties struct {
	// Synapse spark job reference.
	SparkJob *SynapseSparkJobReference `json:"sparkJob,omitempty"`
}

// Execute spark job activity.
type SynapseSparkJobDefinitionActivity struct {
	Activity
	// Execute spark job activity properties.
	TypeProperties *SynapseSparkJobActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSparkJobDefinitionActivity.
func (s SynapseSparkJobDefinitionActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SparkJob")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSparkJobDefinitionActivity.
func (s *SynapseSparkJobDefinitionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.Activity.unmarshalInternal(rawMsg)
}

// Synapse spark job reference type.
type SynapseSparkJobReference struct {
	// Reference spark job name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Synapse spark job reference type.
	Type *SparkJobReferenceType `json:"type,omitempty"`
}

// TabularSourceClassification provides polymorphic access to related types.
// Call the interface's GetTabularSource() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *TabularSource, *AmazonMWSSource, *AmazonRedshiftSource, *AzureMariaDBSource, *AzureMySqlSource, *AzurePostgreSqlSource,
// - *AzureSqlSource, *AzureTableSource, *CassandraSource, *ConcurSource, *CouchbaseSource, *Db2Source, *DrillSource, *DynamicsAXSource,
// - *EloquaSource, *GoogleAdWordsSource, *GoogleBigQuerySource, *GreenplumSource, *HBaseSource, *HiveSource, *HubspotSource,
// - *ImpalaSource, *InformixSource, *JiraSource, *MagentoSource, *MariaDBSource, *MarketoSource, *MySqlSource, *NetezzaSource,
// - *OdbcSource, *OracleServiceCloudSource, *PaypalSource, *PhoenixSource, *PostgreSqlSource, *PrestoSource, *QuickBooksSource,
// - *ResponsysSource, *SalesforceMarketingCloudSource, *SalesforceSource, *SapBwSource, *SapCloudForCustomerSource, *SapEccSource,
// - *SapHanaSource, *SapOpenHubSource, *SapTableSource, *ServiceNowSource, *ShopifySource, *SparkSource, *SqlDWSource, *SqlMISource,
// - *SqlServerSource, *SqlSource, *SquareSource, *SybaseSource, *TeradataSource, *VerticaSource, *XeroSource, *ZohoSource
type TabularSourceClassification interface {
	CopySourceClassification
	// GetTabularSource() returns the TabularSource content of the underlying type.
	GetTabularSource() *TabularSource
}

// Copy activity sources of tabular type.
type TabularSource struct {
	CopySource
	// Query timeout. Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	QueryTimeout *interface{} `json:"queryTimeout,omitempty"`
}

// GetTabularSource implements the TabularSourceClassification interface for type TabularSource.
func (t *TabularSource) GetTabularSource() *TabularSource { return t }

// MarshalJSON implements the json.Marshaller interface for type TabularSource.
func (t TabularSource) MarshalJSON() ([]byte, error) {
	objectMap := t.marshalInternal("TabularSource")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TabularSource.
func (t *TabularSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TabularSource) marshalInternal(discValue string) map[string]interface{} {
	objectMap := t.CopySource.marshalInternal(discValue)
	if t.QueryTimeout != nil {
		objectMap["queryTimeout"] = t.QueryTimeout
	}
	return objectMap
}

func (t *TabularSource) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "queryTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &t.QueryTimeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.CopySource.unmarshalInternal(rawMsg)
}

// A copy activity tabular translator.
type TabularTranslator struct {
	CopyTranslator
	// The JSON Path of the Nested Array that is going to do cross-apply. Type: object (or Expression with resultType object).
	CollectionReference *interface{} `json:"collectionReference,omitempty"`

	// Column mappings. Example: "UserId: MyUserId, Group: MyGroup, Name: MyName" Type: string (or Expression with resultType string). This property will be
	// retired. Please use mappings property.
	ColumnMappings *interface{} `json:"columnMappings,omitempty"`

	// Whether to map complex (array and object) values to simple strings in json format. Type: boolean (or Expression with resultType boolean).
	MapComplexValuesToString *interface{} `json:"mapComplexValuesToString,omitempty"`

	// Column mappings with logical types. Tabular->tabular example:
	// [{"source":{"name":"CustomerName","type":"String"},"sink":{"name":"ClientName","type":"String"}},{"source":{"name":"CustomerAddress","type":"String"},"sink":{"name":"ClientAddress","type":"String"}}].
	// Hierarchical->tabular example:
	// [{"source":{"path":"$.CustomerName","type":"String"},"sink":{"name":"ClientName","type":"String"}},{"source":{"path":"$.CustomerAddress","type":"String"},"sink":{"name":"ClientAddress","type":"String"}}].
	// Type: object (or Expression with resultType object).
	Mappings *interface{} `json:"mappings,omitempty"`

	// The schema mapping to map between tabular data and hierarchical data. Example: {"Column1": "$.Column1", "Column2": "$.Column2.Property1", "Column3":
	// "$.Column2.Property2"}. Type: object (or Expression
	// with resultType object). This property will be retired. Please use mappings property.
	SchemaMapping *interface{} `json:"schemaMapping,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TabularTranslator.
func (t TabularTranslator) MarshalJSON() ([]byte, error) {
	objectMap := t.CopyTranslator.marshalInternal("TabularTranslator")
	if t.CollectionReference != nil {
		objectMap["collectionReference"] = t.CollectionReference
	}
	if t.ColumnMappings != nil {
		objectMap["columnMappings"] = t.ColumnMappings
	}
	if t.MapComplexValuesToString != nil {
		objectMap["mapComplexValuesToString"] = t.MapComplexValuesToString
	}
	if t.Mappings != nil {
		objectMap["mappings"] = t.Mappings
	}
	if t.SchemaMapping != nil {
		objectMap["schemaMapping"] = t.SchemaMapping
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TabularTranslator.
func (t *TabularTranslator) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collectionReference":
			if val != nil {
				err = json.Unmarshal(*val, &t.CollectionReference)
			}
			delete(rawMsg, key)
		case "columnMappings":
			if val != nil {
				err = json.Unmarshal(*val, &t.ColumnMappings)
			}
			delete(rawMsg, key)
		case "mapComplexValuesToString":
			if val != nil {
				err = json.Unmarshal(*val, &t.MapComplexValuesToString)
			}
			delete(rawMsg, key)
		case "mappings":
			if val != nil {
				err = json.Unmarshal(*val, &t.Mappings)
			}
			delete(rawMsg, key)
		case "schemaMapping":
			if val != nil {
				err = json.Unmarshal(*val, &t.SchemaMapping)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.CopyTranslator.unmarshalInternal(rawMsg)
}

// Linked service for Teradata data source.
type TeradataLinkedService struct {
	LinkedService
	// Teradata linked service properties.
	TypeProperties *TeradataLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TeradataLinkedService.
func (t TeradataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := t.LinkedService.marshalInternal("Teradata")
	if t.TypeProperties != nil {
		objectMap["typeProperties"] = t.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedService.
func (t *TeradataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &t.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.LinkedService.unmarshalInternal(rawMsg)
}

// Teradata linked service properties.
type TeradataLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *TeradataAuthenticationType `json:"authenticationType,omitempty"`

	// Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedServiceTypeProperties.
func (t *TeradataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &t.AuthenticationType)
			}
			delete(rawMsg, key)
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &t.ConnectionString)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &t.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "password":
			if val != nil {
				t.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &t.Server)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &t.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The settings that will be leveraged for teradata source partitioning.
type TeradataPartitionSettings struct {
	// The name of the column that will be used for proceeding range or hash partitioning. Type: string (or Expression with resultType string).
	PartitionColumnName *interface{} `json:"partitionColumnName,omitempty"`

	// The minimum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionLowerBound *interface{} `json:"partitionLowerBound,omitempty"`

	// The maximum value of column specified in partitionColumnName that will be used for proceeding range partitioning. Type: string (or Expression with resultType
	// string).
	PartitionUpperBound *interface{} `json:"partitionUpperBound,omitempty"`
}

// A copy activity Teradata source.
type TeradataSource struct {
	TabularSource
	// The partition mechanism that will be used for teradata read in parallel.
	PartitionOption *TeradataPartitionOption `json:"partitionOption,omitempty"`

	// The settings that will be leveraged for teradata source partitioning.
	PartitionSettings *TeradataPartitionSettings `json:"partitionSettings,omitempty"`

	// Teradata query. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TeradataSource.
func (t TeradataSource) MarshalJSON() ([]byte, error) {
	objectMap := t.TabularSource.marshalInternal("TeradataSource")
	if t.PartitionOption != nil {
		objectMap["partitionOption"] = t.PartitionOption
	}
	if t.PartitionSettings != nil {
		objectMap["partitionSettings"] = t.PartitionSettings
	}
	if t.Query != nil {
		objectMap["query"] = t.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataSource.
func (t *TeradataSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "partitionOption":
			if val != nil {
				err = json.Unmarshal(*val, &t.PartitionOption)
			}
			delete(rawMsg, key)
		case "partitionSettings":
			if val != nil {
				err = json.Unmarshal(*val, &t.PartitionSettings)
			}
			delete(rawMsg, key)
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &t.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.TabularSource.unmarshalInternal(rawMsg)
}

// The Teradata database dataset.
type TeradataTableDataset struct {
	Dataset
	// Teradata dataset properties.
	TypeProperties *TeradataTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TeradataTableDataset.
func (t TeradataTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := t.Dataset.marshalInternal("TeradataTable")
	if t.TypeProperties != nil {
		objectMap["typeProperties"] = t.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataTableDataset.
func (t *TeradataTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &t.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.Dataset.unmarshalInternal(rawMsg)
}

// Teradata dataset properties.
type TeradataTableDatasetTypeProperties struct {
	// The database name of Teradata. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The table name of Teradata. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`
}

// The data stored in text format.
type TextFormat struct {
	DatasetStorageFormat
	// The column delimiter. Type: string (or Expression with resultType string).
	ColumnDelimiter *interface{} `json:"columnDelimiter,omitempty"`

	// The code page name of the preferred encoding. If miss, the default value is ΓÇ£utf-8ΓÇ¥, unless BOM denotes another Unicode encoding. Refer to the ΓÇ£NameΓÇ¥
	// column of the table in the following link
	// to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx. Type: string (or Expression with resultType string).
	EncodingName *interface{} `json:"encodingName,omitempty"`

	// The escape character. Type: string (or Expression with resultType string).
	EscapeChar *interface{} `json:"escapeChar,omitempty"`

	// When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the first row of data. The default
	// value is false. Type: boolean (or Expression
	// with resultType boolean).
	FirstRowAsHeader *interface{} `json:"firstRowAsHeader,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue *interface{} `json:"nullValue,omitempty"`

	// The quote character. Type: string (or Expression with resultType string).
	QuoteChar *interface{} `json:"quoteChar,omitempty"`

	// The row delimiter. Type: string (or Expression with resultType string).
	RowDelimiter *interface{} `json:"rowDelimiter,omitempty"`

	// The number of lines/rows to be skipped when parsing text files. The default value is 0. Type: integer (or Expression with resultType integer).
	SkipLineCount *interface{} `json:"skipLineCount,omitempty"`

	// Treat empty column values in the text file as null. The default value is true. Type: boolean (or Expression with resultType boolean).
	TreatEmptyAsNull *interface{} `json:"treatEmptyAsNull,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TextFormat.
func (t TextFormat) MarshalJSON() ([]byte, error) {
	objectMap := t.DatasetStorageFormat.marshalInternal("TextFormat")
	if t.ColumnDelimiter != nil {
		objectMap["columnDelimiter"] = t.ColumnDelimiter
	}
	if t.EncodingName != nil {
		objectMap["encodingName"] = t.EncodingName
	}
	if t.EscapeChar != nil {
		objectMap["escapeChar"] = t.EscapeChar
	}
	if t.FirstRowAsHeader != nil {
		objectMap["firstRowAsHeader"] = t.FirstRowAsHeader
	}
	if t.NullValue != nil {
		objectMap["nullValue"] = t.NullValue
	}
	if t.QuoteChar != nil {
		objectMap["quoteChar"] = t.QuoteChar
	}
	if t.RowDelimiter != nil {
		objectMap["rowDelimiter"] = t.RowDelimiter
	}
	if t.SkipLineCount != nil {
		objectMap["skipLineCount"] = t.SkipLineCount
	}
	if t.TreatEmptyAsNull != nil {
		objectMap["treatEmptyAsNull"] = t.TreatEmptyAsNull
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextFormat.
func (t *TextFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			if val != nil {
				err = json.Unmarshal(*val, &t.ColumnDelimiter)
			}
			delete(rawMsg, key)
		case "encodingName":
			if val != nil {
				err = json.Unmarshal(*val, &t.EncodingName)
			}
			delete(rawMsg, key)
		case "escapeChar":
			if val != nil {
				err = json.Unmarshal(*val, &t.EscapeChar)
			}
			delete(rawMsg, key)
		case "firstRowAsHeader":
			if val != nil {
				err = json.Unmarshal(*val, &t.FirstRowAsHeader)
			}
			delete(rawMsg, key)
		case "nullValue":
			if val != nil {
				err = json.Unmarshal(*val, &t.NullValue)
			}
			delete(rawMsg, key)
		case "quoteChar":
			if val != nil {
				err = json.Unmarshal(*val, &t.QuoteChar)
			}
			delete(rawMsg, key)
		case "rowDelimiter":
			if val != nil {
				err = json.Unmarshal(*val, &t.RowDelimiter)
			}
			delete(rawMsg, key)
		case "skipLineCount":
			if val != nil {
				err = json.Unmarshal(*val, &t.SkipLineCount)
			}
			delete(rawMsg, key)
		case "treatEmptyAsNull":
			if val != nil {
				err = json.Unmarshal(*val, &t.TreatEmptyAsNull)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.DatasetStorageFormat.unmarshalInternal(rawMsg)
}

// The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'
type TrackedResource struct {
	Resource
	// The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags *map[string]string `json:"tags,omitempty"`
}

// A data flow transformation.
type Transformation struct {
	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Transformation name.
	Name *string `json:"name,omitempty"`
}

// TriggerClassification provides polymorphic access to related types.
// Call the interface's GetTrigger() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *Trigger, *BlobEventsTrigger, *BlobTrigger, *ChainingTrigger, *MultiplePipelineTrigger, *RerunTumblingWindowTrigger,
// - *ScheduleTrigger, *TumblingWindowTrigger
type TriggerClassification interface {
	// GetTrigger() returns the Trigger content of the underlying type.
	GetTrigger() *Trigger
}

// Azure Synapse nested object which contains information about creating pipeline run
type Trigger struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`

	// Trigger type.
	Type *string `json:"type,omitempty"`
}

// GetTrigger implements the TriggerClassification interface for type Trigger.
func (t *Trigger) GetTrigger() *Trigger { return t }

// UnmarshalJSON implements the json.Unmarshaller interface for type Trigger.
func (t *Trigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t Trigger) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if t.Annotations != nil {
		objectMap["annotations"] = t.Annotations
	}
	if t.Description != nil {
		objectMap["description"] = t.Description
	}
	if t.RuntimeState != nil {
		objectMap["runtimeState"] = t.RuntimeState
	}
	t.Type = &discValue
	objectMap["type"] = t.Type
	if t.AdditionalProperties != nil {
		for key, val := range *t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return objectMap
}

func (t *Trigger) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &t.Annotations)
			}
			delete(rawMsg, key)
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &t.Description)
			}
			delete(rawMsg, key)
		case "runtimeState":
			if val != nil {
				err = json.Unmarshal(*val, &t.RuntimeState)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &t.Type)
			}
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*t.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerCreateOrUpdateTriggerOptions contains the optional parameters for the Trigger.CreateOrUpdateTrigger method.
type TriggerCreateOrUpdateTriggerOptions struct {
	// ETag of the trigger entity. Should only be specified for update, for which it should match existing entity or can be * for unconditional update.
	IfMatch *string
}

// TriggerDeleteTriggerOptions contains the optional parameters for the Trigger.DeleteTrigger method.
type TriggerDeleteTriggerOptions struct {
	// placeholder for future optional parameters
}

// Defines the response of a provision trigger dependency operation.
type TriggerDependencyProvisioningStatus struct {
	// Provisioning status.
	ProvisioningStatus *string `json:"provisioningStatus,omitempty"`

	// Trigger name.
	TriggerName *string `json:"triggerName,omitempty"`
}

// TriggerDependencyReferenceClassification provides polymorphic access to related types.
// Call the interface's GetTriggerDependencyReference() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *TriggerDependencyReference, *TumblingWindowTriggerDependencyReference
type TriggerDependencyReferenceClassification interface {
	DependencyReferenceClassification
	// GetTriggerDependencyReference() returns the TriggerDependencyReference content of the underlying type.
	GetTriggerDependencyReference() *TriggerDependencyReference
}

// Trigger referenced dependency.
type TriggerDependencyReference struct {
	DependencyReference
	// Referenced trigger.
	ReferenceTrigger *TriggerReference `json:"referenceTrigger,omitempty"`
}

// GetTriggerDependencyReference implements the TriggerDependencyReferenceClassification interface for type TriggerDependencyReference.
func (t *TriggerDependencyReference) GetTriggerDependencyReference() *TriggerDependencyReference {
	return t
}

// MarshalJSON implements the json.Marshaller interface for type TriggerDependencyReference.
func (t TriggerDependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := t.marshalInternal("TriggerDependencyReference")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerDependencyReference.
func (t *TriggerDependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TriggerDependencyReference) marshalInternal(discValue string) map[string]interface{} {
	objectMap := t.DependencyReference.marshalInternal(discValue)
	if t.ReferenceTrigger != nil {
		objectMap["referenceTrigger"] = t.ReferenceTrigger
	}
	return objectMap
}

func (t *TriggerDependencyReference) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "referenceTrigger":
			if val != nil {
				err = json.Unmarshal(*val, &t.ReferenceTrigger)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.DependencyReference.unmarshalInternal(rawMsg)
}

// TriggerGetEventSubscriptionStatusOptions contains the optional parameters for the Trigger.GetEventSubscriptionStatus method.
type TriggerGetEventSubscriptionStatusOptions struct {
	// placeholder for future optional parameters
}

// TriggerGetTriggerOptions contains the optional parameters for the Trigger.GetTrigger method.
type TriggerGetTriggerOptions struct {
	// ETag of the trigger entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will
	// be returned.
	IfNoneMatch *string
}

// TriggerGetTriggersByWorkspaceOptions contains the optional parameters for the Trigger.GetTriggersByWorkspace method.
type TriggerGetTriggersByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// A list of trigger resources.
type TriggerListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of triggers.
	Value *[]TriggerResource `json:"value,omitempty"`
}

// TriggerListResponseResponse is the response envelope for operations that return a TriggerListResponse type.
type TriggerListResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of trigger resources.
	TriggerListResponse *TriggerListResponse
}

// Pipeline that needs to be triggered with the given parameters.
type TriggerPipelineReference struct {
	// Pipeline parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Pipeline reference.
	PipelineReference *PipelineReference `json:"pipelineReference,omitempty"`
}

// Trigger reference type.
type TriggerReference struct {
	// Reference trigger name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Trigger reference type.
	Type *TriggerReferenceType `json:"type,omitempty"`
}

// Trigger resource type.
type TriggerResource struct {
	AzureEntityResource
	// Properties of the trigger.
	Properties TriggerClassification `json:"properties,omitempty"`
}

// TriggerResourcePollerResponse is the response envelope for operations that asynchronously return a TriggerResource type.
type TriggerResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*TriggerResourceResponse, error)

	// Poller contains an initialized poller.
	Poller TriggerResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerResourceResponse is the response envelope for operations that return a TriggerResource type.
type TriggerResourceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Trigger resource type.
	TriggerResource *TriggerResource
}

// Trigger runs.
type TriggerRun struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Trigger error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// List of property name and value related to trigger run. Name, value pair depends on type of trigger.
	Properties *map[string]string `json:"properties,omitempty" azure:"ro"`

	// Trigger run status.
	Status *TriggerRunStatus `json:"status,omitempty" azure:"ro"`

	// Trigger name.
	TriggerName *string `json:"triggerName,omitempty" azure:"ro"`

	// Trigger run id.
	TriggerRunID *string `json:"triggerRunId,omitempty" azure:"ro"`

	// Trigger run start time.
	TriggerRunTimestamp *time.Time `json:"triggerRunTimestamp,omitempty" azure:"ro"`

	// Trigger type.
	TriggerType *string `json:"triggerType,omitempty" azure:"ro"`

	// List of pipeline name and run Id triggered by the trigger run.
	TriggeredPipelines *map[string]string `json:"triggeredPipelines,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerRun.
func (t TriggerRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.Message != nil {
		objectMap["message"] = t.Message
	}
	if t.Properties != nil {
		objectMap["properties"] = t.Properties
	}
	if t.Status != nil {
		objectMap["status"] = t.Status
	}
	if t.TriggerName != nil {
		objectMap["triggerName"] = t.TriggerName
	}
	if t.TriggerRunID != nil {
		objectMap["triggerRunId"] = t.TriggerRunID
	}
	if t.TriggerRunTimestamp != nil {
		objectMap["triggerRunTimestamp"] = (*timeRFC3339)(t.TriggerRunTimestamp)
	}
	if t.TriggerType != nil {
		objectMap["triggerType"] = t.TriggerType
	}
	if t.TriggeredPipelines != nil {
		objectMap["triggeredPipelines"] = t.TriggeredPipelines
	}
	if t.AdditionalProperties != nil {
		for key, val := range *t.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerRun.
func (t *TriggerRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "message":
			if val != nil {
				err = json.Unmarshal(*val, &t.Message)
			}
			delete(rawMsg, key)
		case "properties":
			if val != nil {
				err = json.Unmarshal(*val, &t.Properties)
			}
			delete(rawMsg, key)
		case "status":
			if val != nil {
				err = json.Unmarshal(*val, &t.Status)
			}
			delete(rawMsg, key)
		case "triggerName":
			if val != nil {
				err = json.Unmarshal(*val, &t.TriggerName)
			}
			delete(rawMsg, key)
		case "triggerRunId":
			if val != nil {
				err = json.Unmarshal(*val, &t.TriggerRunID)
			}
			delete(rawMsg, key)
		case "triggerRunTimestamp":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				t.TriggerRunTimestamp = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "triggerType":
			if val != nil {
				err = json.Unmarshal(*val, &t.TriggerType)
			}
			delete(rawMsg, key)
		case "triggeredPipelines":
			if val != nil {
				err = json.Unmarshal(*val, &t.TriggeredPipelines)
			}
			delete(rawMsg, key)
		default:
			if t.AdditionalProperties == nil {
				t.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*t.AdditionalProperties)[key] = aux
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TriggerRunCancelTriggerInstanceOptions contains the optional parameters for the TriggerRun.CancelTriggerInstance method.
type TriggerRunCancelTriggerInstanceOptions struct {
	// placeholder for future optional parameters
}

// TriggerRunQueryTriggerRunsByWorkspaceOptions contains the optional parameters for the TriggerRun.QueryTriggerRunsByWorkspace method.
type TriggerRunQueryTriggerRunsByWorkspaceOptions struct {
	// placeholder for future optional parameters
}

// TriggerRunRerunTriggerInstanceOptions contains the optional parameters for the TriggerRun.RerunTriggerInstance method.
type TriggerRunRerunTriggerInstanceOptions struct {
	// placeholder for future optional parameters
}

// A list of trigger runs.
type TriggerRunsQueryResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of trigger runs.
	Value *[]TriggerRun `json:"value,omitempty"`
}

// TriggerRunsQueryResponseResponse is the response envelope for operations that return a TriggerRunsQueryResponse type.
type TriggerRunsQueryResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of trigger runs.
	TriggerRunsQueryResponse *TriggerRunsQueryResponse
}

// TriggerStartTriggerOptions contains the optional parameters for the Trigger.StartTrigger method.
type TriggerStartTriggerOptions struct {
	// placeholder for future optional parameters
}

// TriggerStopTriggerOptions contains the optional parameters for the Trigger.StopTrigger method.
type TriggerStopTriggerOptions struct {
	// placeholder for future optional parameters
}

// TriggerSubscribeTriggerToEventsOptions contains the optional parameters for the Trigger.SubscribeTriggerToEvents method.
type TriggerSubscribeTriggerToEventsOptions struct {
	// placeholder for future optional parameters
}

// Defines the response of a trigger subscription operation.
type TriggerSubscriptionOperationStatus struct {
	// Event Subscription Status.
	Status *EventSubscriptionStatus `json:"status,omitempty" azure:"ro"`

	// Trigger name.
	TriggerName *string `json:"triggerName,omitempty" azure:"ro"`
}

// TriggerSubscriptionOperationStatusPollerResponse is the response envelope for operations that asynchronously return a TriggerSubscriptionOperationStatus
// type.
type TriggerSubscriptionOperationStatusPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*TriggerSubscriptionOperationStatusResponse, error)

	// Poller contains an initialized poller.
	Poller TriggerSubscriptionOperationStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerSubscriptionOperationStatusResponse is the response envelope for operations that return a TriggerSubscriptionOperationStatus type.
type TriggerSubscriptionOperationStatusResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Defines the response of a trigger subscription operation.
	TriggerSubscriptionOperationStatus *TriggerSubscriptionOperationStatus
}

// TriggerUnsubscribeTriggerFromEventsOptions contains the optional parameters for the Trigger.UnsubscribeTriggerFromEvents method.
type TriggerUnsubscribeTriggerFromEventsOptions struct {
	// placeholder for future optional parameters
}

// Trigger that schedules pipeline runs for all fixed time interval windows from a start time without gaps and also supports backfill scenarios (when start
// time is in the past).
type TumblingWindowTrigger struct {
	Trigger
	// Pipeline for which runs are created when an event is fired for trigger window that is ready.
	Pipeline *TriggerPipelineReference `json:"pipeline,omitempty"`

	// Tumbling Window Trigger properties.
	TypeProperties *TumblingWindowTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTrigger.
func (t TumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := t.Trigger.marshalInternal("TumblingWindowTrigger")
	if t.Pipeline != nil {
		objectMap["pipeline"] = t.Pipeline
	}
	if t.TypeProperties != nil {
		objectMap["typeProperties"] = t.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTrigger.
func (t *TumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pipeline":
			if val != nil {
				err = json.Unmarshal(*val, &t.Pipeline)
			}
			delete(rawMsg, key)
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &t.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.Trigger.unmarshalInternal(rawMsg)
}

// Referenced tumbling window trigger dependency.
type TumblingWindowTriggerDependencyReference struct {
	TriggerDependencyReference
	// Timespan applied to the start time of a tumbling window when evaluating dependency.
	Offset *string `json:"offset,omitempty"`

	// The size of the window when evaluating the dependency. If undefined the frequency of the tumbling window will be used.
	Size *string `json:"size,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTriggerDependencyReference.
func (t TumblingWindowTriggerDependencyReference) MarshalJSON() ([]byte, error) {
	objectMap := t.TriggerDependencyReference.marshalInternal("TumblingWindowTriggerDependencyReference")
	if t.Offset != nil {
		objectMap["offset"] = t.Offset
	}
	if t.Size != nil {
		objectMap["size"] = t.Size
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTriggerDependencyReference.
func (t *TumblingWindowTriggerDependencyReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "offset":
			if val != nil {
				err = json.Unmarshal(*val, &t.Offset)
			}
			delete(rawMsg, key)
		case "size":
			if val != nil {
				err = json.Unmarshal(*val, &t.Size)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return t.TriggerDependencyReference.unmarshalInternal(rawMsg)
}

// Tumbling Window Trigger properties.
type TumblingWindowTriggerTypeProperties struct {
	// Specifies how long the trigger waits past due time before triggering new run. It doesn't alter window start and end time. The default is 0. Type: string
	// (or Expression with resultType string),
	// pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Delay *interface{} `json:"delay,omitempty"`

	// Triggers that this trigger depends on. Only tumbling window triggers are supported.
	DependsOn *[]DependencyReferenceClassification `json:"dependsOn,omitempty"`

	// The end time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The frequency of the time windows.
	Frequency *TumblingWindowFrequency `json:"frequency,omitempty"`

	// The interval of the time windows. The minimum interval allowed is 15 Minutes.
	Interval *int32 `json:"interval,omitempty"`

	// The max number of parallel time windows (ready for execution) for which a new run is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// Retry policy that will be applied for failed pipeline runs.
	RetryPolicy *RetryPolicy `json:"retryPolicy,omitempty"`

	// The start time for the time period for the trigger during which events are fired for windows that are ready. Only UTC time is currently supported.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TumblingWindowTriggerTypeProperties.
func (t TumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.Delay != nil {
		objectMap["delay"] = t.Delay
	}
	if t.DependsOn != nil {
		objectMap["dependsOn"] = t.DependsOn
	}
	if t.EndTime != nil {
		objectMap["endTime"] = (*timeRFC3339)(t.EndTime)
	}
	if t.Frequency != nil {
		objectMap["frequency"] = t.Frequency
	}
	if t.Interval != nil {
		objectMap["interval"] = t.Interval
	}
	if t.MaxConcurrency != nil {
		objectMap["maxConcurrency"] = t.MaxConcurrency
	}
	if t.RetryPolicy != nil {
		objectMap["retryPolicy"] = t.RetryPolicy
	}
	if t.StartTime != nil {
		objectMap["startTime"] = (*timeRFC3339)(t.StartTime)
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TumblingWindowTriggerTypeProperties.
func (t *TumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delay":
			if val != nil {
				err = json.Unmarshal(*val, &t.Delay)
			}
			delete(rawMsg, key)
		case "dependsOn":
			if val != nil {
				t.DependsOn, err = unmarshalDependencyReferenceClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "endTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				t.EndTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		case "frequency":
			if val != nil {
				err = json.Unmarshal(*val, &t.Frequency)
			}
			delete(rawMsg, key)
		case "interval":
			if val != nil {
				err = json.Unmarshal(*val, &t.Interval)
			}
			delete(rawMsg, key)
		case "maxConcurrency":
			if val != nil {
				err = json.Unmarshal(*val, &t.MaxConcurrency)
			}
			delete(rawMsg, key)
		case "retryPolicy":
			if val != nil {
				err = json.Unmarshal(*val, &t.RetryPolicy)
			}
			delete(rawMsg, key)
		case "startTime":
			if val != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*val, &aux)
				t.StartTime = (*time.Time)(&aux)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// This activity executes inner activities until the specified boolean expression results to true or timeout is reached, whichever is earlier.
type UntilActivity struct {
	Activity
	// Until activity properties.
	TypeProperties *UntilActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UntilActivity.
func (u UntilActivity) MarshalJSON() ([]byte, error) {
	objectMap := u.Activity.marshalInternal("Until")
	if u.TypeProperties != nil {
		objectMap["typeProperties"] = u.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivity.
func (u *UntilActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &u.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return u.Activity.unmarshalInternal(rawMsg)
}

// Until activity properties.
type UntilActivityTypeProperties struct {
	// List of activities to execute.
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// An expression that would evaluate to Boolean. The loop will continue until this expression evaluates to true
	Expression *Expression `json:"expression,omitempty"`

	// Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7) which is 1 week as default.
	// Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])). Type: string (or Expression with resultType string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *interface{} `json:"timeout,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivityTypeProperties.
func (u *UntilActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				u.Activities, err = unmarshalActivityClassificationArray(*val)
			}
			delete(rawMsg, key)
		case "expression":
			if val != nil {
				err = json.Unmarshal(*val, &u.Expression)
			}
			delete(rawMsg, key)
		case "timeout":
			if val != nil {
				err = json.Unmarshal(*val, &u.Timeout)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// User property.
type UserProperty struct {
	// User property name.
	Name *string `json:"name,omitempty"`

	// User property value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// This activity verifies that an external resource exists.
type ValidationActivity struct {
	Activity
	// Validation activity properties.
	TypeProperties *ValidationActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidationActivity.
func (v ValidationActivity) MarshalJSON() ([]byte, error) {
	objectMap := v.Activity.marshalInternal("Validation")
	if v.TypeProperties != nil {
		objectMap["typeProperties"] = v.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationActivity.
func (v *ValidationActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &v.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return v.Activity.unmarshalInternal(rawMsg)
}

// Validation activity properties.
type ValidationActivityTypeProperties struct {
	// Can be used if dataset points to a folder. If set to true, the folder must have at least one file. If set to false, the folder must be empty. Type: boolean
	// (or Expression with resultType boolean).
	ChildItems *interface{} `json:"childItems,omitempty"`

	// Validation activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Can be used if dataset points to a file. The file must be greater than or equal in size to the value specified. Type: integer (or Expression with resultType
	// integer).
	MinimumSize *interface{} `json:"minimumSize,omitempty"`

	// A delay in seconds between validation attempts. If no value is specified, 10 seconds will be used as the default. Type: integer (or Expression with resultType
	// integer).
	Sleep *interface{} `json:"sleep,omitempty"`

	// Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7) which is 1 week as default.
	// Type: string (or Expression with resultType
	// string), pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *interface{} `json:"timeout,omitempty"`
}

// Definition of a single variable for a Pipeline.
type VariableSpecification struct {
	// Default value of variable.
	DefaultValue *interface{} `json:"defaultValue,omitempty"`

	// Variable type.
	Type *VariableType `json:"type,omitempty"`
}

// Vertica Properties
type VerticaDatasetTypeProperties struct {
	// The schema name of the Vertica. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Vertica. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Vertica linked service.
type VerticaLinkedService struct {
	LinkedService
	// Vertica linked service properties.
	TypeProperties *VerticaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VerticaLinkedService.
func (v VerticaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := v.LinkedService.marshalInternal("Vertica")
	if v.TypeProperties != nil {
		objectMap["typeProperties"] = v.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaLinkedService.
func (v *VerticaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &v.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return v.LinkedService.unmarshalInternal(rawMsg)
}

// Vertica linked service properties.
type VerticaLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// A copy activity Vertica source.
type VerticaSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VerticaSource.
func (v VerticaSource) MarshalJSON() ([]byte, error) {
	objectMap := v.TabularSource.marshalInternal("VerticaSource")
	if v.Query != nil {
		objectMap["query"] = v.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaSource.
func (v *VerticaSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &v.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return v.TabularSource.unmarshalInternal(rawMsg)
}

// Vertica dataset.
type VerticaTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *VerticaDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VerticaTableDataset.
func (v VerticaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := v.Dataset.marshalInternal("VerticaTable")
	if v.TypeProperties != nil {
		objectMap["typeProperties"] = v.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaTableDataset.
func (v *VerticaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &v.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return v.Dataset.unmarshalInternal(rawMsg)
}

// Virtual Network Profile
type VirtualNetworkProfile struct {
	// Subnet ID used for computes in workspace
	ComputeSubnetID *string `json:"computeSubnetId,omitempty"`
}

// This activity suspends pipeline execution for the specified interval.
type WaitActivity struct {
	Activity
	// Wait activity properties.
	TypeProperties *WaitActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WaitActivity.
func (w WaitActivity) MarshalJSON() ([]byte, error) {
	objectMap := w.Activity.marshalInternal("Wait")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WaitActivity.
func (w *WaitActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.Activity.unmarshalInternal(rawMsg)
}

// Wait activity properties.
type WaitActivityTypeProperties struct {
	// Duration in seconds.
	WaitTimeInSeconds *int32 `json:"waitTimeInSeconds,omitempty"`
}

// Web activity.
type WebActivity struct {
	ExecutionActivity
	// Web activity properties.
	TypeProperties *WebActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebActivity.
func (w WebActivity) MarshalJSON() ([]byte, error) {
	objectMap := w.ExecutionActivity.marshalInternal("WebActivity")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivity.
func (w *WebActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.ExecutionActivity.unmarshalInternal(rawMsg)
}

// Web activity authentication properties.
type WebActivityAuthentication struct {
	// Password for the PFX file or basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Base64-encoded contents of a PFX file.
	Pfx SecretBaseClassification `json:"pfx,omitempty"`

	// Resource for which Azure Auth token will be requested when using MSI Authentication.
	Resource *string `json:"resource,omitempty"`

	// Web activity authentication (Basic/ClientCertificate/MSI)
	Type *string `json:"type,omitempty"`

	// Web activity authentication user name for basic authentication.
	Username *string `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivityAuthentication.
func (w *WebActivityAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			if val != nil {
				w.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "pfx":
			if val != nil {
				w.Pfx, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "resource":
			if val != nil {
				err = json.Unmarshal(*val, &w.Resource)
			}
			delete(rawMsg, key)
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &w.Type)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &w.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Web activity type properties.
type WebActivityTypeProperties struct {
	// Authentication method used for calling the endpoint.
	Authentication *WebActivityAuthentication `json:"authentication,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType
	// string).
	Body *interface{} `json:"body,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// List of datasets passed to web endpoint.
	Datasets *[]DatasetReference `json:"datasets,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us",
	// "Content-Type": "application/json" }. Type:
	// string (or Expression with resultType string).
	Headers *interface{} `json:"headers,omitempty"`

	// List of linked services passed to web endpoint.
	LinkedServices *[]LinkedServiceReference `json:"linkedServices,omitempty"`

	// Rest API method for target endpoint.
	Method *WebActivityMethod `json:"method,omitempty"`

	// Web activity target endpoint and path. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// A WebLinkedService that uses anonymous authentication to communicate with an HTTP endpoint.
type WebAnonymousAuthentication struct {
	WebLinkedServiceTypeProperties
}

// MarshalJSON implements the json.Marshaller interface for type WebAnonymousAuthentication.
func (w WebAnonymousAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := w.WebLinkedServiceTypeProperties.marshalInternal(WebAuthenticationTypeAnonymous)
	return json.Marshal(objectMap)
}

// A WebLinkedService that uses basic authentication to communicate with an HTTP endpoint.
type WebBasicAuthentication struct {
	WebLinkedServiceTypeProperties
	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebBasicAuthentication.
func (w WebBasicAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := w.WebLinkedServiceTypeProperties.marshalInternal(WebAuthenticationTypeBasic)
	if w.Password != nil {
		objectMap["password"] = w.Password
	}
	if w.Username != nil {
		objectMap["username"] = w.Username
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebBasicAuthentication.
func (w *WebBasicAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			if val != nil {
				w.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &w.Username)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.WebLinkedServiceTypeProperties.unmarshalInternal(rawMsg)
}

// A WebLinkedService that uses client certificate based authentication to communicate with an HTTP endpoint. This scheme follows mutual authentication;
// the server must also provide valid credentials to
// the client.
type WebClientCertificateAuthentication struct {
	WebLinkedServiceTypeProperties
	// Password for the PFX file.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Base64-encoded contents of a PFX file.
	Pfx SecretBaseClassification `json:"pfx,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebClientCertificateAuthentication.
func (w WebClientCertificateAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := w.WebLinkedServiceTypeProperties.marshalInternal(WebAuthenticationTypeClientCertificate)
	if w.Password != nil {
		objectMap["password"] = w.Password
	}
	if w.Pfx != nil {
		objectMap["pfx"] = w.Pfx
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebClientCertificateAuthentication.
func (w *WebClientCertificateAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			if val != nil {
				w.Password, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "pfx":
			if val != nil {
				w.Pfx, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.WebLinkedServiceTypeProperties.unmarshalInternal(rawMsg)
}

// WebHook activity.
type WebHookActivity struct {
	Activity
	// WebHook activity properties.
	TypeProperties *WebHookActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebHookActivity.
func (w WebHookActivity) MarshalJSON() ([]byte, error) {
	objectMap := w.Activity.marshalInternal("WebHook")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookActivity.
func (w *WebHookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.Activity.unmarshalInternal(rawMsg)
}

// WebHook activity type properties.
type WebHookActivityTypeProperties struct {
	// Authentication method used for calling the endpoint.
	Authentication *WebActivityAuthentication `json:"authentication,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type: string (or Expression with resultType
	// string).
	Body *interface{} `json:"body,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers" : { "Accept-Language": "en-us",
	// "Content-Type": "application/json" }. Type:
	// string (or Expression with resultType string).
	Headers *interface{} `json:"headers,omitempty"`

	// Rest API method for target endpoint.
	Method *WebHookActivityMethod `json:"method,omitempty"`

	// When set to true, statusCode, output and error in callback request body will be consumed by activity. The activity can be marked as failed by setting
	// statusCode >= 400 in callback request. Default is
	// false. Type: boolean (or Expression with resultType boolean).
	ReportStatusOnCallBack *interface{} `json:"reportStatusOnCallBack,omitempty"`

	// The timeout within which the webhook should be called back. If there is no value specified, it defaults to 10 minutes. Type: string. Pattern: ((\d+).)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *string `json:"timeout,omitempty"`

	// WebHook activity target endpoint and path. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// Web linked service.
type WebLinkedService struct {
	LinkedService
	// Web linked service properties.
	TypeProperties WebLinkedServiceTypePropertiesClassification `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebLinkedService.
func (w WebLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := w.LinkedService.marshalInternal("Web")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedService.
func (w *WebLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				w.TypeProperties, err = unmarshalWebLinkedServiceTypePropertiesClassification(*val)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.LinkedService.unmarshalInternal(rawMsg)
}

// WebLinkedServiceTypePropertiesClassification provides polymorphic access to related types.
// Call the interface's GetWebLinkedServiceTypeProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *WebLinkedServiceTypeProperties, *WebAnonymousAuthentication, *WebBasicAuthentication, *WebClientCertificateAuthentication
type WebLinkedServiceTypePropertiesClassification interface {
	// GetWebLinkedServiceTypeProperties() returns the WebLinkedServiceTypeProperties content of the underlying type.
	GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties
}

// Base definition of WebLinkedServiceTypeProperties, this typeProperties is polymorphic based on authenticationType, so not flattened in SDK models.
type WebLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the web table source.
	AuthenticationType *WebAuthenticationType `json:"authenticationType,omitempty"`

	// The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// GetWebLinkedServiceTypeProperties implements the WebLinkedServiceTypePropertiesClassification interface for type WebLinkedServiceTypeProperties.
func (w *WebLinkedServiceTypeProperties) GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties {
	return w
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedServiceTypeProperties.
func (w *WebLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return w.unmarshalInternal(rawMsg)
}

func (w WebLinkedServiceTypeProperties) marshalInternal(discValue WebAuthenticationType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	w.AuthenticationType = &discValue
	objectMap["authenticationType"] = w.AuthenticationType
	if w.URL != nil {
		objectMap["url"] = w.URL
	}
	return objectMap
}

func (w *WebLinkedServiceTypeProperties) unmarshalInternal(rawMsg map[string]*json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &w.AuthenticationType)
			}
			delete(rawMsg, key)
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &w.URL)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A copy activity source for web page table.
type WebSource struct {
	CopySource
}

// MarshalJSON implements the json.Marshaller interface for type WebSource.
func (w WebSource) MarshalJSON() ([]byte, error) {
	objectMap := w.CopySource.marshalInternal("WebSource")
	return json.Marshal(objectMap)
}

// The dataset points to a HTML table in the web page.
type WebTableDataset struct {
	Dataset
	// Web table dataset properties.
	TypeProperties *WebTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebTableDataset.
func (w WebTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := w.Dataset.marshalInternal("WebTable")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebTableDataset.
func (w *WebTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return w.Dataset.unmarshalInternal(rawMsg)
}

// Web table dataset properties.
type WebTableDatasetTypeProperties struct {
	// The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum: 0.
	Index *interface{} `json:"index,omitempty"`

	// The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// A workspace
type Workspace struct {
	TrackedResource
	// Identity of the workspace
	IDentity *ManagedIDentity `json:"identity,omitempty"`

	// Workspace resource properties
	Properties *WorkspaceProperties `json:"properties,omitempty"`
}

// WorkspaceGetOptions contains the optional parameters for the Workspace.Get method.
type WorkspaceGetOptions struct {
	// placeholder for future optional parameters
}

// Identity properties of the workspace resource.
type WorkspaceIDentity struct {
	// The principal id of the identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// The client tenant id of the identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// The identity type. Currently the only supported type is 'SystemAssigned'.
	Type *string `json:"type,omitempty"`
}

// Details of the customer managed key associated with the workspace
type WorkspaceKeyDetails struct {
	// Workspace Key sub-resource key vault url
	KeyVaultURL *string `json:"keyVaultUrl,omitempty"`

	// Workspace Key sub-resource name
	Name *string `json:"name,omitempty"`
}

// Workspace properties
type WorkspaceProperties struct {
	// Babylon Configuration
	BabylonConfiguration *BabylonConfiguration `json:"babylonConfiguration,omitempty"`

	// Connectivity endpoints
	ConnectivityEndpoints *map[string]string `json:"connectivityEndpoints,omitempty"`

	// Workspace default data lake storage account details
	DefaultDataLakeStorage *DataLakeStorageAccountDetails `json:"defaultDataLakeStorage,omitempty"`

	// The encryption details of the workspace
	Encryption *EncryptionDetails `json:"encryption,omitempty"`

	// Workspace level configs and feature flags
	ExtraProperties *map[string]interface{} `json:"extraProperties,omitempty" azure:"ro"`

	// Workspace managed resource group. The resource group name uniquely identifies the resource group within the user subscriptionId. The resource group name
	// must be no longer than 90 characters long, and
	// must be alphanumeric characters (Char.IsLetterOrDigit()) and '-', '_', '(', ')' and'.'. Note that the name cannot end with '.'
	ManagedResourceGroupName *string `json:"managedResourceGroupName,omitempty"`

	// Setting this to 'default' will ensure that all compute for this workspace is in a virtual network managed on behalf of the user.
	ManagedVirtualNetwork *string `json:"managedVirtualNetwork,omitempty"`

	// Managed Virtual Network Settings
	ManagedVirtualNetworkSettings *ManagedVirtualNetworkSettings `json:"managedVirtualNetworkSettings,omitempty"`

	// Private endpoint connections to the workspace
	PrivateEndpointConnections *[]PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`

	// Resource provisioning state
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// Login for workspace SQL active directory administrator
	SQLAdministratorLogin *string `json:"sqlAdministratorLogin,omitempty"`

	// SQL administrator login password
	SQLAdministratorLoginPassword *string `json:"sqlAdministratorLoginPassword,omitempty"`

	// Virtual Network profile
	VirtualNetworkProfile *VirtualNetworkProfile `json:"virtualNetworkProfile,omitempty"`

	// The workspace unique identifier
	WorkspaceUId *string `json:"workspaceUID,omitempty" azure:"ro"`
}

// WorkspaceResponse is the response envelope for operations that return a Workspace type.
type WorkspaceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A workspace
	Workspace *Workspace
}

// Parameters for updating a workspace resource.
type WorkspaceUpdateParameters struct {
	// Managed service identity of the workspace.
	IDentity *WorkspaceIDentity `json:"identity,omitempty"`

	// The resource tags.
	Tags *map[string]string `json:"tags,omitempty"`
}

// Xero Service linked service.
type XeroLinkedService struct {
	LinkedService
	// Xero Service linked service properties.
	TypeProperties *XeroLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XeroLinkedService.
func (x XeroLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := x.LinkedService.marshalInternal("Xero")
	if x.TypeProperties != nil {
		objectMap["typeProperties"] = x.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedService.
func (x *XeroLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &x.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return x.LinkedService.unmarshalInternal(rawMsg)
}

// Xero Service linked service properties.
type XeroLinkedServiceTypeProperties struct {
	// The consumer key associated with the Xero application.
	ConsumerKey SecretBaseClassification `json:"consumerKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Xero server. (i.e. api.xero.com)
	Host *interface{} `json:"host,omitempty"`

	// The private key from the .pem file that was generated for your Xero private application. You must include all the text from the .pem file, including
	// the Unix line endings( ).
	PrivateKey SecretBaseClassification `json:"privateKey,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedServiceTypeProperties.
func (x *XeroLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consumerKey":
			if val != nil {
				x.ConsumerKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &x.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &x.Host)
			}
			delete(rawMsg, key)
		case "privateKey":
			if val != nil {
				x.PrivateKey, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &x.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &x.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &x.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Xero Service dataset.
type XeroObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XeroObjectDataset.
func (x XeroObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := x.Dataset.marshalInternal("XeroObject")
	if x.TypeProperties != nil {
		objectMap["typeProperties"] = x.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroObjectDataset.
func (x *XeroObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &x.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return x.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Xero Service source.
type XeroSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XeroSource.
func (x XeroSource) MarshalJSON() ([]byte, error) {
	objectMap := x.TabularSource.marshalInternal("XeroSource")
	if x.Query != nil {
		objectMap["query"] = x.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroSource.
func (x *XeroSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &x.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return x.TabularSource.unmarshalInternal(rawMsg)
}

// Zoho server linked service.
type ZohoLinkedService struct {
	LinkedService
	// Zoho server linked service properties.
	TypeProperties *ZohoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ZohoLinkedService.
func (z ZohoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := z.LinkedService.marshalInternal("Zoho")
	if z.TypeProperties != nil {
		objectMap["typeProperties"] = z.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedService.
func (z *ZohoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &z.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return z.LinkedService.unmarshalInternal(rawMsg)
}

// Zoho server linked service properties.
type ZohoLinkedServiceTypeProperties struct {
	// The access token for Zoho authentication.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager. Type: string (or Expression
	// with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting over SSL. The default value
	// is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedServiceTypeProperties.
func (z *ZohoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				z.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
			delete(rawMsg, key)
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &z.EncryptedCredential)
			}
			delete(rawMsg, key)
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &z.Endpoint)
			}
			delete(rawMsg, key)
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &z.UseEncryptedEndpoints)
			}
			delete(rawMsg, key)
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &z.UseHostVerification)
			}
			delete(rawMsg, key)
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &z.UsePeerVerification)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Zoho server dataset.
type ZohoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ZohoObjectDataset.
func (z ZohoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := z.Dataset.marshalInternal("ZohoObject")
	if z.TypeProperties != nil {
		objectMap["typeProperties"] = z.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoObjectDataset.
func (z *ZohoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &z.TypeProperties)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return z.Dataset.unmarshalInternal(rawMsg)
}

// A copy activity Zoho server source.
type ZohoSource struct {
	TabularSource
	// A query to retrieve data from source. Type: string (or Expression with resultType string).
	Query *interface{} `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ZohoSource.
func (z ZohoSource) MarshalJSON() ([]byte, error) {
	objectMap := z.TabularSource.marshalInternal("ZohoSource")
	if z.Query != nil {
		objectMap["query"] = z.Query
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoSource.
func (z *ZohoSource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &z.Query)
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return z.TabularSource.unmarshalInternal(rawMsg)
}
