//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// dataFlowClientGetDataFlowsByWorkspacePager provides operations for iterating over paged responses.
type dataFlowClientGetDataFlowsByWorkspacePager struct {
	client    *dataFlowClient
	current   dataFlowClientGetDataFlowsByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, dataFlowClientGetDataFlowsByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *dataFlowClientGetDataFlowsByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *dataFlowClientGetDataFlowsByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataFlowListResponse.NextLink == nil || len(*p.current.DataFlowListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getDataFlowsByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current dataFlowClientGetDataFlowsByWorkspaceResponse page.
func (p *dataFlowClientGetDataFlowsByWorkspacePager) PageResponse() dataFlowClientGetDataFlowsByWorkspaceResponse {
	return p.current
}

// dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspacePager provides operations for iterating over paged responses.
type dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspacePager struct {
	client    *dataFlowDebugSessionClient
	current   dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.QueryDataFlowDebugSessionsResponse.NextLink == nil || len(*p.current.QueryDataFlowDebugSessionsResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.queryDataFlowDebugSessionsByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspaceResponse page.
func (p *dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspacePager) PageResponse() dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspaceResponse {
	return p.current
}

// datasetClientGetDatasetsByWorkspacePager provides operations for iterating over paged responses.
type datasetClientGetDatasetsByWorkspacePager struct {
	client    *datasetClient
	current   datasetClientGetDatasetsByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, datasetClientGetDatasetsByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *datasetClientGetDatasetsByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *datasetClientGetDatasetsByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatasetListResponse.NextLink == nil || len(*p.current.DatasetListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getDatasetsByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current datasetClientGetDatasetsByWorkspaceResponse page.
func (p *datasetClientGetDatasetsByWorkspacePager) PageResponse() datasetClientGetDatasetsByWorkspaceResponse {
	return p.current
}

// libraryClientListPager provides operations for iterating over paged responses.
type libraryClientListPager struct {
	client    *libraryClient
	current   libraryClientListResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, libraryClientListResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *libraryClientListPager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *libraryClientListPager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LibraryListResponse.NextLink == nil || len(*p.current.LibraryListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current libraryClientListResponse page.
func (p *libraryClientListPager) PageResponse() libraryClientListResponse {
	return p.current
}

// linkedServiceClientGetLinkedServicesByWorkspacePager provides operations for iterating over paged responses.
type linkedServiceClientGetLinkedServicesByWorkspacePager struct {
	client    *linkedServiceClient
	current   linkedServiceClientGetLinkedServicesByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, linkedServiceClientGetLinkedServicesByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *linkedServiceClientGetLinkedServicesByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *linkedServiceClientGetLinkedServicesByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LinkedServiceListResponse.NextLink == nil || len(*p.current.LinkedServiceListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getLinkedServicesByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current linkedServiceClientGetLinkedServicesByWorkspaceResponse page.
func (p *linkedServiceClientGetLinkedServicesByWorkspacePager) PageResponse() linkedServiceClientGetLinkedServicesByWorkspaceResponse {
	return p.current
}

// notebookClientGetNotebookSummaryByWorkSpacePager provides operations for iterating over paged responses.
type notebookClientGetNotebookSummaryByWorkSpacePager struct {
	client    *notebookClient
	current   notebookClientGetNotebookSummaryByWorkSpaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, notebookClientGetNotebookSummaryByWorkSpaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *notebookClientGetNotebookSummaryByWorkSpacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *notebookClientGetNotebookSummaryByWorkSpacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotebookListResponse.NextLink == nil || len(*p.current.NotebookListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getNotebookSummaryByWorkSpaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current notebookClientGetNotebookSummaryByWorkSpaceResponse page.
func (p *notebookClientGetNotebookSummaryByWorkSpacePager) PageResponse() notebookClientGetNotebookSummaryByWorkSpaceResponse {
	return p.current
}

// notebookClientGetNotebooksByWorkspacePager provides operations for iterating over paged responses.
type notebookClientGetNotebooksByWorkspacePager struct {
	client    *notebookClient
	current   notebookClientGetNotebooksByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, notebookClientGetNotebooksByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *notebookClientGetNotebooksByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *notebookClientGetNotebooksByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotebookListResponse.NextLink == nil || len(*p.current.NotebookListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getNotebooksByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current notebookClientGetNotebooksByWorkspaceResponse page.
func (p *notebookClientGetNotebooksByWorkspacePager) PageResponse() notebookClientGetNotebooksByWorkspaceResponse {
	return p.current
}

// pipelineClientGetPipelinesByWorkspacePager provides operations for iterating over paged responses.
type pipelineClientGetPipelinesByWorkspacePager struct {
	client    *pipelineClient
	current   pipelineClientGetPipelinesByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, pipelineClientGetPipelinesByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *pipelineClientGetPipelinesByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *pipelineClientGetPipelinesByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PipelineListResponse.NextLink == nil || len(*p.current.PipelineListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getPipelinesByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current pipelineClientGetPipelinesByWorkspaceResponse page.
func (p *pipelineClientGetPipelinesByWorkspacePager) PageResponse() pipelineClientGetPipelinesByWorkspaceResponse {
	return p.current
}

// sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspacePager provides operations for iterating over paged responses.
type sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspacePager struct {
	client    *sparkJobDefinitionClient
	current   sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SparkJobDefinitionsListResponse.NextLink == nil || len(*p.current.SparkJobDefinitionsListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getSparkJobDefinitionsByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspaceResponse page.
func (p *sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspacePager) PageResponse() sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspaceResponse {
	return p.current
}

// sqlScriptClientGetSQLScriptsByWorkspacePager provides operations for iterating over paged responses.
type sqlScriptClientGetSQLScriptsByWorkspacePager struct {
	client    *sqlScriptClient
	current   sqlScriptClientGetSQLScriptsByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, sqlScriptClientGetSQLScriptsByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *sqlScriptClientGetSQLScriptsByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *sqlScriptClientGetSQLScriptsByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SQLScriptsListResponse.NextLink == nil || len(*p.current.SQLScriptsListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getSQLScriptsByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current sqlScriptClientGetSQLScriptsByWorkspaceResponse page.
func (p *sqlScriptClientGetSQLScriptsByWorkspacePager) PageResponse() sqlScriptClientGetSQLScriptsByWorkspaceResponse {
	return p.current
}

// triggerClientGetTriggersByWorkspacePager provides operations for iterating over paged responses.
type triggerClientGetTriggersByWorkspacePager struct {
	client    *triggerClient
	current   triggerClientGetTriggersByWorkspaceResponse
	err       error
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, triggerClientGetTriggersByWorkspaceResponse) (*policy.Request, error)
}

// Err returns the last error encountered while paging.
func (p *triggerClientGetTriggersByWorkspacePager) Err() error {
	return p.err
}

// NextPage returns true if the pager advanced to the next page.
// Returns false if there are no more pages or an error occurred.
func (p *triggerClientGetTriggersByWorkspacePager) NextPage(ctx context.Context) bool {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggerListResponse.NextLink == nil || len(*p.current.TriggerListResponse.NextLink) == 0 {
			return false
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		p.err = err
		return false
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		p.err = err
		return false
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		p.err = runtime.NewResponseError(resp)
		return false
	}
	result, err := p.client.getTriggersByWorkspaceHandleResponse(resp)
	if err != nil {
		p.err = err
		return false
	}
	p.current = result
	return true
}

// PageResponse returns the current triggerClientGetTriggersByWorkspaceResponse page.
func (p *triggerClientGetTriggersByWorkspacePager) PageResponse() triggerClientGetTriggersByWorkspaceResponse {
	return p.current
}
