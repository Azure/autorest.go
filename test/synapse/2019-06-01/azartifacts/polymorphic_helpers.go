// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import "encoding/json"

func unmarshalActivityClassification(body []byte) (ActivityClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b ActivityClassification
	switch m["type"] {
	case "AppendVariable":
		b = &AppendVariableActivity{}
	case "AzureDataExplorerCommand":
		b = &AzureDataExplorerCommandActivity{}
	case "AzureFunctionActivity":
		b = &AzureFunctionActivity{}
	case "AzureMLBatchExecution":
		b = &AzureMlBatchExecutionActivity{}
	case "AzureMLExecutePipeline":
		b = &AzureMlExecutePipelineActivity{}
	case "AzureMLUpdateResource":
		b = &AzureMlUpdateResourceActivity{}
	case "Container":
		b = &ControlActivity{}
	case "Copy":
		b = &CopyActivity{}
	case "Custom":
		b = &CustomActivity{}
	case "DataLakeAnalyticsU-SQL":
		b = &DataLakeAnalyticsUsqlActivity{}
	case "DatabricksNotebook":
		b = &DatabricksNotebookActivity{}
	case "DatabricksSparkJar":
		b = &DatabricksSparkJarActivity{}
	case "DatabricksSparkPython":
		b = &DatabricksSparkPythonActivity{}
	case "Delete":
		b = &DeleteActivity{}
	case "ExecuteDataFlow":
		b = &ExecuteDataFlowActivity{}
	case "ExecutePipeline":
		b = &ExecutePipelineActivity{}
	case "ExecuteSSISPackage":
		b = &ExecuteSsisPackageActivity{}
	case "Execution":
		b = &ExecutionActivity{}
	case "Filter":
		b = &FilterActivity{}
	case "ForEach":
		b = &ForEachActivity{}
	case "GetMetadata":
		b = &GetMetadataActivity{}
	case "HDInsightHive":
		b = &HdInsightHiveActivity{}
	case "HDInsightMapReduce":
		b = &HdInsightMapReduceActivity{}
	case "HDInsightPig":
		b = &HdInsightPigActivity{}
	case "HDInsightSpark":
		b = &HdInsightSparkActivity{}
	case "HDInsightStreaming":
		b = &HdInsightStreamingActivity{}
	case "IfCondition":
		b = &IfConditionActivity{}
	case "Lookup":
		b = &LookupActivity{}
	case "SetVariable":
		b = &SetVariableActivity{}
	case "SqlServerStoredProcedure":
		b = &SQLServerStoredProcedureActivity{}
	case "Switch":
		b = &SwitchActivity{}
	case "Until":
		b = &UntilActivity{}
	case "Validation":
		b = &ValidationActivity{}
	case "Wait":
		b = &WaitActivity{}
	case "WebActivity":
		b = &WebActivity{}
	case "WebHook":
		b = &WebHookActivity{}
	default:
		b = &Activity{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalActivityClassificationArray(body []byte) (*[]ActivityClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ActivityClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalActivityClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalExecutionActivityClassification(body []byte) (ExecutionActivityClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b ExecutionActivityClassification
	switch m["type"] {
	case "AzureDataExplorerCommand":
		b = &AzureDataExplorerCommandActivity{}
	case "AzureFunctionActivity":
		b = &AzureFunctionActivity{}
	case "AzureMLBatchExecution":
		b = &AzureMlBatchExecutionActivity{}
	case "AzureMLExecutePipeline":
		b = &AzureMlExecutePipelineActivity{}
	case "AzureMLUpdateResource":
		b = &AzureMlUpdateResourceActivity{}
	case "Copy":
		b = &CopyActivity{}
	case "Custom":
		b = &CustomActivity{}
	case "DataLakeAnalyticsU-SQL":
		b = &DataLakeAnalyticsUsqlActivity{}
	case "DatabricksNotebook":
		b = &DatabricksNotebookActivity{}
	case "DatabricksSparkJar":
		b = &DatabricksSparkJarActivity{}
	case "DatabricksSparkPython":
		b = &DatabricksSparkPythonActivity{}
	case "Delete":
		b = &DeleteActivity{}
	case "ExecuteDataFlow":
		b = &ExecuteDataFlowActivity{}
	case "ExecuteSSISPackage":
		b = &ExecuteSsisPackageActivity{}
	case "GetMetadata":
		b = &GetMetadataActivity{}
	case "HDInsightHive":
		b = &HdInsightHiveActivity{}
	case "HDInsightMapReduce":
		b = &HdInsightMapReduceActivity{}
	case "HDInsightPig":
		b = &HdInsightPigActivity{}
	case "HDInsightSpark":
		b = &HdInsightSparkActivity{}
	case "HDInsightStreaming":
		b = &HdInsightStreamingActivity{}
	case "Lookup":
		b = &LookupActivity{}
	case "SqlServerStoredProcedure":
		b = &SQLServerStoredProcedureActivity{}
	case "WebActivity":
		b = &WebActivity{}
	default:
		b = &ExecutionActivity{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalExecutionActivityClassificationArray(body []byte) (*[]ExecutionActivityClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]ExecutionActivityClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalExecutionActivityClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalCopySinkClassification(body []byte) (CopySinkClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b CopySinkClassification
	switch m["type"] {
	default:
		b = &CopySink{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalCopySinkClassificationArray(body []byte) (*[]CopySinkClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CopySinkClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCopySinkClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalCopySourceClassification(body []byte) (CopySourceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b CopySourceClassification
	switch m["type"] {
	default:
		b = &CopySource{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalCopySourceClassificationArray(body []byte) (*[]CopySourceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]CopySourceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalCopySourceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDataFlowClassification(body []byte) (DataFlowClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DataFlowClassification
	switch m["type"] {
	case "MappingDataFlow":
		b = &MappingDataFlow{}
	default:
		b = &DataFlow{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDataFlowClassificationArray(body []byte) (*[]DataFlowClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DataFlowClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDataFlowClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetClassification(body []byte) (DatasetClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetClassification
	switch m["type"] {
	case "AmazonMWSObject":
		b = &AmazonMwsObjectDataset{}
	case "AmazonRedshiftTable":
		b = &AmazonRedshiftTableDataset{}
	case "Avro":
		b = &AvroDataset{}
	case "AzureDataExplorerTable":
		b = &AzureDataExplorerTableDataset{}
	case "AzureMariaDBTable":
		b = &AzureMariaDbTableDataset{}
	case "AzureMySqlTable":
		b = &AzureMySQLTableDataset{}
	case "AzurePostgreSqlTable":
		b = &AzurePostgreSQLTableDataset{}
	case "AzureSearchIndex":
		b = &AzureSearchIndexDataset{}
	case "AzureSqlDWTable":
		b = &AzureSQLDwTableDataset{}
	case "AzureSqlMITable":
		b = &AzureSQLMiTableDataset{}
	case "AzureSqlTable":
		b = &AzureSQLTableDataset{}
	case "AzureTable":
		b = &AzureTableDataset{}
	case "Binary":
		b = &BinaryDataset{}
	case "CassandraTable":
		b = &CassandraTableDataset{}
	case "CommonDataServiceForAppsEntity":
		b = &CommonDataServiceForAppsEntityDataset{}
	case "ConcurObject":
		b = &ConcurObjectDataset{}
	case "CosmosDbMongoDbApiCollection":
		b = &CosmosDbMongoDbAPICollectionDataset{}
	case "CosmosDbSqlApiCollection":
		b = &CosmosDbSQLAPICollectionDataset{}
	case "CouchbaseTable":
		b = &CouchbaseTableDataset{}
	case "Db2Table":
		b = &Db2TableDataset{}
	case "DelimitedText":
		b = &DelimitedTextDataset{}
	case "DocumentDbCollection":
		b = &DocumentDbCollectionDataset{}
	case "DrillTable":
		b = &DrillTableDataset{}
	case "DynamicsAXResource":
		b = &DynamicsAxResourceDataset{}
	case "DynamicsCrmEntity":
		b = &DynamicsCrmEntityDataset{}
	case "DynamicsEntity":
		b = &DynamicsEntityDataset{}
	case "EloquaObject":
		b = &EloquaObjectDataset{}
	case "GoogleAdWordsObject":
		b = &GoogleAdWordsObjectDataset{}
	case "GoogleBigQueryObject":
		b = &GoogleBigQueryObjectDataset{}
	case "GreenplumTable":
		b = &GreenplumTableDataset{}
	case "HBaseObject":
		b = &HBaseObjectDataset{}
	case "HiveObject":
		b = &HiveObjectDataset{}
	case "HubspotObject":
		b = &HubspotObjectDataset{}
	case "ImpalaObject":
		b = &ImpalaObjectDataset{}
	case "InformixTable":
		b = &InformixTableDataset{}
	case "JiraObject":
		b = &JiraObjectDataset{}
	case "Json":
		b = &JSONDataset{}
	case "MagentoObject":
		b = &MagentoObjectDataset{}
	case "MariaDBTable":
		b = &MariaDbTableDataset{}
	case "MarketoObject":
		b = &MarketoObjectDataset{}
	case "MicrosoftAccessTable":
		b = &MicrosoftAccessTableDataset{}
	case "MongoDbCollection":
		b = &MongoDbCollectionDataset{}
	case "MongoDbV2Collection":
		b = &MongoDbV2CollectionDataset{}
	case "MySqlTable":
		b = &MySQLTableDataset{}
	case "NetezzaTable":
		b = &NetezzaTableDataset{}
	case "ODataResource":
		b = &ODataResourceDataset{}
	case "OdbcTable":
		b = &OdbcTableDataset{}
	case "Office365Table":
		b = &Office365Dataset{}
	case "OracleServiceCloudObject":
		b = &OracleServiceCloudObjectDataset{}
	case "OracleTable":
		b = &OracleTableDataset{}
	case "Orc":
		b = &OrcDataset{}
	case "Parquet":
		b = &ParquetDataset{}
	case "PaypalObject":
		b = &PaypalObjectDataset{}
	case "PhoenixObject":
		b = &PhoenixObjectDataset{}
	case "PostgreSqlTable":
		b = &PostgreSQLTableDataset{}
	case "PrestoObject":
		b = &PrestoObjectDataset{}
	case "QuickBooksObject":
		b = &QuickBooksObjectDataset{}
	case "RelationalTable":
		b = &RelationalTableDataset{}
	case "ResponsysObject":
		b = &ResponsysObjectDataset{}
	case "RestResource":
		b = &RestResourceDataset{}
	case "SalesforceMarketingCloudObject":
		b = &SalesforceMarketingCloudObjectDataset{}
	case "SalesforceObject":
		b = &SalesforceObjectDataset{}
	case "SalesforceServiceCloudObject":
		b = &SalesforceServiceCloudObjectDataset{}
	case "SapBwCube":
		b = &SapBwCubeDataset{}
	case "SapCloudForCustomerResource":
		b = &SapCloudForCustomerResourceDataset{}
	case "SapEccResource":
		b = &SapEccResourceDataset{}
	case "SapHanaTable":
		b = &SapHanaTableDataset{}
	case "SapOpenHubTable":
		b = &SapOpenHubTableDataset{}
	case "SapTableResource":
		b = &SapTableResourceDataset{}
	case "ServiceNowObject":
		b = &ServiceNowObjectDataset{}
	case "ShopifyObject":
		b = &ShopifyObjectDataset{}
	case "SparkObject":
		b = &SparkObjectDataset{}
	case "SqlServerTable":
		b = &SQLServerTableDataset{}
	case "SquareObject":
		b = &SquareObjectDataset{}
	case "SybaseTable":
		b = &SybaseTableDataset{}
	case "TeradataTable":
		b = &TeradataTableDataset{}
	case "VerticaTable":
		b = &VerticaTableDataset{}
	case "WebTable":
		b = &WebTableDataset{}
	case "XeroObject":
		b = &XeroObjectDataset{}
	case "ZohoObject":
		b = &ZohoObjectDataset{}
	default:
		b = &Dataset{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetClassificationArray(body []byte) (*[]DatasetClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetCompressionClassification(body []byte) (DatasetCompressionClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetCompressionClassification
	switch m["type"] {
	case "BZip2":
		b = &DatasetBZip2Compression{}
	case "Deflate":
		b = &DatasetDeflateCompression{}
	case "GZip":
		b = &DatasetGZipCompression{}
	case "ZipDeflate":
		b = &DatasetZipDeflateCompression{}
	default:
		b = &DatasetCompression{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetCompressionClassificationArray(body []byte) (*[]DatasetCompressionClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetCompressionClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetCompressionClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalDatasetLocationClassification(body []byte) (DatasetLocationClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DatasetLocationClassification
	switch m["type"] {
	default:
		b = &DatasetLocation{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDatasetLocationClassificationArray(body []byte) (*[]DatasetLocationClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DatasetLocationClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDatasetLocationClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalLinkedServiceClassification(body []byte) (LinkedServiceClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b LinkedServiceClassification
	switch m["type"] {
	case "AmazonMWS":
		b = &AmazonMwsLinkedService{}
	case "AmazonRedshift":
		b = &AmazonRedshiftLinkedService{}
	case "AmazonS3":
		b = &AmazonS3LinkedService{}
	case "AzureBatch":
		b = &AzureBatchLinkedService{}
	case "AzureBlobFS":
		b = &AzureBlobFsLinkedService{}
	case "AzureBlobStorage":
		b = &AzureBlobStorageLinkedService{}
	case "AzureDataExplorer":
		b = &AzureDataExplorerLinkedService{}
	case "AzureDataLakeAnalytics":
		b = &AzureDataLakeAnalyticsLinkedService{}
	case "AzureDataLakeStore":
		b = &AzureDataLakeStoreLinkedService{}
	case "AzureDatabricks":
		b = &AzureDatabricksLinkedService{}
	case "AzureFileStorage":
		b = &AzureFileStorageLinkedService{}
	case "AzureFunction":
		b = &AzureFunctionLinkedService{}
	case "AzureKeyVault":
		b = &AzureKeyVaultLinkedService{}
	case "AzureML":
		b = &AzureMlLinkedService{}
	case "AzureMLService":
		b = &AzureMlServiceLinkedService{}
	case "AzureMariaDB":
		b = &AzureMariaDbLinkedService{}
	case "AzureMySql":
		b = &AzureMySQLLinkedService{}
	case "AzurePostgreSql":
		b = &AzurePostgreSQLLinkedService{}
	case "AzureSearch":
		b = &AzureSearchLinkedService{}
	case "AzureSqlDW":
		b = &AzureSQLDwLinkedService{}
	case "AzureSqlDatabase":
		b = &AzureSQLDatabaseLinkedService{}
	case "AzureSqlMI":
		b = &AzureSQLMiLinkedService{}
	case "AzureStorage":
		b = &AzureStorageLinkedService{}
	case "AzureTableStorage":
		b = &AzureTableStorageLinkedService{}
	case "Cassandra":
		b = &CassandraLinkedService{}
	case "CommonDataServiceForApps":
		b = &CommonDataServiceForAppsLinkedService{}
	case "Concur":
		b = &ConcurLinkedService{}
	case "CosmosDb":
		b = &CosmosDbLinkedService{}
	case "CosmosDbMongoDbApi":
		b = &CosmosDbMongoDbAPILinkedService{}
	case "Couchbase":
		b = &CouchbaseLinkedService{}
	case "CustomDataSource":
		b = &CustomDataSourceLinkedService{}
	case "Db2":
		b = &Db2LinkedService{}
	case "Drill":
		b = &DrillLinkedService{}
	case "Dynamics":
		b = &DynamicsLinkedService{}
	case "DynamicsAX":
		b = &DynamicsAxLinkedService{}
	case "DynamicsCrm":
		b = &DynamicsCrmLinkedService{}
	case "Eloqua":
		b = &EloquaLinkedService{}
	case "FileServer":
		b = &FileServerLinkedService{}
	case "FtpServer":
		b = &FtpServerLinkedService{}
	case "GoogleAdWords":
		b = &GoogleAdWordsLinkedService{}
	case "GoogleBigQuery":
		b = &GoogleBigQueryLinkedService{}
	case "GoogleCloudStorage":
		b = &GoogleCloudStorageLinkedService{}
	case "Greenplum":
		b = &GreenplumLinkedService{}
	case "HBase":
		b = &HBaseLinkedService{}
	case "HDInsight":
		b = &HdInsightLinkedService{}
	case "HDInsightOnDemand":
		b = &HdInsightOnDemandLinkedService{}
	case "Hdfs":
		b = &HdfsLinkedService{}
	case "Hive":
		b = &HiveLinkedService{}
	case "HttpServer":
		b = &HTTPLinkedService{}
	case "Hubspot":
		b = &HubspotLinkedService{}
	case "Impala":
		b = &ImpalaLinkedService{}
	case "Informix":
		b = &InformixLinkedService{}
	case "Jira":
		b = &JiraLinkedService{}
	case "Magento":
		b = &MagentoLinkedService{}
	case "MariaDB":
		b = &MariaDbLinkedService{}
	case "Marketo":
		b = &MarketoLinkedService{}
	case "MicrosoftAccess":
		b = &MicrosoftAccessLinkedService{}
	case "MongoDb":
		b = &MongoDbLinkedService{}
	case "MongoDbV2":
		b = &MongoDbV2LinkedService{}
	case "MySql":
		b = &MySQLLinkedService{}
	case "Netezza":
		b = &NetezzaLinkedService{}
	case "OData":
		b = &ODataLinkedService{}
	case "Odbc":
		b = &OdbcLinkedService{}
	case "Office365":
		b = &Office365LinkedService{}
	case "Oracle":
		b = &OracleLinkedService{}
	case "OracleServiceCloud":
		b = &OracleServiceCloudLinkedService{}
	case "Paypal":
		b = &PaypalLinkedService{}
	case "Phoenix":
		b = &PhoenixLinkedService{}
	case "PostgreSql":
		b = &PostgreSQLLinkedService{}
	case "Presto":
		b = &PrestoLinkedService{}
	case "QuickBooks":
		b = &QuickBooksLinkedService{}
	case "Responsys":
		b = &ResponsysLinkedService{}
	case "RestService":
		b = &RestServiceLinkedService{}
	case "Salesforce":
		b = &SalesforceLinkedService{}
	case "SalesforceMarketingCloud":
		b = &SalesforceMarketingCloudLinkedService{}
	case "SalesforceServiceCloud":
		b = &SalesforceServiceCloudLinkedService{}
	case "SapBW":
		b = &SapBwLinkedService{}
	case "SapCloudForCustomer":
		b = &SapCloudForCustomerLinkedService{}
	case "SapEcc":
		b = &SapEccLinkedService{}
	case "SapHana":
		b = &SapHanaLinkedService{}
	case "SapOpenHub":
		b = &SapOpenHubLinkedService{}
	case "SapTable":
		b = &SapTableLinkedService{}
	case "ServiceNow":
		b = &ServiceNowLinkedService{}
	case "Sftp":
		b = &SftpServerLinkedService{}
	case "Shopify":
		b = &ShopifyLinkedService{}
	case "Spark":
		b = &SparkLinkedService{}
	case "SqlServer":
		b = &SQLServerLinkedService{}
	case "Square":
		b = &SquareLinkedService{}
	case "Sybase":
		b = &SybaseLinkedService{}
	case "Teradata":
		b = &TeradataLinkedService{}
	case "Vertica":
		b = &VerticaLinkedService{}
	case "Web":
		b = &WebLinkedService{}
	case "Xero":
		b = &XeroLinkedService{}
	case "Zoho":
		b = &ZohoLinkedService{}
	default:
		b = &LinkedService{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalLinkedServiceClassificationArray(body []byte) (*[]LinkedServiceClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]LinkedServiceClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalLinkedServiceClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalSecretBaseClassification(body []byte) (SecretBaseClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b SecretBaseClassification
	switch m["type"] {
	case "AzureKeyVaultSecret":
		b = &AzureKeyVaultSecretReference{}
	case "SecureString":
		b = &SecureString{}
	default:
		b = &SecretBase{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalSecretBaseClassificationArray(body []byte) (*[]SecretBaseClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SecretBaseClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSecretBaseClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalTriggerClassification(body []byte) (TriggerClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b TriggerClassification
	switch m["type"] {
	case "MultiplePipelineTrigger":
		b = &MultiplePipelineTrigger{}
	case "RerunTumblingWindowTrigger":
		b = &RerunTumblingWindowTrigger{}
	default:
		b = &Trigger{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalTriggerClassificationArray(body []byte) (*[]TriggerClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]TriggerClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalTriggerClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalWebLinkedServiceTypePropertiesClassification(body []byte) (WebLinkedServiceTypePropertiesClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b WebLinkedServiceTypePropertiesClassification
	switch m["authenticationType"] {
	case WebAuthenticationTypeAnonymous:
		b = &WebAnonymousAuthentication{}
	case WebAuthenticationTypeBasic:
		b = &WebBasicAuthentication{}
	case WebAuthenticationTypeClientCertificate:
		b = &WebClientCertificateAuthentication{}
	default:
		b = &WebLinkedServiceTypeProperties{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalWebLinkedServiceTypePropertiesClassificationArray(body []byte) (*[]WebLinkedServiceTypePropertiesClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]WebLinkedServiceTypePropertiesClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalWebLinkedServiceTypePropertiesClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func strptr(s string) *string {
	return &s
}
