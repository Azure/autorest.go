// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// ActivityClassification provides polymorphic access to related types.
type ActivityClassification interface {
	GetActivity() *Activity
}

// A pipeline activity.
type Activity struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Activity depends on condition.
	DependsOn *[]ActivityDependency `json:"dependsOn,omitempty"`

	// Activity description.
	Description *string `json:"description,omitempty"`

	// Activity name.
	Name *string `json:"name,omitempty"`

	// Type of activity.
	Type *string `json:"type,omitempty"`

	// Activity user properties.
	UserProperties *[]UserProperty `json:"userProperties,omitempty"`
}

// GetActivity implements the ActivityClassification interface for type Activity.
func (a *Activity) GetActivity() *Activity { return a }

// UnmarshalJSON implements the json.Unmarshaller interface for type Activity.
func (a *Activity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependsOn":
			if val != nil {
				err = json.Unmarshal(*val, &a.DependsOn)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &a.Description)
			}
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &a.Name)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &a.Type)
			}
		case "userProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.UserProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (a Activity) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if a.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = a.AdditionalProperties
	}
	if a.DependsOn != nil {
		objectMap["dependsOn"] = a.DependsOn
	}
	if a.Description != nil {
		objectMap["description"] = a.Description
	}
	if a.Name != nil {
		objectMap["name"] = a.Name
	}
	a.Type = &discValue
	objectMap["type"] = a.Type
	if a.UserProperties != nil {
		objectMap["userProperties"] = a.UserProperties
	}
	return objectMap
}

// Activity dependency information.
type ActivityDependency struct {
	// Activity name.
	Activity *string `json:"activity,omitempty"`

	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Match-Condition for the dependency.
	DependencyConditions *[]DependencyCondition `json:"dependencyConditions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityDependency.
func (a ActivityDependency) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Activity != nil {
		objectMap["activity"] = a.Activity
	}
	if a.DependencyConditions != nil {
		objectMap["dependencyConditions"] = a.DependencyConditions
	}
	if a.AdditionalProperties != nil {
		for key, val := range *a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityDependency.
func (a *ActivityDependency) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activity":
			if val != nil {
				err = json.Unmarshal(*val, &a.Activity)
			}
		case "dependencyConditions":
			if val != nil {
				err = json.Unmarshal(*val, &a.DependencyConditions)
			}
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*a.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Execution policy for an activity.
type ActivityPolicy struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Maximum ordinary retry attempts. Default is 0. Type: integer (or Expression with resultType integer), minimum: 0.
	Retry *interface{} `json:"retry,omitempty"`

	// Interval between each retry attempt (in seconds). The default is 30 sec.
	RetryIntervalInSeconds *int32 `json:"retryIntervalInSeconds,omitempty"`

	// When set to true, Input from activity is considered as secure and will not be logged to monitoring.
	SecureInput *bool `json:"secureInput,omitempty"`

	// When set to true, Output from activity is considered as secure and will not be logged to monitoring.
	SecureOutput *bool `json:"secureOutput,omitempty"`

	// Specifies the timeout for the activity to run. The default timeout is 7 days. Type: string (or Expression with resultType
	// string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *interface{} `json:"timeout,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityPolicy.
func (a ActivityPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Retry != nil {
		objectMap["retry"] = a.Retry
	}
	if a.RetryIntervalInSeconds != nil {
		objectMap["retryIntervalInSeconds"] = a.RetryIntervalInSeconds
	}
	if a.SecureInput != nil {
		objectMap["secureInput"] = a.SecureInput
	}
	if a.SecureOutput != nil {
		objectMap["secureOutput"] = a.SecureOutput
	}
	if a.Timeout != nil {
		objectMap["timeout"] = a.Timeout
	}
	if a.AdditionalProperties != nil {
		for key, val := range *a.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityPolicy.
func (a *ActivityPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retry":
			if val != nil {
				err = json.Unmarshal(*val, &a.Retry)
			}
		case "retryIntervalInSeconds":
			if val != nil {
				err = json.Unmarshal(*val, &a.RetryIntervalInSeconds)
			}
		case "secureInput":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecureInput)
			}
		case "secureOutput":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecureOutput)
			}
		case "timeout":
			if val != nil {
				err = json.Unmarshal(*val, &a.Timeout)
			}
		default:
			if a.AdditionalProperties == nil {
				a.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*a.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Information about an activity run in a pipeline.
type ActivityRun struct {
	// The name of the activity.
	ActivityName *string `json:"activityName,omitempty" azure:"ro"`

	// The end time of the activity run in 'ISO 8601' format.
	ActivityRunEnd *time.Time `json:"activityRunEnd,omitempty" azure:"ro"`

	// The id of the activity run.
	ActivityRunID *string `json:"activityRunId,omitempty" azure:"ro"`

	// The start time of the activity run in 'ISO 8601' format.
	ActivityRunStart *time.Time `json:"activityRunStart,omitempty" azure:"ro"`

	// The type of the activity.
	ActivityType *string `json:"activityType,omitempty" azure:"ro"`

	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The duration of the activity run.
	DurationInMS *int32 `json:"durationInMs,omitempty" azure:"ro"`

	// The error if any from the activity run.
	Error *interface{} `json:"error,omitempty" azure:"ro"`

	// The input for the activity.
	Input *interface{} `json:"input,omitempty" azure:"ro"`

	// The name of the compute linked service.
	LinkedServiceName *string `json:"linkedServiceName,omitempty" azure:"ro"`

	// The output for the activity.
	Output *interface{} `json:"output,omitempty" azure:"ro"`

	// The name of the pipeline.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// The id of the pipeline run.
	PipelineRunID *string `json:"pipelineRunId,omitempty" azure:"ro"`

	// The status of the activity run.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ActivityRun.
func (a ActivityRun) MarshalJSON() ([]byte, error) {
	type alias ActivityRun
	aux := &struct {
		*alias
		ActivityRunEnd       *timeRFC3339       `json:"activityRunEnd"`
		ActivityRunStart     *timeRFC3339       `json:"activityRunStart"`
		AdditionalProperties *map[string]string `json:"AdditionalProperties"`
	}{
		alias:            (*alias)(&a),
		ActivityRunEnd:   (*timeRFC3339)(a.ActivityRunEnd),
		ActivityRunStart: (*timeRFC3339)(a.ActivityRunStart),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ActivityRun.
func (a *ActivityRun) UnmarshalJSON(data []byte) error {
	type alias ActivityRun
	aux := &struct {
		*alias
		ActivityRunEnd       *timeRFC3339       `json:"activityRunEnd"`
		ActivityRunStart     *timeRFC3339       `json:"activityRunStart"`
		AdditionalProperties *map[string]string `json:"AdditionalProperties"`
	}{
		alias: (*alias)(a),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	a.ActivityRunEnd = (*time.Time)(aux.ActivityRunEnd)
	a.ActivityRunStart = (*time.Time)(aux.ActivityRunStart)
	a.AdditionalProperties = (*map[string]string)(aux.AdditionalProperties)
	return nil
}

// A list activity runs.
type ActivityRunsQueryResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of activity runs.
	Value *[]ActivityRun `json:"value,omitempty"`
}

// ActivityRunsQueryResponseResponse is the response envelope for operations that return a ActivityRunsQueryResponse type.
type ActivityRunsQueryResponseResponse struct {
	// A list activity runs.
	ActivityRunsQueryResponse *ActivityRunsQueryResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Response body structure for starting data flow debug session.
type AddDataFlowToDebugSessionResponse struct {
	// The ID of data flow debug job version.
	JobVersion *string `json:"jobVersion,omitempty"`
}

// AddDataFlowToDebugSessionResponseResponse is the response envelope for operations that return a AddDataFlowToDebugSessionResponse
// type.
type AddDataFlowToDebugSessionResponseResponse struct {
	// Response body structure for starting data flow debug session.
	AddDataFlowToDebugSessionResponse *AddDataFlowToDebugSessionResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Amazon Marketplace Web Service linked service.
type AmazonMwsLinkedService struct {
	LinkedService
	// Amazon Marketplace Web Service linked service properties.
	TypeProperties *AmazonMwsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMwsLinkedService.
func (a AmazonMwsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AmazonMWS")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsLinkedService.
func (a *AmazonMwsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Amazon Marketplace Web Service linked service properties.
type AmazonMwsLinkedServiceTypeProperties struct {
	// The access key id used to access data.
	AccessKeyID *interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Amazon MWS server, (i.e. mws.amazonservices.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The Amazon Marketplace ID you want to retrieve data from. To retrieve data from multiple Marketplace IDs, separate them
	// with a comma (,). (i.e. A2EUQ1WTGCTBG2)
	MarketplaceID *interface{} `json:"marketplaceID,omitempty"`

	// The Amazon MWS authentication token.
	MwsAuthToken SecretBaseClassification `json:"mwsAuthToken,omitempty"`

	// The secret key used to access data.
	SecretKey SecretBaseClassification `json:"secretKey,omitempty"`

	// The Amazon seller ID.
	SellerID *interface{} `json:"sellerID,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsLinkedServiceTypeProperties.
func (a *AmazonMwsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccessKeyID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.Endpoint)
			}
		case "marketplaceID":
			if val != nil {
				err = json.Unmarshal(*val, &a.MarketplaceID)
			}
		case "mwsAuthToken":
			if val != nil {
				a.MwsAuthToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "secretKey":
			if val != nil {
				a.SecretKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "sellerID":
			if val != nil {
				err = json.Unmarshal(*val, &a.SellerID)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &a.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &a.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &a.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Amazon Marketplace Web Service dataset.
type AmazonMwsObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonMwsObjectDataset.
func (a AmazonMwsObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AmazonMWSObject")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonMwsObjectDataset.
func (a *AmazonMwsObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Linked service for Amazon Redshift.
type AmazonRedshiftLinkedService struct {
	LinkedService
	// Amazon Redshift linked service properties.
	TypeProperties *AmazonRedshiftLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftLinkedService.
func (a AmazonRedshiftLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AmazonRedshift")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedService.
func (a *AmazonRedshiftLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Amazon Redshift linked service properties.
type AmazonRedshiftLinkedServiceTypeProperties struct {
	// The database name of the Amazon Redshift source. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password of the Amazon Redshift source.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the Amazon Redshift server uses to listen for client connections. The default value is 5439. Type:
	// integer (or Expression with resultType integer).
	Port *interface{} `json:"port,omitempty"`

	// The name of the Amazon Redshift server. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// The username of the Amazon Redshift source. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftLinkedServiceTypeProperties.
func (a *AmazonRedshiftLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &a.Database)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "password":
			if val != nil {
				a.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &a.Port)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &a.Server)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &a.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Amazon Redshift table dataset.
type AmazonRedshiftTableDataset struct {
	Dataset
	// Amazon Redshift table dataset properties.
	TypeProperties *AmazonRedshiftTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonRedshiftTableDataset.
func (a AmazonRedshiftTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AmazonRedshiftTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonRedshiftTableDataset.
func (a *AmazonRedshiftTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Amazon Redshift table dataset properties.
type AmazonRedshiftTableDatasetTypeProperties struct {
	// The Amazon Redshift schema name. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The Amazon Redshift table name. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Linked service for Amazon S3.
type AmazonS3LinkedService struct {
	LinkedService
	// Amazon S3 linked service properties.
	TypeProperties *AmazonS3LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AmazonS3LinkedService.
func (a AmazonS3LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AmazonS3")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedService.
func (a *AmazonS3LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Amazon S3 linked service properties.
type AmazonS3LinkedServiceTypeProperties struct {
	// The access key identifier of the Amazon S3 Identity and Access Management (IAM) user. Type: string (or Expression with
	// resultType string).
	AccessKeyID *interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Amazon S3 Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the S3 Connector. This is an optional property; change it only if you
	// want to try a different service endpoint or want to switch between https and http. Type: string (or Expression with resultType
	// string).
	ServiceURL *interface{} `json:"serviceUrl,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AmazonS3LinkedServiceTypeProperties.
func (a *AmazonS3LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccessKeyID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "secretAccessKey":
			if val != nil {
				a.SecretAccessKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "serviceUrl":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServiceURL)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Append value for a Variable of type Array.
type AppendVariableActivity struct {
	Activity
	// Append Variable activity properties.
	TypeProperties *AppendVariableActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AppendVariableActivity.
func (a AppendVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.Activity.marshalInternal("AppendVariable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AppendVariableActivity.
func (a *AppendVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Activity)
}

// AppendVariable activity properties.
type AppendVariableActivityTypeProperties struct {
	// Value to be appended. Could be a static value or Expression
	Value *interface{} `json:"value,omitempty"`

	// Name of the variable whose value needs to be appended to.
	VariableName *string `json:"variableName,omitempty"`
}

// Avro dataset.
type AvroDataset struct {
	Dataset
	// Avro dataset properties.
	TypeProperties *AvroDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvroDataset.
func (a AvroDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("Avro")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDataset.
func (a *AvroDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Avro dataset properties.
type AvroDatasetTypeProperties struct {
	AvroCompressionCodec *AvroCompressionCodec `json:"avroCompressionCodec,omitempty"`
	AvroCompressionLevel *int32                `json:"avroCompressionLevel,omitempty"`

	// The location of the avro storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvroDatasetTypeProperties.
func (a *AvroDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avroCompressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &a.AvroCompressionCodec)
			}
		case "avroCompressionLevel":
			if val != nil {
				err = json.Unmarshal(*val, &a.AvroCompressionLevel)
			}
		case "location":
			if val != nil {
				a.Location, err = unmarshalDatasetLocationClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Batch linked service.
type AzureBatchLinkedService struct {
	LinkedService
	// Azure Batch linked service properties.
	TypeProperties *AzureBatchLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBatchLinkedService.
func (a AzureBatchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureBatch")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedService.
func (a *AzureBatchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Batch linked service properties.
type AzureBatchLinkedServiceTypeProperties struct {
	// The Azure Batch account access key.
	AccessKey SecretBaseClassification `json:"accessKey,omitempty"`

	// The Azure Batch account name. Type: string (or Expression with resultType string).
	AccountName *interface{} `json:"accountName,omitempty"`

	// The Azure Batch URI. Type: string (or Expression with resultType string).
	BatchURI *interface{} `json:"batchUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure Storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The Azure Batch pool name. Type: string (or Expression with resultType string).
	PoolName *interface{} `json:"poolName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBatchLinkedServiceTypeProperties.
func (a *AzureBatchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKey":
			if val != nil {
				a.AccessKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "accountName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountName)
			}
		case "batchUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.BatchURI)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &a.LinkedServiceName)
			}
		case "poolName":
			if val != nil {
				err = json.Unmarshal(*val, &a.PoolName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Data Lake Storage Gen2 linked service.
type AzureBlobFsLinkedService struct {
	LinkedService
	// Azure Data Lake Storage Gen2 linked service properties.
	TypeProperties *AzureBlobFsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFsLinkedService.
func (a AzureBlobFsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureBlobFS")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsLinkedService.
func (a *AzureBlobFsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Data Lake Storage Gen2 linked service properties.
type AzureBlobFsLinkedServiceTypeProperties struct {
	// Account key for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
	AccountKey *interface{} `json:"accountKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Storage Gen2 account. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Storage Gen2 account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFsLinkedServiceTypeProperties.
func (a *AzureBlobFsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountKey)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &a.URL)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The azure blob storage linked service.
type AzureBlobStorageLinkedService struct {
	LinkedService
	// Azure Blob Storage linked service properties.
	TypeProperties *AzureBlobStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobStorageLinkedService.
func (a AzureBlobStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureBlobStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedService.
func (a *AzureBlobStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Blob Storage linked service properties.
type AzureBlobStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// The connection string. It is mutually exclusive with sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure Blob Storage resource. It is mutually exclusive with connectionString, serviceEndpoint property. Type:
	// string, SecureString or AzureKeyVaultSecretReference.
	SasURI *interface{} `json:"sasUri,omitempty"`

	// Blob service endpoint of the Azure Blob Storage resource. It is mutually exclusive with connectionString, sasUri property.
	ServiceEndpoint *string `json:"serviceEndpoint,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Data Warehouse.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobStorageLinkedServiceTypeProperties.
func (a *AzureBlobStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountKey)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "sasToken":
			if val != nil {
				err = json.Unmarshal(*val, &a.SasToken)
			}
		case "sasUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.SasURI)
			}
		case "serviceEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServiceEndpoint)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Data Explorer command activity.
type AzureDataExplorerCommandActivity struct {
	ExecutionActivity
	// Azure Data Explorer command activity properties.
	TypeProperties *AzureDataExplorerCommandActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerCommandActivity.
func (a AzureDataExplorerCommandActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureDataExplorerCommand")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerCommandActivity.
func (a *AzureDataExplorerCommandActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.ExecutionActivity)
}

// Azure Data Explorer command activity properties.
type AzureDataExplorerCommandActivityTypeProperties struct {
	// A control command, according to the Azure Data Explorer command syntax. Type: string (or Expression with resultType string).
	Command *interface{} `json:"command,omitempty"`

	// Control command timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9]))..)
	CommandTimeout *interface{} `json:"commandTimeout,omitempty"`
}

// Azure Data Explorer (Kusto) dataset properties.
type AzureDataExplorerDatasetTypeProperties struct {
	// The table name of the Azure Data Explorer database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`
}

// Azure Data Explorer (Kusto) linked service.
type AzureDataExplorerLinkedService struct {
	LinkedService
	// Azure Data Explorer (Kusto) linked service properties.
	TypeProperties *AzureDataExplorerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerLinkedService.
func (a AzureDataExplorerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDataExplorer")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedService.
func (a *AzureDataExplorerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Data Explorer (Kusto) linked service properties.
type AzureDataExplorerLinkedServiceTypeProperties struct {
	// Database name for connection. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The endpoint of Azure Data Explorer (the engine's endpoint). URL will be in the format https://<clusterName>.<regionName>.kusto.windows.net.
	// Type: string (or Expression with resultType string)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The ID of the service principal used to authenticate against Azure Data Explorer. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Kusto.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerLinkedServiceTypeProperties.
func (a *AzureDataExplorerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &a.Database)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.Endpoint)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Azure Data Explorer (Kusto) dataset.
type AzureDataExplorerTableDataset struct {
	Dataset
	// Azure Data Explorer (Kusto) dataset properties.
	TypeProperties *AzureDataExplorerDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataExplorerTableDataset.
func (a AzureDataExplorerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureDataExplorerTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataExplorerTableDataset.
func (a *AzureDataExplorerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure Data Lake Analytics linked service.
type AzureDataLakeAnalyticsLinkedService struct {
	LinkedService
	// Azure Data Lake Analytics linked service properties.
	TypeProperties *AzureDataLakeAnalyticsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a AzureDataLakeAnalyticsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDataLakeAnalytics")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedService.
func (a *AzureDataLakeAnalyticsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Data Lake Analytics linked service properties.
type AzureDataLakeAnalyticsLinkedServiceTypeProperties struct {
	// The Azure Data Lake Analytics account name. Type: string (or Expression with resultType string).
	AccountName *interface{} `json:"accountName,omitempty"`

	// Azure Data Lake Analytics URI Type: string (or Expression with resultType string).
	DataLakeAnalyticsURI *interface{} `json:"dataLakeAnalyticsUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Data Lake Analytics account resource group name (if different from Data Factory account). Type: string (or Expression with
	// resultType string).
	ResourceGroupName *interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Analytics account. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Analytics account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Data Lake Analytics account subscription ID (if different from Data Factory account). Type: string (or Expression with
	// resultType string).
	SubscriptionID *interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeAnalyticsLinkedServiceTypeProperties.
func (a *AzureDataLakeAnalyticsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountName)
			}
		case "dataLakeAnalyticsUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.DataLakeAnalyticsURI)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "resourceGroupName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceGroupName)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "subscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &a.SubscriptionID)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Data Lake Store linked service.
type AzureDataLakeStoreLinkedService struct {
	LinkedService
	// Azure Data Lake Store linked service properties.
	TypeProperties *AzureDataLakeStoreLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDataLakeStoreLinkedService.
func (a AzureDataLakeStoreLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDataLakeStore")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedService.
func (a *AzureDataLakeStoreLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Data Lake Store linked service properties.
type AzureDataLakeStoreLinkedServiceTypeProperties struct {
	// Data Lake Store account name. Type: string (or Expression with resultType string).
	AccountName *interface{} `json:"accountName,omitempty"`

	// Data Lake Store service URI. Type: string (or Expression with resultType string).
	DataLakeStoreURI *interface{} `json:"dataLakeStoreUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Data Lake Store account resource group name (if different from Data Factory account). Type: string (or Expression with
	// resultType string).
	ResourceGroupName *interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the application used to authenticate against the Azure Data Lake Store account. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The Key of the application used to authenticate against the Azure Data Lake Store account.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Data Lake Store account subscription ID (if different from Data Factory account). Type: string (or Expression with resultType
	// string).
	SubscriptionID *interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDataLakeStoreLinkedServiceTypeProperties.
func (a *AzureDataLakeStoreLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountName":
			if val != nil {
				err = json.Unmarshal(*val, &a.AccountName)
			}
		case "dataLakeStoreUri":
			if val != nil {
				err = json.Unmarshal(*val, &a.DataLakeStoreURI)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "resourceGroupName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceGroupName)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "subscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &a.SubscriptionID)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Databricks linked service.
type AzureDatabricksLinkedService struct {
	LinkedService
	// Azure Databricks linked service properties.
	TypeProperties *AzureDatabricksLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureDatabricksLinkedService.
func (a AzureDatabricksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureDatabricks")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedService.
func (a *AzureDatabricksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Databricks linked service properties.
type AzureDatabricksLinkedServiceTypeProperties struct {
	// Access token for databricks REST API. Refer to https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string
	// (or Expression with resultType string).
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// <REGION>.azuredatabricks.net, domain name of your Databricks deployment. Type: string (or Expression with resultType string).
	Domain *interface{} `json:"domain,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The id of an existing interactive cluster that will be used for all runs of this activity. Type: string (or Expression
	// with resultType string).
	ExistingClusterID *interface{} `json:"existingClusterId,omitempty"`

	// The id of an existing instance pool that will be used for all runs of this activity. Type: string (or Expression with resultType
	// string).
	InstancePoolID *interface{} `json:"instancePoolId,omitempty"`

	// Additional tags for cluster resources. This property is ignored in instance pool configurations.
	NewClusterCustomTags *map[string]interface{} `json:"newClusterCustomTags,omitempty"`

	// The driver node type for the new job cluster. This property is ignored in instance pool configurations. Type: string (or
	// Expression with resultType string).
	NewClusterDriverNodeType *interface{} `json:"newClusterDriverNodeType,omitempty"`

	// Enable the elastic disk on the new cluster. This property is now ignored, and takes the default elastic disk behavior in
	// Databricks (elastic disks are always enabled). Type: boolean (or Expression with resultType boolean).
	NewClusterEnableElasticDisk *interface{} `json:"newClusterEnableElasticDisk,omitempty"`

	// User-defined initialization scripts for the new cluster. Type: array of strings (or Expression with resultType array of
	// strings).
	NewClusterInitScripts *interface{} `json:"newClusterInitScripts,omitempty"`

	// The node type of the new job cluster. This property is required if newClusterVersion is specified and instancePoolId is
	// not specified. If instancePoolId is specified, this property is ignored. Type: string (or Expression with resultType string).
	NewClusterNodeType *interface{} `json:"newClusterNodeType,omitempty"`

	// If not using an existing interactive cluster, this specifies the number of worker nodes to use for the new job cluster
	// or instance pool. For new job clusters, this a string-formatted Int32, like '1' means numOfWorker is 1 or '1:10' means
	// auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted Int32, and can only specify a fixed
	// number of worker nodes, such as '2'. Required if newClusterVersion is specified. Type: string (or Expression with resultType
	// string).
	NewClusterNumOfWorker *interface{} `json:"newClusterNumOfWorker,omitempty"`

	// A set of optional, user-specified Spark configuration key-value pairs.
	NewClusterSparkConf *map[string]interface{} `json:"newClusterSparkConf,omitempty"`

	// A set of optional, user-specified Spark environment variables key-value pairs.
	NewClusterSparkEnvVars *map[string]interface{} `json:"newClusterSparkEnvVars,omitempty"`

	// If not using an existing interactive cluster, this specifies the Spark version of a new job cluster or instance pool nodes
	// created for each run of this activity. Required if instancePoolId is specified. Type: string (or Expression with resultType
	// string).
	NewClusterVersion *interface{} `json:"newClusterVersion,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureDatabricksLinkedServiceTypeProperties.
func (a *AzureDatabricksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				a.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "domain":
			if val != nil {
				err = json.Unmarshal(*val, &a.Domain)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "existingClusterId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ExistingClusterID)
			}
		case "instancePoolId":
			if val != nil {
				err = json.Unmarshal(*val, &a.InstancePoolID)
			}
		case "newClusterCustomTags":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterCustomTags)
			}
		case "newClusterDriverNodeType":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterDriverNodeType)
			}
		case "newClusterEnableElasticDisk":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterEnableElasticDisk)
			}
		case "newClusterInitScripts":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterInitScripts)
			}
		case "newClusterNodeType":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterNodeType)
			}
		case "newClusterNumOfWorker":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterNumOfWorker)
			}
		case "newClusterSparkConf":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterSparkConf)
			}
		case "newClusterSparkEnvVars":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterSparkEnvVars)
			}
		case "newClusterVersion":
			if val != nil {
				err = json.Unmarshal(*val, &a.NewClusterVersion)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure File Storage linked service.
type AzureFileStorageLinkedService struct {
	LinkedService
	// Azure File Storage linked service properties.
	TypeProperties *AzureFileStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileStorageLinkedService.
func (a AzureFileStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureFileStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedService.
func (a *AzureFileStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure File Storage linked service properties.
type AzureFileStorageLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name of the server. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password to logon the server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User ID to logon the server. Type: string (or Expression with resultType string).
	UserID *interface{} `json:"userId,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileStorageLinkedServiceTypeProperties.
func (a *AzureFileStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &a.Host)
			}
		case "password":
			if val != nil {
				a.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userId":
			if val != nil {
				err = json.Unmarshal(*val, &a.UserID)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Function activity.
type AzureFunctionActivity struct {
	ExecutionActivity
	// Azure Function activity properties.
	TypeProperties *AzureFunctionActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionActivity.
func (a AzureFunctionActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureFunctionActivity")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionActivity.
func (a *AzureFunctionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.ExecutionActivity)
}

// Azure Function activity type properties.
type AzureFunctionActivityTypeProperties struct {
	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type:
	// string (or Expression with resultType string).
	Body *interface{} `json:"body,omitempty"`

	// Name of the Function that the Azure Function Activity will call. Type: string (or Expression with resultType string)
	FunctionName *interface{} `json:"functionName,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers"
	// : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
	Headers *interface{} `json:"headers,omitempty"`

	// Rest API method for target endpoint.
	Method *AzureFunctionActivityMethod `json:"method,omitempty"`
}

// Azure Function linked service.
type AzureFunctionLinkedService struct {
	LinkedService
	// Azure Function linked service properties.
	TypeProperties *AzureFunctionLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureFunctionLinkedService.
func (a AzureFunctionLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureFunction")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedService.
func (a *AzureFunctionLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Function linked service properties.
type AzureFunctionLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Azure Function App. URL will be in the format https://<accountName>.azurewebsites.net.
	FunctionAppURL *interface{} `json:"functionAppUrl,omitempty"`

	// Function or Host key for Azure Function App.
	FunctionKey SecretBaseClassification `json:"functionKey,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFunctionLinkedServiceTypeProperties.
func (a *AzureFunctionLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "functionAppUrl":
			if val != nil {
				err = json.Unmarshal(*val, &a.FunctionAppURL)
			}
		case "functionKey":
			if val != nil {
				a.FunctionKey, err = unmarshalSecretBaseClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure Key Vault linked service.
type AzureKeyVaultLinkedService struct {
	LinkedService
	// Azure Key Vault linked service properties.
	TypeProperties *AzureKeyVaultLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultLinkedService.
func (a AzureKeyVaultLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureKeyVault")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultLinkedService.
func (a *AzureKeyVaultLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Key Vault linked service properties.
type AzureKeyVaultLinkedServiceTypeProperties struct {
	// The base URL of the Azure Key Vault. e.g. https://myakv.vault.azure.net Type: string (or Expression with resultType string).
	BaseURL *interface{} `json:"baseUrl,omitempty"`
}

// Azure Key Vault secret reference.
type AzureKeyVaultSecretReference struct {
	SecretBase
	// The name of the secret in Azure Key Vault. Type: string (or Expression with resultType string).
	SecretName *interface{} `json:"secretName,omitempty"`

	// The version of the secret in Azure Key Vault. The default value is the latest version of the secret. Type: string (or Expression
	// with resultType string).
	SecretVersion *interface{} `json:"secretVersion,omitempty"`

	// The Azure Key Vault linked service reference.
	Store *LinkedServiceReference `json:"store,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureKeyVaultSecretReference.
func (a AzureKeyVaultSecretReference) MarshalJSON() ([]byte, error) {
	objectMap := a.SecretBase.marshalInternal("AzureKeyVaultSecret")
	if a.SecretName != nil {
		objectMap["secretName"] = a.SecretName
	}
	if a.SecretVersion != nil {
		objectMap["secretVersion"] = a.SecretVersion
	}
	if a.Store != nil {
		objectMap["store"] = a.Store
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureKeyVaultSecretReference.
func (a *AzureKeyVaultSecretReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretName":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecretName)
			}
		case "secretVersion":
			if val != nil {
				err = json.Unmarshal(*val, &a.SecretVersion)
			}
		case "store":
			if val != nil {
				err = json.Unmarshal(*val, &a.Store)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.SecretBase)
}

// Azure Database for MariaDB linked service.
type AzureMariaDbLinkedService struct {
	LinkedService
	// Azure Database for MariaDB linked service properties.
	TypeProperties *AzureMariaDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDbLinkedService.
func (a AzureMariaDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureMariaDB")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDbLinkedService.
func (a *AzureMariaDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Database for MariaDB linked service properties.
type AzureMariaDbLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// Azure Database for MariaDB dataset.
type AzureMariaDbTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMariaDbTableDataset.
func (a AzureMariaDbTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureMariaDBTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMariaDbTableDataset.
func (a *AzureMariaDbTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure ML Batch Execution activity.
type AzureMlBatchExecutionActivity struct {
	ExecutionActivity
	// Azure ML Batch Execution activity properties.
	TypeProperties *AzureMlBatchExecutionActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlBatchExecutionActivity.
func (a AzureMlBatchExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureMLBatchExecution")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlBatchExecutionActivity.
func (a *AzureMlBatchExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.ExecutionActivity)
}

// Azure ML Batch Execution activity properties.
type AzureMlBatchExecutionActivityTypeProperties struct {
	// Key,Value pairs to be passed to the Azure ML Batch Execution Service endpoint. Keys must match the names of web service
	// parameters defined in the published Azure ML web service. Values will be passed in the GlobalParameters property of the
	// Azure ML batch execution request.
	GlobalParameters *map[string]interface{} `json:"globalParameters,omitempty"`

	// Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Inputs to AzureMLWebServiceFile objects specifying
	// the input Blob locations.. This information will be passed in the WebServiceInputs property of the Azure ML batch execution
	// request.
	WebServiceInputs *map[string]AzureMlWebServiceFile `json:"webServiceInputs,omitempty"`

	// Key,Value pairs, mapping the names of Azure ML endpoint's Web Service Outputs to AzureMLWebServiceFile objects specifying
	// the output Blob locations. This information will be passed in the WebServiceOutputs property of the Azure ML batch execution
	// request.
	WebServiceOutputs *map[string]AzureMlWebServiceFile `json:"webServiceOutputs,omitempty"`
}

// Azure ML Execute Pipeline activity.
type AzureMlExecutePipelineActivity struct {
	ExecutionActivity
	// Azure ML Execute Pipeline activity properties.
	TypeProperties *AzureMlExecutePipelineActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlExecutePipelineActivity.
func (a AzureMlExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureMLExecutePipeline")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlExecutePipelineActivity.
func (a *AzureMlExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.ExecutionActivity)
}

// Azure ML Execute Pipeline activity properties.
type AzureMlExecutePipelineActivityTypeProperties struct {
	// Whether to continue execution of other steps in the PipelineRun if a step fails. This information will be passed in the
	// continueOnStepFailure property of the published pipeline execution request. Type: boolean (or Expression with resultType
	// boolean).
	ContinueOnStepFailure *interface{} `json:"continueOnStepFailure,omitempty"`

	// Run history experiment name of the pipeline run. This information will be passed in the ExperimentName property of the
	// published pipeline execution request. Type: string (or Expression with resultType string).
	ExperimentName *interface{} `json:"experimentName,omitempty"`

	// The parent Azure ML Service pipeline run id. This information will be passed in the ParentRunId property of the published
	// pipeline execution request. Type: string (or Expression with resultType string).
	MlParentRunID *interface{} `json:"mlParentRunId,omitempty"`

	// ID of the published Azure ML pipeline. Type: string (or Expression with resultType string).
	MlPipelineID *interface{} `json:"mlPipelineId,omitempty"`

	// Key,Value pairs to be passed to the published Azure ML pipeline endpoint. Keys must match the names of pipeline parameters
	// defined in the published pipeline. Values will be passed in the ParameterAssignments property of the published pipeline
	// execution request. Type: object with key value pairs (or Expression with resultType object).
	MlPipelineParameters *interface{} `json:"mlPipelineParameters,omitempty"`
}

// Azure ML Studio Web Service linked service.
type AzureMlLinkedService struct {
	LinkedService
	// Azure ML Studio Web Service linked service properties.
	TypeProperties *AzureMlLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlLinkedService.
func (a AzureMlLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureML")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlLinkedService.
func (a *AzureMlLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure ML Studio Web Service linked service properties.
type AzureMlLinkedServiceTypeProperties struct {
	// The API key for accessing the Azure ML model endpoint.
	APIKey SecretBaseClassification `json:"apiKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Batch Execution REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
	MlEndpoint *interface{} `json:"mlEndpoint,omitempty"`

	// The ID of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio
	// web service. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against the ARM-based updateResourceEndpoint of an Azure ML Studio
	// web service.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The Update Resource REST URL for an Azure ML Studio Web Service endpoint. Type: string (or Expression with resultType string).
	UpdateResourceEndpoint *interface{} `json:"updateResourceEndpoint,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlLinkedServiceTypeProperties.
func (a *AzureMlLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiKey":
			if val != nil {
				a.APIKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "mlEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.MlEndpoint)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		case "updateResourceEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &a.UpdateResourceEndpoint)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure ML Service linked service.
type AzureMlServiceLinkedService struct {
	LinkedService
	// Azure ML Service linked service properties.
	TypeProperties *AzureMlServiceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlServiceLinkedService.
func (a AzureMlServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureMLService")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlServiceLinkedService.
func (a *AzureMlServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure ML Service linked service properties.
type AzureMlServiceLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Azure ML Service workspace name. Type: string (or Expression with resultType string).
	MlWorkspaceName *interface{} `json:"mlWorkspaceName,omitempty"`

	// Azure ML Service workspace resource group name. Type: string (or Expression with resultType string).
	ResourceGroupName *interface{} `json:"resourceGroupName,omitempty"`

	// The ID of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline. Type:
	// string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against the endpoint of a published Azure ML Service pipeline.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Azure ML Service workspace subscription ID. Type: string (or Expression with resultType string).
	SubscriptionID *interface{} `json:"subscriptionId,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlServiceLinkedServiceTypeProperties.
func (a *AzureMlServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "mlWorkspaceName":
			if val != nil {
				err = json.Unmarshal(*val, &a.MlWorkspaceName)
			}
		case "resourceGroupName":
			if val != nil {
				err = json.Unmarshal(*val, &a.ResourceGroupName)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "subscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &a.SubscriptionID)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure ML Update Resource management activity.
type AzureMlUpdateResourceActivity struct {
	ExecutionActivity
	// Azure ML Update Resource management activity properties.
	TypeProperties *AzureMlUpdateResourceActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMlUpdateResourceActivity.
func (a AzureMlUpdateResourceActivity) MarshalJSON() ([]byte, error) {
	objectMap := a.ExecutionActivity.marshalInternal("AzureMLUpdateResource")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMlUpdateResourceActivity.
func (a *AzureMlUpdateResourceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.ExecutionActivity)
}

// Azure ML Update Resource activity properties.
type AzureMlUpdateResourceActivityTypeProperties struct {
	// The relative file path in trainedModelLinkedService to represent the .ilearner file that will be uploaded by the update
	// operation. Type: string (or Expression with resultType string).
	TrainedModelFilePath *interface{} `json:"trainedModelFilePath,omitempty"`

	// Name of Azure Storage linked service holding the .ilearner file that will be uploaded by the update operation.
	TrainedModelLinkedServiceName *LinkedServiceReference `json:"trainedModelLinkedServiceName,omitempty"`

	// Name of the Trained Model module in the Web Service experiment to be updated. Type: string (or Expression with resultType
	// string).
	TrainedModelName *interface{} `json:"trainedModelName,omitempty"`
}

// Azure ML WebService Input/Output file
type AzureMlWebServiceFile struct {
	// The relative file path, including container name, in the Azure Blob Storage specified by the LinkedService. Type: string
	// (or Expression with resultType string).
	FilePath *interface{} `json:"filePath,omitempty"`

	// Reference to an Azure Storage LinkedService, where Azure ML WebService Input/Output file located.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`
}

// Azure MySQL database linked service.
type AzureMySQLLinkedService struct {
	LinkedService
	// Azure MySQL database linked service properties.
	TypeProperties *AzureMySQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLLinkedService.
func (a AzureMySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureMySql")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLLinkedService.
func (a *AzureMySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure MySQL database linked service properties.
type AzureMySQLLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// The Azure MySQL database dataset.
type AzureMySQLTableDataset struct {
	Dataset
	// Azure MySQL database dataset properties.
	TypeProperties *AzureMySQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureMySQLTableDataset.
func (a AzureMySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureMySqlTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureMySQLTableDataset.
func (a *AzureMySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure MySQL database dataset properties.
type AzureMySQLTableDatasetTypeProperties struct {
	// The name of Azure MySQL database table. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// The Azure MySQL database table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Azure PostgreSQL linked service.
type AzurePostgreSQLLinkedService struct {
	LinkedService
	// Azure PostgreSQL linked service properties.
	TypeProperties *AzurePostgreSQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLLinkedService.
func (a AzurePostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzurePostgreSql")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLLinkedService.
func (a *AzurePostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure PostgreSQL linked service properties.
type AzurePostgreSQLLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// Azure PostgreSQL dataset.
type AzurePostgreSQLTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *AzurePostgreSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzurePostgreSQLTableDataset.
func (a AzurePostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzurePostgreSqlTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzurePostgreSQLTableDataset.
func (a *AzurePostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure PostgreSQL dataset properties.
type AzurePostgreSQLTableDatasetTypeProperties struct {
	// The schema name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure PostgreSQL database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// The table name of the Azure PostgreSQL database which includes both schema and table. Type: string (or Expression with
	// resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Microsoft Azure SQL Database linked service.
type AzureSQLDatabaseLinkedService struct {
	LinkedService
	// Azure SQL Database linked service properties.
	TypeProperties *AzureSQLDatabaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDatabaseLinkedService.
func (a AzureSQLDatabaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSqlDatabase")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedService.
func (a *AzureSQLDatabaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure SQL Database linked service properties.
type AzureSQLDatabaseLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Database. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Database.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDatabaseLinkedServiceTypeProperties.
func (a *AzureSQLDatabaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "password":
			if val != nil {
				err = json.Unmarshal(*val, &a.Password)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Azure SQL Data Warehouse linked service.
type AzureSQLDwLinkedService struct {
	LinkedService
	// Azure SQL Data Warehouse linked service properties.
	TypeProperties *AzureSQLDwLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDwLinkedService.
func (a AzureSQLDwLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSqlDW")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDwLinkedService.
func (a *AzureSQLDwLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure SQL Data Warehouse linked service properties.
type AzureSQLDwLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Data Warehouse. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Data Warehouse.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDwLinkedServiceTypeProperties.
func (a *AzureSQLDwLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "password":
			if val != nil {
				err = json.Unmarshal(*val, &a.Password)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Azure SQL Data Warehouse dataset.
type AzureSQLDwTableDataset struct {
	Dataset
	// Azure SQL Data Warehouse dataset properties.
	TypeProperties *AzureSQLDwTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLDwTableDataset.
func (a AzureSQLDwTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSqlDWTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLDwTableDataset.
func (a *AzureSQLDwTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure SQL Data Warehouse dataset properties.
type AzureSQLDwTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Azure SQL Managed Instance linked service.
type AzureSQLMiLinkedService struct {
	LinkedService
	// Azure SQL Managed Instance linked service properties.
	TypeProperties *AzureSQLMiLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMiLinkedService.
func (a AzureSQLMiLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSqlMI")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMiLinkedService.
func (a *AzureSQLMiLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure SQL Managed Instance linked service properties.
type AzureSQLMiLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`

	// The ID of the service principal used to authenticate against Azure SQL Managed Instance. Type: string (or Expression with
	// resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key of the service principal used to authenticate against Azure SQL Managed Instance.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The name or ID of the tenant to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMiLinkedServiceTypeProperties.
func (a *AzureSQLMiLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &a.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "password":
			if val != nil {
				err = json.Unmarshal(*val, &a.Password)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &a.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				a.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &a.Tenant)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Azure SQL Managed Instance dataset.
type AzureSQLMiTableDataset struct {
	Dataset
	// Azure SQL Managed Instance dataset properties.
	TypeProperties *AzureSQLMiTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLMiTableDataset.
func (a AzureSQLMiTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSqlMITable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLMiTableDataset.
func (a *AzureSQLMiTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure SQL Managed Instance dataset properties.
type AzureSQLMiTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL Managed Instance. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL Managed Instance dataset. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// The Azure SQL Server database dataset.
type AzureSQLTableDataset struct {
	Dataset
	// Azure SQL dataset properties.
	TypeProperties *AzureSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSQLTableDataset.
func (a AzureSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSqlTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSQLTableDataset.
func (a *AzureSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure SQL dataset properties.
type AzureSQLTableDatasetTypeProperties struct {
	// The schema name of the Azure SQL database. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Azure SQL database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// The Azure Search Index.
type AzureSearchIndexDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *AzureSearchIndexDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchIndexDataset.
func (a AzureSearchIndexDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureSearchIndex")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchIndexDataset.
func (a *AzureSearchIndexDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Properties specific to this dataset type.
type AzureSearchIndexDatasetTypeProperties struct {
	// The name of the Azure Search Index. Type: string (or Expression with resultType string).
	IndexName *interface{} `json:"indexName,omitempty"`
}

// Linked service for Windows Azure Search Service.
type AzureSearchLinkedService struct {
	LinkedService
	// Windows Azure Search Service linked service properties.
	TypeProperties *AzureSearchLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureSearchLinkedService.
func (a AzureSearchLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureSearch")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedService.
func (a *AzureSearchLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Windows Azure Search Service linked service properties.
type AzureSearchLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Admin Key for Azure Search service
	Key SecretBaseClassification `json:"key,omitempty"`

	// URL for Azure Search service. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureSearchLinkedServiceTypeProperties.
func (a *AzureSearchLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &a.EncryptedCredential)
			}
		case "key":
			if val != nil {
				a.Key, err = unmarshalSecretBaseClassification(*val)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &a.URL)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The storage account linked service.
type AzureStorageLinkedService struct {
	LinkedService
	// Azure Storage linked service properties.
	TypeProperties *AzureStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureStorageLinkedService.
func (a AzureStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureStorageLinkedService.
func (a *AzureStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Azure Storage linked service properties.
type AzureStorageLinkedServiceTypeProperties struct {
	// The Azure key vault secret reference of accountKey in connection string.
	AccountKey *AzureKeyVaultSecretReference `json:"accountKey,omitempty"`

	// The connection string. It is mutually exclusive with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of sasToken in sas uri.
	SasToken *AzureKeyVaultSecretReference `json:"sasToken,omitempty"`

	// SAS URI of the Azure Storage resource. It is mutually exclusive with connectionString property. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	SasURI *interface{} `json:"sasUri,omitempty"`
}

// The Azure Table storage dataset.
type AzureTableDataset struct {
	Dataset
	// Azure Table dataset properties.
	TypeProperties *AzureTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableDataset.
func (a AzureTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := a.Dataset.marshalInternal("AzureTable")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableDataset.
func (a *AzureTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.Dataset)
}

// Azure Table dataset properties.
type AzureTableDatasetTypeProperties struct {
	// The table name of the Azure Table storage. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// The azure table storage linked service.
type AzureTableStorageLinkedService struct {
	LinkedService
	// Azure Table Storage linked service properties.
	TypeProperties *AzureStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AzureTableStorageLinkedService.
func (a AzureTableStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := a.LinkedService.marshalInternal("AzureTableStorage")
	if a.TypeProperties != nil {
		objectMap["typeProperties"] = a.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureTableStorageLinkedService.
func (a *AzureTableStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &a.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &a.LinkedService)
}

// Big data pool reference.
type BigDataPoolReference struct {
	// Reference big data pool name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Big data pool reference type.
	Type *string `json:"type,omitempty"`
}

// Binary dataset.
type BinaryDataset struct {
	Dataset
	// Binary dataset properties.
	TypeProperties *BinaryDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BinaryDataset.
func (b BinaryDataset) MarshalJSON() ([]byte, error) {
	objectMap := b.Dataset.marshalInternal("Binary")
	if b.TypeProperties != nil {
		objectMap["typeProperties"] = b.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDataset.
func (b *BinaryDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &b.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &b.Dataset)
}

// Binary dataset properties.
type BinaryDatasetTypeProperties struct {
	// The data compression method used for the binary dataset.
	Compression DatasetCompressionClassification `json:"compression,omitempty"`

	// The location of the Binary storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BinaryDatasetTypeProperties.
func (b *BinaryDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			if val != nil {
				b.Compression, err = unmarshalDatasetCompressionClassification(*val)
			}
		case "location":
			if val != nil {
				b.Location, err = unmarshalDatasetLocationClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Linked service for Cassandra data source.
type CassandraLinkedService struct {
	LinkedService
	// Cassandra linked service properties.
	TypeProperties *CassandraLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CassandraLinkedService.
func (c CassandraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("Cassandra")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedService.
func (c *CassandraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// Cassandra linked service properties.
type CassandraLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection. Type: string (or Expression with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name for connection. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port for the connection. Type: integer (or Expression with resultType integer).
	Port *interface{} `json:"port,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraLinkedServiceTypeProperties.
func (c *CassandraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &c.AuthenticationType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &c.Host)
			}
		case "password":
			if val != nil {
				c.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &c.Port)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &c.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Cassandra database dataset.
type CassandraTableDataset struct {
	Dataset
	// Cassandra dataset properties.
	TypeProperties *CassandraTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CassandraTableDataset.
func (c CassandraTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CassandraTable")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CassandraTableDataset.
func (c *CassandraTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.Dataset)
}

// Cassandra dataset properties.
type CassandraTableDatasetTypeProperties struct {
	// The keyspace of the Cassandra database. Type: string (or Expression with resultType string).
	Keyspace *interface{} `json:"keyspace,omitempty"`

	// The table name of the Cassandra database. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// The object that defines the structure of an Azure Synapse error response.
type CloudError struct {
	// Error data
	InnerError *CloudErrorBody `json:"error,omitempty"`
}

// Error implements the error interface for type CloudError.
func (e CloudError) Error() string {
	msg := ""
	if e.InnerError != nil {
		msg += fmt.Sprintf("InnerError: %v\n", *e.InnerError)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// The object that defines the structure of an Azure Synapse error.
type CloudErrorBody struct {
	// Error code.
	Code *string `json:"code,omitempty"`

	// Array with additional error details.
	Details *[]CloudError `json:"details,omitempty"`

	// Error message.
	Message *string `json:"message,omitempty"`

	// Property name/path in request associated with error.
	Target *string `json:"target,omitempty"`
}

// The Common Data Service for Apps entity dataset.
type CommonDataServiceForAppsEntityDataset struct {
	Dataset
	// Common Data Service for Apps entity dataset properties.
	TypeProperties *CommonDataServiceForAppsEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c CommonDataServiceForAppsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CommonDataServiceForAppsEntity")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsEntityDataset.
func (c *CommonDataServiceForAppsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.Dataset)
}

// Common Data Service for Apps entity dataset properties.
type CommonDataServiceForAppsEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName *interface{} `json:"entityName,omitempty"`
}

// Common Data Service for Apps linked service.
type CommonDataServiceForAppsLinkedService struct {
	LinkedService
	// Common Data Service for Apps linked service properties.
	TypeProperties *CommonDataServiceForAppsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CommonDataServiceForAppsLinkedService.
func (c CommonDataServiceForAppsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CommonDataServiceForApps")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedService.
func (c *CommonDataServiceForAppsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// Common Data Service for Apps linked service properties.
type CommonDataServiceForAppsLinkedServiceTypeProperties struct {
	// The authentication type to connect to Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises
	// with Ifd scenario. 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression
	// with resultType string).
	AuthenticationType *DynamicsAuthenticationType `json:"authenticationType,omitempty"`

	// The deployment type of the Common Data Service for Apps instance. 'Online' for Common Data Service for Apps Online and
	// 'OnPremisesWithIfd' for Common Data Service for Apps on-premises with Ifd. Type: string (or Expression with resultType
	// string).
	DeploymentType *DynamicsDeploymentType `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed
	// for online. Type: string (or Expression with resultType string).
	HostName *interface{} `json:"hostName,omitempty"`

	// The organization name of the Common Data Service for Apps instance. The property is required for on-prem and required for
	// online when there are more than one Common Data Service for Apps instances associated with the user. Type: string (or Expression
	// with resultType string).
	OrganizationName *interface{} `json:"organizationName,omitempty"`

	// Password to access the Common Data Service for Apps instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Common Data Service for Apps server. The property is required for on-prem and not allowed for online.
	// Default is 443. Type: integer (or Expression with resultType integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert',
	// servicePrincipalCredential can only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
	ServicePrincipalCredentialType *DynamicsServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Common Data Service for Apps server. The property is required for on-line and not allowed for
	// on-prem. Type: string (or Expression with resultType string).
	ServiceURI *interface{} `json:"serviceUri,omitempty"`

	// User name to access the Common Data Service for Apps instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommonDataServiceForAppsLinkedServiceTypeProperties.
func (c *CommonDataServiceForAppsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &c.AuthenticationType)
			}
		case "deploymentType":
			if val != nil {
				err = json.Unmarshal(*val, &c.DeploymentType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
		case "hostName":
			if val != nil {
				err = json.Unmarshal(*val, &c.HostName)
			}
		case "organizationName":
			if val != nil {
				err = json.Unmarshal(*val, &c.OrganizationName)
			}
		case "password":
			if val != nil {
				c.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &c.Port)
			}
		case "servicePrincipalCredential":
			if val != nil {
				c.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &c.ServicePrincipalCredentialType)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &c.ServicePrincipalID)
			}
		case "serviceUri":
			if val != nil {
				err = json.Unmarshal(*val, &c.ServiceURI)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &c.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Concur Service linked service.
type ConcurLinkedService struct {
	LinkedService
	// Concur Service linked service properties.
	TypeProperties *ConcurLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConcurLinkedService.
func (c ConcurLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("Concur")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedService.
func (c *ConcurLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// Concur Service linked service properties.
type ConcurLinkedServiceTypeProperties struct {
	// Application client_id supplied by Concur App Management.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password corresponding to the user name that you provided in the username field.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name that you use to access Concur Service.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurLinkedServiceTypeProperties.
func (c *ConcurLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &c.ClientID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
		case "password":
			if val != nil {
				c.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &c.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &c.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &c.UsePeerVerification)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &c.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Concur Service dataset.
type ConcurObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConcurObjectDataset.
func (c ConcurObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("ConcurObject")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConcurObjectDataset.
func (c *ConcurObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.Dataset)
}

// Base class for all control activities like IfCondition, ForEach , Until.
type ControlActivity struct {
	Activity
}

// MarshalJSON implements the json.Marshaller interface for type ControlActivity.
func (c ControlActivity) MarshalJSON() ([]byte, error) {
	objectMap := c.Activity.marshalInternal("Container")
	return json.Marshal(objectMap)
}

// Copy activity.
type CopyActivity struct {
	ExecutionActivity
	// List of inputs for the activity.
	Inputs *[]DatasetReference `json:"inputs,omitempty"`

	// List of outputs for the activity.
	Outputs *[]DatasetReference `json:"outputs,omitempty"`

	// Copy activity properties.
	TypeProperties *CopyActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CopyActivity.
func (c CopyActivity) MarshalJSON() ([]byte, error) {
	objectMap := c.ExecutionActivity.marshalInternal("Copy")
	if c.Inputs != nil {
		objectMap["inputs"] = c.Inputs
	}
	if c.Outputs != nil {
		objectMap["outputs"] = c.Outputs
	}
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivity.
func (c *CopyActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inputs":
			if val != nil {
				err = json.Unmarshal(*val, &c.Inputs)
			}
		case "outputs":
			if val != nil {
				err = json.Unmarshal(*val, &c.Outputs)
			}
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.ExecutionActivity)
}

// Copy activity properties.
type CopyActivityTypeProperties struct {
	// Maximum number of data integration units that can be used to perform this data movement. Type: integer (or Expression with
	// resultType integer), minimum: 0.
	DataIntegrationUnits *interface{} `json:"dataIntegrationUnits,omitempty"`

	// Whether to skip incompatible row. Default value is false. Type: boolean (or Expression with resultType boolean).
	EnableSkipIncompatibleRow *interface{} `json:"enableSkipIncompatibleRow,omitempty"`

	// Specifies whether to copy data via an interim staging. Default value is false. Type: boolean (or Expression with resultType
	// boolean).
	EnableStaging *interface{} `json:"enableStaging,omitempty"`

	// Maximum number of concurrent sessions opened on the source or sink to avoid overloading the data store. Type: integer (or
	// Expression with resultType integer), minimum: 0.
	ParallelCopies *interface{} `json:"parallelCopies,omitempty"`

	// Preserve rules.
	Preserve *[]interface{} `json:"preserve,omitempty"`

	// Preserve Rules.
	PreserveRules *[]interface{} `json:"preserveRules,omitempty"`

	// Redirect incompatible row settings when EnableSkipIncompatibleRow is true.
	RedirectIncompatibleRowSettings *RedirectIncompatibleRowSettings `json:"redirectIncompatibleRowSettings,omitempty"`

	// Copy activity sink.
	Sink CopySinkClassification `json:"sink,omitempty"`

	// Copy activity source.
	Source CopySourceClassification `json:"source,omitempty"`

	// Specifies interim staging settings when EnableStaging is true.
	StagingSettings *StagingSettings `json:"stagingSettings,omitempty"`

	// Copy activity translator. If not specified, tabular translator is used.
	Translator *interface{} `json:"translator,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyActivityTypeProperties.
func (c *CopyActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrationUnits":
			if val != nil {
				err = json.Unmarshal(*val, &c.DataIntegrationUnits)
			}
		case "enableSkipIncompatibleRow":
			if val != nil {
				err = json.Unmarshal(*val, &c.EnableSkipIncompatibleRow)
			}
		case "enableStaging":
			if val != nil {
				err = json.Unmarshal(*val, &c.EnableStaging)
			}
		case "parallelCopies":
			if val != nil {
				err = json.Unmarshal(*val, &c.ParallelCopies)
			}
		case "preserve":
			if val != nil {
				err = json.Unmarshal(*val, &c.Preserve)
			}
		case "preserveRules":
			if val != nil {
				err = json.Unmarshal(*val, &c.PreserveRules)
			}
		case "redirectIncompatibleRowSettings":
			if val != nil {
				err = json.Unmarshal(*val, &c.RedirectIncompatibleRowSettings)
			}
		case "sink":
			if val != nil {
				c.Sink, err = unmarshalCopySinkClassification(*val)
			}
		case "source":
			if val != nil {
				c.Source, err = unmarshalCopySourceClassification(*val)
			}
		case "stagingSettings":
			if val != nil {
				err = json.Unmarshal(*val, &c.StagingSettings)
			}
		case "translator":
			if val != nil {
				err = json.Unmarshal(*val, &c.Translator)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CopySinkClassification provides polymorphic access to related types.
type CopySinkClassification interface {
	GetCopySink() *CopySink
}

// A copy activity sink.
type CopySink struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The maximum concurrent connection count for the sink data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections *interface{} `json:"maxConcurrentConnections,omitempty"`

	// Sink retry count. Type: integer (or Expression with resultType integer).
	SinkRetryCount *interface{} `json:"sinkRetryCount,omitempty"`

	// Sink retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SinkRetryWait *interface{} `json:"sinkRetryWait,omitempty"`

	// Copy sink type.
	Type *string `json:"type,omitempty"`

	// Write batch size. Type: integer (or Expression with resultType integer), minimum: 0.
	WriteBatchSize *interface{} `json:"writeBatchSize,omitempty"`

	// Write batch timeout. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	WriteBatchTimeout *interface{} `json:"writeBatchTimeout,omitempty"`
}

// GetCopySink implements the CopySinkClassification interface for type CopySink.
func (c *CopySink) GetCopySink() *CopySink { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySink.
func (c *CopySink) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxConcurrentConnections":
			if val != nil {
				err = json.Unmarshal(*val, &c.MaxConcurrentConnections)
			}
		case "sinkRetryCount":
			if val != nil {
				err = json.Unmarshal(*val, &c.SinkRetryCount)
			}
		case "sinkRetryWait":
			if val != nil {
				err = json.Unmarshal(*val, &c.SinkRetryWait)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &c.Type)
			}
		case "writeBatchSize":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBatchSize)
			}
		case "writeBatchTimeout":
			if val != nil {
				err = json.Unmarshal(*val, &c.WriteBatchTimeout)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (c CopySink) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if c.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = c.AdditionalProperties
	}
	if c.MaxConcurrentConnections != nil {
		objectMap["maxConcurrentConnections"] = c.MaxConcurrentConnections
	}
	if c.SinkRetryCount != nil {
		objectMap["sinkRetryCount"] = c.SinkRetryCount
	}
	if c.SinkRetryWait != nil {
		objectMap["sinkRetryWait"] = c.SinkRetryWait
	}
	c.Type = &discValue
	objectMap["type"] = c.Type
	if c.WriteBatchSize != nil {
		objectMap["writeBatchSize"] = c.WriteBatchSize
	}
	if c.WriteBatchTimeout != nil {
		objectMap["writeBatchTimeout"] = c.WriteBatchTimeout
	}
	return objectMap
}

// CopySourceClassification provides polymorphic access to related types.
type CopySourceClassification interface {
	GetCopySource() *CopySource
}

// A copy activity source.
type CopySource struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The maximum concurrent connection count for the source data store. Type: integer (or Expression with resultType integer).
	MaxConcurrentConnections *interface{} `json:"maxConcurrentConnections,omitempty"`

	// Source retry count. Type: integer (or Expression with resultType integer).
	SourceRetryCount *interface{} `json:"sourceRetryCount,omitempty"`

	// Source retry wait. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	SourceRetryWait *interface{} `json:"sourceRetryWait,omitempty"`

	// Copy source type.
	Type *string `json:"type,omitempty"`
}

// GetCopySource implements the CopySourceClassification interface for type CopySource.
func (c *CopySource) GetCopySource() *CopySource { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CopySource.
func (c *CopySource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxConcurrentConnections":
			if val != nil {
				err = json.Unmarshal(*val, &c.MaxConcurrentConnections)
			}
		case "sourceRetryCount":
			if val != nil {
				err = json.Unmarshal(*val, &c.SourceRetryCount)
			}
		case "sourceRetryWait":
			if val != nil {
				err = json.Unmarshal(*val, &c.SourceRetryWait)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &c.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (c CopySource) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if c.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = c.AdditionalProperties
	}
	if c.MaxConcurrentConnections != nil {
		objectMap["maxConcurrentConnections"] = c.MaxConcurrentConnections
	}
	if c.SourceRetryCount != nil {
		objectMap["sourceRetryCount"] = c.SourceRetryCount
	}
	if c.SourceRetryWait != nil {
		objectMap["sourceRetryWait"] = c.SourceRetryWait
	}
	c.Type = &discValue
	objectMap["type"] = c.Type
	return objectMap
}

// Microsoft Azure Cosmos Database (CosmosDB) linked service.
type CosmosDbLinkedService struct {
	LinkedService
	// CosmosDB linked service properties.
	TypeProperties *CosmosDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbLinkedService.
func (c CosmosDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CosmosDb")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedService.
func (c *CosmosDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// CosmosDB linked service properties.
type CosmosDbLinkedServiceTypeProperties struct {
	// The endpoint of the Azure CosmosDB account. Type: string (or Expression with resultType string)
	AccountEndpoint *interface{} `json:"accountEndpoint,omitempty"`

	// The account key of the Azure CosmosDB account. Type: SecureString or AzureKeyVaultSecretReference.
	AccountKey SecretBaseClassification `json:"accountKey,omitempty"`

	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The name of the database. Type: string (or Expression with resultType string)
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbLinkedServiceTypeProperties.
func (c *CosmosDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountEndpoint":
			if val != nil {
				err = json.Unmarshal(*val, &c.AccountEndpoint)
			}
		case "accountKey":
			if val != nil {
				c.AccountKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &c.ConnectionString)
			}
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &c.Database)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &c.EncryptedCredential)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The CosmosDB (MongoDB API) database dataset.
type CosmosDbMongoDbAPICollectionDataset struct {
	Dataset
	// CosmosDB (MongoDB API) database dataset properties.
	TypeProperties *CosmosDbMongoDbAPICollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c CosmosDbMongoDbAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CosmosDbMongoDbApiCollection")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPICollectionDataset.
func (c *CosmosDbMongoDbAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.Dataset)
}

// CosmosDB (MongoDB API) database dataset properties.
type CosmosDbMongoDbAPICollectionDatasetTypeProperties struct {
	// The collection name of the CosmosDB (MongoDB API) database. Type: string (or Expression with resultType string).
	Collection *interface{} `json:"collection,omitempty"`
}

// Linked service for CosmosDB (MongoDB API) data source.
type CosmosDbMongoDbAPILinkedService struct {
	LinkedService
	// CosmosDB (MongoDB API) linked service properties.
	TypeProperties *CosmosDbMongoDbAPILinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c CosmosDbMongoDbAPILinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CosmosDbMongoDbApi")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbMongoDbAPILinkedService.
func (c *CosmosDbMongoDbAPILinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// CosmosDB (MongoDB API) linked service properties.
type CosmosDbMongoDbAPILinkedServiceTypeProperties struct {
	// The CosmosDB (MongoDB API) connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string,
	// SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The name of the CosmosDB (MongoDB API) database that you want to access. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`
}

// Microsoft Azure CosmosDB (SQL API) Collection dataset.
type CosmosDbSQLAPICollectionDataset struct {
	Dataset
	// CosmosDB (SQL API) Collection dataset properties.
	TypeProperties *CosmosDbSQLAPICollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c CosmosDbSQLAPICollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CosmosDbSqlApiCollection")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CosmosDbSQLAPICollectionDataset.
func (c *CosmosDbSQLAPICollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.Dataset)
}

// CosmosDB (SQL API) Collection dataset properties.
type CosmosDbSQLAPICollectionDatasetTypeProperties struct {
	// CosmosDB (SQL API) collection name. Type: string (or Expression with resultType string).
	CollectionName *interface{} `json:"collectionName,omitempty"`
}

// Couchbase server linked service.
type CouchbaseLinkedService struct {
	LinkedService
	// Couchbase server linked service properties.
	TypeProperties *CouchbaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseLinkedService.
func (c CouchbaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("Couchbase")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseLinkedService.
func (c *CouchbaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// Couchbase server linked service properties.
type CouchbaseLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The Azure key vault secret reference of credString in connection string.
	CredString *AzureKeyVaultSecretReference `json:"credString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`
}

// Couchbase server dataset.
type CouchbaseTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CouchbaseTableDataset.
func (c CouchbaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := c.Dataset.marshalInternal("CouchbaseTable")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CouchbaseTableDataset.
func (c *CouchbaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.Dataset)
}

// Request body structure for creating data flow debug session.
type CreateDataFlowDebugSessionRequest struct {
	// Timeout setting for Databricks cluster.
	ClusterTimeout *int32 `json:"clusterTimeout,omitempty"`

	// Data bricks linked service.
	DataBricksLinkedService *LinkedServiceResource `json:"dataBricksLinkedService,omitempty"`

	// The name of the data flow.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of existing Databricks cluster.
	ExistingClusterID *string `json:"existingClusterId,omitempty"`

	// The name of new Databricks cluster.
	NewClusterName *string `json:"newClusterName,omitempty"`

	// The type of new Databricks cluster.
	NewClusterNodeType *string `json:"newClusterNodeType,omitempty"`
}

// Response body structure for creating data flow debug session.
type CreateDataFlowDebugSessionResponse struct {
	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// CreateDataFlowDebugSessionResponsePollerResponse is the response envelope for operations that asynchronously return a CreateDataFlowDebugSessionResponse
// type.
type CreateDataFlowDebugSessionResponsePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*CreateDataFlowDebugSessionResponseResponse, error)

	// Poller contains an initialized poller.
	Poller CreateDataFlowDebugSessionResponsePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CreateDataFlowDebugSessionResponseResponse is the response envelope for operations that return a CreateDataFlowDebugSessionResponse
// type.
type CreateDataFlowDebugSessionResponseResponse struct {
	// Response body structure for creating data flow debug session.
	CreateDataFlowDebugSessionResponse *CreateDataFlowDebugSessionResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Response body with a run identifier.
type CreateRunResponse struct {
	// Identifier of a run.
	RunID *string `json:"runId,omitempty"`
}

// CreateRunResponsePollerResponse is the response envelope for operations that asynchronously return a CreateRunResponse
// type.
type CreateRunResponsePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*CreateRunResponseResponse, error)

	// Poller contains an initialized poller.
	Poller CreateRunResponsePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// CreateRunResponseResponse is the response envelope for operations that return a CreateRunResponse type.
type CreateRunResponseResponse struct {
	// Response body with a run identifier.
	CreateRunResponse *CreateRunResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Custom activity type.
type CustomActivity struct {
	ExecutionActivity
	// Custom activity properties.
	TypeProperties *CustomActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomActivity.
func (c CustomActivity) MarshalJSON() ([]byte, error) {
	objectMap := c.ExecutionActivity.marshalInternal("Custom")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomActivity.
func (c *CustomActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.ExecutionActivity)
}

// Reference objects for custom activity
type CustomActivityReferenceObject struct {
	// Dataset references.
	Datasets *[]DatasetReference `json:"datasets,omitempty"`

	// Linked service references.
	LinkedServices *[]LinkedServiceReference `json:"linkedServices,omitempty"`
}

// Custom activity properties.
type CustomActivityTypeProperties struct {
	// Command for custom activity Type: string (or Expression with resultType string).
	Command *interface{} `json:"command,omitempty"`

	// User defined property bag. There is no restriction on the keys or values that can be used. The user specified custom activity
	// has the full responsibility to consume and interpret the content defined.
	ExtendedProperties *map[string]interface{} `json:"extendedProperties,omitempty"`

	// Folder path for resource files Type: string (or Expression with resultType string).
	FolderPath *interface{} `json:"folderPath,omitempty"`

	// Reference objects
	ReferenceObjects *CustomActivityReferenceObject `json:"referenceObjects,omitempty"`

	// Resource linked service reference.
	ResourceLinkedService *LinkedServiceReference `json:"resourceLinkedService,omitempty"`

	// The retention time for the files submitted for custom activity. Type: double (or Expression with resultType double).
	RetentionTimeInDays *interface{} `json:"retentionTimeInDays,omitempty"`
}

// Custom linked service.
type CustomDataSourceLinkedService struct {
	LinkedService
	// Custom linked service properties.
	TypeProperties *interface{} `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CustomDataSourceLinkedService.
func (c CustomDataSourceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := c.LinkedService.marshalInternal("CustomDataSource")
	if c.TypeProperties != nil {
		objectMap["typeProperties"] = c.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomDataSourceLinkedService.
func (c *CustomDataSourceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &c.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &c.LinkedService)
}

// DataFlowClassification provides polymorphic access to related types.
type DataFlowClassification interface {
	GetDataFlow() *DataFlow
}

// Azure Synapse nested object which contains a flow with data movements and transformations.
type DataFlow struct {
	// List of tags that can be used for describing the data flow.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// The description of the data flow.
	Description *string `json:"description,omitempty"`

	// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
	Folder *DataFlowFolder `json:"folder,omitempty"`

	// Type of data flow.
	Type *string `json:"type,omitempty"`
}

// GetDataFlow implements the DataFlowClassification interface for type DataFlow.
func (d *DataFlow) GetDataFlow() *DataFlow { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlow.
func (d *DataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &d.Annotations)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &d.Description)
			}
		case "folder":
			if val != nil {
				err = json.Unmarshal(*val, &d.Folder)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (d DataFlow) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.Annotations != nil {
		objectMap["annotations"] = d.Annotations
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.Folder != nil {
		objectMap["folder"] = d.Folder
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	return objectMap
}

// DataFlowCreateOrUpdateDataFlowOptions contains the optional parameters for the DataFlow.CreateOrUpdateDataFlow method.
type DataFlowCreateOrUpdateDataFlowOptions struct {
	// ETag of the data flow entity. Should only be specified for update, for which it should match existing entity or can be
	// * for unconditional update.
	IfMatch *string
}

// Request body structure for data flow expression preview.
type DataFlowDebugCommandRequest struct {
	// The command name.
	CommandName *string `json:"commandName,omitempty"`

	// The command payload object.
	CommandPayload *interface{} `json:"commandPayload,omitempty"`

	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// Response body structure of data flow result for data preview, statistics or expression preview.
type DataFlowDebugCommandResponse struct {
	// The result data of data preview, statistics or expression preview.
	Data *string `json:"data,omitempty"`

	// The run status of data preview, statistics or expression preview.
	Status *string `json:"status,omitempty"`
}

// DataFlowDebugCommandResponsePollerResponse is the response envelope for operations that asynchronously return a DataFlowDebugCommandResponse
// type.
type DataFlowDebugCommandResponsePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*DataFlowDebugCommandResponseResponse, error)

	// Poller contains an initialized poller.
	Poller DataFlowDebugCommandResponsePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugCommandResponseResponse is the response envelope for operations that return a DataFlowDebugCommandResponse
// type.
type DataFlowDebugCommandResponseResponse struct {
	// Response body structure of data flow result for data preview, statistics or expression preview.
	DataFlowDebugCommandResponse *DataFlowDebugCommandResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Request body structure for starting data flow debug session.
type DataFlowDebugPackage struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Data flow instance.
	DataFlow *DataFlowDebugResource `json:"dataFlow,omitempty"`

	// List of datasets.
	Datasets *[]DatasetDebugResource `json:"datasets,omitempty"`

	// Data flow debug settings.
	DebugSettings *DataFlowDebugPackageDebugSettings `json:"debugSettings,omitempty"`

	// List of linked services.
	LinkedServices *[]LinkedServiceDebugResource `json:"linkedServices,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Staging info for debug session.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugPackage.
func (d DataFlowDebugPackage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DataFlow != nil {
		objectMap["dataFlow"] = d.DataFlow
	}
	if d.Datasets != nil {
		objectMap["datasets"] = d.Datasets
	}
	if d.DebugSettings != nil {
		objectMap["debugSettings"] = d.DebugSettings
	}
	if d.LinkedServices != nil {
		objectMap["linkedServices"] = d.LinkedServices
	}
	if d.SessionID != nil {
		objectMap["sessionId"] = d.SessionID
	}
	if d.Staging != nil {
		objectMap["staging"] = d.Staging
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugPackage.
func (d *DataFlowDebugPackage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataFlow":
			if val != nil {
				err = json.Unmarshal(*val, &d.DataFlow)
			}
		case "datasets":
			if val != nil {
				err = json.Unmarshal(*val, &d.Datasets)
			}
		case "debugSettings":
			if val != nil {
				err = json.Unmarshal(*val, &d.DebugSettings)
			}
		case "linkedServices":
			if val != nil {
				err = json.Unmarshal(*val, &d.LinkedServices)
			}
		case "sessionId":
			if val != nil {
				err = json.Unmarshal(*val, &d.SessionID)
			}
		case "staging":
			if val != nil {
				err = json.Unmarshal(*val, &d.Staging)
			}
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Data flow debug settings.
type DataFlowDebugPackageDebugSettings struct {
	// Parameters for dataset.
	DatasetParameters *interface{} `json:"datasetParameters,omitempty"`

	// Data flow parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Source setting for data flow debug.
	SourceSettings *[]DataFlowSourceSetting `json:"sourceSettings,omitempty"`
}

// Request body structure for data flow preview data.
type DataFlowDebugPreviewDataRequest struct {
	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The row limit for preview request.
	RowLimits *int32 `json:"rowLimits,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The output stream name.
	StreamName *string `json:"streamName,omitempty"`
}

// Response body structure of data flow query for data preview, statistics or expression preview.
type DataFlowDebugQueryResponse struct {
	// The run ID of data flow debug session.
	RunID *string `json:"runId,omitempty"`
}

// Data flow debug resource.
type DataFlowDebugResource struct {
	SubResourceDebugResource
	// Data flow properties.
	Properties DataFlowClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugResource.
func (d *DataFlowDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				d.Properties, err = unmarshalDataFlowClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.SubResourceDebugResource)
}

// Response body structure of data flow result for data preview, statistics or expression preview.
type DataFlowDebugResultResponse struct {
	// The result data of data preview, statistics or expression preview.
	Data *string `json:"data,omitempty"`

	// The run status of data preview, statistics or expression preview.
	Status *string `json:"status,omitempty"`
}

// Data flow debug session info.
type DataFlowDebugSessionInfo struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Compute type of the cluster.
	ComputeType *string `json:"computeType,omitempty"`

	// Core count of the cluster.
	CoreCount *int32 `json:"coreCount,omitempty"`

	// The name of the data flow.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// Attached integration runtime name of data flow debug session.
	IntegrationRuntimeName *string `json:"integrationRuntimeName,omitempty"`

	// Last activity time of data flow debug session.
	LastActivityTime *string `json:"lastActivityTime,omitempty"`

	// Node count of the cluster. (deprecated property)
	NodeCount *int32 `json:"nodeCount,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Start time of data flow debug session.
	StartTime *string `json:"startTime,omitempty"`

	// Compute type of the cluster.
	TimeToLiveInMinutes *int32 `json:"timeToLiveInMinutes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowDebugSessionInfo.
func (d DataFlowDebugSessionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ComputeType != nil {
		objectMap["computeType"] = d.ComputeType
	}
	if d.CoreCount != nil {
		objectMap["coreCount"] = d.CoreCount
	}
	if d.DataFlowName != nil {
		objectMap["dataFlowName"] = d.DataFlowName
	}
	if d.IntegrationRuntimeName != nil {
		objectMap["integrationRuntimeName"] = d.IntegrationRuntimeName
	}
	if d.LastActivityTime != nil {
		objectMap["lastActivityTime"] = d.LastActivityTime
	}
	if d.NodeCount != nil {
		objectMap["nodeCount"] = d.NodeCount
	}
	if d.SessionID != nil {
		objectMap["sessionId"] = d.SessionID
	}
	if d.StartTime != nil {
		objectMap["startTime"] = d.StartTime
	}
	if d.TimeToLiveInMinutes != nil {
		objectMap["timeToLiveInMinutes"] = d.TimeToLiveInMinutes
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowDebugSessionInfo.
func (d *DataFlowDebugSessionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "computeType":
			if val != nil {
				err = json.Unmarshal(*val, &d.ComputeType)
			}
		case "coreCount":
			if val != nil {
				err = json.Unmarshal(*val, &d.CoreCount)
			}
		case "dataFlowName":
			if val != nil {
				err = json.Unmarshal(*val, &d.DataFlowName)
			}
		case "integrationRuntimeName":
			if val != nil {
				err = json.Unmarshal(*val, &d.IntegrationRuntimeName)
			}
		case "lastActivityTime":
			if val != nil {
				err = json.Unmarshal(*val, &d.LastActivityTime)
			}
		case "nodeCount":
			if val != nil {
				err = json.Unmarshal(*val, &d.NodeCount)
			}
		case "sessionId":
			if val != nil {
				err = json.Unmarshal(*val, &d.SessionID)
			}
		case "startTime":
			if val != nil {
				err = json.Unmarshal(*val, &d.StartTime)
			}
		case "timeToLiveInMinutes":
			if val != nil {
				err = json.Unmarshal(*val, &d.TimeToLiveInMinutes)
			}
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Request body structure for data flow statistics.
type DataFlowDebugStatisticsRequest struct {
	// List of column names.
	Columns *[]string `json:"columns,omitempty"`

	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The output stream name.
	StreamName *string `json:"streamName,omitempty"`
}

// The folder that this data flow is in. If not specified, Data flow will appear at the root level.
type DataFlowFolder struct {
	// The name of the folder that this data flow is in.
	Name *string `json:"name,omitempty"`
}

// DataFlowGetDataFlowOptions contains the optional parameters for the DataFlow.GetDataFlow method.
type DataFlowGetDataFlowOptions struct {
	// ETag of the data flow entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// A list of data flow resources.
type DataFlowListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of data flows.
	Value *[]DataFlowResource `json:"value,omitempty"`
}

// DataFlowListResponseResponse is the response envelope for operations that return a DataFlowListResponse type.
type DataFlowListResponseResponse struct {
	// A list of data flow resources.
	DataFlowListResponse *DataFlowListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Data flow reference type.
type DataFlowReference struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Reference data flow parameters from dataset.
	DatasetParameters *interface{} `json:"datasetParameters,omitempty"`

	// Reference data flow name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Data flow reference type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowReference.
func (d DataFlowReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DatasetParameters != nil {
		objectMap["datasetParameters"] = d.DatasetParameters
	}
	if d.ReferenceName != nil {
		objectMap["referenceName"] = d.ReferenceName
	}
	if d.Type != nil {
		objectMap["type"] = d.Type
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowReference.
func (d *DataFlowReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasetParameters":
			if val != nil {
				err = json.Unmarshal(*val, &d.DatasetParameters)
			}
		case "referenceName":
			if val != nil {
				err = json.Unmarshal(*val, &d.ReferenceName)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Data flow resource type.
type DataFlowResource struct {
	SubResource
	// Data flow properties.
	Properties DataFlowClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowResource.
func (d *DataFlowResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				d.Properties, err = unmarshalDataFlowClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.SubResource)
}

// DataFlowResourceResponse is the response envelope for operations that return a DataFlowResource type.
type DataFlowResourceResponse struct {
	// Data flow resource type.
	DataFlowResource *DataFlowResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Transformation for data flow sink.
type DataFlowSink struct {
	Transformation
	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`
}

// Transformation for data flow source.
type DataFlowSource struct {
	Transformation
	// Dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`
}

// Definition of data flow source setting for debug.
type DataFlowSourceSetting struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Defines the row limit of data flow source in debug.
	RowLimit *int32 `json:"rowLimit,omitempty"`

	// The data flow source name.
	SourceName *string `json:"sourceName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataFlowSourceSetting.
func (d DataFlowSourceSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.RowLimit != nil {
		objectMap["rowLimit"] = d.RowLimit
	}
	if d.SourceName != nil {
		objectMap["sourceName"] = d.SourceName
	}
	if d.AdditionalProperties != nil {
		for key, val := range *d.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataFlowSourceSetting.
func (d *DataFlowSourceSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rowLimit":
			if val != nil {
				err = json.Unmarshal(*val, &d.RowLimit)
			}
		case "sourceName":
			if val != nil {
				err = json.Unmarshal(*val, &d.SourceName)
			}
		default:
			if d.AdditionalProperties == nil {
				d.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*d.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Staging info for execute data flow activity.
type DataFlowStagingInfo struct {
	// Folder path for staging blob.
	FolderPath *string `json:"folderPath,omitempty"`

	// Staging linked service reference.
	LinkedService *LinkedServiceReference `json:"linkedService,omitempty"`
}

// Data Lake Analytics U-SQL activity.
type DataLakeAnalyticsUsqlActivity struct {
	ExecutionActivity
	// Data Lake Analytics U-SQL activity properties.
	TypeProperties *DataLakeAnalyticsUsqlActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataLakeAnalyticsUsqlActivity.
func (d DataLakeAnalyticsUsqlActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DataLakeAnalyticsU-SQL")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataLakeAnalyticsUsqlActivity.
func (d *DataLakeAnalyticsUsqlActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.ExecutionActivity)
}

// DataLakeAnalyticsU-SQL activity properties.
type DataLakeAnalyticsUsqlActivityTypeProperties struct {
	// Compilation mode of U-SQL. Must be one of these values : Semantic, Full and SingleBox. Type: string (or Expression with
	// resultType string).
	CompilationMode *interface{} `json:"compilationMode,omitempty"`

	// The maximum number of nodes simultaneously used to run the job. Default value is 1. Type: integer (or Expression with resultType
	// integer), minimum: 1.
	DegreeOfParallelism *interface{} `json:"degreeOfParallelism,omitempty"`

	// Parameters for U-SQL job request.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Determines which jobs out of all that are queued should be selected to run first. The lower the number, the higher the
	// priority. Default value is 1000. Type: integer (or Expression with resultType integer), minimum: 1.
	Priority *interface{} `json:"priority,omitempty"`

	// Runtime version of the U-SQL engine to use. Type: string (or Expression with resultType string).
	RuntimeVersion *interface{} `json:"runtimeVersion,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Case-sensitive path to folder that contains the U-SQL script. Type: string (or Expression with resultType string).
	ScriptPath *interface{} `json:"scriptPath,omitempty"`
}

// DatabricksNotebook activity.
type DatabricksNotebookActivity struct {
	ExecutionActivity
	// Databricks Notebook activity properties.
	TypeProperties *DatabricksNotebookActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksNotebookActivity.
func (d DatabricksNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DatabricksNotebook")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksNotebookActivity.
func (d *DatabricksNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.ExecutionActivity)
}

// Databricks notebook activity properties.
type DatabricksNotebookActivityTypeProperties struct {
	// Base parameters to be used for each run of this job.If the notebook takes a parameter that is not specified, the default
	// value from the notebook will be used.
	BaseParameters *map[string]interface{} `json:"baseParameters,omitempty"`

	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries *[]map[string]interface{} `json:"libraries,omitempty"`

	// The absolute path of the notebook to be run in the Databricks Workspace. This path must begin with a slash. Type: string
	// (or Expression with resultType string).
	NotebookPath *interface{} `json:"notebookPath,omitempty"`
}

// DatabricksSparkJar activity.
type DatabricksSparkJarActivity struct {
	ExecutionActivity
	// Databricks SparkJar activity properties.
	TypeProperties *DatabricksSparkJarActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkJarActivity.
func (d DatabricksSparkJarActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DatabricksSparkJar")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkJarActivity.
func (d *DatabricksSparkJarActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.ExecutionActivity)
}

// Databricks SparkJar activity properties.
type DatabricksSparkJarActivityTypeProperties struct {
	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries *[]map[string]interface{} `json:"libraries,omitempty"`

	// The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as
	// a library. Type: string (or Expression with resultType string).
	MainClassName *interface{} `json:"mainClassName,omitempty"`

	// Parameters that will be passed to the main method.
	Parameters *[]interface{} `json:"parameters,omitempty"`
}

// DatabricksSparkPython activity.
type DatabricksSparkPythonActivity struct {
	ExecutionActivity
	// Databricks SparkPython activity properties.
	TypeProperties *DatabricksSparkPythonActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabricksSparkPythonActivity.
func (d DatabricksSparkPythonActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("DatabricksSparkPython")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabricksSparkPythonActivity.
func (d *DatabricksSparkPythonActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.ExecutionActivity)
}

// Databricks SparkPython activity properties.
type DatabricksSparkPythonActivityTypeProperties struct {
	// A list of libraries to be installed on the cluster that will execute the job.
	Libraries *[]map[string]interface{} `json:"libraries,omitempty"`

	// Command line parameters that will be passed to the Python file.
	Parameters *[]interface{} `json:"parameters,omitempty"`

	// The URI of the Python file to be executed. DBFS paths are supported. Type: string (or Expression with resultType string).
	PythonFile *interface{} `json:"pythonFile,omitempty"`
}

// DatasetClassification provides polymorphic access to related types.
type DatasetClassification interface {
	GetDataset() *Dataset
}

// The Azure Data Factory nested object which identifies data within different data stores, such as tables, files, folders,
// and documents.
type Dataset struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// List of tags that can be used for describing the Dataset.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// Dataset description.
	Description *string `json:"description,omitempty"`

	// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
	Folder *DatasetFolder `json:"folder,omitempty"`

	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Parameters for dataset.
	Parameters *map[string]ParameterSpecification `json:"parameters,omitempty"`

	// Columns that define the physical type schema of the dataset. Type: array (or Expression with resultType array), itemType:
	// DatasetSchemaDataElement.
	Schema *interface{} `json:"schema,omitempty"`

	// Columns that define the structure of the dataset. Type: array (or Expression with resultType array), itemType: DatasetDataElement.
	Structure *interface{} `json:"structure,omitempty"`

	// Type of dataset.
	Type *string `json:"type,omitempty"`
}

// GetDataset implements the DatasetClassification interface for type Dataset.
func (d *Dataset) GetDataset() *Dataset { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type Dataset.
func (d *Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &d.Annotations)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &d.Description)
			}
		case "folder":
			if val != nil {
				err = json.Unmarshal(*val, &d.Folder)
			}
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &d.LinkedServiceName)
			}
		case "parameters":
			if val != nil {
				err = json.Unmarshal(*val, &d.Parameters)
			}
		case "schema":
			if val != nil {
				err = json.Unmarshal(*val, &d.Schema)
			}
		case "structure":
			if val != nil {
				err = json.Unmarshal(*val, &d.Structure)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (d Dataset) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = d.AdditionalProperties
	}
	if d.Annotations != nil {
		objectMap["annotations"] = d.Annotations
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.Folder != nil {
		objectMap["folder"] = d.Folder
	}
	if d.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = d.LinkedServiceName
	}
	if d.Parameters != nil {
		objectMap["parameters"] = d.Parameters
	}
	if d.Schema != nil {
		objectMap["schema"] = d.Schema
	}
	if d.Structure != nil {
		objectMap["structure"] = d.Structure
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	return objectMap
}

// The BZip2 compression method used on a dataset.
type DatasetBZip2Compression struct {
	DatasetCompression
}

// MarshalJSON implements the json.Marshaller interface for type DatasetBZip2Compression.
func (d DatasetBZip2Compression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("BZip2")
	return json.Marshal(objectMap)
}

// DatasetCompressionClassification provides polymorphic access to related types.
type DatasetCompressionClassification interface {
	GetDatasetCompression() *DatasetCompression
}

// The compression method used on a dataset.
type DatasetCompression struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Type of dataset compression.
	Type *string `json:"type,omitempty"`
}

// GetDatasetCompression implements the DatasetCompressionClassification interface for type DatasetCompression.
func (d *DatasetCompression) GetDatasetCompression() *DatasetCompression { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetCompression.
func (d *DatasetCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (d DatasetCompression) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = d.AdditionalProperties
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	return objectMap
}

// DatasetCreateOrUpdateDatasetOptions contains the optional parameters for the Dataset.CreateOrUpdateDataset method.
type DatasetCreateOrUpdateDatasetOptions struct {
	// ETag of the dataset entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// Dataset debug resource.
type DatasetDebugResource struct {
	SubResourceDebugResource
	// Dataset properties.
	Properties DatasetClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetDebugResource.
func (d *DatasetDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				d.Properties, err = unmarshalDatasetClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.SubResourceDebugResource)
}

// The Deflate compression method used on a dataset.
type DatasetDeflateCompression struct {
	DatasetCompression
	// The Deflate compression level.
	Level *DatasetCompressionLevel `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetDeflateCompression.
func (d DatasetDeflateCompression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("Deflate")
	if d.Level != nil {
		objectMap["level"] = d.Level
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetDeflateCompression.
func (d *DatasetDeflateCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			if val != nil {
				err = json.Unmarshal(*val, &d.Level)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.DatasetCompression)
}

// The folder that this Dataset is in. If not specified, Dataset will appear at the root level.
type DatasetFolder struct {
	// The name of the folder that this Dataset is in.
	Name *string `json:"name,omitempty"`
}

// The GZip compression method used on a dataset.
type DatasetGZipCompression struct {
	DatasetCompression
	// The GZip compression level.
	Level *DatasetCompressionLevel `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetGZipCompression.
func (d DatasetGZipCompression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("GZip")
	if d.Level != nil {
		objectMap["level"] = d.Level
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetGZipCompression.
func (d *DatasetGZipCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			if val != nil {
				err = json.Unmarshal(*val, &d.Level)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.DatasetCompression)
}

// DatasetGetDatasetOptions contains the optional parameters for the Dataset.GetDataset method.
type DatasetGetDatasetOptions struct {
	// ETag of the dataset entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// A list of dataset resources.
type DatasetListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of datasets.
	Value *[]DatasetResource `json:"value,omitempty"`
}

// DatasetListResponseResponse is the response envelope for operations that return a DatasetListResponse type.
type DatasetListResponseResponse struct {
	// A list of dataset resources.
	DatasetListResponse *DatasetListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetLocationClassification provides polymorphic access to related types.
type DatasetLocationClassification interface {
	GetDatasetLocation() *DatasetLocation
}

// Dataset location.
type DatasetLocation struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Specify the file name of dataset. Type: string (or Expression with resultType string).
	FileName *interface{} `json:"fileName,omitempty"`

	// Specify the folder path of dataset. Type: string (or Expression with resultType string)
	FolderPath *interface{} `json:"folderPath,omitempty"`

	// Type of dataset storage location.
	Type *string `json:"type,omitempty"`
}

// GetDatasetLocation implements the DatasetLocationClassification interface for type DatasetLocation.
func (d *DatasetLocation) GetDatasetLocation() *DatasetLocation { return d }

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetLocation.
func (d *DatasetLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileName":
			if val != nil {
				err = json.Unmarshal(*val, &d.FileName)
			}
		case "folderPath":
			if val != nil {
				err = json.Unmarshal(*val, &d.FolderPath)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &d.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (d DatasetLocation) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if d.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = d.AdditionalProperties
	}
	if d.FileName != nil {
		objectMap["fileName"] = d.FileName
	}
	if d.FolderPath != nil {
		objectMap["folderPath"] = d.FolderPath
	}
	d.Type = &discValue
	objectMap["type"] = d.Type
	return objectMap
}

// Dataset reference type.
type DatasetReference struct {
	// Arguments for dataset.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Reference dataset name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Dataset reference type.
	Type *string `json:"type,omitempty"`
}

// Dataset resource type.
type DatasetResource struct {
	SubResource
	// Dataset properties.
	Properties DatasetClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetResource.
func (d *DatasetResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				d.Properties, err = unmarshalDatasetClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.SubResource)
}

// DatasetResourceResponse is the response envelope for operations that return a DatasetResource type.
type DatasetResourceResponse struct {
	// Dataset resource type.
	DatasetResource *DatasetResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// The ZipDeflate compression method used on a dataset.
type DatasetZipDeflateCompression struct {
	DatasetCompression
	// The ZipDeflate compression level.
	Level *DatasetCompressionLevel `json:"level,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetZipDeflateCompression.
func (d DatasetZipDeflateCompression) MarshalJSON() ([]byte, error) {
	objectMap := d.DatasetCompression.marshalInternal("ZipDeflate")
	if d.Level != nil {
		objectMap["level"] = d.Level
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasetZipDeflateCompression.
func (d *DatasetZipDeflateCompression) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "level":
			if val != nil {
				err = json.Unmarshal(*val, &d.Level)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.DatasetCompression)
}

// Linked service for DB2 data source.
type Db2LinkedService struct {
	LinkedService
	// DB2 linked service properties.
	TypeProperties *Db2LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Db2LinkedService.
func (d Db2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("Db2")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedService.
func (d *Db2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.LinkedService)
}

// DB2 linked service properties.
type Db2LinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *string `json:"authenticationType,omitempty"`

	// Certificate Common Name when TLS is enabled. Type: string (or Expression with resultType string).
	CertificateCommonName *interface{} `json:"certificateCommonName,omitempty"`

	// Database name for connection. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Under where packages are created when querying database. Type: string (or Expression with resultType string).
	PackageCollection *interface{} `json:"packageCollection,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2LinkedServiceTypeProperties.
func (d *Db2LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &d.AuthenticationType)
			}
		case "certificateCommonName":
			if val != nil {
				err = json.Unmarshal(*val, &d.CertificateCommonName)
			}
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &d.Database)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
		case "packageCollection":
			if val != nil {
				err = json.Unmarshal(*val, &d.PackageCollection)
			}
		case "password":
			if val != nil {
				d.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &d.Server)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &d.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Db2 table dataset.
type Db2TableDataset struct {
	Dataset
	// Db2 table dataset properties.
	TypeProperties *Db2TableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Db2TableDataset.
func (d Db2TableDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("Db2Table")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Db2TableDataset.
func (d *Db2TableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// Db2 table dataset properties.
type Db2TableDatasetTypeProperties struct {
	// The Db2 schema name. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The Db2 table name. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Delete activity.
type DeleteActivity struct {
	ExecutionActivity
	// Delete activity properties.
	TypeProperties *DeleteActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeleteActivity.
func (d DeleteActivity) MarshalJSON() ([]byte, error) {
	objectMap := d.ExecutionActivity.marshalInternal("Delete")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteActivity.
func (d *DeleteActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.ExecutionActivity)
}

// Delete activity properties.
type DeleteActivityTypeProperties struct {
	// Delete activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Whether to record detailed logs of delete-activity execution. Default value is false. Type: boolean (or Expression with
	// resultType boolean).
	EnableLogging *interface{} `json:"enableLogging,omitempty"`

	// Log storage settings customer need to provide when enableLogging is true.
	LogStorageSettings *LogStorageSettings `json:"logStorageSettings,omitempty"`

	// The max concurrent connections to connect data source at the same time.
	MaxConcurrentConnections *int32 `json:"maxConcurrentConnections,omitempty"`

	// If true, files or sub-folders under current folder path will be deleted recursively. Default is false. Type: boolean (or
	// Expression with resultType boolean).
	Recursive *interface{} `json:"recursive,omitempty"`
}

// Request body structure for deleting data flow debug session.
type DeleteDataFlowDebugSessionRequest struct {
	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`
}

// Delimited text dataset.
type DelimitedTextDataset struct {
	Dataset
	// Delimited text dataset properties.
	TypeProperties *DelimitedTextDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DelimitedTextDataset.
func (d DelimitedTextDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DelimitedText")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDataset.
func (d *DelimitedTextDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// DelimitedText dataset properties.
type DelimitedTextDatasetTypeProperties struct {
	// The column delimiter. Type: string (or Expression with resultType string).
	ColumnDelimiter  *interface{}                   `json:"columnDelimiter,omitempty"`
	CompressionCodec *DelimitedTextCompressionCodec `json:"compressionCodec,omitempty"`

	// The data compression method used for DelimitedText.
	CompressionLevel *DatasetCompressionLevel `json:"compressionLevel,omitempty"`

	// The code page name of the preferred encoding. If miss, the default value is UTF-8, unless BOM denotes another Unicode encoding.
	// Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx.
	// Type: string (or Expression with resultType string).
	EncodingName *interface{} `json:"encodingName,omitempty"`

	// The escape character. Type: string (or Expression with resultType string).
	EscapeChar *interface{} `json:"escapeChar,omitempty"`

	// When used as input, treat the first row of data as headers. When used as output,write the headers into the output as the
	// first row of data. The default value is false. Type: boolean (or Expression with resultType boolean).
	FirstRowAsHeader *interface{} `json:"firstRowAsHeader,omitempty"`

	// The location of the delimited text storage.
	Location DatasetLocationClassification `json:"location,omitempty"`

	// The null value string. Type: string (or Expression with resultType string).
	NullValue *interface{} `json:"nullValue,omitempty"`

	// The quote character. Type: string (or Expression with resultType string).
	QuoteChar *interface{} `json:"quoteChar,omitempty"`

	// The row delimiter. Type: string (or Expression with resultType string).
	RowDelimiter *interface{} `json:"rowDelimiter,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelimitedTextDatasetTypeProperties.
func (d *DelimitedTextDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "columnDelimiter":
			if val != nil {
				err = json.Unmarshal(*val, &d.ColumnDelimiter)
			}
		case "compressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &d.CompressionCodec)
			}
		case "compressionLevel":
			if val != nil {
				err = json.Unmarshal(*val, &d.CompressionLevel)
			}
		case "encodingName":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncodingName)
			}
		case "escapeChar":
			if val != nil {
				err = json.Unmarshal(*val, &d.EscapeChar)
			}
		case "firstRowAsHeader":
			if val != nil {
				err = json.Unmarshal(*val, &d.FirstRowAsHeader)
			}
		case "location":
			if val != nil {
				d.Location, err = unmarshalDatasetLocationClassification(*val)
			}
		case "nullValue":
			if val != nil {
				err = json.Unmarshal(*val, &d.NullValue)
			}
		case "quoteChar":
			if val != nil {
				err = json.Unmarshal(*val, &d.QuoteChar)
			}
		case "rowDelimiter":
			if val != nil {
				err = json.Unmarshal(*val, &d.RowDelimiter)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Microsoft Azure Document Database Collection dataset.
type DocumentDbCollectionDataset struct {
	Dataset
	// DocumentDB Collection dataset properties.
	TypeProperties *DocumentDbCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DocumentDbCollectionDataset.
func (d DocumentDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DocumentDbCollection")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DocumentDbCollectionDataset.
func (d *DocumentDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// DocumentDB Collection dataset properties.
type DocumentDbCollectionDatasetTypeProperties struct {
	// Document Database collection name. Type: string (or Expression with resultType string).
	CollectionName *interface{} `json:"collectionName,omitempty"`
}

// Drill Dataset Properties
type DrillDatasetTypeProperties struct {
	// The schema name of the Drill. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Drill. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Drill server linked service.
type DrillLinkedService struct {
	LinkedService
	// Drill server linked service properties.
	TypeProperties *DrillLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DrillLinkedService.
func (d DrillLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("Drill")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillLinkedService.
func (d *DrillLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.LinkedService)
}

// Drill server linked service properties.
type DrillLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// Drill server dataset.
type DrillTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *DrillDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DrillTableDataset.
func (d DrillTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DrillTable")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DrillTableDataset.
func (d *DrillTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// Dynamics AX linked service.
type DynamicsAxLinkedService struct {
	LinkedService
	// Dynamics AX linked service properties.
	TypeProperties *DynamicsAxLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAxLinkedService.
func (d DynamicsAxLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("DynamicsAX")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxLinkedService.
func (d *DynamicsAxLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.LinkedService)
}

// Dynamics AX linked service properties.
type DynamicsAxLinkedServiceTypeProperties struct {
	// Specify the resource you are requesting authorization. Type: string (or Expression with resultType string).
	AadResourceID *interface{} `json:"aadResourceId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specify the application's client ID. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the application's key. Mark this field as a SecureString to store it securely in Data Factory, or reference a secret
	// stored in Azure Key Vault. Type: string (or Expression with resultType string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information (domain name or tenant ID) under which your application resides. Retrieve it by hovering
	// the mouse in the top-right corner of the Azure portal. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData endpoint.
	URL *interface{} `json:"url,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxLinkedServiceTypeProperties.
func (d *DynamicsAxLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			if val != nil {
				err = json.Unmarshal(*val, &d.AadResourceID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				d.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &d.Tenant)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &d.URL)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The path of the Dynamics AX OData entity.
type DynamicsAxResourceDataset struct {
	Dataset
	// Dynamics AX OData resource dataset properties.
	TypeProperties *DynamicsAxResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsAxResourceDataset.
func (d DynamicsAxResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DynamicsAXResource")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsAxResourceDataset.
func (d *DynamicsAxResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// Dynamics AX OData resource dataset properties.
type DynamicsAxResourceDatasetTypeProperties struct {
	// The path of the Dynamics AX OData entity. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// The Dynamics CRM entity dataset.
type DynamicsCrmEntityDataset struct {
	Dataset
	// Dynamics CRM entity dataset properties.
	TypeProperties *DynamicsCrmEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmEntityDataset.
func (d DynamicsCrmEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DynamicsCrmEntity")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmEntityDataset.
func (d *DynamicsCrmEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// Dynamics CRM entity dataset properties.
type DynamicsCrmEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName *interface{} `json:"entityName,omitempty"`
}

// Dynamics CRM linked service.
type DynamicsCrmLinkedService struct {
	LinkedService
	// Dynamics CRM linked service properties.
	TypeProperties *DynamicsCrmLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsCrmLinkedService.
func (d DynamicsCrmLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("DynamicsCrm")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedService.
func (d *DynamicsCrmLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.LinkedService)
}

// Dynamics CRM linked service properties.
type DynamicsCrmLinkedServiceTypeProperties struct {
	// The authentication type to connect to Dynamics CRM server. 'Office365' for online scenario, 'Ifd' for on-premises with
	// Ifd scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression
	// with resultType string).
	AuthenticationType *DynamicsAuthenticationType `json:"authenticationType,omitempty"`

	// The deployment type of the Dynamics CRM instance. 'Online' for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics
	// CRM on-premises with Ifd. Type: string (or Expression with resultType string).
	DeploymentType *DynamicsDeploymentType `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online.
	// Type: string (or Expression with resultType string).
	HostName *interface{} `json:"hostName,omitempty"`

	// The organization name of the Dynamics CRM instance. The property is required for on-prem and required for online when there
	// are more than one Dynamics CRM instances associated with the user. Type: string (or Expression with resultType string).
	OrganizationName *interface{} `json:"organizationName,omitempty"`

	// Password to access the Dynamics CRM instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Dynamics CRM server. The property is required for on-prem and not allowed for online. Default is
	// 443. Type: integer (or Expression with resultType integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert',
	// servicePrincipalCredential can only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
	ServicePrincipalCredentialType *DynamicsServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Dynamics CRM server. The property is required for on-line and not allowed for on-prem. Type: string
	// (or Expression with resultType string).
	ServiceURI *interface{} `json:"serviceUri,omitempty"`

	// User name to access the Dynamics CRM instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsCrmLinkedServiceTypeProperties.
func (d *DynamicsCrmLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &d.AuthenticationType)
			}
		case "deploymentType":
			if val != nil {
				err = json.Unmarshal(*val, &d.DeploymentType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
		case "hostName":
			if val != nil {
				err = json.Unmarshal(*val, &d.HostName)
			}
		case "organizationName":
			if val != nil {
				err = json.Unmarshal(*val, &d.OrganizationName)
			}
		case "password":
			if val != nil {
				d.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &d.Port)
			}
		case "servicePrincipalCredential":
			if val != nil {
				d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalCredentialType)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalID)
			}
		case "serviceUri":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServiceURI)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &d.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Dynamics entity dataset.
type DynamicsEntityDataset struct {
	Dataset
	// Dynamics entity dataset properties.
	TypeProperties *DynamicsEntityDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsEntityDataset.
func (d DynamicsEntityDataset) MarshalJSON() ([]byte, error) {
	objectMap := d.Dataset.marshalInternal("DynamicsEntity")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsEntityDataset.
func (d *DynamicsEntityDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.Dataset)
}

// Dynamics entity dataset properties.
type DynamicsEntityDatasetTypeProperties struct {
	// The logical name of the entity. Type: string (or Expression with resultType string).
	EntityName *interface{} `json:"entityName,omitempty"`
}

// Dynamics linked service.
type DynamicsLinkedService struct {
	LinkedService
	// Dynamics linked service properties.
	TypeProperties *DynamicsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DynamicsLinkedService.
func (d DynamicsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := d.LinkedService.marshalInternal("Dynamics")
	if d.TypeProperties != nil {
		objectMap["typeProperties"] = d.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedService.
func (d *DynamicsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &d.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &d.LinkedService)
}

// Dynamics linked service properties.
type DynamicsLinkedServiceTypeProperties struct {
	// The authentication type to connect to Dynamics server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd
	// scenario, 'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or Expression with
	// resultType string).
	AuthenticationType *DynamicsAuthenticationType `json:"authenticationType,omitempty"`

	// The deployment type of the Dynamics instance. 'Online' for Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises
	// with Ifd. Type: string (or Expression with resultType string).
	DeploymentType *DynamicsDeploymentType `json:"deploymentType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The host name of the on-premises Dynamics server. The property is required for on-prem and not allowed for online. Type:
	// string (or Expression with resultType string).
	HostName *string `json:"hostName,omitempty"`

	// The organization name of the Dynamics instance. The property is required for on-prem and required for online when there
	// are more than one Dynamics instances associated with the user. Type: string (or Expression with resultType string).
	OrganizationName *string `json:"organizationName,omitempty"`

	// Password to access the Dynamics instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The port of on-premises Dynamics server. The property is required for on-prem and not allowed for online. Default is 443.
	// Type: integer (or Expression with resultType integer), minimum: 0.
	Port *string `json:"port,omitempty"`

	// The credential of the service principal object in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
	// servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert',
	// servicePrincipalCredential can only be AzureKeyVaultSecretReference.
	ServicePrincipalCredential SecretBaseClassification `json:"servicePrincipalCredential,omitempty"`

	// The service principal credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
	// 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
	ServicePrincipalCredentialType *DynamicsServicePrincipalCredentialType `json:"servicePrincipalCredentialType,omitempty"`

	// The client ID of the application in Azure Active Directory used for Server-To-Server authentication. Type: string (or Expression
	// with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The URL to the Microsoft Dynamics server. The property is required for on-line and not allowed for on-prem. Type: string
	// (or Expression with resultType string).
	ServiceURI *string `json:"serviceUri,omitempty"`

	// User name to access the Dynamics instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DynamicsLinkedServiceTypeProperties.
func (d *DynamicsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &d.AuthenticationType)
			}
		case "deploymentType":
			if val != nil {
				err = json.Unmarshal(*val, &d.DeploymentType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &d.EncryptedCredential)
			}
		case "hostName":
			if val != nil {
				err = json.Unmarshal(*val, &d.HostName)
			}
		case "organizationName":
			if val != nil {
				err = json.Unmarshal(*val, &d.OrganizationName)
			}
		case "password":
			if val != nil {
				d.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &d.Port)
			}
		case "servicePrincipalCredential":
			if val != nil {
				d.ServicePrincipalCredential, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalCredentialType)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServicePrincipalID)
			}
		case "serviceUri":
			if val != nil {
				err = json.Unmarshal(*val, &d.ServiceURI)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &d.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Eloqua server linked service.
type EloquaLinkedService struct {
	LinkedService
	// Eloqua server linked service properties.
	TypeProperties *EloquaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EloquaLinkedService.
func (e EloquaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := e.LinkedService.marshalInternal("Eloqua")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedService.
func (e *EloquaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &e.LinkedService)
}

// Eloqua server linked service properties.
type EloquaLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Eloqua server. (i.e. eloqua.example.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The site name and user name of your Eloqua account in the form: sitename/username. (i.e. Eloqua/Alice)
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaLinkedServiceTypeProperties.
func (e *EloquaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &e.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &e.Endpoint)
			}
		case "password":
			if val != nil {
				e.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &e.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &e.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &e.UsePeerVerification)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &e.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Eloqua server dataset.
type EloquaObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EloquaObjectDataset.
func (e EloquaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := e.Dataset.marshalInternal("EloquaObject")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EloquaObjectDataset.
func (e *EloquaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &e.Dataset)
}

// Request body structure for data flow expression preview.
type EvaluateDataFlowExpressionRequest struct {
	// The data flow which contains the debug session.
	DataFlowName *string `json:"dataFlowName,omitempty"`

	// The expression for preview.
	Expression *string `json:"expression,omitempty"`

	// The row limit for preview request.
	RowLimits *int32 `json:"rowLimits,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// The output stream name.
	StreamName *string `json:"streamName,omitempty"`
}

// Execute data flow activity.
type ExecuteDataFlowActivity struct {
	ExecutionActivity
	// Execute data flow activity properties.
	TypeProperties *ExecuteDataFlowActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteDataFlowActivity.
func (e ExecuteDataFlowActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.ExecutionActivity.marshalInternal("ExecuteDataFlow")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteDataFlowActivity.
func (e *ExecuteDataFlowActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &e.ExecutionActivity)
}

// Execute data flow activity properties.
type ExecuteDataFlowActivityTypeProperties struct {
	// Compute properties for data flow activity.
	Compute *ExecuteDataFlowActivityTypePropertiesCompute `json:"compute,omitempty"`

	// Data flow reference.
	DataFlow *DataFlowReference `json:"dataFlow,omitempty"`

	// The integration runtime reference.
	IntegrationRuntime *IntegrationRuntimeReference `json:"integrationRuntime,omitempty"`

	// Staging info for execute data flow activity.
	Staging *DataFlowStagingInfo `json:"staging,omitempty"`
}

// Compute properties for data flow activity.
type ExecuteDataFlowActivityTypePropertiesCompute struct {
	// Compute type of the cluster which will execute data flow job.
	ComputeType *DataFlowComputeType `json:"computeType,omitempty"`

	// Core count of the cluster which will execute data flow job. Supported values are: 8, 16, 32, 48, 80, 144 and 272.
	CoreCount *int32 `json:"coreCount,omitempty"`
}

// Execute pipeline activity.
type ExecutePipelineActivity struct {
	Activity
	// Execute pipeline activity properties.
	TypeProperties *ExecutePipelineActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecutePipelineActivity.
func (e ExecutePipelineActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.Activity.marshalInternal("ExecutePipeline")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutePipelineActivity.
func (e *ExecutePipelineActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &e.Activity)
}

// Execute pipeline activity properties.
type ExecutePipelineActivityTypeProperties struct {
	// Pipeline parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Pipeline reference.
	Pipeline *PipelineReference `json:"pipeline,omitempty"`

	// Defines whether activity execution will wait for the dependent pipeline execution to finish. Default is false.
	WaitOnCompletion *bool `json:"waitOnCompletion,omitempty"`
}

// Execute SSIS package activity.
type ExecuteSsisPackageActivity struct {
	ExecutionActivity
	// Execute SSIS package activity properties.
	TypeProperties *ExecuteSsisPackageActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecuteSsisPackageActivity.
func (e ExecuteSsisPackageActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.ExecutionActivity.marshalInternal("ExecuteSSISPackage")
	if e.TypeProperties != nil {
		objectMap["typeProperties"] = e.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecuteSsisPackageActivity.
func (e *ExecuteSsisPackageActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &e.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &e.ExecutionActivity)
}

// Execute SSIS package activity properties.
type ExecuteSsisPackageActivityTypeProperties struct {
	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// The environment path to execute the SSIS package. Type: string (or Expression with resultType string).
	EnvironmentPath *interface{} `json:"environmentPath,omitempty"`

	// The package execution credential.
	ExecutionCredential *SsisExecutionCredential `json:"executionCredential,omitempty"`

	// SSIS package execution log location.
	LogLocation *SsisLogLocation `json:"logLocation,omitempty"`

	// The logging level of SSIS package execution. Type: string (or Expression with resultType string).
	LoggingLevel *interface{} `json:"loggingLevel,omitempty"`

	// The package level connection managers to execute the SSIS package.
	PackageConnectionManagers *map[string]interface{} `json:"packageConnectionManagers,omitempty"`

	// SSIS package location.
	PackageLocation *SsisPackageLocation `json:"packageLocation,omitempty"`

	// The package level parameters to execute the SSIS package.
	PackageParameters *map[string]SsisExecutionParameter `json:"packageParameters,omitempty"`

	// The project level connection managers to execute the SSIS package.
	ProjectConnectionManagers *map[string]interface{} `json:"projectConnectionManagers,omitempty"`

	// The project level parameters to execute the SSIS package.
	ProjectParameters *map[string]SsisExecutionParameter `json:"projectParameters,omitempty"`

	// The property overrides to execute the SSIS package.
	PropertyOverrides *map[string]SsisPropertyOverride `json:"propertyOverrides,omitempty"`

	// Specifies the runtime to execute SSIS package. The value should be "x86" or "x64". Type: string (or Expression with resultType
	// string).
	Runtime *interface{} `json:"runtime,omitempty"`
}

// ExecutionActivityClassification provides polymorphic access to related types.
type ExecutionActivityClassification interface {
	ActivityClassification
	GetExecutionActivity() *ExecutionActivity
}

// Base class for all execution activities.
type ExecutionActivity struct {
	Activity
	// Linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Activity policy.
	Policy *ActivityPolicy `json:"policy,omitempty"`
}

// GetExecutionActivity implements the ExecutionActivityClassification interface for type ExecutionActivity.
func (e *ExecutionActivity) GetExecutionActivity() *ExecutionActivity { return e }

// MarshalJSON implements the json.Marshaller interface for type ExecutionActivity.
func (e ExecutionActivity) MarshalJSON() ([]byte, error) {
	objectMap := e.Activity.marshalInternal("Execution")
	if e.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = e.LinkedServiceName
	}
	if e.Policy != nil {
		objectMap["policy"] = e.Policy
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecutionActivity.
func (e *ExecutionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &e.LinkedServiceName)
			}
		case "policy":
			if val != nil {
				err = json.Unmarshal(*val, &e.Policy)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &e.Activity)
}

func (e ExecutionActivity) marshalInternal(discValue string) map[string]interface{} {
	objectMap := e.Activity.marshalInternal(discValue)
	if e.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = e.LinkedServiceName
	}
	if e.Policy != nil {
		objectMap["policy"] = e.Policy
	}
	return objectMap
}

// The exposure control request.
type ExposureControlRequest struct {
	// The feature name.
	FeatureName *string `json:"featureName,omitempty"`

	// The feature type.
	FeatureType *string `json:"featureType,omitempty"`
}

// The exposure control response.
type ExposureControlResponse struct {
	// The feature name.
	FeatureName *string `json:"featureName,omitempty" azure:"ro"`

	// The feature value.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// Azure Synapse expression definition.
type Expression struct {
	// Expression type.
	Type *string `json:"type,omitempty"`

	// Expression value.
	Value *string `json:"value,omitempty"`
}

// File system linked service.
type FileServerLinkedService struct {
	LinkedService
	// File system linked service properties.
	TypeProperties *FileServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileServerLinkedService.
func (f FileServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := f.LinkedService.marshalInternal("FileServer")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedService.
func (f *FileServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &f.LinkedService)
}

// File system linked service properties.
type FileServerLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name of the server. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password to logon the server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User ID to logon the server. Type: string (or Expression with resultType string).
	UserID *interface{} `json:"userId,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileServerLinkedServiceTypeProperties.
func (f *FileServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &f.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &f.Host)
			}
		case "password":
			if val != nil {
				f.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userId":
			if val != nil {
				err = json.Unmarshal(*val, &f.UserID)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Filter and return results from input array based on the conditions.
type FilterActivity struct {
	Activity
	// Filter activity properties.
	TypeProperties *FilterActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FilterActivity.
func (f FilterActivity) MarshalJSON() ([]byte, error) {
	objectMap := f.Activity.marshalInternal("Filter")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FilterActivity.
func (f *FilterActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &f.Activity)
}

// Filter activity properties.
type FilterActivityTypeProperties struct {
	// Condition to be used for filtering the input.
	Condition *Expression `json:"condition,omitempty"`

	// Input array on which filter should be applied.
	Items *Expression `json:"items,omitempty"`
}

// This activity is used for iterating over a collection and execute given activities.
type ForEachActivity struct {
	Activity
	// ForEach activity properties.
	TypeProperties *ForEachActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ForEachActivity.
func (f ForEachActivity) MarshalJSON() ([]byte, error) {
	objectMap := f.Activity.marshalInternal("ForEach")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivity.
func (f *ForEachActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &f.Activity)
}

// ForEach activity properties.
type ForEachActivityTypeProperties struct {
	// List of activities to execute .
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// Batch count to be used for controlling the number of parallel execution (when isSequential is set to false).
	BatchCount *int32 `json:"batchCount,omitempty"`

	// Should the loop be executed in sequence or in parallel (max 50)
	IsSequential *bool `json:"isSequential,omitempty"`

	// Collection to iterate.
	Items *Expression `json:"items,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ForEachActivityTypeProperties.
func (f *ForEachActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				f.Activities, err = unmarshalActivityClassificationArray(*val)
			}
		case "batchCount":
			if val != nil {
				err = json.Unmarshal(*val, &f.BatchCount)
			}
		case "isSequential":
			if val != nil {
				err = json.Unmarshal(*val, &f.IsSequential)
			}
		case "items":
			if val != nil {
				err = json.Unmarshal(*val, &f.Items)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A FTP server Linked Service.
type FtpServerLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *FtpServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FtpServerLinkedService.
func (f FtpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := f.LinkedService.marshalInternal("FtpServer")
	if f.TypeProperties != nil {
		objectMap["typeProperties"] = f.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedService.
func (f *FtpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &f.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &f.LinkedService)
}

// Properties specific to this linked service type.
type FtpServerLinkedServiceTypeProperties struct {
	// The authentication type to be used to connect to the FTP server.
	AuthenticationType *FtpAuthenticationType `json:"authenticationType,omitempty"`

	// If true, validate the FTP server SSL certificate when connect over SSL/TLS channel. Default value is true. Type: boolean
	// (or Expression with resultType boolean).
	EnableServerCertificateValidation *interface{} `json:"enableServerCertificateValidation,omitempty"`

	// If true, connect to the FTP server over SSL/TLS channel. Default value is true. Type: boolean (or Expression with resultType
	// boolean).
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Host name of the FTP server. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// Password to logon the FTP server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the FTP server uses to listen for client connections. Default value is 21. Type: integer (or Expression
	// with resultType integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// Username to logon the FTP server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FtpServerLinkedServiceTypeProperties.
func (f *FtpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &f.AuthenticationType)
			}
		case "enableServerCertificateValidation":
			if val != nil {
				err = json.Unmarshal(*val, &f.EnableServerCertificateValidation)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &f.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &f.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &f.Host)
			}
		case "password":
			if val != nil {
				f.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &f.Port)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &f.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Properties specific to this dataset type.
type GenericDatasetTypeProperties struct {
	// The table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Activity to get metadata of dataset
type GetMetadataActivity struct {
	ExecutionActivity
	// GetMetadata activity properties.
	TypeProperties *GetMetadataActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetMetadataActivity.
func (g GetMetadataActivity) MarshalJSON() ([]byte, error) {
	objectMap := g.ExecutionActivity.marshalInternal("GetMetadata")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetMetadataActivity.
func (g *GetMetadataActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.ExecutionActivity)
}

// GetMetadata activity properties.
type GetMetadataActivityTypeProperties struct {
	// GetMetadata activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Fields of metadata to get from dataset.
	FieldList *[]interface{} `json:"fieldList,omitempty"`
}

// The request payload of get SSIS object metadata.
type GetSsisObjectMetadataRequest struct {
	// Metadata path.
	MetadataPath *string `json:"metadataPath,omitempty"`
}

// Google AdWords service linked service.
type GoogleAdWordsLinkedService struct {
	LinkedService
	// Google AdWords service linked service properties.
	TypeProperties *GoogleAdWordsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsLinkedService.
func (g GoogleAdWordsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("GoogleAdWords")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedService.
func (g *GoogleAdWordsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.LinkedService)
}

// Google AdWords service linked service properties.
type GoogleAdWordsLinkedServiceTypeProperties struct {
	// The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
	AuthenticationType *GoogleAdWordsAuthenticationType `json:"authenticationType,omitempty"`

	// The Client customer ID of the AdWords account that you want to fetch report data for.
	ClientCustomerID *interface{} `json:"clientCustomerID,omitempty"`

	// The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType
	// string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret of the google application used to acquire the refresh token.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The developer token associated with the manager account that you use to grant access to the AdWords API.
	DeveloperToken SecretBaseClassification `json:"developerToken,omitempty"`

	// The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
	Email *interface{} `json:"email,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The full path to the .p12 key file that is used to authenticate the service account email address and can only be used
	// on self-hosted IR.
	KeyFilePath *interface{} `json:"keyFilePath,omitempty"`

	// The refresh token obtained from Google for authorizing access to AdWords for UserAuthentication.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsLinkedServiceTypeProperties.
func (g *GoogleAdWordsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &g.AuthenticationType)
			}
		case "clientCustomerID":
			if val != nil {
				err = json.Unmarshal(*val, &g.ClientCustomerID)
			}
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &g.ClientID)
			}
		case "clientSecret":
			if val != nil {
				g.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "developerToken":
			if val != nil {
				g.DeveloperToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "email":
			if val != nil {
				err = json.Unmarshal(*val, &g.Email)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &g.EncryptedCredential)
			}
		case "keyFilePath":
			if val != nil {
				err = json.Unmarshal(*val, &g.KeyFilePath)
			}
		case "refreshToken":
			if val != nil {
				g.RefreshToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &g.TrustedCertPath)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &g.UseSystemTrustStore)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Google AdWords service dataset.
type GoogleAdWordsObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleAdWordsObjectDataset.
func (g GoogleAdWordsObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := g.Dataset.marshalInternal("GoogleAdWordsObject")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleAdWordsObjectDataset.
func (g *GoogleAdWordsObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.Dataset)
}

// Google BigQuery Dataset Properties
type GoogleBigQueryDatasetTypeProperties struct {
	// The database name of the Google BigQuery. Type: string (or Expression with resultType string).
	Dataset *interface{} `json:"dataset,omitempty"`

	// The table name of the Google BigQuery. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using database + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Google BigQuery service linked service.
type GoogleBigQueryLinkedService struct {
	LinkedService
	// Google BigQuery service linked service properties.
	TypeProperties *GoogleBigQueryLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryLinkedService.
func (g GoogleBigQueryLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("GoogleBigQuery")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedService.
func (g *GoogleBigQueryLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.LinkedService)
}

// Google BigQuery service linked service properties.
type GoogleBigQueryLinkedServiceTypeProperties struct {
	// A comma-separated list of public BigQuery projects to access.
	AdditionalProjects *interface{} `json:"additionalProjects,omitempty"`

	// The OAuth 2.0 authentication mechanism used for authentication. ServiceAuthentication can only be used on self-hosted IR.
	AuthenticationType *GoogleBigQueryAuthenticationType `json:"authenticationType,omitempty"`

	// The client id of the google application used to acquire the refresh token. Type: string (or Expression with resultType
	// string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret of the google application used to acquire the refresh token.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The service account email ID that is used for ServiceAuthentication and can only be used on self-hosted IR.
	Email *interface{} `json:"email,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The full path to the .p12 key file that is used to authenticate the service account email address and can only be used
	// on self-hosted IR.
	KeyFilePath *interface{} `json:"keyFilePath,omitempty"`

	// The default BigQuery project to query against.
	Project *interface{} `json:"project,omitempty"`

	// The refresh token obtained from Google for authorizing access to BigQuery for UserAuthentication.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// Whether to request access to Google Drive. Allowing Google Drive access enables support for federated tables that combine
	// BigQuery data with data from Google Drive. The default value is false.
	RequestGoogleDriveScope *interface{} `json:"requestGoogleDriveScope,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryLinkedServiceTypeProperties.
func (g *GoogleBigQueryLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProjects":
			if val != nil {
				err = json.Unmarshal(*val, &g.AdditionalProjects)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &g.AuthenticationType)
			}
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &g.ClientID)
			}
		case "clientSecret":
			if val != nil {
				g.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "email":
			if val != nil {
				err = json.Unmarshal(*val, &g.Email)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &g.EncryptedCredential)
			}
		case "keyFilePath":
			if val != nil {
				err = json.Unmarshal(*val, &g.KeyFilePath)
			}
		case "project":
			if val != nil {
				err = json.Unmarshal(*val, &g.Project)
			}
		case "refreshToken":
			if val != nil {
				g.RefreshToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "requestGoogleDriveScope":
			if val != nil {
				err = json.Unmarshal(*val, &g.RequestGoogleDriveScope)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &g.TrustedCertPath)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &g.UseSystemTrustStore)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Google BigQuery service dataset.
type GoogleBigQueryObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GoogleBigQueryDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleBigQueryObjectDataset.
func (g GoogleBigQueryObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := g.Dataset.marshalInternal("GoogleBigQueryObject")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleBigQueryObjectDataset.
func (g *GoogleBigQueryObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.Dataset)
}

// Linked service for Google Cloud Storage.
type GoogleCloudStorageLinkedService struct {
	LinkedService
	// Google Cloud Storage linked service properties.
	TypeProperties *GoogleCloudStorageLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GoogleCloudStorageLinkedService.
func (g GoogleCloudStorageLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("GoogleCloudStorage")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedService.
func (g *GoogleCloudStorageLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.LinkedService)
}

// Google Cloud Storage linked service properties.
type GoogleCloudStorageLinkedServiceTypeProperties struct {
	// The access key identifier of the Google Cloud Storage Identity and Access Management (IAM) user. Type: string (or Expression
	// with resultType string).
	AccessKeyID *interface{} `json:"accessKeyId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The secret access key of the Google Cloud Storage Identity and Access Management (IAM) user.
	SecretAccessKey SecretBaseClassification `json:"secretAccessKey,omitempty"`

	// This value specifies the endpoint to access with the Google Cloud Storage Connector. This is an optional property; change
	// it only if you want to try a different service endpoint or want to switch between https and http. Type: string (or Expression
	// with resultType string).
	ServiceURL *interface{} `json:"serviceUrl,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GoogleCloudStorageLinkedServiceTypeProperties.
func (g *GoogleCloudStorageLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessKeyId":
			if val != nil {
				err = json.Unmarshal(*val, &g.AccessKeyID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &g.EncryptedCredential)
			}
		case "secretAccessKey":
			if val != nil {
				g.SecretAccessKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "serviceUrl":
			if val != nil {
				err = json.Unmarshal(*val, &g.ServiceURL)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Greenplum Dataset Properties
type GreenplumDatasetTypeProperties struct {
	// The schema name of Greenplum. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of Greenplum. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Greenplum Database linked service.
type GreenplumLinkedService struct {
	LinkedService
	// Greenplum Database linked service properties.
	TypeProperties *GreenplumLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumLinkedService.
func (g GreenplumLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := g.LinkedService.marshalInternal("Greenplum")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumLinkedService.
func (g *GreenplumLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.LinkedService)
}

// Greenplum Database linked service properties.
type GreenplumLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// Greenplum Database dataset.
type GreenplumTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GreenplumDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GreenplumTableDataset.
func (g GreenplumTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := g.Dataset.marshalInternal("GreenplumTable")
	if g.TypeProperties != nil {
		objectMap["typeProperties"] = g.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GreenplumTableDataset.
func (g *GreenplumTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &g.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &g.Dataset)
}

// HBase server linked service.
type HBaseLinkedService struct {
	LinkedService
	// HBase server linked service properties.
	TypeProperties *HBaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HBaseLinkedService.
func (h HBaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HBase")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedService.
func (h *HBaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// HBase server linked service properties.
type HBaseLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication mechanism to use to connect to the HBase server.
	AuthenticationType *HBaseAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the HBase server. (i.e. /gateway/sandbox/hbase/version)
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// The IP address or host name of the HBase server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the HBase instance uses to listen for client connections. The default value is 9090.
	Port *interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// The user name used to connect to the HBase instance.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseLinkedServiceTypeProperties.
func (h *HBaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowHostNameCnMismatch)
			}
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowSelfSignedServerCert)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.HTTPPath)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &h.Host)
			}
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &h.Port)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.TrustedCertPath)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &h.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HBase server dataset.
type HBaseObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HBaseObjectDataset.
func (h HBaseObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := h.Dataset.marshalInternal("HBaseObject")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HBaseObjectDataset.
func (h *HBaseObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.Dataset)
}

// Linked service for an HTTP source.
type HTTPLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *HTTPLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HTTPLinkedService.
func (h HTTPLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HttpServer")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedService.
func (h *HTTPLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// Properties specific to this linked service type.
type HTTPLinkedServiceTypeProperties struct {
	// The authentication type to be used to connect to the HTTP server.
	AuthenticationType *HttpAuthenticationType `json:"authenticationType,omitempty"`

	// Thumbprint of certificate for ClientCertificate authentication. Only valid for on-premises copy. For on-premises copy with
	// ClientCertificate authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string
	// (or Expression with resultType string).
	CertThumbprint *interface{} `json:"certThumbprint,omitempty"`

	// Base64 encoded certificate data for ClientCertificate authentication. For on-premises copy with ClientCertificate authentication,
	// either CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression with resultType string).
	EmbeddedCertData *interface{} `json:"embeddedCertData,omitempty"`

	// If true, validate the HTTPS server SSL certificate. Default value is true. Type: boolean (or Expression with resultType
	// boolean).
	EnableServerCertificateValidation *interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic, Digest, Windows, or ClientCertificate with EmbeddedCertData authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`

	// User name for Basic, Digest, or Windows authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPLinkedServiceTypeProperties.
func (h *HTTPLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
		case "certThumbprint":
			if val != nil {
				err = json.Unmarshal(*val, &h.CertThumbprint)
			}
		case "embeddedCertData":
			if val != nil {
				err = json.Unmarshal(*val, &h.EmbeddedCertData)
			}
		case "enableServerCertificateValidation":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnableServerCertificateValidation)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &h.URL)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &h.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HTTPPollerResponse contains the asynchronous HTTP response from the call to the service endpoint.
type HTTPPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*http.Response, error)

	// Poller contains an initialized poller.
	Poller HTTPPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// HDInsight Hive activity type.
type HdInsightHiveActivity struct {
	ExecutionActivity
	// HDInsight Hive activity properties.
	TypeProperties *HdInsightHiveActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightHiveActivity.
func (h HdInsightHiveActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightHive")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightHiveActivity.
func (h *HdInsightHiveActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.ExecutionActivity)
}

// HDInsight Hive activity properties.
type HdInsightHiveActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for Hive job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Query timeout value (in minutes). Effective when the HDInsight cluster is with ESP (Enterprise Security Package)
	QueryTimeout *int32 `json:"queryTimeout,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Script path. Type: string (or Expression with resultType string).
	ScriptPath *interface{} `json:"scriptPath,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`

	// User specified arguments under hivevar namespace.
	Variables *[]interface{} `json:"variables,omitempty"`
}

// HDInsight linked service.
type HdInsightLinkedService struct {
	LinkedService
	// HDInsight linked service properties.
	TypeProperties *HdInsightLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightLinkedService.
func (h HdInsightLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HDInsight")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightLinkedService.
func (h *HdInsightLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// HDInsight linked service properties.
type HdInsightLinkedServiceTypeProperties struct {
	// HDInsight cluster URI. Type: string (or Expression with resultType string).
	ClusterURI *interface{} `json:"clusterUri,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specify the FileSystem if the main storage for the HDInsight is ADLS Gen2. Type: string (or Expression with resultType
	// string).
	FileSystem *interface{} `json:"fileSystem,omitempty"`

	// A reference to the Azure SQL linked service that points to the HCatalog database.
	HcatalogLinkedServiceName *LinkedServiceReference `json:"hcatalogLinkedServiceName,omitempty"`

	// Specify if the HDInsight is created with ESP (Enterprise Security Package). Type: Boolean.
	IsEspEnabled *interface{} `json:"isEspEnabled,omitempty"`

	// The Azure Storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// HDInsight cluster password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// HDInsight cluster user name. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightLinkedServiceTypeProperties.
func (h *HdInsightLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterUri":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterURI)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "fileSystem":
			if val != nil {
				err = json.Unmarshal(*val, &h.FileSystem)
			}
		case "hcatalogLinkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &h.HcatalogLinkedServiceName)
			}
		case "isEspEnabled":
			if val != nil {
				err = json.Unmarshal(*val, &h.IsEspEnabled)
			}
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &h.LinkedServiceName)
			}
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &h.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsight MapReduce activity type.
type HdInsightMapReduceActivity struct {
	ExecutionActivity
	// HDInsight MapReduce activity properties.
	TypeProperties *HdInsightMapReduceActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightMapReduceActivity.
func (h HdInsightMapReduceActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightMapReduce")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightMapReduceActivity.
func (h *HdInsightMapReduceActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.ExecutionActivity)
}

// HDInsight MapReduce activity properties.
type HdInsightMapReduceActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// Class name. Type: string (or Expression with resultType string).
	ClassName *interface{} `json:"className,omitempty"`

	// Allows user to specify defines for the MapReduce job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Jar path. Type: string (or Expression with resultType string).
	JarFilePath *interface{} `json:"jarFilePath,omitempty"`

	// Jar libs.
	JarLibs *[]interface{} `json:"jarLibs,omitempty"`

	// Jar linked service reference.
	JarLinkedService *LinkedServiceReference `json:"jarLinkedService,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// HDInsight ondemand linked service.
type HdInsightOnDemandLinkedService struct {
	LinkedService
	// HDInsight ondemand linked service properties.
	TypeProperties *HdInsightOnDemandLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightOnDemandLinkedService.
func (h HdInsightOnDemandLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("HDInsightOnDemand")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightOnDemandLinkedService.
func (h *HdInsightOnDemandLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// HDInsight ondemand linked service properties.
type HdInsightOnDemandLinkedServiceTypeProperties struct {
	// Specifies additional storage accounts for the HDInsight linked service so that the Data Factory service can register them
	// on your behalf.
	AdditionalLinkedServiceNames *[]LinkedServiceReference `json:"additionalLinkedServiceNames,omitempty"`

	// The prefix of cluster name, postfix will be distinct with timestamp. Type: string (or Expression with resultType string).
	ClusterNamePrefix *interface{} `json:"clusterNamePrefix,omitempty"`

	// The password to access the cluster.
	ClusterPassword SecretBaseClassification `json:"clusterPassword,omitempty"`

	// The resource group where the cluster belongs. Type: string (or Expression with resultType string).
	ClusterResourceGroup *interface{} `json:"clusterResourceGroup,omitempty"`

	// The password to SSH remotely connect clusters node (for Linux).
	ClusterSSHPassword SecretBaseClassification `json:"clusterSshPassword,omitempty"`

	// The username to SSH remotely connect to clusters node (for Linux). Type: string (or Expression with resultType string).
	ClusterSSHUserName *interface{} `json:"clusterSshUserName,omitempty"`

	// Number of worker/data nodes in the cluster. Suggestion value: 4. Type: string (or Expression with resultType string).
	ClusterSize *interface{} `json:"clusterSize,omitempty"`

	// The cluster type. Type: string (or Expression with resultType string).
	ClusterType *interface{} `json:"clusterType,omitempty"`

	// The username to access the cluster. Type: string (or Expression with resultType string).
	ClusterUserName *interface{} `json:"clusterUserName,omitempty"`

	// Specifies the core configuration parameters (as in core-site.xml) for the HDInsight cluster to be created.
	CoreConfiguration *interface{} `json:"coreConfiguration,omitempty"`

	// Specifies the size of the data node for the HDInsight cluster.
	DataNodeSize *interface{} `json:"dataNodeSize,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specifies the HBase configuration parameters (hbase-site.xml) for the HDInsight cluster.
	HBaseConfiguration *interface{} `json:"hBaseConfiguration,omitempty"`

	// The name of Azure SQL linked service that point to the HCatalog database. The on-demand HDInsight cluster is created by
	// using the Azure SQL database as the metastore.
	HcatalogLinkedServiceName *LinkedServiceReference `json:"hcatalogLinkedServiceName,omitempty"`

	// Specifies the HDFS configuration parameters (hdfs-site.xml) for the HDInsight cluster.
	HdfsConfiguration *interface{} `json:"hdfsConfiguration,omitempty"`

	// Specifies the size of the head node for the HDInsight cluster.
	HeadNodeSize *interface{} `json:"headNodeSize,omitempty"`

	// Specifies the hive configuration parameters (hive-site.xml) for the HDInsight cluster.
	HiveConfiguration *interface{} `json:"hiveConfiguration,omitempty"`

	// The customers subscription to host the cluster. Type: string (or Expression with resultType string).
	HostSubscriptionID *interface{} `json:"hostSubscriptionId,omitempty"`

	// Azure Storage linked service to be used by the on-demand cluster for storing and processing data.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// Specifies the MapReduce configuration parameters (mapred-site.xml) for the HDInsight cluster.
	MapReduceConfiguration *interface{} `json:"mapReduceConfiguration,omitempty"`

	// Specifies the Oozie configuration parameters (oozie-site.xml) for the HDInsight cluster.
	OozieConfiguration *interface{} `json:"oozieConfiguration,omitempty"`

	// Custom script actions to run on HDI ondemand cluster once it's up. Please refer to https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
	ScriptActions *[]ScriptAction `json:"scriptActions,omitempty"`

	// The service principal id for the hostSubscriptionId. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The key for the service principal id.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The version of spark if the cluster type is 'spark'. Type: string (or Expression with resultType string).
	SparkVersion *interface{} `json:"sparkVersion,omitempty"`

	// Specifies the Storm configuration parameters (storm-site.xml) for the HDInsight cluster.
	StormConfiguration *interface{} `json:"stormConfiguration,omitempty"`

	// The ARM resource ID for the subnet in the vNet. If virtualNetworkId was specified, then this property is required. Type:
	// string (or Expression with resultType string).
	SubnetName *interface{} `json:"subnetName,omitempty"`

	// The Tenant id/name to which the service principal belongs. Type: string (or Expression with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The allowed idle time for the on-demand HDInsight cluster. Specifies how long the on-demand HDInsight cluster stays alive
	// after completion of an activity run if there are no other active jobs in the cluster. The minimum value is 5 mins. Type:
	// string (or Expression with resultType string).
	TimeToLive *interface{} `json:"timeToLive,omitempty"`

	// Version of the HDInsight cluster. Type: string (or Expression with resultType string).
	Version *interface{} `json:"version,omitempty"`

	// The ARM resource ID for the vNet to which the cluster should be joined after creation. Type: string (or Expression with
	// resultType string).
	VirtualNetworkID *interface{} `json:"virtualNetworkId,omitempty"`

	// Specifies the Yarn configuration parameters (yarn-site.xml) for the HDInsight cluster.
	YarnConfiguration *interface{} `json:"yarnConfiguration,omitempty"`

	// Specifies the size of the Zoo Keeper node for the HDInsight cluster.
	ZookeeperNodeSize *interface{} `json:"zookeeperNodeSize,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightOnDemandLinkedServiceTypeProperties.
func (h *HdInsightOnDemandLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalLinkedServiceNames":
			if val != nil {
				err = json.Unmarshal(*val, &h.AdditionalLinkedServiceNames)
			}
		case "clusterNamePrefix":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterNamePrefix)
			}
		case "clusterPassword":
			if val != nil {
				h.ClusterPassword, err = unmarshalSecretBaseClassification(*val)
			}
		case "clusterResourceGroup":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterResourceGroup)
			}
		case "clusterSshPassword":
			if val != nil {
				h.ClusterSSHPassword, err = unmarshalSecretBaseClassification(*val)
			}
		case "clusterSshUserName":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterSSHUserName)
			}
		case "clusterSize":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterSize)
			}
		case "clusterType":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterType)
			}
		case "clusterUserName":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClusterUserName)
			}
		case "coreConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.CoreConfiguration)
			}
		case "dataNodeSize":
			if val != nil {
				err = json.Unmarshal(*val, &h.DataNodeSize)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "hBaseConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.HBaseConfiguration)
			}
		case "hcatalogLinkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &h.HcatalogLinkedServiceName)
			}
		case "hdfsConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.HdfsConfiguration)
			}
		case "headNodeSize":
			if val != nil {
				err = json.Unmarshal(*val, &h.HeadNodeSize)
			}
		case "hiveConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.HiveConfiguration)
			}
		case "hostSubscriptionId":
			if val != nil {
				err = json.Unmarshal(*val, &h.HostSubscriptionID)
			}
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &h.LinkedServiceName)
			}
		case "mapReduceConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.MapReduceConfiguration)
			}
		case "oozieConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.OozieConfiguration)
			}
		case "scriptActions":
			if val != nil {
				err = json.Unmarshal(*val, &h.ScriptActions)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &h.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				h.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "sparkVersion":
			if val != nil {
				err = json.Unmarshal(*val, &h.SparkVersion)
			}
		case "stormConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.StormConfiguration)
			}
		case "subnetName":
			if val != nil {
				err = json.Unmarshal(*val, &h.SubnetName)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &h.Tenant)
			}
		case "timeToLive":
			if val != nil {
				err = json.Unmarshal(*val, &h.TimeToLive)
			}
		case "version":
			if val != nil {
				err = json.Unmarshal(*val, &h.Version)
			}
		case "virtualNetworkId":
			if val != nil {
				err = json.Unmarshal(*val, &h.VirtualNetworkID)
			}
		case "yarnConfiguration":
			if val != nil {
				err = json.Unmarshal(*val, &h.YarnConfiguration)
			}
		case "zookeeperNodeSize":
			if val != nil {
				err = json.Unmarshal(*val, &h.ZookeeperNodeSize)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HDInsight Pig activity type.
type HdInsightPigActivity struct {
	ExecutionActivity
	// HDInsight Pig activity properties.
	TypeProperties *HdInsightPigActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightPigActivity.
func (h HdInsightPigActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightPig")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightPigActivity.
func (h *HdInsightPigActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.ExecutionActivity)
}

// HDInsight Pig activity properties.
type HdInsightPigActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity. Type: array (or Expression with resultType array).
	Arguments *interface{} `json:"arguments,omitempty"`

	// Allows user to specify defines for Pig job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Script linked service reference.
	ScriptLinkedService *LinkedServiceReference `json:"scriptLinkedService,omitempty"`

	// Script path. Type: string (or Expression with resultType string).
	ScriptPath *interface{} `json:"scriptPath,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// HDInsight Spark activity.
type HdInsightSparkActivity struct {
	ExecutionActivity
	// HDInsight spark activity properties.
	TypeProperties *HdInsightSparkActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightSparkActivity.
func (h HdInsightSparkActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightSpark")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightSparkActivity.
func (h *HdInsightSparkActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.ExecutionActivity)
}

// HDInsight spark activity properties.
type HdInsightSparkActivityTypeProperties struct {
	// The user-specified arguments to HDInsightSparkActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// The application's Java/Spark main class.
	ClassName *string `json:"className,omitempty"`

	// The relative path to the root folder of the code/package to be executed. Type: string (or Expression with resultType string).
	EntryFilePath *interface{} `json:"entryFilePath,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// The user to impersonate that will execute the job. Type: string (or Expression with resultType string).
	ProxyUser *interface{} `json:"proxyUser,omitempty"`

	// The root path in 'sparkJobLinkedService' for all the jobs files. Type: string (or Expression with resultType string).
	RootPath *interface{} `json:"rootPath,omitempty"`

	// Spark configuration property.
	SparkConfig *map[string]interface{} `json:"sparkConfig,omitempty"`

	// The storage linked service for uploading the entry file and dependencies, and for receiving logs.
	SparkJobLinkedService *LinkedServiceReference `json:"sparkJobLinkedService,omitempty"`
}

// HDInsight streaming activity type.
type HdInsightStreamingActivity struct {
	ExecutionActivity
	// HDInsight streaming activity properties.
	TypeProperties *HdInsightStreamingActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdInsightStreamingActivity.
func (h HdInsightStreamingActivity) MarshalJSON() ([]byte, error) {
	objectMap := h.ExecutionActivity.marshalInternal("HDInsightStreaming")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdInsightStreamingActivity.
func (h *HdInsightStreamingActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.ExecutionActivity)
}

// HDInsight streaming activity properties.
type HdInsightStreamingActivityTypeProperties struct {
	// User specified arguments to HDInsightActivity.
	Arguments *[]interface{} `json:"arguments,omitempty"`

	// Combiner executable name. Type: string (or Expression with resultType string).
	Combiner *interface{} `json:"combiner,omitempty"`

	// Command line environment values.
	CommandEnvironment *[]interface{} `json:"commandEnvironment,omitempty"`

	// Allows user to specify defines for streaming job request.
	Defines *map[string]interface{} `json:"defines,omitempty"`

	// Linked service reference where the files are located.
	FileLinkedService *LinkedServiceReference `json:"fileLinkedService,omitempty"`

	// Paths to streaming job files. Can be directories.
	FilePaths *[]interface{} `json:"filePaths,omitempty"`

	// Debug info option.
	GetDebugInfo *HDInsightActivityDebugInfoOption `json:"getDebugInfo,omitempty"`

	// Input blob path. Type: string (or Expression with resultType string).
	Input *interface{} `json:"input,omitempty"`

	// Mapper executable name. Type: string (or Expression with resultType string).
	Mapper *interface{} `json:"mapper,omitempty"`

	// Output blob path. Type: string (or Expression with resultType string).
	Output *interface{} `json:"output,omitempty"`

	// Reducer executable name. Type: string (or Expression with resultType string).
	Reducer *interface{} `json:"reducer,omitempty"`

	// Storage linked service references.
	StorageLinkedServices *[]LinkedServiceReference `json:"storageLinkedServices,omitempty"`
}

// Hadoop Distributed File System (HDFS) linked service.
type HdfsLinkedService struct {
	LinkedService
	// HDFS linked service properties.
	TypeProperties *HdfsLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HdfsLinkedService.
func (h HdfsLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("Hdfs")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedService.
func (h *HdfsLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// HDFS linked service properties.
type HdfsLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the HDFS. Possible values are: Anonymous and Windows. Type: string (or Expression
	// with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Windows authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1 . Type: string (or Expression with resultType
	// string).
	URL *interface{} `json:"url,omitempty"`

	// User name for Windows authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HdfsLinkedServiceTypeProperties.
func (h *HdfsLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &h.URL)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &h.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Hive Properties
type HiveDatasetTypeProperties struct {
	// The schema name of the Hive. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Hive. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Hive Server linked service.
type HiveLinkedService struct {
	LinkedService
	// Hive Server linked service properties.
	TypeProperties *HiveLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveLinkedService.
func (h HiveLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("Hive")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedService.
func (h *HiveLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// Hive Server linked service properties.
type HiveLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication method used to access the Hive server.
	AuthenticationType *HiveAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Hive server.
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// IP address or host name of the Hive server, separated by ';' for multiple hosts (only when serviceDiscoveryMode is enable).
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the Username field
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Hive server uses to listen for client connections.
	Port *interface{} `json:"port,omitempty"`

	// The type of Hive server.
	ServerType *HiveServerType `json:"serverType,omitempty"`

	// true to indicate using the ZooKeeper service, false not.
	ServiceDiscoveryMode *interface{} `json:"serviceDiscoveryMode,omitempty"`

	// The transport protocol to use in the Thrift layer.
	ThriftTransportProtocol *HiveThriftTransportProtocol `json:"thriftTransportProtocol,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether the driver uses native HiveQL queries,or converts them into an equivalent form in HiveQL.
	UseNativeQuery *interface{} `json:"useNativeQuery,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name that you use to access Hive Server.
	Username *interface{} `json:"username,omitempty"`

	// The namespace on ZooKeeper under which Hive Server 2 nodes are added.
	ZooKeeperNameSpace *interface{} `json:"zooKeeperNameSpace,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveLinkedServiceTypeProperties.
func (h *HiveLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowHostNameCnMismatch)
			}
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &h.AllowSelfSignedServerCert)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &h.AuthenticationType)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &h.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.HTTPPath)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &h.Host)
			}
		case "password":
			if val != nil {
				h.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &h.Port)
			}
		case "serverType":
			if val != nil {
				err = json.Unmarshal(*val, &h.ServerType)
			}
		case "serviceDiscoveryMode":
			if val != nil {
				err = json.Unmarshal(*val, &h.ServiceDiscoveryMode)
			}
		case "thriftTransportProtocol":
			if val != nil {
				err = json.Unmarshal(*val, &h.ThriftTransportProtocol)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &h.TrustedCertPath)
			}
		case "useNativeQuery":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseNativeQuery)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseSystemTrustStore)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &h.Username)
			}
		case "zooKeeperNameSpace":
			if val != nil {
				err = json.Unmarshal(*val, &h.ZooKeeperNameSpace)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Hive Server dataset.
type HiveObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *HiveDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HiveObjectDataset.
func (h HiveObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := h.Dataset.marshalInternal("HiveObject")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HiveObjectDataset.
func (h *HiveObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.Dataset)
}

// Hubspot Service linked service.
type HubspotLinkedService struct {
	LinkedService
	// Hubspot Service linked service properties.
	TypeProperties *HubspotLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HubspotLinkedService.
func (h HubspotLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := h.LinkedService.marshalInternal("Hubspot")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedService.
func (h *HubspotLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.LinkedService)
}

// Hubspot Service linked service properties.
type HubspotLinkedServiceTypeProperties struct {
	// The access token obtained when initially authenticating your OAuth integration.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The client ID associated with your Hubspot application.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with your Hubspot application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The refresh token obtained when initially authenticating your OAuth integration.
	RefreshToken SecretBaseClassification `json:"refreshToken,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotLinkedServiceTypeProperties.
func (h *HubspotLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				h.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &h.ClientID)
			}
		case "clientSecret":
			if val != nil {
				h.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &h.EncryptedCredential)
			}
		case "refreshToken":
			if val != nil {
				h.RefreshToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &h.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &h.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Hubspot Service dataset.
type HubspotObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HubspotObjectDataset.
func (h HubspotObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := h.Dataset.marshalInternal("HubspotObject")
	if h.TypeProperties != nil {
		objectMap["typeProperties"] = h.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HubspotObjectDataset.
func (h *HubspotObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &h.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &h.Dataset)
}

// This activity evaluates a boolean expression and executes either the activities under the ifTrueActivities property or
// the ifFalseActivities property depending on the result of the expression.
type IfConditionActivity struct {
	Activity
	// IfCondition activity properties.
	TypeProperties *IfConditionActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IfConditionActivity.
func (i IfConditionActivity) MarshalJSON() ([]byte, error) {
	objectMap := i.Activity.marshalInternal("IfCondition")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivity.
func (i *IfConditionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &i.Activity)
}

// IfCondition activity properties.
type IfConditionActivityTypeProperties struct {
	// An expression that would evaluate to Boolean. This is used to determine the block of activities (ifTrueActivities or ifFalseActivities)
	// that will be executed.
	Expression *Expression `json:"expression,omitempty"`

	// List of activities to execute if expression is evaluated to false. This is an optional property and if not provided, the
	// activity will exit without any action.
	IfFalseActivities *[]ActivityClassification `json:"ifFalseActivities,omitempty"`

	// List of activities to execute if expression is evaluated to true. This is an optional property and if not provided, the
	// activity will exit without any action.
	IfTrueActivities *[]ActivityClassification `json:"ifTrueActivities,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IfConditionActivityTypeProperties.
func (i *IfConditionActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expression":
			if val != nil {
				err = json.Unmarshal(*val, &i.Expression)
			}
		case "ifFalseActivities":
			if val != nil {
				i.IfFalseActivities, err = unmarshalActivityClassificationArray(*val)
			}
		case "ifTrueActivities":
			if val != nil {
				i.IfTrueActivities, err = unmarshalActivityClassificationArray(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Impala Dataset Properties
type ImpalaDatasetTypeProperties struct {
	// The schema name of the Impala. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Impala. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Impala server linked service.
type ImpalaLinkedService struct {
	LinkedService
	// Impala server linked service properties.
	TypeProperties *ImpalaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaLinkedService.
func (i ImpalaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := i.LinkedService.marshalInternal("Impala")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedService.
func (i *ImpalaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &i.LinkedService)
}

// Impala server linked service properties.
type ImpalaLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication type to use.
	AuthenticationType *ImpalaAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The IP address or host name of the Impala server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name when using UsernameAndPassword.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Impala server uses to listen for client connections. The default value is 21050.
	Port *interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to access the Impala server. The default value is anonymous when using SASLUsername.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaLinkedServiceTypeProperties.
func (i *ImpalaLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &i.AllowHostNameCnMismatch)
			}
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &i.AllowSelfSignedServerCert)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &i.AuthenticationType)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &i.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &i.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &i.Host)
			}
		case "password":
			if val != nil {
				i.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &i.Port)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &i.TrustedCertPath)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &i.UseSystemTrustStore)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &i.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Impala server dataset.
type ImpalaObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *ImpalaDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ImpalaObjectDataset.
func (i ImpalaObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := i.Dataset.marshalInternal("ImpalaObject")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImpalaObjectDataset.
func (i *ImpalaObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &i.Dataset)
}

// Informix linked service.
type InformixLinkedService struct {
	LinkedService
	// Informix linked service properties.
	TypeProperties *InformixLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixLinkedService.
func (i InformixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := i.LinkedService.marshalInternal("Informix")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedService.
func (i *InformixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &i.LinkedService)
}

// Informix linked service properties.
type InformixLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the Informix as ODBC data store. Possible values are: Anonymous and Basic. Type:
	// string (or Expression with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixLinkedServiceTypeProperties.
func (i *InformixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &i.AuthenticationType)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &i.ConnectionString)
			}
		case "credential":
			if val != nil {
				i.Credential, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &i.EncryptedCredential)
			}
		case "password":
			if val != nil {
				i.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &i.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Informix table dataset.
type InformixTableDataset struct {
	Dataset
	// Informix table dataset properties.
	TypeProperties *InformixTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InformixTableDataset.
func (i InformixTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := i.Dataset.marshalInternal("InformixTable")
	if i.TypeProperties != nil {
		objectMap["typeProperties"] = i.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InformixTableDataset.
func (i *InformixTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &i.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &i.Dataset)
}

// Informix table dataset properties.
type InformixTableDatasetTypeProperties struct {
	// The Informix table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Integration runtime reference type.
type IntegrationRuntimeReference struct {
	// Arguments for integration runtime.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Reference integration runtime name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Type of integration runtime.
	Type *string `json:"type,omitempty"`
}

// Json dataset.
type JSONDataset struct {
	Dataset
	// Json dataset properties.
	TypeProperties *JSONDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JSONDataset.
func (j JSONDataset) MarshalJSON() ([]byte, error) {
	objectMap := j.Dataset.marshalInternal("Json")
	if j.TypeProperties != nil {
		objectMap["typeProperties"] = j.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDataset.
func (j *JSONDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &j.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &j.Dataset)
}

// Json dataset properties.
type JSONDatasetTypeProperties struct {
	// The data compression method used for the json dataset.
	Compression DatasetCompressionClassification `json:"compression,omitempty"`

	// The code page name of the preferred encoding. If not specified, the default value is UTF-8, unless BOM denotes another
	// Unicode encoding. Refer to the name column of the table in the following link to set supported values: https://msdn.microsoft.com/library/system.text.encoding.aspx.
	// Type: string (or Expression with resultType string).
	EncodingName *interface{} `json:"encodingName,omitempty"`

	// The location of the json data storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONDatasetTypeProperties.
func (j *JSONDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compression":
			if val != nil {
				j.Compression, err = unmarshalDatasetCompressionClassification(*val)
			}
		case "encodingName":
			if val != nil {
				err = json.Unmarshal(*val, &j.EncodingName)
			}
		case "location":
			if val != nil {
				j.Location, err = unmarshalDatasetLocationClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Jira Service linked service.
type JiraLinkedService struct {
	LinkedService
	// Jira Service linked service properties.
	TypeProperties *JiraLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JiraLinkedService.
func (j JiraLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := j.LinkedService.marshalInternal("Jira")
	if j.TypeProperties != nil {
		objectMap["typeProperties"] = j.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedService.
func (j *JiraLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &j.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &j.LinkedService)
}

// Jira Service linked service properties.
type JiraLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The IP address or host name of the Jira service. (e.g. jira.example.com)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the username field.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Jira server uses to listen for client connections. The default value is 443 if connecting through
	// HTTPS, or 8080 if connecting through HTTP.
	Port *interface{} `json:"port,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name that you use to access Jira Service.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraLinkedServiceTypeProperties.
func (j *JiraLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &j.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &j.Host)
			}
		case "password":
			if val != nil {
				j.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &j.Port)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &j.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &j.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &j.UsePeerVerification)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &j.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Jira Service dataset.
type JiraObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JiraObjectDataset.
func (j JiraObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := j.Dataset.marshalInternal("JiraObject")
	if j.TypeProperties != nil {
		objectMap["typeProperties"] = j.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JiraObjectDataset.
func (j *JiraObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &j.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &j.Dataset)
}

// LinkedServiceClassification provides polymorphic access to related types.
type LinkedServiceClassification interface {
	GetLinkedService() *LinkedService
}

// The Azure Synapse nested object which contains the information and credential which can be used to connect with related
// store or compute resource.
type LinkedService struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// List of tags that can be used for describing the linked service.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// Linked service description.
	Description *string `json:"description,omitempty"`

	// Parameters for linked service.
	Parameters *map[string]ParameterSpecification `json:"parameters,omitempty"`

	// Type of linked service.
	Type *string `json:"type,omitempty"`
}

// GetLinkedService implements the LinkedServiceClassification interface for type LinkedService.
func (l *LinkedService) GetLinkedService() *LinkedService { return l }

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedService.
func (l *LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &l.Annotations)
			}
		case "connectVia":
			if val != nil {
				err = json.Unmarshal(*val, &l.ConnectVia)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &l.Description)
			}
		case "parameters":
			if val != nil {
				err = json.Unmarshal(*val, &l.Parameters)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &l.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (l LinkedService) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if l.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = l.AdditionalProperties
	}
	if l.Annotations != nil {
		objectMap["annotations"] = l.Annotations
	}
	if l.ConnectVia != nil {
		objectMap["connectVia"] = l.ConnectVia
	}
	if l.Description != nil {
		objectMap["description"] = l.Description
	}
	if l.Parameters != nil {
		objectMap["parameters"] = l.Parameters
	}
	l.Type = &discValue
	objectMap["type"] = l.Type
	return objectMap
}

// LinkedServiceCreateOrUpdateLinkedServiceOptions contains the optional parameters for the LinkedService.CreateOrUpdateLinkedService
// method.
type LinkedServiceCreateOrUpdateLinkedServiceOptions struct {
	// ETag of the linkedService entity. Should only be specified for update, for which it should match existing entity or can
	// be * for unconditional update.
	IfMatch *string
}

// Linked service debug resource.
type LinkedServiceDebugResource struct {
	SubResourceDebugResource
	// Properties of linked service.
	Properties LinkedServiceClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceDebugResource.
func (l *LinkedServiceDebugResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				l.Properties, err = unmarshalLinkedServiceClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &l.SubResourceDebugResource)
}

// LinkedServiceGetLinkedServiceOptions contains the optional parameters for the LinkedService.GetLinkedService method.
type LinkedServiceGetLinkedServiceOptions struct {
	// ETag of the linked service entity. Should only be specified for get. If the ETag matches the existing entity tag, or if
	// * was provided, then no content will be returned.
	IfNoneMatch *string
}

// A list of linked service resources.
type LinkedServiceListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of linked services.
	Value *[]LinkedServiceResource `json:"value,omitempty"`
}

// LinkedServiceListResponseResponse is the response envelope for operations that return a LinkedServiceListResponse type.
type LinkedServiceListResponseResponse struct {
	// A list of linked service resources.
	LinkedServiceListResponse *LinkedServiceListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Linked service reference type.
type LinkedServiceReference struct {
	// Arguments for LinkedService.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Reference LinkedService name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Linked service reference type.
	Type *string `json:"type,omitempty"`
}

// Linked service resource type.
type LinkedServiceResource struct {
	SubResource
	// Properties of linked service.
	Properties LinkedServiceClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinkedServiceResource.
func (l *LinkedServiceResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				l.Properties, err = unmarshalLinkedServiceClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &l.SubResource)
}

// LinkedServiceResourcePollerResponse is the response envelope for operations that asynchronously return a LinkedServiceResource
// type.
type LinkedServiceResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*LinkedServiceResourceResponse, error)

	// Poller contains an initialized poller.
	Poller LinkedServiceResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServiceResourceResponse is the response envelope for operations that return a LinkedServiceResource type.
type LinkedServiceResourceResponse struct {
	// Linked service resource type.
	LinkedServiceResource *LinkedServiceResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Log storage settings.
type LogStorageSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Log storage linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The path to storage for storing detailed logs of activity execution. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LogStorageSettings.
func (l LogStorageSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if l.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = l.LinkedServiceName
	}
	if l.Path != nil {
		objectMap["path"] = l.Path
	}
	if l.AdditionalProperties != nil {
		for key, val := range *l.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogStorageSettings.
func (l *LogStorageSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &l.LinkedServiceName)
			}
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &l.Path)
			}
		default:
			if l.AdditionalProperties == nil {
				l.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*l.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Lookup activity.
type LookupActivity struct {
	ExecutionActivity
	// Lookup activity properties.
	TypeProperties *LookupActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LookupActivity.
func (l LookupActivity) MarshalJSON() ([]byte, error) {
	objectMap := l.ExecutionActivity.marshalInternal("Lookup")
	if l.TypeProperties != nil {
		objectMap["typeProperties"] = l.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivity.
func (l *LookupActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &l.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &l.ExecutionActivity)
}

// Lookup activity properties.
type LookupActivityTypeProperties struct {
	// Lookup activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Whether to return first row or all rows. Default value is true. Type: boolean (or Expression with resultType boolean).
	FirstRowOnly *interface{} `json:"firstRowOnly,omitempty"`

	// Dataset-specific source properties, same as copy activity source.
	Source CopySourceClassification `json:"source,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LookupActivityTypeProperties.
func (l *LookupActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataset":
			if val != nil {
				err = json.Unmarshal(*val, &l.Dataset)
			}
		case "firstRowOnly":
			if val != nil {
				err = json.Unmarshal(*val, &l.FirstRowOnly)
			}
		case "source":
			if val != nil {
				l.Source, err = unmarshalCopySourceClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Magento server linked service.
type MagentoLinkedService struct {
	LinkedService
	// Magento server linked service properties.
	TypeProperties *MagentoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MagentoLinkedService.
func (m MagentoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("Magento")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedService.
func (m *MagentoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// Magento server linked service properties.
type MagentoLinkedServiceTypeProperties struct {
	// The access token from Magento.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Magento instance. (i.e. 192.168.222.110/magento3)
	Host *interface{} `json:"host,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoLinkedServiceTypeProperties.
func (m *MagentoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				m.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &m.Host)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Magento server dataset.
type MagentoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MagentoObjectDataset.
func (m MagentoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MagentoObject")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MagentoObjectDataset.
func (m *MagentoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// Mapping data flow.
type MappingDataFlow struct {
	DataFlow
	// Mapping data flow type properties.
	TypeProperties *MappingDataFlowTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MappingDataFlow.
func (m MappingDataFlow) MarshalJSON() ([]byte, error) {
	objectMap := m.DataFlow.marshalInternal("MappingDataFlow")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MappingDataFlow.
func (m *MappingDataFlow) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.DataFlow)
}

// Mapping data flow type properties.
type MappingDataFlowTypeProperties struct {
	// DataFlow script.
	Script *string `json:"script,omitempty"`

	// List of sinks in data flow.
	Sinks *[]DataFlowSink `json:"sinks,omitempty"`

	// List of sources in data flow.
	Sources *[]DataFlowSource `json:"sources,omitempty"`

	// List of transformations in data flow.
	Transformations *[]Transformation `json:"transformations,omitempty"`
}

// MariaDB server linked service.
type MariaDbLinkedService struct {
	LinkedService
	// MariaDB server linked service properties.
	TypeProperties *MariaDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MariaDbLinkedService.
func (m MariaDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MariaDB")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDbLinkedService.
func (m *MariaDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// MariaDB server linked service properties.
type MariaDbLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// MariaDB server dataset.
type MariaDbTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MariaDbTableDataset.
func (m MariaDbTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MariaDBTable")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MariaDbTableDataset.
func (m *MariaDbTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// Marketo server linked service.
type MarketoLinkedService struct {
	LinkedService
	// Marketo server linked service properties.
	TypeProperties *MarketoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketoLinkedService.
func (m MarketoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("Marketo")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedService.
func (m *MarketoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// Marketo server linked service properties.
type MarketoLinkedServiceTypeProperties struct {
	// The client Id of your Marketo service.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret of your Marketo service.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoLinkedServiceTypeProperties.
func (m *MarketoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &m.ClientID)
			}
		case "clientSecret":
			if val != nil {
				m.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &m.Endpoint)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &m.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Marketo server dataset.
type MarketoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MarketoObjectDataset.
func (m MarketoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MarketoObject")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MarketoObjectDataset.
func (m *MarketoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// Microsoft Access linked service.
type MicrosoftAccessLinkedService struct {
	LinkedService
	// Microsoft Access linked service properties.
	TypeProperties *MicrosoftAccessLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessLinkedService.
func (m MicrosoftAccessLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MicrosoftAccess")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedService.
func (m *MicrosoftAccessLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// Microsoft Access linked service properties.
type MicrosoftAccessLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic.
	// Type: string (or Expression with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessLinkedServiceTypeProperties.
func (m *MicrosoftAccessLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &m.AuthenticationType)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &m.ConnectionString)
			}
		case "credential":
			if val != nil {
				m.Credential, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
		case "password":
			if val != nil {
				m.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &m.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Microsoft Access table dataset.
type MicrosoftAccessTableDataset struct {
	Dataset
	// Microsoft Access table dataset properties.
	TypeProperties *MicrosoftAccessTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MicrosoftAccessTableDataset.
func (m MicrosoftAccessTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MicrosoftAccessTable")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MicrosoftAccessTableDataset.
func (m *MicrosoftAccessTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// Microsoft Access table dataset properties.
type MicrosoftAccessTableDatasetTypeProperties struct {
	// The Microsoft Access table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// The MongoDB database dataset.
type MongoDbCollectionDataset struct {
	Dataset
	// MongoDB database dataset properties.
	TypeProperties *MongoDbCollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionDataset.
func (m MongoDbCollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MongoDbCollection")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCollectionDataset.
func (m *MongoDbCollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// MongoDB database dataset properties.
type MongoDbCollectionDatasetTypeProperties struct {
	// The table name of the MongoDB database. Type: string (or Expression with resultType string).
	CollectionName *interface{} `json:"collectionName,omitempty"`
}

// Linked service for MongoDb data source.
type MongoDbLinkedService struct {
	LinkedService
	// MongoDB linked service properties.
	TypeProperties *MongoDbLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbLinkedService.
func (m MongoDbLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MongoDb")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedService.
func (m *MongoDbLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// MongoDB linked service properties.
type MongoDbLinkedServiceTypeProperties struct {
	// Specifies whether to allow self-signed certificates from the server. The default value is false. Type: boolean (or Expression
	// with resultType boolean).
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// Database to verify the username and password. Type: string (or Expression with resultType string).
	AuthSource *interface{} `json:"authSource,omitempty"`

	// The authentication type to be used to connect to the MongoDB database.
	AuthenticationType *MongoDbAuthenticationType `json:"authenticationType,omitempty"`

	// The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
	DatabaseName *interface{} `json:"databaseName,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false. Type: boolean (or
	// Expression with resultType boolean).
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the MongoDB server uses to listen for client connections. The default value is 27017. Type: integer
	// (or Expression with resultType integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// The IP address or server name of the MongoDB server. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbLinkedServiceTypeProperties.
func (m *MongoDbLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &m.AllowSelfSignedServerCert)
			}
		case "authSource":
			if val != nil {
				err = json.Unmarshal(*val, &m.AuthSource)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &m.AuthenticationType)
			}
		case "databaseName":
			if val != nil {
				err = json.Unmarshal(*val, &m.DatabaseName)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &m.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &m.EncryptedCredential)
			}
		case "password":
			if val != nil {
				m.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &m.Port)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &m.Server)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &m.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The MongoDB database dataset.
type MongoDbV2CollectionDataset struct {
	Dataset
	// MongoDB database dataset properties.
	TypeProperties *MongoDbV2CollectionDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2CollectionDataset.
func (m MongoDbV2CollectionDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MongoDbV2Collection")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2CollectionDataset.
func (m *MongoDbV2CollectionDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// MongoDB database dataset properties.
type MongoDbV2CollectionDatasetTypeProperties struct {
	// The collection name of the MongoDB database. Type: string (or Expression with resultType string).
	Collection *interface{} `json:"collection,omitempty"`
}

// Linked service for MongoDB data source.
type MongoDbV2LinkedService struct {
	LinkedService
	// MongoDB linked service properties.
	TypeProperties *MongoDbV2LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbV2LinkedService.
func (m MongoDbV2LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MongoDbV2")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbV2LinkedService.
func (m *MongoDbV2LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// MongoDB linked service properties.
type MongoDbV2LinkedServiceTypeProperties struct {
	// The MongoDB connection string. Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or
	// AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The name of the MongoDB database that you want to access. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`
}

// Base class for all triggers that support one to many model for trigger to pipeline.
type MultiplePipelineTrigger struct {
	Trigger
	// Pipelines that need to be started.
	Pipelines *[]TriggerPipelineReference `json:"pipelines,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MultiplePipelineTrigger.
func (m MultiplePipelineTrigger) MarshalJSON() ([]byte, error) {
	objectMap := m.Trigger.marshalInternal("MultiplePipelineTrigger")
	if m.Pipelines != nil {
		objectMap["pipelines"] = m.Pipelines
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiplePipelineTrigger.
func (m *MultiplePipelineTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "pipelines":
			if val != nil {
				err = json.Unmarshal(*val, &m.Pipelines)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Trigger)
}

// Linked service for MySQL data source.
type MySQLLinkedService struct {
	LinkedService
	// MySQL linked service properties.
	TypeProperties *MySQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MySQLLinkedService.
func (m MySQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := m.LinkedService.marshalInternal("MySql")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLLinkedService.
func (m *MySQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.LinkedService)
}

// MySQL linked service properties.
type MySQLLinkedServiceTypeProperties struct {
	// The connection string.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// The MySQL table dataset.
type MySQLTableDataset struct {
	Dataset
	// MySQL table dataset properties.
	TypeProperties *MySQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MySQLTableDataset.
func (m MySQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := m.Dataset.marshalInternal("MySqlTable")
	if m.TypeProperties != nil {
		objectMap["typeProperties"] = m.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLTableDataset.
func (m *MySQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &m.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &m.Dataset)
}

// MySql table dataset properties.
type MySQLTableDatasetTypeProperties struct {
	// The MySQL table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Netezza linked service.
type NetezzaLinkedService struct {
	LinkedService
	// Netezza linked service properties.
	TypeProperties *NetezzaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaLinkedService.
func (n NetezzaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := n.LinkedService.marshalInternal("Netezza")
	if n.TypeProperties != nil {
		objectMap["typeProperties"] = n.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaLinkedService.
func (n *NetezzaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &n.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &n.LinkedService)
}

// Netezza linked service properties.
type NetezzaLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// Netezza dataset.
type NetezzaTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *NetezzaTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetezzaTableDataset.
func (n NetezzaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := n.Dataset.marshalInternal("NetezzaTable")
	if n.TypeProperties != nil {
		objectMap["typeProperties"] = n.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetezzaTableDataset.
func (n *NetezzaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &n.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &n.Dataset)
}

// Netezza dataset properties.
type NetezzaTableDatasetTypeProperties struct {
	// The schema name of the Netezza. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Netezza. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Notebook.
type Notebook struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Big data pool reference.
	BigDataPool *BigDataPoolReference `json:"bigDataPool,omitempty"`

	// Array of cells of the current notebook.
	Cells *[]NotebookCell `json:"cells,omitempty"`

	// The description of the notebook.
	Description *string `json:"description,omitempty"`

	// Notebook root-level metadata.
	Metadata *NotebookMetadata `json:"metadata,omitempty"`

	// Notebook format (major number). Incremented between backwards incompatible changes to the notebook format.
	Nbformat *int32 `json:"nbformat,omitempty"`

	// Notebook format (minor number). Incremented for backward compatible changes to the notebook format.
	NbformatMinor *int32 `json:"nbformat_minor,omitempty"`

	// Session properties.
	SessionProperties *NotebookSessionProperties `json:"sessionProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Notebook.
func (n Notebook) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.BigDataPool != nil {
		objectMap["bigDataPool"] = n.BigDataPool
	}
	if n.Cells != nil {
		objectMap["cells"] = n.Cells
	}
	if n.Description != nil {
		objectMap["description"] = n.Description
	}
	if n.Metadata != nil {
		objectMap["metadata"] = n.Metadata
	}
	if n.Nbformat != nil {
		objectMap["nbformat"] = n.Nbformat
	}
	if n.NbformatMinor != nil {
		objectMap["nbformat_minor"] = n.NbformatMinor
	}
	if n.SessionProperties != nil {
		objectMap["sessionProperties"] = n.SessionProperties
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Notebook.
func (n *Notebook) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bigDataPool":
			if val != nil {
				err = json.Unmarshal(*val, &n.BigDataPool)
			}
		case "cells":
			if val != nil {
				err = json.Unmarshal(*val, &n.Cells)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &n.Description)
			}
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &n.Metadata)
			}
		case "nbformat":
			if val != nil {
				err = json.Unmarshal(*val, &n.Nbformat)
			}
		case "nbformat_minor":
			if val != nil {
				err = json.Unmarshal(*val, &n.NbformatMinor)
			}
		case "sessionProperties":
			if val != nil {
				err = json.Unmarshal(*val, &n.SessionProperties)
			}
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Notebook cell.
type NotebookCell struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Attachments associated with the cell.
	Attachments *interface{} `json:"attachments,omitempty"`

	// String identifying the type of cell.
	CellType *string `json:"cell_type,omitempty"`

	// Cell-level metadata.
	Metadata *interface{} `json:"metadata,omitempty"`

	// Cell-level output items.
	Outputs *[]NotebookCellOutputItem `json:"outputs,omitempty"`

	// Contents of the cell, represented as an array of lines.
	Source *[]string `json:"source,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookCell.
func (n NotebookCell) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.Attachments != nil {
		objectMap["attachments"] = n.Attachments
	}
	if n.CellType != nil {
		objectMap["cell_type"] = n.CellType
	}
	if n.Metadata != nil {
		objectMap["metadata"] = n.Metadata
	}
	if n.Outputs != nil {
		objectMap["outputs"] = n.Outputs
	}
	if n.Source != nil {
		objectMap["source"] = n.Source
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookCell.
func (n *NotebookCell) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attachments":
			if val != nil {
				err = json.Unmarshal(*val, &n.Attachments)
			}
		case "cell_type":
			if val != nil {
				err = json.Unmarshal(*val, &n.CellType)
			}
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &n.Metadata)
			}
		case "outputs":
			if val != nil {
				err = json.Unmarshal(*val, &n.Outputs)
			}
		case "source":
			if val != nil {
				err = json.Unmarshal(*val, &n.Source)
			}
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// An item of the notebook cell execution output.
type NotebookCellOutputItem struct {
	// Output data. Use MIME type as key, and content as value.
	Data *interface{} `json:"data,omitempty"`

	// Execution sequence number.
	ExecutionCount *int32 `json:"execution_count,omitempty"`

	// Metadata for the output item.
	Metadata *interface{} `json:"metadata,omitempty"`

	// For output_type=stream, determines the name of stream (stdout / stderr).
	Name *string `json:"name,omitempty"`

	// Execution, display, or stream outputs.
	OutputType *CellOutputType `json:"output_type,omitempty"`

	// For output_type=stream, the stream's text output, represented as a string or an array of strings.
	Text *interface{} `json:"text,omitempty"`
}

// NotebookCreateOrUpdateNotebookOptions contains the optional parameters for the Notebook.CreateOrUpdateNotebook method.
type NotebookCreateOrUpdateNotebookOptions struct {
	// ETag of the Note book entity. Should only be specified for update, for which it should match existing entity or can be
	// * for unconditional update.
	IfMatch *string
}

// NotebookGetNotebookOptions contains the optional parameters for the Notebook.GetNotebook method.
type NotebookGetNotebookOptions struct {
	// ETag of the Notebook entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// Kernel information.
type NotebookKernelSpec struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Name to display in UI.
	DisplayName *string `json:"display_name,omitempty"`

	// Name of the kernel specification.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookKernelSpec.
func (n NotebookKernelSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.DisplayName != nil {
		objectMap["display_name"] = n.DisplayName
	}
	if n.Name != nil {
		objectMap["name"] = n.Name
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookKernelSpec.
func (n *NotebookKernelSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "display_name":
			if val != nil {
				err = json.Unmarshal(*val, &n.DisplayName)
			}
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &n.Name)
			}
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Language info.
type NotebookLanguageInfo struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The codemirror mode to use for code in this language.
	CodemirrorMode *string `json:"codemirror_mode,omitempty"`

	// The programming language which this kernel runs.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookLanguageInfo.
func (n NotebookLanguageInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.CodemirrorMode != nil {
		objectMap["codemirror_mode"] = n.CodemirrorMode
	}
	if n.Name != nil {
		objectMap["name"] = n.Name
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookLanguageInfo.
func (n *NotebookLanguageInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codemirror_mode":
			if val != nil {
				err = json.Unmarshal(*val, &n.CodemirrorMode)
			}
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &n.Name)
			}
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// A list of Notebook resources.
type NotebookListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of Notebooks.
	Value *[]NotebookResource `json:"value,omitempty"`
}

// NotebookListResponseResponse is the response envelope for operations that return a NotebookListResponse type.
type NotebookListResponseResponse struct {
	// A list of Notebook resources.
	NotebookListResponse *NotebookListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Notebook root-level metadata.
type NotebookMetadata struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Kernel information.
	Kernelspec *NotebookKernelSpec `json:"kernelspec,omitempty"`

	// Language info.
	LanguageInfo *NotebookLanguageInfo `json:"language_info,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NotebookMetadata.
func (n NotebookMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.Kernelspec != nil {
		objectMap["kernelspec"] = n.Kernelspec
	}
	if n.LanguageInfo != nil {
		objectMap["language_info"] = n.LanguageInfo
	}
	if n.AdditionalProperties != nil {
		for key, val := range *n.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NotebookMetadata.
func (n *NotebookMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelspec":
			if val != nil {
				err = json.Unmarshal(*val, &n.Kernelspec)
			}
		case "language_info":
			if val != nil {
				err = json.Unmarshal(*val, &n.LanguageInfo)
			}
		default:
			if n.AdditionalProperties == nil {
				n.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*n.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Notebook resource type.
type NotebookResource struct {
	SubResource
	// Properties of Notebook.
	Properties *Notebook `json:"properties,omitempty"`
}

// NotebookResourcePollerResponse is the response envelope for operations that asynchronously return a NotebookResource type.
type NotebookResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*NotebookResourceResponse, error)

	// Poller contains an initialized poller.
	Poller NotebookResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookResourceResponse is the response envelope for operations that return a NotebookResource type.
type NotebookResourceResponse struct {
	// Notebook resource type.
	NotebookResource *NotebookResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Session properties.
type NotebookSessionProperties struct {
	// Number of cores to use for the driver.
	DriverCores *int32 `json:"driverCores,omitempty"`

	// Amount of memory to use for the driver process.
	DriverMemory *string `json:"driverMemory,omitempty"`

	// Number of cores to use for each executor.
	ExecutorCores *int32 `json:"executorCores,omitempty"`

	// Amount of memory to use per executor process.
	ExecutorMemory *string `json:"executorMemory,omitempty"`

	// Number of executors to launch for this session.
	NumExecutors *int32 `json:"numExecutors,omitempty"`
}

// Open Data Protocol (OData) linked service.
type ODataLinkedService struct {
	LinkedService
	// OData linked service properties.
	TypeProperties *ODataLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataLinkedService.
func (o ODataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("OData")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedService.
func (o *ODataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.LinkedService)
}

// OData linked service properties.
type ODataLinkedServiceTypeProperties struct {
	// Specify the resource you are requesting authorization to use Directory. Type: string (or Expression with resultType string).
	AadResourceID *interface{} `json:"aadResourceId,omitempty"`

	// Specify the credential type (key or cert) is used for service principal.
	AadServicePrincipalCredentialType *ODataAadServicePrincipalCredentialType `json:"aadServicePrincipalCredentialType,omitempty"`

	// Type of authentication used to connect to the OData service.
	AuthenticationType *ODataAuthenticationType `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password of the OData service.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specify the base64 encoded certificate of your application registered in Azure Active Directory. Type: string (or Expression
	// with resultType string).
	ServicePrincipalEmbeddedCert SecretBaseClassification `json:"servicePrincipalEmbeddedCert,omitempty"`

	// Specify the password of your certificate if your certificate has a password and you are using AadServicePrincipal authentication.
	// Type: string (or Expression with resultType string).
	ServicePrincipalEmbeddedCertPassword SecretBaseClassification `json:"servicePrincipalEmbeddedCertPassword,omitempty"`

	// Specify the application id of your application registered in Azure Active Directory. Type: string (or Expression with resultType
	// string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the secret of your application registered in Azure Active Directory. Type: string (or Expression with resultType
	// string).
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information (domain name or tenant ID) under which your application resides. Type: string (or Expression
	// with resultType string).
	Tenant *interface{} `json:"tenant,omitempty"`

	// The URL of the OData service endpoint. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`

	// User name of the OData service. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataLinkedServiceTypeProperties.
func (o *ODataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			if val != nil {
				err = json.Unmarshal(*val, &o.AadResourceID)
			}
		case "aadServicePrincipalCredentialType":
			if val != nil {
				err = json.Unmarshal(*val, &o.AadServicePrincipalCredentialType)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &o.AuthenticationType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
		case "password":
			if val != nil {
				o.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalEmbeddedCert":
			if val != nil {
				o.ServicePrincipalEmbeddedCert, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalEmbeddedCertPassword":
			if val != nil {
				o.ServicePrincipalEmbeddedCertPassword, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &o.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &o.Tenant)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &o.URL)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &o.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Open Data Protocol (OData) resource dataset.
type ODataResourceDataset struct {
	Dataset
	// OData dataset properties.
	TypeProperties *ODataResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataResourceDataset.
func (o ODataResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("ODataResource")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ODataResourceDataset.
func (o *ODataResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.Dataset)
}

// OData dataset properties.
type ODataResourceDatasetTypeProperties struct {
	// The OData resource path. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// Open Database Connectivity (ODBC) linked service.
type OdbcLinkedService struct {
	LinkedService
	// ODBC linked service properties.
	TypeProperties *OdbcLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcLinkedService.
func (o OdbcLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("Odbc")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedService.
func (o *OdbcLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.LinkedService)
}

// ODBC linked service properties.
type OdbcLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the ODBC data store. Possible values are: Anonymous and Basic. Type: string (or
	// Expression with resultType string).
	AuthenticationType *interface{} `json:"authenticationType,omitempty"`

	// The non-access credential portion of the connection string as well as an optional encrypted credential. Type: string, SecureString
	// or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The access credential portion of the connection string specified in driver-specific property-value format.
	Credential SecretBaseClassification `json:"credential,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcLinkedServiceTypeProperties.
func (o *OdbcLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &o.AuthenticationType)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &o.ConnectionString)
			}
		case "credential":
			if val != nil {
				o.Credential, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
		case "password":
			if val != nil {
				o.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &o.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The ODBC table dataset.
type OdbcTableDataset struct {
	Dataset
	// ODBC table dataset properties.
	TypeProperties *OdbcTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OdbcTableDataset.
func (o OdbcTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("OdbcTable")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OdbcTableDataset.
func (o *OdbcTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.Dataset)
}

// ODBC table dataset properties.
type OdbcTableDatasetTypeProperties struct {
	// The ODBC table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// The Office365 account.
type Office365Dataset struct {
	Dataset
	// Office365 dataset properties.
	TypeProperties *Office365DatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Office365Dataset.
func (o Office365Dataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("Office365Table")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365Dataset.
func (o *Office365Dataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.Dataset)
}

// Office365 dataset properties.
type Office365DatasetTypeProperties struct {
	// A predicate expression that can be used to filter the specific rows to extract from Office 365. Type: string (or Expression
	// with resultType string).
	Predicate *interface{} `json:"predicate,omitempty"`

	// Name of the dataset to extract from Office 365. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Office365 linked service.
type Office365LinkedService struct {
	LinkedService
	// Office365 linked service properties.
	TypeProperties *Office365LinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Office365LinkedService.
func (o Office365LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("Office365")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedService.
func (o *Office365LinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.LinkedService)
}

// Office365 linked service properties.
type Office365LinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Azure tenant ID to which the Office 365 account belongs. Type: string (or Expression with resultType string).
	Office365TenantID *interface{} `json:"office365TenantId,omitempty"`

	// Specify the application's client ID. Type: string (or Expression with resultType string).
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// Specify the application's key.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// Specify the tenant information under which your Azure AD web application resides. Type: string (or Expression with resultType
	// string).
	ServicePrincipalTenantID *interface{} `json:"servicePrincipalTenantId,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Office365LinkedServiceTypeProperties.
func (o *Office365LinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
		case "office365TenantId":
			if val != nil {
				err = json.Unmarshal(*val, &o.Office365TenantID)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &o.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				o.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalTenantId":
			if val != nil {
				err = json.Unmarshal(*val, &o.ServicePrincipalTenantID)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Oracle database.
type OracleLinkedService struct {
	LinkedService
	// Oracle database linked service properties.
	TypeProperties *OracleLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleLinkedService.
func (o OracleLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("Oracle")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleLinkedService.
func (o *OracleLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.LinkedService)
}

// Oracle database linked service properties.
type OracleLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// Oracle Service Cloud linked service.
type OracleServiceCloudLinkedService struct {
	LinkedService
	// Oracle Service Cloud linked service properties.
	TypeProperties *OracleServiceCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudLinkedService.
func (o OracleServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := o.LinkedService.marshalInternal("OracleServiceCloud")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedService.
func (o *OracleServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.LinkedService)
}

// Oracle Service Cloud linked service properties.
type OracleServiceCloudLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Oracle Service Cloud instance.
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the username key.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
	// with resultType boolean).
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name that you use to access Oracle Service Cloud server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudLinkedServiceTypeProperties.
func (o *OracleServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &o.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &o.Host)
			}
		case "password":
			if val != nil {
				o.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &o.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &o.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &o.UsePeerVerification)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &o.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Oracle Service Cloud dataset.
type OracleServiceCloudObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleServiceCloudObjectDataset.
func (o OracleServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("OracleServiceCloudObject")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleServiceCloudObjectDataset.
func (o *OracleServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.Dataset)
}

// The on-premises Oracle database dataset.
type OracleTableDataset struct {
	Dataset
	// On-premises Oracle dataset properties.
	TypeProperties *OracleTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleTableDataset.
func (o OracleTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("OracleTable")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleTableDataset.
func (o *OracleTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.Dataset)
}

// On-premises Oracle dataset properties.
type OracleTableDatasetTypeProperties struct {
	// The schema name of the on-premises Oracle database. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the on-premises Oracle database. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// ORC dataset.
type OrcDataset struct {
	Dataset
	// ORC dataset properties.
	TypeProperties *OrcDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OrcDataset.
func (o OrcDataset) MarshalJSON() ([]byte, error) {
	objectMap := o.Dataset.marshalInternal("Orc")
	if o.TypeProperties != nil {
		objectMap["typeProperties"] = o.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDataset.
func (o *OrcDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &o.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &o.Dataset)
}

// ORC dataset properties.
type OrcDatasetTypeProperties struct {
	// The location of the ORC data storage.
	Location            DatasetLocationClassification `json:"location,omitempty"`
	OrcCompressionCodec *OrcCompressionCodec          `json:"orcCompressionCodec,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OrcDatasetTypeProperties.
func (o *OrcDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			if val != nil {
				o.Location, err = unmarshalDatasetLocationClassification(*val)
			}
		case "orcCompressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &o.OrcCompressionCodec)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Definition of a single parameter for an entity.
type ParameterSpecification struct {
	// Default value of parameter.
	DefaultValue *interface{} `json:"defaultValue,omitempty"`

	// Parameter type.
	Type *ParameterType `json:"type,omitempty"`
}

// Parquet dataset.
type ParquetDataset struct {
	Dataset
	// Parquet dataset properties.
	TypeProperties *ParquetDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ParquetDataset.
func (p ParquetDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("Parquet")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDataset.
func (p *ParquetDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.Dataset)
}

// Parquet dataset properties.
type ParquetDatasetTypeProperties struct {
	CompressionCodec *ParquetCompressionCodec `json:"compressionCodec,omitempty"`

	// The location of the parquet storage.
	Location DatasetLocationClassification `json:"location,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ParquetDatasetTypeProperties.
func (p *ParquetDatasetTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compressionCodec":
			if val != nil {
				err = json.Unmarshal(*val, &p.CompressionCodec)
			}
		case "location":
			if val != nil {
				p.Location, err = unmarshalDatasetLocationClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Paypal Service linked service.
type PaypalLinkedService struct {
	LinkedService
	// Paypal Service linked service properties.
	TypeProperties *PaypalLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaypalLinkedService.
func (p PaypalLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("Paypal")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedService.
func (p *PaypalLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.LinkedService)
}

// Paypal Service linked service properties.
type PaypalLinkedServiceTypeProperties struct {
	// The client ID associated with your PayPal application.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with your PayPal application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the PayPal instance. (i.e. api.sandbox.paypal.com)
	Host *interface{} `json:"host,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalLinkedServiceTypeProperties.
func (p *PaypalLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &p.ClientID)
			}
		case "clientSecret":
			if val != nil {
				p.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &p.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &p.Host)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &p.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Paypal Service dataset.
type PaypalObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PaypalObjectDataset.
func (p PaypalObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PaypalObject")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PaypalObjectDataset.
func (p *PaypalObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.Dataset)
}

// Phoenix Dataset Properties
type PhoenixDatasetTypeProperties struct {
	// The schema name of the Phoenix. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Phoenix. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Phoenix server linked service.
type PhoenixLinkedService struct {
	LinkedService
	// Phoenix server linked service properties.
	TypeProperties *PhoenixLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixLinkedService.
func (p PhoenixLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("Phoenix")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedService.
func (p *PhoenixLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.LinkedService)
}

// Phoenix server linked service properties.
type PhoenixLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication mechanism used to connect to the Phoenix server.
	AuthenticationType *PhoenixAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Phoenix server. (i.e. /gateway/sandbox/phoenix/version). The default value is hbasephoenix
	// if using WindowsAzureHDInsightService.
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// The IP address or host name of the Phoenix server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Phoenix server uses to listen for client connections. The default value is 8765.
	Port *interface{} `json:"port,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to connect to the Phoenix server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixLinkedServiceTypeProperties.
func (p *PhoenixLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowHostNameCnMismatch)
			}
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowSelfSignedServerCert)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &p.AuthenticationType)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &p.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &p.EncryptedCredential)
			}
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &p.HTTPPath)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &p.Host)
			}
		case "password":
			if val != nil {
				p.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &p.Port)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &p.TrustedCertPath)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseSystemTrustStore)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &p.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Phoenix server dataset.
type PhoenixObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *PhoenixDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PhoenixObjectDataset.
func (p PhoenixObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PhoenixObject")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PhoenixObjectDataset.
func (p *PhoenixObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.Dataset)
}

// A workspace pipeline.
type Pipeline struct {
	// List of activities in pipeline.
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// List of tags that can be used for describing the Pipeline.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// The max number of concurrent runs for the pipeline.
	Concurrency *int32 `json:"concurrency,omitempty"`

	// The description of the pipeline.
	Description *string `json:"description,omitempty"`

	// The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
	Folder *PipelineFolder `json:"folder,omitempty"`

	// List of parameters for pipeline.
	Parameters *map[string]ParameterSpecification `json:"parameters,omitempty"`

	// Dimensions emitted by Pipeline.
	RunDimensions *map[string]interface{} `json:"runDimensions,omitempty"`

	// List of variables for pipeline.
	Variables *map[string]VariableSpecification `json:"variables,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Pipeline.
func (p *Pipeline) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				p.Activities, err = unmarshalActivityClassificationArray(*val)
			}
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &p.Annotations)
			}
		case "concurrency":
			if val != nil {
				err = json.Unmarshal(*val, &p.Concurrency)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &p.Description)
			}
		case "folder":
			if val != nil {
				err = json.Unmarshal(*val, &p.Folder)
			}
		case "parameters":
			if val != nil {
				err = json.Unmarshal(*val, &p.Parameters)
			}
		case "runDimensions":
			if val != nil {
				err = json.Unmarshal(*val, &p.RunDimensions)
			}
		case "variables":
			if val != nil {
				err = json.Unmarshal(*val, &p.Variables)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineCreateOrUpdatePipelineOptions contains the optional parameters for the Pipeline.CreateOrUpdatePipeline method.
type PipelineCreateOrUpdatePipelineOptions struct {
	// ETag of the pipeline entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// PipelineCreatePipelineRunOptions contains the optional parameters for the Pipeline.CreatePipelineRun method.
type PipelineCreatePipelineRunOptions struct {
	// Recovery mode flag. If recovery mode is set to true, the specified referenced pipeline run and the new run will be grouped
	// under the same groupId.
	IsRecovery *bool
	// Parameters of the pipeline run. These parameters will be used only if the runId is not specified.
	Parameters *map[string]interface{}
	// The pipeline run identifier. If run ID is specified the parameters of the specified run will be used to create a new run.
	ReferencePipelineRunId *string
	// In recovery mode, the rerun will start from this activity. If not specified, all activities will run.
	StartActivityName *string
}

// The folder that this Pipeline is in. If not specified, Pipeline will appear at the root level.
type PipelineFolder struct {
	// The name of the folder that this Pipeline is in.
	Name *string `json:"name,omitempty"`
}

// PipelineGetPipelineOptions contains the optional parameters for the Pipeline.GetPipeline method.
type PipelineGetPipelineOptions struct {
	// ETag of the pipeline entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// A list of pipeline resources.
type PipelineListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of pipelines.
	Value *[]PipelineResource `json:"value,omitempty"`
}

// PipelineListResponseResponse is the response envelope for operations that return a PipelineListResponse type.
type PipelineListResponseResponse struct {
	// A list of pipeline resources.
	PipelineListResponse *PipelineListResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Pipeline reference type.
type PipelineReference struct {
	// Reference name.
	Name *string `json:"name,omitempty"`

	// Reference pipeline name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Pipeline reference type.
	Type *string `json:"type,omitempty"`
}

// Pipeline resource type.
type PipelineResource struct {
	SubResource
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Properties of the pipeline.
	Properties *Pipeline `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineResource.
func (p PipelineResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ID != nil {
		objectMap["id"] = p.ID
	}
	if p.Name != nil {
		objectMap["name"] = p.Name
	}
	if p.Type != nil {
		objectMap["type"] = p.Type
	}
	if p.Etag != nil {
		objectMap["etag"] = p.Etag
	}
	if p.Properties != nil {
		objectMap["properties"] = p.Properties
	}
	if p.AdditionalProperties != nil {
		for key, val := range *p.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineResource.
func (p *PipelineResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			if val != nil {
				err = json.Unmarshal(*val, &p.ID)
			}
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &p.Name)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &p.Type)
			}
		case "etag":
			if val != nil {
				err = json.Unmarshal(*val, &p.Etag)
			}
		case "properties":
			if val != nil {
				err = json.Unmarshal(*val, &p.Properties)
			}
		default:
			if p.AdditionalProperties == nil {
				p.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*p.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PipelineResourcePollerResponse is the response envelope for operations that asynchronously return a PipelineResource type.
type PipelineResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*PipelineResourceResponse, error)

	// Poller contains an initialized poller.
	Poller PipelineResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineResourceResponse is the response envelope for operations that return a PipelineResource type.
type PipelineResourceResponse struct {
	// Pipeline resource type.
	PipelineResource *PipelineResource

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Information about a pipeline run.
type PipelineRun struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The duration of a pipeline run.
	DurationInMS *int32 `json:"durationInMs,omitempty" azure:"ro"`

	// Entity that started the pipeline run.
	InvokedBy *PipelineRunInvokedBy `json:"invokedBy,omitempty" azure:"ro"`

	// Indicates if the recovered pipeline run is the latest in its group.
	IsLatest *bool `json:"isLatest,omitempty" azure:"ro"`

	// The last updated timestamp for the pipeline run event in ISO8601 format.
	LastUpdated *time.Time `json:"lastUpdated,omitempty" azure:"ro"`

	// The message from a pipeline run.
	Message *string `json:"message,omitempty" azure:"ro"`

	// The full or partial list of parameter name, value pair used in the pipeline run.
	Parameters *map[string]string `json:"parameters,omitempty" azure:"ro"`

	// The pipeline name.
	PipelineName *string `json:"pipelineName,omitempty" azure:"ro"`

	// The end time of a pipeline run in ISO8601 format.
	RunEnd *time.Time `json:"runEnd,omitempty" azure:"ro"`

	// Identifier that correlates all the recovery runs of a pipeline run.
	RunGroupID *string `json:"runGroupId,omitempty" azure:"ro"`

	// Identifier of a run.
	RunID *string `json:"runId,omitempty" azure:"ro"`

	// The start time of a pipeline run in ISO8601 format.
	RunStart *time.Time `json:"runStart,omitempty" azure:"ro"`

	// The status of a pipeline run.
	Status *string `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PipelineRun.
func (p PipelineRun) MarshalJSON() ([]byte, error) {
	type alias PipelineRun
	aux := &struct {
		*alias
		AdditionalProperties *map[string]string `json:"AdditionalProperties"`
		LastUpdated          *timeRFC3339       `json:"lastUpdated"`
		RunEnd               *timeRFC3339       `json:"runEnd"`
		RunStart             *timeRFC3339       `json:"runStart"`
	}{
		alias:       (*alias)(&p),
		LastUpdated: (*timeRFC3339)(p.LastUpdated),
		RunEnd:      (*timeRFC3339)(p.RunEnd),
		RunStart:    (*timeRFC3339)(p.RunStart),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PipelineRun.
func (p *PipelineRun) UnmarshalJSON(data []byte) error {
	type alias PipelineRun
	aux := &struct {
		*alias
		AdditionalProperties *map[string]string `json:"AdditionalProperties"`
		LastUpdated          *timeRFC3339       `json:"lastUpdated"`
		RunEnd               *timeRFC3339       `json:"runEnd"`
		RunStart             *timeRFC3339       `json:"runStart"`
	}{
		alias: (*alias)(p),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	p.AdditionalProperties = (*map[string]string)(aux.AdditionalProperties)
	p.LastUpdated = (*time.Time)(aux.LastUpdated)
	p.RunEnd = (*time.Time)(aux.RunEnd)
	p.RunStart = (*time.Time)(aux.RunStart)
	return nil
}

// PipelineRunCancelPipelineRunOptions contains the optional parameters for the PipelineRun.CancelPipelineRun method.
type PipelineRunCancelPipelineRunOptions struct {
	// If true, cancel all the Child pipelines that are triggered by the current pipeline.
	IsRecursive *bool
}

// Provides entity name and id that started the pipeline run.
type PipelineRunInvokedBy struct {
	// The ID of the entity that started the run.
	ID *string `json:"id,omitempty" azure:"ro"`

	// The type of the entity that started the run.
	InvokedByType *string `json:"invokedByType,omitempty" azure:"ro"`

	// Name of the entity that started the pipeline run.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// PipelineRunResponse is the response envelope for operations that return a PipelineRun type.
type PipelineRunResponse struct {
	// Information about a pipeline run.
	PipelineRun *PipelineRun

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// A list pipeline runs.
type PipelineRunsQueryResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of pipeline runs.
	Value *[]PipelineRun `json:"value,omitempty"`
}

// PipelineRunsQueryResponseResponse is the response envelope for operations that return a PipelineRunsQueryResponse type.
type PipelineRunsQueryResponseResponse struct {
	// A list pipeline runs.
	PipelineRunsQueryResponse *PipelineRunsQueryResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// Linked service for PostgreSQL data source.
type PostgreSQLLinkedService struct {
	LinkedService
	// PostgreSQL linked service properties.
	TypeProperties *PostgreSQLLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLLinkedService.
func (p PostgreSQLLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("PostgreSql")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLLinkedService.
func (p *PostgreSQLLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.LinkedService)
}

// PostgreSQL linked service properties.
type PostgreSQLLinkedServiceTypeProperties struct {
	// The connection string.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Password *AzureKeyVaultSecretReference `json:"password,omitempty"`
}

// The PostgreSQL table dataset.
type PostgreSQLTableDataset struct {
	Dataset
	// PostgreSQL table dataset properties.
	TypeProperties *PostgreSQLTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLTableDataset.
func (p PostgreSQLTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PostgreSqlTable")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLTableDataset.
func (p *PostgreSQLTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.Dataset)
}

// PostgreSQL table dataset properties.
type PostgreSQLTableDatasetTypeProperties struct {
	// The PostgreSQL schema name. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The PostgreSQL table name. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Presto Dataset Properties
type PrestoDatasetTypeProperties struct {
	// The schema name of the Presto. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Presto. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Presto server linked service.
type PrestoLinkedService struct {
	LinkedService
	// Presto server linked service properties.
	TypeProperties *PrestoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrestoLinkedService.
func (p PrestoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := p.LinkedService.marshalInternal("Presto")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedService.
func (p *PrestoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.LinkedService)
}

// Presto server linked service properties.
type PrestoLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication mechanism used to connect to the Presto server.
	AuthenticationType *PrestoAuthenticationType `json:"authenticationType,omitempty"`

	// The catalog context for all request against the server.
	Catalog *interface{} `json:"catalog,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The IP address or host name of the Presto server. (i.e. 192.168.222.160)
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Presto server uses to listen for client connections. The default value is 8080.
	Port *interface{} `json:"port,omitempty"`

	// The version of the Presto server. (i.e. 0.148-t)
	ServerVersion *interface{} `json:"serverVersion,omitempty"`

	// The local time zone used by the connection. Valid values for this option are specified in the IANA Time Zone Database.
	// The default value is the system time zone.
	TimeZoneID *interface{} `json:"timeZoneID,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name used to connect to the Presto server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoLinkedServiceTypeProperties.
func (p *PrestoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowHostNameCnMismatch)
			}
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &p.AllowSelfSignedServerCert)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &p.AuthenticationType)
			}
		case "catalog":
			if val != nil {
				err = json.Unmarshal(*val, &p.Catalog)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &p.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &p.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &p.Host)
			}
		case "password":
			if val != nil {
				p.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &p.Port)
			}
		case "serverVersion":
			if val != nil {
				err = json.Unmarshal(*val, &p.ServerVersion)
			}
		case "timeZoneID":
			if val != nil {
				err = json.Unmarshal(*val, &p.TimeZoneID)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &p.TrustedCertPath)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &p.UseSystemTrustStore)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &p.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Presto server dataset.
type PrestoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *PrestoDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrestoObjectDataset.
func (p PrestoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := p.Dataset.marshalInternal("PrestoObject")
	if p.TypeProperties != nil {
		objectMap["typeProperties"] = p.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PrestoObjectDataset.
func (p *PrestoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &p.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &p.Dataset)
}

// A list of active debug sessions.
type QueryDataFlowDebugSessionsResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// Array with all active debug sessions.
	Value *[]DataFlowDebugSessionInfo `json:"value,omitempty"`
}

// QueryDataFlowDebugSessionsResponseResponse is the response envelope for operations that return a QueryDataFlowDebugSessionsResponse
// type.
type QueryDataFlowDebugSessionsResponseResponse struct {
	// A list of active debug sessions.
	QueryDataFlowDebugSessionsResponse *QueryDataFlowDebugSessionsResponse

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// QuickBooks server linked service.
type QuickBooksLinkedService struct {
	LinkedService
	// QuickBooks server linked service properties.
	TypeProperties *QuickBooksLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksLinkedService.
func (q QuickBooksLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := q.LinkedService.marshalInternal("QuickBooks")
	if q.TypeProperties != nil {
		objectMap["typeProperties"] = q.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedService.
func (q *QuickBooksLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &q.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &q.LinkedService)
}

// QuickBooks server linked service properties.
type QuickBooksLinkedServiceTypeProperties struct {
	// The access token for OAuth 1.0 authentication.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The access token secret for OAuth 1.0 authentication.
	AccessTokenSecret SecretBaseClassification `json:"accessTokenSecret,omitempty"`

	// The company ID of the QuickBooks company to authorize.
	CompanyID *interface{} `json:"companyId,omitempty"`

	// The consumer key for OAuth 1.0 authentication.
	ConsumerKey *interface{} `json:"consumerKey,omitempty"`

	// The consumer secret for OAuth 1.0 authentication.
	ConsumerSecret SecretBaseClassification `json:"consumerSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the QuickBooks server. (i.e. quickbooks.api.intuit.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksLinkedServiceTypeProperties.
func (q *QuickBooksLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				q.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "accessTokenSecret":
			if val != nil {
				q.AccessTokenSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "companyId":
			if val != nil {
				err = json.Unmarshal(*val, &q.CompanyID)
			}
		case "consumerKey":
			if val != nil {
				err = json.Unmarshal(*val, &q.ConsumerKey)
			}
		case "consumerSecret":
			if val != nil {
				q.ConsumerSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &q.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &q.Endpoint)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &q.UseEncryptedEndpoints)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QuickBooks server dataset.
type QuickBooksObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuickBooksObjectDataset.
func (q QuickBooksObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := q.Dataset.marshalInternal("QuickBooksObject")
	if q.TypeProperties != nil {
		objectMap["typeProperties"] = q.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuickBooksObjectDataset.
func (q *QuickBooksObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &q.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &q.Dataset)
}

// Redirect incompatible row settings
type RedirectIncompatibleRowSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Name of the Azure Storage, Storage SAS, or Azure Data Lake Store linked service used for redirecting incompatible row.
	// Must be specified if redirectIncompatibleRowSettings is specified. Type: string (or Expression with resultType string).
	LinkedServiceName *interface{} `json:"linkedServiceName,omitempty"`

	// The path for storing the redirect incompatible row data. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RedirectIncompatibleRowSettings.
func (r RedirectIncompatibleRowSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = r.LinkedServiceName
	}
	if r.Path != nil {
		objectMap["path"] = r.Path
	}
	if r.AdditionalProperties != nil {
		for key, val := range *r.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RedirectIncompatibleRowSettings.
func (r *RedirectIncompatibleRowSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &r.LinkedServiceName)
			}
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &r.Path)
			}
		default:
			if r.AdditionalProperties == nil {
				r.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*r.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The relational table dataset.
type RelationalTableDataset struct {
	Dataset
	// Relational table dataset properties.
	TypeProperties *RelationalTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RelationalTableDataset.
func (r RelationalTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := r.Dataset.marshalInternal("RelationalTable")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationalTableDataset.
func (r *RelationalTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.Dataset)
}

// Relational table dataset properties.
type RelationalTableDatasetTypeProperties struct {
	// The relational table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// A list of rerun triggers.
type RerunTriggerListResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// List of rerun triggers.
	Value *[]RerunTriggerResource `json:"value,omitempty"`
}

// RerunTrigger resource type.
type RerunTriggerResource struct {
	SubResource
	// Properties of the rerun trigger.
	Properties *RerunTumblingWindowTrigger `json:"properties,omitempty"`
}

// Trigger that schedules pipeline reruns for all fixed time interval windows from a requested start time to requested end
// time.
type RerunTumblingWindowTrigger struct {
	Trigger
	// Rerun Trigger properties.
	TypeProperties *RerunTumblingWindowTriggerTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTrigger.
func (r RerunTumblingWindowTrigger) MarshalJSON() ([]byte, error) {
	objectMap := r.Trigger.marshalInternal("RerunTumblingWindowTrigger")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTrigger.
func (r *RerunTumblingWindowTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.Trigger)
}

// Rerun tumbling window trigger Parameters.
type RerunTumblingWindowTriggerActionParameters struct {
	// The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The max number of parallel time windows (ready for execution) for which a rerun is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTriggerActionParameters.
func (r RerunTumblingWindowTriggerActionParameters) MarshalJSON() ([]byte, error) {
	type alias RerunTumblingWindowTriggerActionParameters
	aux := &struct {
		*alias
		EndTime   *timeRFC3339 `json:"endTime"`
		StartTime *timeRFC3339 `json:"startTime"`
	}{
		alias:     (*alias)(&r),
		EndTime:   (*timeRFC3339)(r.EndTime),
		StartTime: (*timeRFC3339)(r.StartTime),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTriggerActionParameters.
func (r *RerunTumblingWindowTriggerActionParameters) UnmarshalJSON(data []byte) error {
	type alias RerunTumblingWindowTriggerActionParameters
	aux := &struct {
		*alias
		EndTime   *timeRFC3339 `json:"endTime"`
		StartTime *timeRFC3339 `json:"startTime"`
	}{
		alias: (*alias)(r),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	r.EndTime = (*time.Time)(aux.EndTime)
	r.StartTime = (*time.Time)(aux.StartTime)
	return nil
}

// Rerun Trigger properties.
type RerunTumblingWindowTriggerTypeProperties struct {
	// The max number of parallel time windows (ready for execution) for which a rerun is triggered.
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// The parent trigger reference.
	ParentTrigger *interface{} `json:"parentTrigger,omitempty"`

	// The end time for the time period for which restatement is initiated. Only UTC time is currently supported.
	RequestedEndTime *time.Time `json:"requestedEndTime,omitempty"`

	// The start time for the time period for which restatement is initiated. Only UTC time is currently supported.
	RequestedStartTime *time.Time `json:"requestedStartTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r RerunTumblingWindowTriggerTypeProperties) MarshalJSON() ([]byte, error) {
	type alias RerunTumblingWindowTriggerTypeProperties
	aux := &struct {
		*alias
		RequestedEndTime   *timeRFC3339 `json:"requestedEndTime"`
		RequestedStartTime *timeRFC3339 `json:"requestedStartTime"`
	}{
		alias:              (*alias)(&r),
		RequestedEndTime:   (*timeRFC3339)(r.RequestedEndTime),
		RequestedStartTime: (*timeRFC3339)(r.RequestedStartTime),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RerunTumblingWindowTriggerTypeProperties.
func (r *RerunTumblingWindowTriggerTypeProperties) UnmarshalJSON(data []byte) error {
	type alias RerunTumblingWindowTriggerTypeProperties
	aux := &struct {
		*alias
		RequestedEndTime   *timeRFC3339 `json:"requestedEndTime"`
		RequestedStartTime *timeRFC3339 `json:"requestedStartTime"`
	}{
		alias: (*alias)(r),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	r.RequestedEndTime = (*time.Time)(aux.RequestedEndTime)
	r.RequestedStartTime = (*time.Time)(aux.RequestedStartTime)
	return nil
}

// Azure Synapse top-level resource.
type Resource struct {
	// Etag identifies change in the resource.
	ETag *string `json:"eTag,omitempty" azure:"ro"`

	// The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// The resource location.
	Location *string `json:"location,omitempty"`

	// The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// The resource tags.
	Tags *map[string]string `json:"tags,omitempty"`

	// The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// Responsys linked service.
type ResponsysLinkedService struct {
	LinkedService
	// Responsys linked service properties.
	TypeProperties *ResponsysLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysLinkedService.
func (r ResponsysLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := r.LinkedService.marshalInternal("Responsys")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedService.
func (r *ResponsysLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.LinkedService)
}

// Responsys linked service properties.
type ResponsysLinkedServiceTypeProperties struct {
	// The client ID associated with the Responsys application. Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with the Responsys application. Type: string (or Expression with resultType string).
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Responsys server.
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
	// with resultType boolean).
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysLinkedServiceTypeProperties.
func (r *ResponsysLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &r.ClientID)
			}
		case "clientSecret":
			if val != nil {
				r.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &r.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &r.Endpoint)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &r.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &r.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &r.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Responsys dataset.
type ResponsysObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResponsysObjectDataset.
func (r ResponsysObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := r.Dataset.marshalInternal("ResponsysObject")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResponsysObjectDataset.
func (r *ResponsysObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.Dataset)
}

// A Rest service dataset.
type RestResourceDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *RestResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestResourceDataset.
func (r RestResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := r.Dataset.marshalInternal("RestResource")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestResourceDataset.
func (r *RestResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.Dataset)
}

// Properties specific to this dataset type.
type RestResourceDatasetTypeProperties struct {
	// The additional HTTP headers in the request to the RESTful API. Type: string (or Expression with resultType string).
	AdditionalHeaders *interface{} `json:"additionalHeaders,omitempty"`

	// The pagination rules to compose next page requests. Type: string (or Expression with resultType string).
	PaginationRules *interface{} `json:"paginationRules,omitempty"`

	// The relative URL to the resource that the RESTful API provides. Type: string (or Expression with resultType string).
	RelativeURL *interface{} `json:"relativeUrl,omitempty"`

	// The HTTP request body to the RESTful API if requestMethod is POST. Type: string (or Expression with resultType string).
	RequestBody *interface{} `json:"requestBody,omitempty"`

	// The HTTP method used to call the RESTful API. The default is GET. Type: string (or Expression with resultType string).
	RequestMethod *interface{} `json:"requestMethod,omitempty"`
}

// Rest Service linked service.
type RestServiceLinkedService struct {
	LinkedService
	// Rest Service linked service properties.
	TypeProperties *RestServiceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RestServiceLinkedService.
func (r RestServiceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := r.LinkedService.marshalInternal("RestService")
	if r.TypeProperties != nil {
		objectMap["typeProperties"] = r.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedService.
func (r *RestServiceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &r.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &r.LinkedService)
}

// Rest Service linked service properties.
type RestServiceLinkedServiceTypeProperties struct {
	// The resource you are requesting authorization to use.
	AadResourceID *interface{} `json:"aadResourceId,omitempty"`

	// Type of authentication used to connect to the REST service.
	AuthenticationType *RestServiceAuthenticationType `json:"authenticationType,omitempty"`

	// Whether to validate server side SSL certificate when connecting to the endpoint.The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	EnableServerCertificateValidation *interface{} `json:"enableServerCertificateValidation,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password used in Basic authentication type.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The application's client ID used in AadServicePrincipal authentication type.
	ServicePrincipalID *interface{} `json:"servicePrincipalId,omitempty"`

	// The application's key used in AadServicePrincipal authentication type.
	ServicePrincipalKey SecretBaseClassification `json:"servicePrincipalKey,omitempty"`

	// The tenant information (domain name or tenant ID) used in AadServicePrincipal authentication type under which your application
	// resides.
	Tenant *interface{} `json:"tenant,omitempty"`

	// The base URL of the REST service.
	URL *interface{} `json:"url,omitempty"`

	// The user name used in Basic authentication type.
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestServiceLinkedServiceTypeProperties.
func (r *RestServiceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "aadResourceId":
			if val != nil {
				err = json.Unmarshal(*val, &r.AadResourceID)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &r.AuthenticationType)
			}
		case "enableServerCertificateValidation":
			if val != nil {
				err = json.Unmarshal(*val, &r.EnableServerCertificateValidation)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &r.EncryptedCredential)
			}
		case "password":
			if val != nil {
				r.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "servicePrincipalId":
			if val != nil {
				err = json.Unmarshal(*val, &r.ServicePrincipalID)
			}
		case "servicePrincipalKey":
			if val != nil {
				r.ServicePrincipalKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "tenant":
			if val != nil {
				err = json.Unmarshal(*val, &r.Tenant)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &r.URL)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &r.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Query parameters for listing runs.
type RunFilterParameters struct {
	// The continuation token for getting the next page of results. Null for first page.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of filters.
	Filters *[]RunQueryFilter `json:"filters,omitempty"`

	// The time at or after which the run event was updated in 'ISO 8601' format.
	LastUpdatedAfter *time.Time `json:"lastUpdatedAfter,omitempty"`

	// The time at or before which the run event was updated in 'ISO 8601' format.
	LastUpdatedBefore *time.Time `json:"lastUpdatedBefore,omitempty"`

	// List of OrderBy option.
	OrderBy *[]RunQueryOrderBy `json:"orderBy,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunFilterParameters.
func (r RunFilterParameters) MarshalJSON() ([]byte, error) {
	type alias RunFilterParameters
	aux := &struct {
		*alias
		LastUpdatedAfter  *timeRFC3339 `json:"lastUpdatedAfter"`
		LastUpdatedBefore *timeRFC3339 `json:"lastUpdatedBefore"`
	}{
		alias:             (*alias)(&r),
		LastUpdatedAfter:  (*timeRFC3339)(r.LastUpdatedAfter),
		LastUpdatedBefore: (*timeRFC3339)(r.LastUpdatedBefore),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RunFilterParameters.
func (r *RunFilterParameters) UnmarshalJSON(data []byte) error {
	type alias RunFilterParameters
	aux := &struct {
		*alias
		LastUpdatedAfter  *timeRFC3339 `json:"lastUpdatedAfter"`
		LastUpdatedBefore *timeRFC3339 `json:"lastUpdatedBefore"`
	}{
		alias: (*alias)(r),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	r.LastUpdatedAfter = (*time.Time)(aux.LastUpdatedAfter)
	r.LastUpdatedBefore = (*time.Time)(aux.LastUpdatedBefore)
	return nil
}

// Query filter option for listing runs.
type RunQueryFilter struct {
	// Parameter name to be used for filter. The allowed operands to query pipeline runs are PipelineName, RunStart, RunEnd and
	// Status; to query activity runs are ActivityName, ActivityRunStart, ActivityRunEnd, ActivityType and Status, and to query
	// trigger runs are TriggerName, TriggerRunTimestamp and Status.
	Operand *RunQueryFilterOperand `json:"operand,omitempty"`

	// Operator to be used for filter.
	Operator *RunQueryFilterOperator `json:"operator,omitempty"`

	// List of filter values.
	Values *[]string `json:"values,omitempty"`
}

// An object to provide order by options for listing runs.
type RunQueryOrderBy struct {
	// Sorting order of the parameter.
	Order *RunQueryOrder `json:"order,omitempty"`

	// Parameter name to be used for order by. The allowed parameters to order by for pipeline runs are PipelineName, RunStart,
	// RunEnd and Status; for activity runs are ActivityName, ActivityRunStart, ActivityRunEnd and Status; for trigger runs are
	// TriggerName, TriggerRunTimestamp and Status.
	OrderBy *RunQueryOrderByField `json:"orderBy,omitempty"`
}

// The connection used to execute the SQL script.
type SQLConnection struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The identifier of the connection.
	Name *string `json:"name,omitempty"`

	// The type of the connection.
	Type *SqlConnectionType `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLConnection.
func (s SQLConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	if s.Type != nil {
		objectMap["type"] = s.Type
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLConnection.
func (s *SQLConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &s.Name)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQL pool reference type.
type SQLPoolReference struct {
	// Reference SQL pool name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// SQL pool reference type.
	Type *string `json:"type,omitempty"`
}

// Execute SQL pool stored procedure activity.
type SQLPoolStoredProcedureActivity struct {
	Activity
	// SQL pool stored procedure reference.
	SQLPool *SQLPoolReference `json:"sqlPool,omitempty"`

	// Execute SQL pool stored procedure activity properties.
	TypeProperties *SQLPoolStoredProcedureActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLPoolStoredProcedureActivity.
func (s SQLPoolStoredProcedureActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SqlPoolStoredProcedure")
	if s.SQLPool != nil {
		objectMap["sqlPool"] = s.SQLPool
	}
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLPoolStoredProcedureActivity.
func (s *SQLPoolStoredProcedureActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sqlPool":
			if val != nil {
				err = json.Unmarshal(*val, &s.SQLPool)
			}
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Activity)
}

// SQL stored procedure activity properties.
type SQLPoolStoredProcedureActivityTypeProperties struct {
	// Stored procedure name. Type: string (or Expression with resultType string).
	StoredProcedureName *interface{} `json:"storedProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// SQL script.
type SQLScript struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The content of the SQL script.
	Content *SQLScriptContent `json:"content,omitempty"`

	// The description of the SQL script.
	Description *string `json:"description,omitempty"`

	// The type of the SQL script.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLScript.
func (s SQLScript) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Content != nil {
		objectMap["content"] = s.Content
	}
	if s.Description != nil {
		objectMap["description"] = s.Description
	}
	if s.Type != nil {
		objectMap["type"] = s.Type
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLScript.
func (s *SQLScript) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
			if val != nil {
				err = json.Unmarshal(*val, &s.Content)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &s.Description)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The content of the SQL script.
type SQLScriptContent struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The connection used to execute the SQL script.
	CurrentConnection *SQLConnection `json:"currentConnection,omitempty"`

	// The metadata of the SQL script.
	Metadata *SQLScriptMetadata `json:"metadata,omitempty"`

	// SQL query to execute.
	Query *string `json:"query,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLScriptContent.
func (s SQLScriptContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.CurrentConnection != nil {
		objectMap["currentConnection"] = s.CurrentConnection
	}
	if s.Metadata != nil {
		objectMap["metadata"] = s.Metadata
	}
	if s.Query != nil {
		objectMap["query"] = s.Query
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLScriptContent.
func (s *SQLScriptContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentConnection":
			if val != nil {
				err = json.Unmarshal(*val, &s.CurrentConnection)
			}
		case "metadata":
			if val != nil {
				err = json.Unmarshal(*val, &s.Metadata)
			}
		case "query":
			if val != nil {
				err = json.Unmarshal(*val, &s.Query)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLScriptCreateOrUpdateSQLScriptOptions contains the optional parameters for the SQLScript.CreateOrUpdateSQLScript method.
type SQLScriptCreateOrUpdateSQLScriptOptions struct {
	// ETag of the SQL script entity. Should only be specified for update, for which it should match existing entity or can be
	// * for unconditional update.
	IfMatch *string
}

// SQLScriptGetSQLScriptOptions contains the optional parameters for the SQLScript.GetSQLScript method.
type SQLScriptGetSQLScriptOptions struct {
	// ETag of the sql compute entity. Should only be specified for get. If the ETag matches the existing entity tag, or if *
	// was provided, then no content will be returned.
	IfNoneMatch *string
}

// The metadata of the SQL script.
type SQLScriptMetadata struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The language of the SQL script.
	Language *string `json:"language,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLScriptMetadata.
func (s SQLScriptMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Language != nil {
		objectMap["language"] = s.Language
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLScriptMetadata.
func (s *SQLScriptMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Sql Script resource type.
type SQLScriptResource struct {
	SubResource
	// Properties of sql script.
	Properties *SQLScript `json:"properties,omitempty"`
}

// SQLScriptResourceResponse is the response envelope for operations that return a SQLScriptResource type.
type SQLScriptResourceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Sql Script resource type.
	SQLScriptResource *SQLScriptResource
}

// A list of sql scripts resources.
type SQLScriptsListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of sql scripts.
	Value *[]SQLScriptResource `json:"value,omitempty"`
}

// SQLScriptsListResponseResponse is the response envelope for operations that return a SQLScriptsListResponse type.
type SQLScriptsListResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of sql scripts resources.
	SQLScriptsListResponse *SQLScriptsListResponse
}

// SQL Server linked service.
type SQLServerLinkedService struct {
	LinkedService
	// SQL Server linked service properties.
	TypeProperties *SQLServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerLinkedService.
func (s SQLServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SqlServer")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedService.
func (s *SQLServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// SQL Server linked service properties.
type SQLServerLinkedServiceTypeProperties struct {
	// The connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The on-premises Windows authentication password.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The on-premises Windows authentication user name. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerLinkedServiceTypeProperties.
func (s *SQLServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &s.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQL stored procedure activity type.
type SQLServerStoredProcedureActivity struct {
	ExecutionActivity
	// SQL stored procedure activity properties.
	TypeProperties *SQLServerStoredProcedureActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerStoredProcedureActivity.
func (s SQLServerStoredProcedureActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.ExecutionActivity.marshalInternal("SqlServerStoredProcedure")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerStoredProcedureActivity.
func (s *SQLServerStoredProcedureActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.ExecutionActivity)
}

// SQL stored procedure activity properties.
type SQLServerStoredProcedureActivityTypeProperties struct {
	// Stored procedure name. Type: string (or Expression with resultType string).
	StoredProcedureName *interface{} `json:"storedProcedureName,omitempty"`

	// Value and type setting for stored procedure parameters. Example: "{Parameter1: {value: "1", type: "int"}}".
	StoredProcedureParameters *map[string]StoredProcedureParameter `json:"storedProcedureParameters,omitempty"`
}

// The on-premises SQL Server dataset.
type SQLServerTableDataset struct {
	Dataset
	// On-premises SQL Server dataset properties.
	TypeProperties *SQLServerTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerTableDataset.
func (s SQLServerTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SqlServerTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLServerTableDataset.
func (s *SQLServerTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// On-premises SQL Server dataset properties.
type SQLServerTableDatasetTypeProperties struct {
	// The schema name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the SQL Server dataset. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Linked service for Salesforce.
type SalesforceLinkedService struct {
	LinkedService
	// Salesforce linked service properties.
	TypeProperties *SalesforceLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceLinkedService.
func (s SalesforceLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Salesforce")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedService.
func (s *SalesforceLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Salesforce linked service properties.
type SalesforceLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of Salesforce instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify 'https://test.salesforce.com'.
	// To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'. Type: string (or Expression
	// with resultType string).
	EnvironmentURL *interface{} `json:"environmentUrl,omitempty"`

	// The password for Basic authentication of the Salesforce instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The security token is required to remotely access Salesforce instance.
	SecurityToken SecretBaseClassification `json:"securityToken,omitempty"`

	// The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceLinkedServiceTypeProperties.
func (s *SalesforceLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "environmentUrl":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnvironmentURL)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "securityToken":
			if val != nil {
				s.SecurityToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Salesforce Marketing Cloud linked service.
type SalesforceMarketingCloudLinkedService struct {
	LinkedService
	// Salesforce Marketing Cloud linked service properties.
	TypeProperties *SalesforceMarketingCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudLinkedService.
func (s SalesforceMarketingCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SalesforceMarketingCloud")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedService.
func (s *SalesforceMarketingCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Salesforce Marketing Cloud linked service properties.
type SalesforceMarketingCloudLinkedServiceTypeProperties struct {
	// The client ID associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with the Salesforce Marketing Cloud application. Type: string (or Expression with resultType
	// string).
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
	// with resultType boolean).
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true. Type: boolean (or Expression with resultType boolean).
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true. Type: boolean
	// (or Expression with resultType boolean).
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudLinkedServiceTypeProperties.
func (s *SalesforceMarketingCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
		case "clientSecret":
			if val != nil {
				s.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Salesforce Marketing Cloud dataset.
type SalesforceMarketingCloudObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s SalesforceMarketingCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SalesforceMarketingCloudObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceMarketingCloudObjectDataset.
func (s *SalesforceMarketingCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// The Salesforce object dataset.
type SalesforceObjectDataset struct {
	Dataset
	// Salesforce object dataset properties.
	TypeProperties *SalesforceObjectDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceObjectDataset.
func (s SalesforceObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SalesforceObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceObjectDataset.
func (s *SalesforceObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Salesforce object dataset properties.
type SalesforceObjectDatasetTypeProperties struct {
	// The Salesforce object API name. Type: string (or Expression with resultType string).
	ObjectAPIName *interface{} `json:"objectApiName,omitempty"`
}

// Linked service for Salesforce Service Cloud.
type SalesforceServiceCloudLinkedService struct {
	LinkedService
	// Salesforce Service Cloud linked service properties.
	TypeProperties *SalesforceServiceCloudLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudLinkedService.
func (s SalesforceServiceCloudLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SalesforceServiceCloud")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedService.
func (s *SalesforceServiceCloudLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Salesforce Service Cloud linked service properties.
type SalesforceServiceCloudLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of Salesforce Service Cloud instance. Default is 'https://login.salesforce.com'. To copy data from sandbox, specify
	// 'https://test.salesforce.com'. To copy data from custom domain, specify, for example, 'https://[domain].my.salesforce.com'.
	// Type: string (or Expression with resultType string).
	EnvironmentURL *interface{} `json:"environmentUrl,omitempty"`

	// Extended properties appended to the connection string. Type: string (or Expression with resultType string).
	ExtendedProperties *interface{} `json:"extendedProperties,omitempty"`

	// The password for Basic authentication of the Salesforce instance.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The security token is required to remotely access Salesforce instance.
	SecurityToken SecretBaseClassification `json:"securityToken,omitempty"`

	// The username for Basic authentication of the Salesforce instance. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudLinkedServiceTypeProperties.
func (s *SalesforceServiceCloudLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "environmentUrl":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnvironmentURL)
			}
		case "extendedProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExtendedProperties)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "securityToken":
			if val != nil {
				s.SecurityToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Salesforce Service Cloud object dataset.
type SalesforceServiceCloudObjectDataset struct {
	Dataset
	// Salesforce Service Cloud object dataset properties.
	TypeProperties *SalesforceServiceCloudObjectDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SalesforceServiceCloudObjectDataset.
func (s SalesforceServiceCloudObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SalesforceServiceCloudObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SalesforceServiceCloudObjectDataset.
func (s *SalesforceServiceCloudObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Salesforce Service Cloud object dataset properties.
type SalesforceServiceCloudObjectDatasetTypeProperties struct {
	// The Salesforce Service Cloud object API name. Type: string (or Expression with resultType string).
	ObjectAPIName *interface{} `json:"objectApiName,omitempty"`
}

// The SAP BW cube dataset.
type SapBwCubeDataset struct {
	Dataset
}

// MarshalJSON implements the json.Marshaller interface for type SapBwCubeDataset.
func (s SapBwCubeDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapBwCube")
	return json.Marshal(objectMap)
}

// SAP Business Warehouse Linked Service.
type SapBwLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SapBwLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapBwLinkedService.
func (s SapBwLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapBW")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwLinkedService.
func (s *SapBwLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Properties specific to this linked service type.
type SapBwLinkedServiceTypeProperties struct {
	// Client ID of the client on the BW system. (Usually a three-digit decimal number represented as a string) Type: string (or
	// Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password to access the SAP BW server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP BW instance. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// System number of the BW system. (Usually a two-digit decimal number represented as a string.) Type: string (or Expression
	// with resultType string).
	SystemNumber *interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP BW server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapBwLinkedServiceTypeProperties.
func (s *SapBwLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
		case "systemNumber":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemNumber)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Linked service for SAP Cloud for Customer.
type SapCloudForCustomerLinkedService struct {
	LinkedService
	// SAP Cloud for Customer linked service properties.
	TypeProperties *SapCloudForCustomerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerLinkedService.
func (s SapCloudForCustomerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapCloudForCustomer")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedService.
func (s *SapCloudForCustomerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// SAP Cloud for Customer linked service properties.
type SapCloudForCustomerLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The URL of SAP Cloud for Customer OData API. For example, '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type:
	// string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`

	// The username for Basic authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerLinkedServiceTypeProperties.
func (s *SapCloudForCustomerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &s.URL)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The path of the SAP Cloud for Customer OData entity.
type SapCloudForCustomerResourceDataset struct {
	Dataset
	// SAP Cloud For Customer OData resource dataset properties.
	TypeProperties *SapCloudForCustomerResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapCloudForCustomerResourceDataset.
func (s SapCloudForCustomerResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapCloudForCustomerResource")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapCloudForCustomerResourceDataset.
func (s *SapCloudForCustomerResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Sap Cloud For Customer OData resource dataset properties.
type SapCloudForCustomerResourceDatasetTypeProperties struct {
	// The path of the SAP Cloud for Customer OData entity. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// Linked service for SAP ERP Central Component(SAP ECC).
type SapEccLinkedService struct {
	LinkedService
	// SAP ECC linked service properties.
	TypeProperties *SapEccLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapEccLinkedService.
func (s SapEccLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapEcc")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedService.
func (s *SapEccLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// SAP ECC linked service properties.
type SapEccLinkedServiceTypeProperties struct {
	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Either encryptedCredential or username/password must be provided. Type: string (or Expression with resultType string).
	EncryptedCredential *string `json:"encryptedCredential,omitempty"`

	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The URL of SAP ECC OData API. For example, '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression
	// with resultType string).
	URL *string `json:"url,omitempty"`

	// The username for Basic authentication. Type: string (or Expression with resultType string).
	Username *string `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccLinkedServiceTypeProperties.
func (s *SapEccLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &s.URL)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The path of the SAP ECC OData entity.
type SapEccResourceDataset struct {
	Dataset
	// SAP ECC OData resource dataset properties.
	TypeProperties *SapEccResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapEccResourceDataset.
func (s SapEccResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapEccResource")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapEccResourceDataset.
func (s *SapEccResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Sap ECC OData resource dataset properties.
type SapEccResourceDatasetTypeProperties struct {
	// The path of the SAP ECC OData entity. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// SAP HANA Linked Service.
type SapHanaLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SapHanaLinkedServiceProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaLinkedService.
func (s SapHanaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapHana")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedService.
func (s *SapHanaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Properties specific to this linked service type.
type SapHanaLinkedServiceProperties struct {
	// The authentication type to be used to connect to the SAP HANA server.
	AuthenticationType *SapHanaAuthenticationType `json:"authenticationType,omitempty"`

	// SAP HANA ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password to access the SAP HANA server.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP HANA server. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username to access the SAP HANA server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaLinkedServiceProperties.
func (s *SapHanaLinkedServiceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &s.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SAP HANA Table properties.
type SapHanaTableDataset struct {
	Dataset
	// SAP HANA Table properties.
	TypeProperties *SapHanaTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapHanaTableDataset.
func (s SapHanaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapHanaTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapHanaTableDataset.
func (s *SapHanaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// SAP HANA Table properties.
type SapHanaTableDatasetTypeProperties struct {
	// The schema name of SAP HANA. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of SAP HANA. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`
}

// SAP Business Warehouse Open Hub Destination Linked Service.
type SapOpenHubLinkedService struct {
	LinkedService
	// Properties specific to SAP Business Warehouse Open Hub Destination linked service type.
	TypeProperties *SapOpenHubLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubLinkedService.
func (s SapOpenHubLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapOpenHub")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedService.
func (s *SapOpenHubLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Properties specific to SAP Business Warehouse Open Hub Destination linked service type.
type SapOpenHubLinkedServiceTypeProperties struct {
	// Client ID of the client on the BW system where the open hub destination is located. (Usually a three-digit decimal number
	// represented as a string) Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Language of the BW system where the open hub destination is located. The default value is EN. Type: string (or Expression
	// with resultType string).
	Language *interface{} `json:"language,omitempty"`

	// Password to access the SAP BW server where the open hub destination is located.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP BW instance where the open hub destination is located. Type: string (or Expression with resultType
	// string).
	Server *interface{} `json:"server,omitempty"`

	// System number of the BW system where the open hub destination is located. (Usually a two-digit decimal number represented
	// as a string.) Type: string (or Expression with resultType string).
	SystemNumber *interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP BW server where the open hub destination is located. Type: string (or Expression with resultType
	// string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubLinkedServiceTypeProperties.
func (s *SapOpenHubLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
		case "systemNumber":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemNumber)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Sap Business Warehouse Open Hub Destination Table properties.
type SapOpenHubTableDataset struct {
	Dataset
	// Sap Business Warehouse Open Hub Destination Table properties.
	TypeProperties *SapOpenHubTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapOpenHubTableDataset.
func (s SapOpenHubTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapOpenHubTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapOpenHubTableDataset.
func (s *SapOpenHubTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Sap Business Warehouse Open Hub Destination Table properties.
type SapOpenHubTableDatasetTypeProperties struct {
	// The ID of request for delta loading. Once it is set, only data with requestId larger than the value of this property will
	// be retrieved. The default value is 0. Type: integer (or Expression with resultType integer ).
	BaseRequestID *interface{} `json:"baseRequestId,omitempty"`

	// Whether to exclude the records of the last request. The default value is true. Type: boolean (or Expression with resultType
	// boolean).
	ExcludeLastRequest *interface{} `json:"excludeLastRequest,omitempty"`

	// The name of the Open Hub Destination with destination type as Database Table. Type: string (or Expression with resultType
	// string).
	OpenHubDestinationName *interface{} `json:"openHubDestinationName,omitempty"`
}

// SAP Table Linked Service.
type SapTableLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SapTableLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapTableLinkedService.
func (s SapTableLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("SapTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedService.
func (s *SapTableLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Properties specific to this linked service type.
type SapTableLinkedServiceTypeProperties struct {
	// Client ID of the client on the SAP system where the table is located. (Usually a three-digit decimal number represented
	// as a string) Type: string (or Expression with resultType string).
	ClientID *interface{} `json:"clientId,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Language of the SAP system where the table is located. The default value is EN. Type: string (or Expression with resultType
	// string).
	Language *interface{} `json:"language,omitempty"`

	// The Logon Group for the SAP System. Type: string (or Expression with resultType string).
	LogonGroup *interface{} `json:"logonGroup,omitempty"`

	// The hostname of the SAP Message Server. Type: string (or Expression with resultType string).
	MessageServer *interface{} `json:"messageServer,omitempty"`

	// The service name or port number of the Message Server. Type: string (or Expression with resultType string).
	MessageServerService *interface{} `json:"messageServerService,omitempty"`

	// Password to access the SAP server where the table is located.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Host name of the SAP instance where the table is located. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// External security product's library to access the SAP server where the table is located. Type: string (or Expression with
	// resultType string).
	SncLibraryPath *interface{} `json:"sncLibraryPath,omitempty"`

	// SNC activation indicator to access the SAP server where the table is located. Must be either 0 (off) or 1 (on). Type: string
	// (or Expression with resultType string).
	SncMode *interface{} `json:"sncMode,omitempty"`

	// Initiator's SNC name to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	SncMyName *interface{} `json:"sncMyName,omitempty"`

	// Communication partner's SNC name to access the SAP server where the table is located. Type: string (or Expression with
	// resultType string).
	SncPartnerName *interface{} `json:"sncPartnerName,omitempty"`

	// SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type: string (or Expression with resultType string).
	SncQop *interface{} `json:"sncQop,omitempty"`

	// SystemID of the SAP system where the table is located. Type: string (or Expression with resultType string).
	SystemID *interface{} `json:"systemId,omitempty"`

	// System number of the SAP system where the table is located. (Usually a two-digit decimal number represented as a string.)
	// Type: string (or Expression with resultType string).
	SystemNumber *interface{} `json:"systemNumber,omitempty"`

	// Username to access the SAP server where the table is located. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableLinkedServiceTypeProperties.
func (s *SapTableLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
		case "logonGroup":
			if val != nil {
				err = json.Unmarshal(*val, &s.LogonGroup)
			}
		case "messageServer":
			if val != nil {
				err = json.Unmarshal(*val, &s.MessageServer)
			}
		case "messageServerService":
			if val != nil {
				err = json.Unmarshal(*val, &s.MessageServerService)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
		case "sncLibraryPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncLibraryPath)
			}
		case "sncMode":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncMode)
			}
		case "sncMyName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncMyName)
			}
		case "sncPartnerName":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncPartnerName)
			}
		case "sncQop":
			if val != nil {
				err = json.Unmarshal(*val, &s.SncQop)
			}
		case "systemId":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemID)
			}
		case "systemNumber":
			if val != nil {
				err = json.Unmarshal(*val, &s.SystemNumber)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SAP Table Resource properties.
type SapTableResourceDataset struct {
	Dataset
	// SAP Table Resource properties.
	TypeProperties *SapTableResourceDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SapTableResourceDataset.
func (s SapTableResourceDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SapTableResource")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SapTableResourceDataset.
func (s *SapTableResourceDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// SAP Table Resource properties.
type SapTableResourceDatasetTypeProperties struct {
	// The name of the SAP Table. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Custom script action to run on HDI ondemand cluster once it's up.
type ScriptAction struct {
	// The user provided name of the script action.
	Name *string `json:"name,omitempty"`

	// The parameters for the script action.
	Parameters *string `json:"parameters,omitempty"`

	// The node types on which the script action should be executed.
	Roles *HdiNodeTypes `json:"roles,omitempty"`

	// The URI for the script action.
	URI *string `json:"uri,omitempty"`
}

// SecretBaseClassification provides polymorphic access to related types.
type SecretBaseClassification interface {
	GetSecretBase() *SecretBase
}

// The base definition of a secret type.
type SecretBase struct {
	// Type of the secret.
	Type *string `json:"type,omitempty"`
}

// GetSecretBase implements the SecretBaseClassification interface for type SecretBase.
func (s *SecretBase) GetSecretBase() *SecretBase { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type SecretBase.
func (s *SecretBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &s.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (s SecretBase) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	s.Type = &discValue
	objectMap["type"] = s.Type
	return objectMap
}

// Azure Synapse secure string definition. The string value will be masked with asterisks '*' during Get or List API calls.
type SecureString struct {
	SecretBase
	// Value of secure string.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecureString.
func (s SecureString) MarshalJSON() ([]byte, error) {
	objectMap := s.SecretBase.marshalInternal("SecureString")
	if s.Value != nil {
		objectMap["value"] = s.Value
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecureString.
func (s *SecureString) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
			if val != nil {
				err = json.Unmarshal(*val, &s.Value)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.SecretBase)
}

// ServiceNow server linked service.
type ServiceNowLinkedService struct {
	LinkedService
	// ServiceNow server linked service properties.
	TypeProperties *ServiceNowLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowLinkedService.
func (s ServiceNowLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("ServiceNow")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedService.
func (s *ServiceNowLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// ServiceNow server linked service properties.
type ServiceNowLinkedServiceTypeProperties struct {
	// The authentication type to use.
	AuthenticationType *ServiceNowAuthenticationType `json:"authenticationType,omitempty"`

	// The client id for OAuth2 authentication.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret for OAuth2 authentication.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the ServiceNow server. (i.e. <instance>.service-now.com)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// The password corresponding to the user name for Basic and OAuth2 authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`

	// The user name used to connect to the ServiceNow server for Basic and OAuth2 authentication.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowLinkedServiceTypeProperties.
func (s *ServiceNowLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
		case "clientSecret":
			if val != nil {
				s.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &s.Endpoint)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ServiceNow server dataset.
type ServiceNowObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceNowObjectDataset.
func (s ServiceNowObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("ServiceNowObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceNowObjectDataset.
func (s *ServiceNowObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Set value for a Variable.
type SetVariableActivity struct {
	Activity
	// Set Variable activity properties.
	TypeProperties *SetVariableActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SetVariableActivity.
func (s SetVariableActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SetVariable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SetVariableActivity.
func (s *SetVariableActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Activity)
}

// SetVariable activity properties.
type SetVariableActivityTypeProperties struct {
	// Value to be set. Could be a static value or Expression
	Value *interface{} `json:"value,omitempty"`

	// Name of the variable whose value needs to be set.
	VariableName *string `json:"variableName,omitempty"`
}

// A linked service for an SSH File Transfer Protocol (SFTP) server.
type SftpServerLinkedService struct {
	LinkedService
	// Properties specific to this linked service type.
	TypeProperties *SftpServerLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SftpServerLinkedService.
func (s SftpServerLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Sftp")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedService.
func (s *SftpServerLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Properties specific to this linked service type.
type SftpServerLinkedServiceTypeProperties struct {
	// The authentication type to be used to connect to the FTP server.
	AuthenticationType *SftpAuthenticationType `json:"authenticationType,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The SFTP server host name. Type: string (or Expression with resultType string).
	Host *interface{} `json:"host,omitempty"`

	// The host key finger-print of the SFTP server. When SkipHostKeyValidation is false, HostKeyFingerprint should be specified.
	// Type: string (or Expression with resultType string).
	HostKeyFingerprint *interface{} `json:"hostKeyFingerprint,omitempty"`

	// The password to decrypt the SSH private key if the SSH private key is encrypted.
	PassPhrase SecretBaseClassification `json:"passPhrase,omitempty"`

	// Password to logon the SFTP server for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port number that the SFTP server uses to listen for client connections. Default value is 22. Type: integer (or
	// Expression with resultType integer), minimum: 0.
	Port *interface{} `json:"port,omitempty"`

	// Base64 encoded SSH private key content for SshPublicKey authentication. For on-premises copy with SshPublicKey authentication,
	// either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH format.
	PrivateKeyContent SecretBaseClassification `json:"privateKeyContent,omitempty"`

	// The SSH private key file path for SshPublicKey authentication. Only valid for on-premises copy. For on-premises copy with
	// SshPublicKey authentication, either PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be
	// OpenSSH format. Type: string (or Expression with resultType string).
	PrivateKeyPath *interface{} `json:"privateKeyPath,omitempty"`

	// If true, skip the SSH host key validation. Default value is false. Type: boolean (or Expression with resultType boolean).
	SkipHostKeyValidation *interface{} `json:"skipHostKeyValidation,omitempty"`

	// The username used to log on to the SFTP server. Type: string (or Expression with resultType string).
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SftpServerLinkedServiceTypeProperties.
func (s *SftpServerLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
		case "hostKeyFingerprint":
			if val != nil {
				err = json.Unmarshal(*val, &s.HostKeyFingerprint)
			}
		case "passPhrase":
			if val != nil {
				s.PassPhrase, err = unmarshalSecretBaseClassification(*val)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &s.Port)
			}
		case "privateKeyContent":
			if val != nil {
				s.PrivateKeyContent, err = unmarshalSecretBaseClassification(*val)
			}
		case "privateKeyPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.PrivateKeyPath)
			}
		case "skipHostKeyValidation":
			if val != nil {
				err = json.Unmarshal(*val, &s.SkipHostKeyValidation)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Shopify Service linked service.
type ShopifyLinkedService struct {
	LinkedService
	// Shopify Service linked service properties.
	TypeProperties *ShopifyLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyLinkedService.
func (s ShopifyLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Shopify")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedService.
func (s *ShopifyLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Shopify Service linked service properties.
type ShopifyLinkedServiceTypeProperties struct {
	// The API access token that can be used to access Shopifys data. The token won't expire if it is offline mode.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Shopify server. (i.e. mystore.myshopify.com)
	Host *interface{} `json:"host,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyLinkedServiceTypeProperties.
func (s *ShopifyLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				s.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Shopify Service dataset.
type ShopifyObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ShopifyObjectDataset.
func (s ShopifyObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("ShopifyObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ShopifyObjectDataset.
func (s *ShopifyObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

type SparkBatchJob struct {
	// The application id of this session
	AppID *string `json:"appId,omitempty"`

	// The detailed application info.
	AppInfo *map[string]string `json:"appInfo,omitempty"`

	// The artifact identifier.
	ArtifactID *string `json:"artifactId,omitempty"`

	// The error information.
	Errors *[]SparkServiceError `json:"errorInfo,omitempty"`

	// The session Id.
	ID *int32 `json:"id,omitempty"`

	// The job type.
	JobType  *SparkJobType       `json:"jobType,omitempty"`
	LivyInfo *SparkBatchJobState `json:"livyInfo,omitempty"`

	// The log lines.
	LogLines *[]string `json:"log,omitempty"`

	// The batch name.
	Name *string `json:"name,omitempty"`

	// The plugin information.
	Plugin *SparkServicePlugin `json:"pluginInfo,omitempty"`

	// The Spark batch job result.
	Result *SparkBatchJobResultType `json:"result,omitempty"`

	// The scheduler information.
	Scheduler *SparkScheduler `json:"schedulerInfo,omitempty"`

	// The Spark pool name.
	SparkPoolName *string `json:"sparkPoolName,omitempty"`

	// The batch state
	State *string `json:"state,omitempty"`

	// The submitter identifier.
	SubmitterID *string `json:"submitterId,omitempty"`

	// The submitter name.
	SubmitterName *string `json:"submitterName,omitempty"`

	// The tags.
	Tags *map[string]string `json:"tags,omitempty"`

	// The workspace name.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

// SparkBatchJobPollerResponse is the response envelope for operations that asynchronously return a SparkBatchJob type.
type SparkBatchJobPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*SparkBatchJobResponse, error)

	// Poller contains an initialized poller.
	Poller SparkBatchJobPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkBatchJobResponse is the response envelope for operations that return a SparkBatchJob type.
type SparkBatchJobResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse   *http.Response
	SparkBatchJob *SparkBatchJob
}

type SparkBatchJobState struct {
	// the Spark job state.
	CurrentState *string `json:"currentState,omitempty"`

	// time that at which "dead" livy state was first seen.
	DeadAt             *time.Time    `json:"deadAt,omitempty"`
	JobCreationRequest *SparkRequest `json:"jobCreationRequest,omitempty"`

	// the time that at which "not_started" livy state was first seen.
	NotStartedAt *time.Time `json:"notStartedAt,omitempty"`

	// the time that at which "recovering" livy state was first seen.
	RecoveringAt *time.Time `json:"recoveringAt,omitempty"`

	// the time that at which "running" livy state was first seen.
	RunningAt *time.Time `json:"runningAt,omitempty"`

	// the time that at which "starting" livy state was first seen.
	StartingAt *time.Time `json:"startingAt,omitempty"`

	// the time that at which "success" livy state was first seen.
	SuccessAt *time.Time `json:"successAt,omitempty"`

	// the time that at which "killed" livy state was first seen.
	TerminatedAt *time.Time `json:"killedAt,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkBatchJobState.
func (s SparkBatchJobState) MarshalJSON() ([]byte, error) {
	type alias SparkBatchJobState
	aux := &struct {
		*alias
		DeadAt       *timeRFC3339 `json:"deadAt"`
		NotStartedAt *timeRFC3339 `json:"notStartedAt"`
		RecoveringAt *timeRFC3339 `json:"recoveringAt"`
		RunningAt    *timeRFC3339 `json:"runningAt"`
		StartingAt   *timeRFC3339 `json:"startingAt"`
		SuccessAt    *timeRFC3339 `json:"successAt"`
		TerminatedAt *timeRFC3339 `json:"killedAt"`
	}{
		alias:        (*alias)(&s),
		DeadAt:       (*timeRFC3339)(s.DeadAt),
		NotStartedAt: (*timeRFC3339)(s.NotStartedAt),
		RecoveringAt: (*timeRFC3339)(s.RecoveringAt),
		RunningAt:    (*timeRFC3339)(s.RunningAt),
		StartingAt:   (*timeRFC3339)(s.StartingAt),
		SuccessAt:    (*timeRFC3339)(s.SuccessAt),
		TerminatedAt: (*timeRFC3339)(s.TerminatedAt),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkBatchJobState.
func (s *SparkBatchJobState) UnmarshalJSON(data []byte) error {
	type alias SparkBatchJobState
	aux := &struct {
		*alias
		DeadAt       *timeRFC3339 `json:"deadAt"`
		NotStartedAt *timeRFC3339 `json:"notStartedAt"`
		RecoveringAt *timeRFC3339 `json:"recoveringAt"`
		RunningAt    *timeRFC3339 `json:"runningAt"`
		StartingAt   *timeRFC3339 `json:"startingAt"`
		SuccessAt    *timeRFC3339 `json:"successAt"`
		TerminatedAt *timeRFC3339 `json:"killedAt"`
	}{
		alias: (*alias)(s),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	s.DeadAt = (*time.Time)(aux.DeadAt)
	s.NotStartedAt = (*time.Time)(aux.NotStartedAt)
	s.RecoveringAt = (*time.Time)(aux.RecoveringAt)
	s.RunningAt = (*time.Time)(aux.RunningAt)
	s.StartingAt = (*time.Time)(aux.StartingAt)
	s.SuccessAt = (*time.Time)(aux.SuccessAt)
	s.TerminatedAt = (*time.Time)(aux.TerminatedAt)
	return nil
}

// Spark Properties
type SparkDatasetTypeProperties struct {
	// The schema name of the Spark. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Spark. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Spark job definition.
type SparkJobDefinition struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// The description of the Spark job definition.
	Description *string `json:"description,omitempty"`

	// The properties of the Spark job.
	JobProperties *SparkJobProperties `json:"jobProperties,omitempty"`

	// The language of the Spark application.
	Language *string `json:"language,omitempty"`

	// The required Spark version of the application.
	RequiredSparkVersion *string `json:"requiredSparkVersion,omitempty"`

	// Big data pool reference.
	TargetBigDataPool *BigDataPoolReference `json:"targetBigDataPool,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkJobDefinition.
func (s SparkJobDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Description != nil {
		objectMap["description"] = s.Description
	}
	if s.JobProperties != nil {
		objectMap["jobProperties"] = s.JobProperties
	}
	if s.Language != nil {
		objectMap["language"] = s.Language
	}
	if s.RequiredSparkVersion != nil {
		objectMap["requiredSparkVersion"] = s.RequiredSparkVersion
	}
	if s.TargetBigDataPool != nil {
		objectMap["targetBigDataPool"] = s.TargetBigDataPool
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkJobDefinition.
func (s *SparkJobDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &s.Description)
			}
		case "jobProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.JobProperties)
			}
		case "language":
			if val != nil {
				err = json.Unmarshal(*val, &s.Language)
			}
		case "requiredSparkVersion":
			if val != nil {
				err = json.Unmarshal(*val, &s.RequiredSparkVersion)
			}
		case "targetBigDataPool":
			if val != nil {
				err = json.Unmarshal(*val, &s.TargetBigDataPool)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SparkJobDefinitionCreateOrUpdateSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.CreateOrUpdateSparkJobDefinition
// method.
type SparkJobDefinitionCreateOrUpdateSparkJobDefinitionOptions struct {
	// ETag of the Spark Job Definition entity. Should only be specified for update, for which it should match existing entity
	// or can be * for unconditional update.
	IfMatch *string
}

// SparkJobDefinitionGetSparkJobDefinitionOptions contains the optional parameters for the SparkJobDefinition.GetSparkJobDefinition
// method.
type SparkJobDefinitionGetSparkJobDefinitionOptions struct {
	// ETag of the Spark Job Definition entity. Should only be specified for get. If the ETag matches the existing entity tag,
	// or if * was provided, then no content will be returned.
	IfNoneMatch *string
}

// Spark job definition resource type.
type SparkJobDefinitionResource struct {
	SubResource
	// Properties of spark job definition.
	Properties *SparkJobDefinition `json:"properties,omitempty"`
}

// SparkJobDefinitionResourceResponse is the response envelope for operations that return a SparkJobDefinitionResource type.
type SparkJobDefinitionResourceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Spark job definition resource type.
	SparkJobDefinitionResource *SparkJobDefinitionResource
}

// A list of spark job definitions resources.
type SparkJobDefinitionsListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of spark job definitions.
	Value *[]SparkJobDefinitionResource `json:"value,omitempty"`
}

// SparkJobDefinitionsListResponseResponse is the response envelope for operations that return a SparkJobDefinitionsListResponse
// type.
type SparkJobDefinitionsListResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of spark job definitions resources.
	SparkJobDefinitionsListResponse *SparkJobDefinitionsListResponse
}

// The properties of the Spark job.
type SparkJobProperties struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Archives to be used in this job.
	Archives *[]string `json:"archives,omitempty"`

	// Command line arguments for the application.
	Args *[]string `json:"args,omitempty"`

	// Main class for Java/Scala application.
	ClassName *string `json:"className,omitempty"`

	// Spark configuration properties.
	Conf *interface{} `json:"conf,omitempty"`

	// Number of cores to use for the driver.
	DriverCores *int32 `json:"driverCores,omitempty"`

	// Amount of memory to use for the driver process.
	DriverMemory *string `json:"driverMemory,omitempty"`

	// Number of cores to use for each executor.
	ExecutorCores *int32 `json:"executorCores,omitempty"`

	// Amount of memory to use per executor process.
	ExecutorMemory *string `json:"executorMemory,omitempty"`

	// File containing the application to execute.
	File *string `json:"file,omitempty"`

	// files to be used in this job.
	Files *[]string `json:"files,omitempty"`

	// Jars to be used in this job.
	Jars *[]string `json:"jars,omitempty"`

	// The name of the job.
	Name *string `json:"name,omitempty"`

	// Number of executors to launch for this job.
	NumExecutors *int32 `json:"numExecutors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkJobProperties.
func (s SparkJobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.Archives != nil {
		objectMap["archives"] = s.Archives
	}
	if s.Args != nil {
		objectMap["args"] = s.Args
	}
	if s.ClassName != nil {
		objectMap["className"] = s.ClassName
	}
	if s.Conf != nil {
		objectMap["conf"] = s.Conf
	}
	if s.DriverCores != nil {
		objectMap["driverCores"] = s.DriverCores
	}
	if s.DriverMemory != nil {
		objectMap["driverMemory"] = s.DriverMemory
	}
	if s.ExecutorCores != nil {
		objectMap["executorCores"] = s.ExecutorCores
	}
	if s.ExecutorMemory != nil {
		objectMap["executorMemory"] = s.ExecutorMemory
	}
	if s.File != nil {
		objectMap["file"] = s.File
	}
	if s.Files != nil {
		objectMap["files"] = s.Files
	}
	if s.Jars != nil {
		objectMap["jars"] = s.Jars
	}
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	if s.NumExecutors != nil {
		objectMap["numExecutors"] = s.NumExecutors
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkJobProperties.
func (s *SparkJobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "archives":
			if val != nil {
				err = json.Unmarshal(*val, &s.Archives)
			}
		case "args":
			if val != nil {
				err = json.Unmarshal(*val, &s.Args)
			}
		case "className":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClassName)
			}
		case "conf":
			if val != nil {
				err = json.Unmarshal(*val, &s.Conf)
			}
		case "driverCores":
			if val != nil {
				err = json.Unmarshal(*val, &s.DriverCores)
			}
		case "driverMemory":
			if val != nil {
				err = json.Unmarshal(*val, &s.DriverMemory)
			}
		case "executorCores":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExecutorCores)
			}
		case "executorMemory":
			if val != nil {
				err = json.Unmarshal(*val, &s.ExecutorMemory)
			}
		case "file":
			if val != nil {
				err = json.Unmarshal(*val, &s.File)
			}
		case "files":
			if val != nil {
				err = json.Unmarshal(*val, &s.Files)
			}
		case "jars":
			if val != nil {
				err = json.Unmarshal(*val, &s.Jars)
			}
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &s.Name)
			}
		case "numExecutors":
			if val != nil {
				err = json.Unmarshal(*val, &s.NumExecutors)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Spark Server linked service.
type SparkLinkedService struct {
	LinkedService
	// Spark Server linked service properties.
	TypeProperties *SparkLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkLinkedService.
func (s SparkLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Spark")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedService.
func (s *SparkLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Spark Server linked service properties.
type SparkLinkedServiceTypeProperties struct {
	// Specifies whether to require a CA-issued SSL certificate name to match the host name of the server when connecting over
	// SSL. The default value is false.
	AllowHostNameCnMismatch *interface{} `json:"allowHostNameCNMismatch,omitempty"`

	// Specifies whether to allow self-signed certificates from the server. The default value is false.
	AllowSelfSignedServerCert *interface{} `json:"allowSelfSignedServerCert,omitempty"`

	// The authentication method used to access the Spark server.
	AuthenticationType *SparkAuthenticationType `json:"authenticationType,omitempty"`

	// Specifies whether the connections to the server are encrypted using SSL. The default value is false.
	EnableSsl *interface{} `json:"enableSsl,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The partial URL corresponding to the Spark server.
	HTTPPath *interface{} `json:"httpPath,omitempty"`

	// IP address or host name of the Spark server
	Host *interface{} `json:"host,omitempty"`

	// The password corresponding to the user name that you provided in the Username field
	Password SecretBaseClassification `json:"password,omitempty"`

	// The TCP port that the Spark server uses to listen for client connections.
	Port *interface{} `json:"port,omitempty"`

	// The type of Spark server.
	ServerType *SparkServerType `json:"serverType,omitempty"`

	// The transport protocol to use in the Thrift layer.
	ThriftTransportProtocol *SparkThriftTransportProtocol `json:"thriftTransportProtocol,omitempty"`

	// The full path of the .pem file containing trusted CA certificates for verifying the server when connecting over SSL. This
	// property can only be set when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
	// IR.
	TrustedCertPath *interface{} `json:"trustedCertPath,omitempty"`

	// Specifies whether to use a CA certificate from the system trust store or from a specified PEM file. The default value is
	// false.
	UseSystemTrustStore *interface{} `json:"useSystemTrustStore,omitempty"`

	// The user name that you use to access Spark Server.
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkLinkedServiceTypeProperties.
func (s *SparkLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowHostNameCNMismatch":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowHostNameCnMismatch)
			}
		case "allowSelfSignedServerCert":
			if val != nil {
				err = json.Unmarshal(*val, &s.AllowSelfSignedServerCert)
			}
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
		case "enableSsl":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnableSsl)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "httpPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.HTTPPath)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "port":
			if val != nil {
				err = json.Unmarshal(*val, &s.Port)
			}
		case "serverType":
			if val != nil {
				err = json.Unmarshal(*val, &s.ServerType)
			}
		case "thriftTransportProtocol":
			if val != nil {
				err = json.Unmarshal(*val, &s.ThriftTransportProtocol)
			}
		case "trustedCertPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.TrustedCertPath)
			}
		case "useSystemTrustStore":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseSystemTrustStore)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Spark Server dataset.
type SparkObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *SparkDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkObjectDataset.
func (s SparkObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SparkObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkObjectDataset.
func (s *SparkObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

type SparkRequest struct {
	Archives  *[]string `json:"archives,omitempty"`
	Arguments *[]string `json:"args,omitempty"`
	ClassName *string   `json:"className,omitempty"`

	// Dictionary of <string>
	Configuration  *map[string]string `json:"conf,omitempty"`
	DriverCores    *int32             `json:"driverCores,omitempty"`
	DriverMemory   *string            `json:"driverMemory,omitempty"`
	ExecutorCores  *int32             `json:"executorCores,omitempty"`
	ExecutorCount  *int32             `json:"numExecutors,omitempty"`
	ExecutorMemory *string            `json:"executorMemory,omitempty"`
	File           *string            `json:"file,omitempty"`
	Files          *[]string          `json:"files,omitempty"`
	Jars           *[]string          `json:"jars,omitempty"`
	Name           *string            `json:"name,omitempty"`
	PythonFiles    *[]string          `json:"pyFiles,omitempty"`
}

type SparkScheduler struct {
	CancellationRequestedAt *time.Time             `json:"cancellationRequestedAt,omitempty"`
	CurrentState            *SchedulerCurrentState `json:"currentState,omitempty"`
	EndedAt                 *time.Time             `json:"endedAt,omitempty"`
	ScheduledAt             *time.Time             `json:"scheduledAt,omitempty"`
	SubmittedAt             *time.Time             `json:"submittedAt,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkScheduler.
func (s SparkScheduler) MarshalJSON() ([]byte, error) {
	type alias SparkScheduler
	aux := &struct {
		*alias
		CancellationRequestedAt *timeRFC3339 `json:"cancellationRequestedAt"`
		EndedAt                 *timeRFC3339 `json:"endedAt"`
		ScheduledAt             *timeRFC3339 `json:"scheduledAt"`
		SubmittedAt             *timeRFC3339 `json:"submittedAt"`
	}{
		alias:                   (*alias)(&s),
		CancellationRequestedAt: (*timeRFC3339)(s.CancellationRequestedAt),
		EndedAt:                 (*timeRFC3339)(s.EndedAt),
		ScheduledAt:             (*timeRFC3339)(s.ScheduledAt),
		SubmittedAt:             (*timeRFC3339)(s.SubmittedAt),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkScheduler.
func (s *SparkScheduler) UnmarshalJSON(data []byte) error {
	type alias SparkScheduler
	aux := &struct {
		*alias
		CancellationRequestedAt *timeRFC3339 `json:"cancellationRequestedAt"`
		EndedAt                 *timeRFC3339 `json:"endedAt"`
		ScheduledAt             *timeRFC3339 `json:"scheduledAt"`
		SubmittedAt             *timeRFC3339 `json:"submittedAt"`
	}{
		alias: (*alias)(s),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	s.CancellationRequestedAt = (*time.Time)(aux.CancellationRequestedAt)
	s.EndedAt = (*time.Time)(aux.EndedAt)
	s.ScheduledAt = (*time.Time)(aux.ScheduledAt)
	s.SubmittedAt = (*time.Time)(aux.SubmittedAt)
	return nil
}

type SparkServiceError struct {
	ErrorCode *string           `json:"errorCode,omitempty"`
	Message   *string           `json:"message,omitempty"`
	Source    *SparkErrorSource `json:"source,omitempty"`
}

type SparkServicePlugin struct {
	CleanupStartedAt             *time.Time          `json:"cleanupStartedAt,omitempty"`
	CurrentState                 *PluginCurrentState `json:"currentState,omitempty"`
	MonitoringStartedAt          *time.Time          `json:"monitoringStartedAt,omitempty"`
	PreparationStartedAt         *time.Time          `json:"preparationStartedAt,omitempty"`
	ResourceAcquisitionStartedAt *time.Time          `json:"resourceAcquisitionStartedAt,omitempty"`
	SubmissionStartedAt          *time.Time          `json:"submissionStartedAt,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SparkServicePlugin.
func (s SparkServicePlugin) MarshalJSON() ([]byte, error) {
	type alias SparkServicePlugin
	aux := &struct {
		*alias
		CleanupStartedAt             *timeRFC3339 `json:"cleanupStartedAt"`
		MonitoringStartedAt          *timeRFC3339 `json:"monitoringStartedAt"`
		PreparationStartedAt         *timeRFC3339 `json:"preparationStartedAt"`
		ResourceAcquisitionStartedAt *timeRFC3339 `json:"resourceAcquisitionStartedAt"`
		SubmissionStartedAt          *timeRFC3339 `json:"submissionStartedAt"`
	}{
		alias:                        (*alias)(&s),
		CleanupStartedAt:             (*timeRFC3339)(s.CleanupStartedAt),
		MonitoringStartedAt:          (*timeRFC3339)(s.MonitoringStartedAt),
		PreparationStartedAt:         (*timeRFC3339)(s.PreparationStartedAt),
		ResourceAcquisitionStartedAt: (*timeRFC3339)(s.ResourceAcquisitionStartedAt),
		SubmissionStartedAt:          (*timeRFC3339)(s.SubmissionStartedAt),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SparkServicePlugin.
func (s *SparkServicePlugin) UnmarshalJSON(data []byte) error {
	type alias SparkServicePlugin
	aux := &struct {
		*alias
		CleanupStartedAt             *timeRFC3339 `json:"cleanupStartedAt"`
		MonitoringStartedAt          *timeRFC3339 `json:"monitoringStartedAt"`
		PreparationStartedAt         *timeRFC3339 `json:"preparationStartedAt"`
		ResourceAcquisitionStartedAt *timeRFC3339 `json:"resourceAcquisitionStartedAt"`
		SubmissionStartedAt          *timeRFC3339 `json:"submissionStartedAt"`
	}{
		alias: (*alias)(s),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	s.CleanupStartedAt = (*time.Time)(aux.CleanupStartedAt)
	s.MonitoringStartedAt = (*time.Time)(aux.MonitoringStartedAt)
	s.PreparationStartedAt = (*time.Time)(aux.PreparationStartedAt)
	s.ResourceAcquisitionStartedAt = (*time.Time)(aux.ResourceAcquisitionStartedAt)
	s.SubmissionStartedAt = (*time.Time)(aux.SubmissionStartedAt)
	return nil
}

// Square Service linked service.
type SquareLinkedService struct {
	LinkedService
	// Square Service linked service properties.
	TypeProperties *SquareLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SquareLinkedService.
func (s SquareLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Square")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedService.
func (s *SquareLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Square Service linked service properties.
type SquareLinkedServiceTypeProperties struct {
	// The client ID associated with your Square application.
	ClientID *interface{} `json:"clientId,omitempty"`

	// The client secret associated with your Square application.
	ClientSecret SecretBaseClassification `json:"clientSecret,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The URL of the Square instance. (i.e. mystore.mysquare.com)
	Host *interface{} `json:"host,omitempty"`

	// The redirect URL assigned in the Square application dashboard. (i.e. http://localhost:2500)
	RedirectURI *interface{} `json:"redirectUri,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareLinkedServiceTypeProperties.
func (s *SquareLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			if val != nil {
				err = json.Unmarshal(*val, &s.ClientID)
			}
		case "clientSecret":
			if val != nil {
				s.ClientSecret, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &s.Host)
			}
		case "redirectUri":
			if val != nil {
				err = json.Unmarshal(*val, &s.RedirectURI)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &s.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Square Service dataset.
type SquareObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SquareObjectDataset.
func (s SquareObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SquareObject")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SquareObjectDataset.
func (s *SquareObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// SSIS access credential.
type SsisAccessCredential struct {
	// Domain for windows authentication.
	Domain *interface{} `json:"domain,omitempty"`

	// Password for windows authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// UseName for windows authentication.
	UserName *interface{} `json:"userName,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisAccessCredential.
func (s *SsisAccessCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
			if val != nil {
				err = json.Unmarshal(*val, &s.Domain)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "userName":
			if val != nil {
				err = json.Unmarshal(*val, &s.UserName)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SSIS embedded child package.
type SsisChildPackage struct {
	// Content for embedded child package. Type: string (or Expression with resultType string).
	PackageContent *interface{} `json:"packageContent,omitempty"`

	// Last modified date for embedded child package.
	PackageLastModifiedDate *string `json:"packageLastModifiedDate,omitempty"`

	// Name for embedded child package.
	PackageName *string `json:"packageName,omitempty"`

	// Path for embedded child package. Type: string (or Expression with resultType string).
	PackagePath *interface{} `json:"packagePath,omitempty"`
}

// SSIS package execution credential.
type SsisExecutionCredential struct {
	// Domain for windows authentication.
	Domain *interface{} `json:"domain,omitempty"`

	// Password for windows authentication.
	Password *SecureString `json:"password,omitempty"`

	// UseName for windows authentication.
	UserName *interface{} `json:"userName,omitempty"`
}

// SSIS execution parameter.
type SsisExecutionParameter struct {
	// SSIS package execution parameter value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// SSIS package execution log location
type SsisLogLocation struct {
	// The SSIS package execution log path. Type: string (or Expression with resultType string).
	LogPath *interface{} `json:"logPath,omitempty"`

	// The type of SSIS log location.
	Type *string `json:"type,omitempty"`

	// SSIS package execution log location properties.
	TypeProperties *SsisLogLocationTypeProperties `json:"typeProperties,omitempty"`
}

// SSIS package execution log location properties.
type SsisLogLocationTypeProperties struct {
	// The package execution log access credential.
	AccessCredential *SsisAccessCredential `json:"accessCredential,omitempty"`

	// Specifies the interval to refresh log. The default interval is 5 minutes. Type: string (or Expression with resultType string),
	// pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	LogRefreshInterval *interface{} `json:"logRefreshInterval,omitempty"`
}

// The status of the operation.
type SsisObjectMetadataStatusResponse struct {
	// The operation error message.
	Error *string `json:"error,omitempty"`

	// The operation name.
	Name *string `json:"name,omitempty"`

	// The operation properties.
	Properties *string `json:"properties,omitempty"`

	// The status of the operation.
	Status *string `json:"status,omitempty"`
}

// SSIS package location.
type SsisPackageLocation struct {
	// The SSIS package path. Type: string (or Expression with resultType string).
	PackagePath *interface{} `json:"packagePath,omitempty"`

	// The type of SSIS package location.
	Type *SsisPackageLocationType `json:"type,omitempty"`

	// SSIS package location properties.
	TypeProperties *SsisPackageLocationTypeProperties `json:"typeProperties,omitempty"`
}

// SSIS package location properties.
type SsisPackageLocationTypeProperties struct {
	// The package access credential.
	AccessCredential *SsisAccessCredential `json:"accessCredential,omitempty"`

	// The embedded child package list.
	ChildPackages *[]SsisChildPackage `json:"childPackages,omitempty"`

	// The configuration file of the package execution. Type: string (or Expression with resultType string).
	ConfigurationPath *interface{} `json:"configurationPath,omitempty"`

	// The embedded package content. Type: string (or Expression with resultType string).
	PackageContent *interface{} `json:"packageContent,omitempty"`

	// The embedded package last modified date.
	PackageLastModifiedDate *string `json:"packageLastModifiedDate,omitempty"`

	// The package name.
	PackageName *string `json:"packageName,omitempty"`

	// Password of the package.
	PackagePassword SecretBaseClassification `json:"packagePassword,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SsisPackageLocationTypeProperties.
func (s *SsisPackageLocationTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.AccessCredential)
			}
		case "childPackages":
			if val != nil {
				err = json.Unmarshal(*val, &s.ChildPackages)
			}
		case "configurationPath":
			if val != nil {
				err = json.Unmarshal(*val, &s.ConfigurationPath)
			}
		case "packageContent":
			if val != nil {
				err = json.Unmarshal(*val, &s.PackageContent)
			}
		case "packageLastModifiedDate":
			if val != nil {
				err = json.Unmarshal(*val, &s.PackageLastModifiedDate)
			}
		case "packageName":
			if val != nil {
				err = json.Unmarshal(*val, &s.PackageName)
			}
		case "packagePassword":
			if val != nil {
				s.PackagePassword, err = unmarshalSecretBaseClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SSIS property override.
type SsisPropertyOverride struct {
	// Whether SSIS package property override value is sensitive data. Value will be encrypted in SSISDB if it is true
	IsSensitive *bool `json:"isSensitive,omitempty"`

	// SSIS package property override value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// Staging settings.
type StagingSettings struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Specifies whether to use compression when copying data via an interim staging. Default value is false. Type: boolean (or
	// Expression with resultType boolean).
	EnableCompression *interface{} `json:"enableCompression,omitempty"`

	// Staging linked service reference.
	LinkedServiceName *LinkedServiceReference `json:"linkedServiceName,omitempty"`

	// The path to storage for storing the interim data. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StagingSettings.
func (s StagingSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.EnableCompression != nil {
		objectMap["enableCompression"] = s.EnableCompression
	}
	if s.LinkedServiceName != nil {
		objectMap["linkedServiceName"] = s.LinkedServiceName
	}
	if s.Path != nil {
		objectMap["path"] = s.Path
	}
	if s.AdditionalProperties != nil {
		for key, val := range *s.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StagingSettings.
func (s *StagingSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableCompression":
			if val != nil {
				err = json.Unmarshal(*val, &s.EnableCompression)
			}
		case "linkedServiceName":
			if val != nil {
				err = json.Unmarshal(*val, &s.LinkedServiceName)
			}
		case "path":
			if val != nil {
				err = json.Unmarshal(*val, &s.Path)
			}
		default:
			if s.AdditionalProperties == nil {
				s.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*s.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Request body structure for starting data flow debug session.
type StartDataFlowDebugSessionRequest struct {
	// Data flow instance.
	DataFlow *DataFlowResource `json:"dataFlow,omitempty"`

	// List of datasets.
	Datasets *[]DatasetResource `json:"datasets,omitempty"`

	// Data flow debug settings.
	DebugSettings *interface{} `json:"debugSettings,omitempty"`

	// The type of new Databricks cluster.
	IncrementalDebug *bool `json:"incrementalDebug,omitempty"`

	// List of linked services.
	LinkedServices *[]LinkedServiceResource `json:"linkedServices,omitempty"`

	// The ID of data flow debug session.
	SessionID *string `json:"sessionId,omitempty"`

	// Staging info for debug session.
	Staging *interface{} `json:"staging,omitempty"`
}

// Response body structure for starting data flow debug session.
type StartDataFlowDebugSessionResponse struct {
	// The ID of data flow debug job version.
	JobVersion *string `json:"jobVersion,omitempty"`
}

// SQL stored procedure parameter.
type StoredProcedureParameter struct {
	// Stored procedure parameter type.
	Type *StoredProcedureParameterType `json:"type,omitempty"`

	// Stored procedure parameter value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// Azure Synapse nested resource, which belongs to a workspace.
type SubResource struct {
	// Etag identifies change in the resource.
	Etag *string `json:"etag,omitempty" azure:"ro"`

	// The resource identifier.
	ID *string `json:"id,omitempty" azure:"ro"`

	// The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// Azure Synapse nested debug resource.
type SubResourceDebugResource struct {
	// The resource name.
	Name *string `json:"name,omitempty"`
}

// This activity evaluates an expression and executes activities under the cases property that correspond to the expression
// evaluation expected in the equals property.
type SwitchActivity struct {
	Activity
	// Switch activity properties.
	TypeProperties *SwitchActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SwitchActivity.
func (s SwitchActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("Switch")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivity.
func (s *SwitchActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Activity)
}

// Switch activity properties.
type SwitchActivityTypeProperties struct {
	// List of cases that correspond to expected values of the 'on' property. This is an optional property and if not provided,
	// the activity will execute activities provided in defaultActivities.
	Cases *[]SwitchCase `json:"cases,omitempty"`

	// List of activities to execute if no case condition is satisfied. This is an optional property and if not provided, the
	// activity will exit without any action.
	DefaultActivities *[]ActivityClassification `json:"defaultActivities,omitempty"`

	// An expression that would evaluate to a string or integer. This is used to determine the block of activities in cases that
	// will be executed.
	On *Expression `json:"on,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchActivityTypeProperties.
func (s *SwitchActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cases":
			if val != nil {
				err = json.Unmarshal(*val, &s.Cases)
			}
		case "defaultActivities":
			if val != nil {
				s.DefaultActivities, err = unmarshalActivityClassificationArray(*val)
			}
		case "on":
			if val != nil {
				err = json.Unmarshal(*val, &s.On)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Switch cases with have a value and corresponding activities.
type SwitchCase struct {
	// List of activities to execute for satisfied case condition.
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// Expected value that satisfies the expression result of the 'on' property.
	Value *string `json:"value,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SwitchCase.
func (s *SwitchCase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				s.Activities, err = unmarshalActivityClassificationArray(*val)
			}
		case "value":
			if val != nil {
				err = json.Unmarshal(*val, &s.Value)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Linked service for Sybase data source.
type SybaseLinkedService struct {
	LinkedService
	// Sybase linked service properties.
	TypeProperties *SybaseLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SybaseLinkedService.
func (s SybaseLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := s.LinkedService.marshalInternal("Sybase")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedService.
func (s *SybaseLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.LinkedService)
}

// Sybase linked service properties.
type SybaseLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *SybaseAuthenticationType `json:"authenticationType,omitempty"`

	// Database name for connection. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Schema name for connection. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseLinkedServiceTypeProperties.
func (s *SybaseLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &s.AuthenticationType)
			}
		case "database":
			if val != nil {
				err = json.Unmarshal(*val, &s.Database)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &s.EncryptedCredential)
			}
		case "password":
			if val != nil {
				s.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "schema":
			if val != nil {
				err = json.Unmarshal(*val, &s.Schema)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &s.Server)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &s.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Sybase table dataset.
type SybaseTableDataset struct {
	Dataset
	// Sybase table dataset properties.
	TypeProperties *SybaseTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SybaseTableDataset.
func (s SybaseTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := s.Dataset.marshalInternal("SybaseTable")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SybaseTableDataset.
func (s *SybaseTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Dataset)
}

// Sybase table dataset properties.
type SybaseTableDatasetTypeProperties struct {
	// The Sybase table name. Type: string (or Expression with resultType string).
	TableName *interface{} `json:"tableName,omitempty"`
}

// Execute Synapse notebook activity.
type SynapseNotebookActivity struct {
	Activity
	// Execute Synapse notebook activity properties.
	TypeProperties *SynapseNotebookActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SynapseNotebookActivity.
func (s SynapseNotebookActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SynapseNotebook")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseNotebookActivity.
func (s *SynapseNotebookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Activity)
}

// Execute Synapse notebook activity properties.
type SynapseNotebookActivityTypeProperties struct {
	// Synapse notebook reference.
	Notebook *SynapseNotebookReference `json:"notebook,omitempty"`

	// Notebook parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`
}

// Synapse notebook reference type.
type SynapseNotebookReference struct {
	// Reference notebook name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Synapse notebook reference type.
	Type *string `json:"type,omitempty"`
}

// Execute spark job activity properties.
type SynapseSparkJobActivityTypeProperties struct {
	// Synapse spark job reference.
	SparkJob *SynapseSparkJobReference `json:"sparkJob,omitempty"`
}

// Execute spark job activity.
type SynapseSparkJobDefinitionActivity struct {
	Activity
	// Execute spark job activity properties.
	TypeProperties *SynapseSparkJobActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SynapseSparkJobDefinitionActivity.
func (s SynapseSparkJobDefinitionActivity) MarshalJSON() ([]byte, error) {
	objectMap := s.Activity.marshalInternal("SparkJob")
	if s.TypeProperties != nil {
		objectMap["typeProperties"] = s.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SynapseSparkJobDefinitionActivity.
func (s *SynapseSparkJobDefinitionActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &s.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &s.Activity)
}

// Synapse spark job reference type.
type SynapseSparkJobReference struct {
	// Reference spark job name.
	ReferenceName *string `json:"referenceName,omitempty"`

	// Synapse spark job reference type.
	Type *string `json:"type,omitempty"`
}

// Linked service for Teradata data source.
type TeradataLinkedService struct {
	LinkedService
	// Teradata linked service properties.
	TypeProperties *TeradataLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TeradataLinkedService.
func (t TeradataLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := t.LinkedService.marshalInternal("Teradata")
	if t.TypeProperties != nil {
		objectMap["typeProperties"] = t.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedService.
func (t *TeradataLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &t.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &t.LinkedService)
}

// Teradata linked service properties.
type TeradataLinkedServiceTypeProperties struct {
	// AuthenticationType to be used for connection.
	AuthenticationType *TeradataAuthenticationType `json:"authenticationType,omitempty"`

	// Teradata ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// Password for authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Server name for connection. Type: string (or Expression with resultType string).
	Server *interface{} `json:"server,omitempty"`

	// Username for authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataLinkedServiceTypeProperties.
func (t *TeradataLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &t.AuthenticationType)
			}
		case "connectionString":
			if val != nil {
				err = json.Unmarshal(*val, &t.ConnectionString)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &t.EncryptedCredential)
			}
		case "password":
			if val != nil {
				t.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "server":
			if val != nil {
				err = json.Unmarshal(*val, &t.Server)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &t.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// The Teradata database dataset.
type TeradataTableDataset struct {
	Dataset
	// Teradata dataset properties.
	TypeProperties *TeradataTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TeradataTableDataset.
func (t TeradataTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := t.Dataset.marshalInternal("TeradataTable")
	if t.TypeProperties != nil {
		objectMap["typeProperties"] = t.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TeradataTableDataset.
func (t *TeradataTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &t.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &t.Dataset)
}

// Teradata dataset properties.
type TeradataTableDatasetTypeProperties struct {
	// The database name of Teradata. Type: string (or Expression with resultType string).
	Database *interface{} `json:"database,omitempty"`

	// The table name of Teradata. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`
}

// A data flow transformation.
type Transformation struct {
	// Transformation description.
	Description *string `json:"description,omitempty"`

	// Transformation name.
	Name *string `json:"name,omitempty"`
}

// TriggerClassification provides polymorphic access to related types.
type TriggerClassification interface {
	GetTrigger() *Trigger
}

// Azure Synapse nested object which contains information about creating pipeline run
type Trigger struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// List of tags that can be used for describing the trigger.
	Annotations *[]interface{} `json:"annotations,omitempty"`

	// Trigger description.
	Description *string `json:"description,omitempty"`

	// Indicates if trigger is running or not. Updated when Start/Stop APIs are called on the Trigger.
	RuntimeState *TriggerRuntimeState `json:"runtimeState,omitempty" azure:"ro"`

	// Trigger type.
	Type *string `json:"type,omitempty"`
}

// GetTrigger implements the TriggerClassification interface for type Trigger.
func (t *Trigger) GetTrigger() *Trigger { return t }

// UnmarshalJSON implements the json.Unmarshaller interface for type Trigger.
func (t *Trigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "annotations":
			if val != nil {
				err = json.Unmarshal(*val, &t.Annotations)
			}
		case "description":
			if val != nil {
				err = json.Unmarshal(*val, &t.Description)
			}
		case "runtimeState":
			if val != nil {
				err = json.Unmarshal(*val, &t.RuntimeState)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &t.Type)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (t Trigger) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	if t.AdditionalProperties != nil {
		objectMap["AdditionalProperties"] = t.AdditionalProperties
	}
	if t.Annotations != nil {
		objectMap["annotations"] = t.Annotations
	}
	if t.Description != nil {
		objectMap["description"] = t.Description
	}
	if t.RuntimeState != nil {
		objectMap["runtimeState"] = t.RuntimeState
	}
	t.Type = &discValue
	objectMap["type"] = t.Type
	return objectMap
}

// TriggerCreateOrUpdateTriggerOptions contains the optional parameters for the Trigger.CreateOrUpdateTrigger method.
type TriggerCreateOrUpdateTriggerOptions struct {
	// ETag of the trigger entity. Should only be specified for update, for which it should match existing entity or can be *
	// for unconditional update.
	IfMatch *string
}

// Defines the response of a provision trigger dependency operation.
type TriggerDependencyProvisioningStatus struct {
	// Provisioning status.
	ProvisioningStatus *string `json:"provisioningStatus,omitempty"`

	// Trigger name.
	TriggerName *string `json:"triggerName,omitempty"`
}

// TriggerGetTriggerOptions contains the optional parameters for the Trigger.GetTrigger method.
type TriggerGetTriggerOptions struct {
	// ETag of the trigger entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was
	// provided, then no content will be returned.
	IfNoneMatch *string
}

// A list of trigger resources.
type TriggerListResponse struct {
	// The link to the next page of results, if any remaining results exist.
	NextLink *string `json:"nextLink,omitempty"`

	// List of triggers.
	Value *[]TriggerResource `json:"value,omitempty"`
}

// TriggerListResponseResponse is the response envelope for operations that return a TriggerListResponse type.
type TriggerListResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of trigger resources.
	TriggerListResponse *TriggerListResponse
}

// Pipeline that needs to be triggered with the given parameters.
type TriggerPipelineReference struct {
	// Pipeline parameters.
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Pipeline reference.
	PipelineReference *PipelineReference `json:"pipelineReference,omitempty"`
}

// Trigger resource type.
type TriggerResource struct {
	SubResource
	// Properties of the trigger.
	Properties TriggerClassification `json:"properties,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerResource.
func (t *TriggerResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			if val != nil {
				t.Properties, err = unmarshalTriggerClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &t.SubResource)
}

// TriggerResourcePollerResponse is the response envelope for operations that asynchronously return a TriggerResource type.
type TriggerResourcePollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*TriggerResourceResponse, error)

	// Poller contains an initialized poller.
	Poller TriggerResourcePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerResourceResponse is the response envelope for operations that return a TriggerResource type.
type TriggerResourceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Trigger resource type.
	TriggerResource *TriggerResource
}

// Trigger runs.
type TriggerRun struct {
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Trigger error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// List of property name and value related to trigger run. Name, value pair depends on type of trigger.
	Properties *map[string]string `json:"properties,omitempty" azure:"ro"`

	// Trigger run status.
	Status *TriggerRunStatus `json:"status,omitempty" azure:"ro"`

	// Trigger name.
	TriggerName *string `json:"triggerName,omitempty" azure:"ro"`

	// Trigger run id.
	TriggerRunID *string `json:"triggerRunId,omitempty" azure:"ro"`

	// Trigger run start time.
	TriggerRunTimestamp *time.Time `json:"triggerRunTimestamp,omitempty" azure:"ro"`

	// Trigger type.
	TriggerType *string `json:"triggerType,omitempty" azure:"ro"`

	// List of pipeline name and run Id triggered by the trigger run.
	TriggeredPipelines *map[string]string `json:"triggeredPipelines,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TriggerRun.
func (t TriggerRun) MarshalJSON() ([]byte, error) {
	type alias TriggerRun
	aux := &struct {
		*alias
		AdditionalProperties *map[string]string `json:"AdditionalProperties"`
		TriggerRunTimestamp  *timeRFC3339       `json:"triggerRunTimestamp"`
	}{
		alias:               (*alias)(&t),
		TriggerRunTimestamp: (*timeRFC3339)(t.TriggerRunTimestamp),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerRun.
func (t *TriggerRun) UnmarshalJSON(data []byte) error {
	type alias TriggerRun
	aux := &struct {
		*alias
		AdditionalProperties *map[string]string `json:"AdditionalProperties"`
		TriggerRunTimestamp  *timeRFC3339       `json:"triggerRunTimestamp"`
	}{
		alias: (*alias)(t),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	t.AdditionalProperties = (*map[string]string)(aux.AdditionalProperties)
	t.TriggerRunTimestamp = (*time.Time)(aux.TriggerRunTimestamp)
	return nil
}

// A list of trigger runs.
type TriggerRunsQueryResponse struct {
	// The continuation token for getting the next page of results, if any remaining results exist, null otherwise.
	ContinuationToken *string `json:"continuationToken,omitempty"`

	// List of trigger runs.
	Value *[]TriggerRun `json:"value,omitempty"`
}

// TriggerRunsQueryResponseResponse is the response envelope for operations that return a TriggerRunsQueryResponse type.
type TriggerRunsQueryResponseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// A list of trigger runs.
	TriggerRunsQueryResponse *TriggerRunsQueryResponse
}

// Defines the response of a trigger subscription operation.
type TriggerSubscriptionOperationStatus struct {
	// Event Subscription Status.
	Status *EventSubscriptionStatus `json:"status,omitempty" azure:"ro"`

	// Trigger name.
	TriggerName *string `json:"triggerName,omitempty" azure:"ro"`
}

// TriggerSubscriptionOperationStatusPollerResponse is the response envelope for operations that asynchronously return a TriggerSubscriptionOperationStatus
// type.
type TriggerSubscriptionOperationStatusPollerResponse struct {
	// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received
	PollUntilDone func(ctx context.Context, frequency time.Duration) (*TriggerSubscriptionOperationStatusResponse, error)

	// Poller contains an initialized poller.
	Poller TriggerSubscriptionOperationStatusPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerSubscriptionOperationStatusResponse is the response envelope for operations that return a TriggerSubscriptionOperationStatus
// type.
type TriggerSubscriptionOperationStatusResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// Defines the response of a trigger subscription operation.
	TriggerSubscriptionOperationStatus *TriggerSubscriptionOperationStatus
}

// This activity executes inner activities until the specified boolean expression results to true or timeout is reached, whichever
// is earlier.
type UntilActivity struct {
	Activity
	// Until activity properties.
	TypeProperties *UntilActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UntilActivity.
func (u UntilActivity) MarshalJSON() ([]byte, error) {
	objectMap := u.Activity.marshalInternal("Until")
	if u.TypeProperties != nil {
		objectMap["typeProperties"] = u.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivity.
func (u *UntilActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &u.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &u.Activity)
}

// Until activity properties.
type UntilActivityTypeProperties struct {
	// List of activities to execute.
	Activities *[]ActivityClassification `json:"activities,omitempty"`

	// An expression that would evaluate to Boolean. The loop will continue until this expression evaluates to true
	Expression *Expression `json:"expression,omitempty"`

	// Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7)
	// which is 1 week as default. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	// Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *interface{} `json:"timeout,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UntilActivityTypeProperties.
func (u *UntilActivityTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activities":
			if val != nil {
				u.Activities, err = unmarshalActivityClassificationArray(*val)
			}
		case "expression":
			if val != nil {
				err = json.Unmarshal(*val, &u.Expression)
			}
		case "timeout":
			if val != nil {
				err = json.Unmarshal(*val, &u.Timeout)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// User property.
type UserProperty struct {
	// User property name.
	Name *string `json:"name,omitempty"`

	// User property value. Type: string (or Expression with resultType string).
	Value *interface{} `json:"value,omitempty"`
}

// This activity verifies that an external resource exists.
type ValidationActivity struct {
	Activity
	// Validation activity properties.
	TypeProperties *ValidationActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidationActivity.
func (v ValidationActivity) MarshalJSON() ([]byte, error) {
	objectMap := v.Activity.marshalInternal("Validation")
	if v.TypeProperties != nil {
		objectMap["typeProperties"] = v.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidationActivity.
func (v *ValidationActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &v.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &v.Activity)
}

// Validation activity properties.
type ValidationActivityTypeProperties struct {
	// Can be used if dataset points to a folder. If set to true, the folder must have at least one file. If set to false, the
	// folder must be empty. Type: boolean (or Expression with resultType boolean).
	ChildItems *interface{} `json:"childItems,omitempty"`

	// Validation activity dataset reference.
	Dataset *DatasetReference `json:"dataset,omitempty"`

	// Can be used if dataset points to a file. The file must be greater than or equal in size to the value specified. Type: integer
	// (or Expression with resultType integer).
	MinimumSize *interface{} `json:"minimumSize,omitempty"`

	// A delay in seconds between validation attempts. If no value is specified, 10 seconds will be used as the default. Type:
	// integer (or Expression with resultType integer).
	Sleep *interface{} `json:"sleep,omitempty"`

	// Specifies the timeout for the activity to run. If there is no value specified, it takes the value of TimeSpan.FromDays(7)
	// which is 1 week as default. Type: string (or Expression with resultType string), pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *interface{} `json:"timeout,omitempty"`
}

// Definition of a single variable for a Pipeline.
type VariableSpecification struct {
	// Default value of variable.
	DefaultValue *interface{} `json:"defaultValue,omitempty"`

	// Variable type.
	Type *VariableType `json:"type,omitempty"`
}

// Vertica Properties
type VerticaDatasetTypeProperties struct {
	// The schema name of the Vertica. Type: string (or Expression with resultType string).
	Schema *interface{} `json:"schema,omitempty"`

	// The table name of the Vertica. Type: string (or Expression with resultType string).
	Table *interface{} `json:"table,omitempty"`

	// This property will be retired. Please consider using schema + table properties instead.
	TableName *interface{} `json:"tableName,omitempty"`
}

// Vertica linked service.
type VerticaLinkedService struct {
	LinkedService
	// Vertica linked service properties.
	TypeProperties *VerticaLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VerticaLinkedService.
func (v VerticaLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := v.LinkedService.marshalInternal("Vertica")
	if v.TypeProperties != nil {
		objectMap["typeProperties"] = v.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaLinkedService.
func (v *VerticaLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &v.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &v.LinkedService)
}

// Vertica linked service properties.
type VerticaLinkedServiceTypeProperties struct {
	// An ODBC connection string. Type: string, SecureString or AzureKeyVaultSecretReference.
	ConnectionString *interface{} `json:"connectionString,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The Azure key vault secret reference of password in connection string.
	Pwd *AzureKeyVaultSecretReference `json:"pwd,omitempty"`
}

// Vertica dataset.
type VerticaTableDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *VerticaDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VerticaTableDataset.
func (v VerticaTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := v.Dataset.marshalInternal("VerticaTable")
	if v.TypeProperties != nil {
		objectMap["typeProperties"] = v.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VerticaTableDataset.
func (v *VerticaTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &v.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &v.Dataset)
}

// This activity suspends pipeline execution for the specified interval.
type WaitActivity struct {
	Activity
	// Wait activity properties.
	TypeProperties *WaitActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WaitActivity.
func (w WaitActivity) MarshalJSON() ([]byte, error) {
	objectMap := w.Activity.marshalInternal("Wait")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WaitActivity.
func (w *WaitActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.Activity)
}

// Wait activity properties.
type WaitActivityTypeProperties struct {
	// Duration in seconds.
	WaitTimeInSeconds *int32 `json:"waitTimeInSeconds,omitempty"`
}

// Web activity.
type WebActivity struct {
	ExecutionActivity
	// Web activity properties.
	TypeProperties *WebActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebActivity.
func (w WebActivity) MarshalJSON() ([]byte, error) {
	objectMap := w.ExecutionActivity.marshalInternal("WebActivity")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivity.
func (w *WebActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.ExecutionActivity)
}

// Web activity authentication properties.
type WebActivityAuthentication struct {
	// Password for the PFX file or basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Base64-encoded contents of a PFX file.
	Pfx SecretBaseClassification `json:"pfx,omitempty"`

	// Resource for which Azure Auth token will be requested when using MSI Authentication.
	Resource *string `json:"resource,omitempty"`

	// Web activity authentication (Basic/ClientCertificate/MSI)
	Type *string `json:"type,omitempty"`

	// Web activity authentication user name for basic authentication.
	Username *string `json:"username,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebActivityAuthentication.
func (w *WebActivityAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			if val != nil {
				w.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "pfx":
			if val != nil {
				w.Pfx, err = unmarshalSecretBaseClassification(*val)
			}
		case "resource":
			if val != nil {
				err = json.Unmarshal(*val, &w.Resource)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &w.Type)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &w.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Web activity type properties.
type WebActivityTypeProperties struct {
	// Authentication method used for calling the endpoint.
	Authentication *WebActivityAuthentication `json:"authentication,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type:
	// string (or Expression with resultType string).
	Body *interface{} `json:"body,omitempty"`

	// The integration runtime reference.
	ConnectVia *IntegrationRuntimeReference `json:"connectVia,omitempty"`

	// List of datasets passed to web endpoint.
	Datasets *[]DatasetReference `json:"datasets,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers"
	// : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
	Headers *interface{} `json:"headers,omitempty"`

	// List of linked services passed to web endpoint.
	LinkedServices *[]LinkedServiceReference `json:"linkedServices,omitempty"`

	// Rest API method for target endpoint.
	Method *WebActivityMethod `json:"method,omitempty"`

	// Web activity target endpoint and path. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// A WebLinkedService that uses anonymous authentication to communicate with an HTTP endpoint.
type WebAnonymousAuthentication struct {
	WebLinkedServiceTypeProperties
}

// MarshalJSON implements the json.Marshaller interface for type WebAnonymousAuthentication.
func (w WebAnonymousAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := w.WebLinkedServiceTypeProperties.marshalInternal(WebAuthenticationTypeAnonymous)
	return json.Marshal(objectMap)
}

// A WebLinkedService that uses basic authentication to communicate with an HTTP endpoint.
type WebBasicAuthentication struct {
	WebLinkedServiceTypeProperties
	// The password for Basic authentication.
	Password SecretBaseClassification `json:"password,omitempty"`

	// User name for Basic authentication. Type: string (or Expression with resultType string).
	Username *interface{} `json:"username,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebBasicAuthentication.
func (w WebBasicAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := w.WebLinkedServiceTypeProperties.marshalInternal(WebAuthenticationTypeBasic)
	if w.Password != nil {
		objectMap["password"] = w.Password
	}
	if w.Username != nil {
		objectMap["username"] = w.Username
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebBasicAuthentication.
func (w *WebBasicAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			if val != nil {
				w.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "username":
			if val != nil {
				err = json.Unmarshal(*val, &w.Username)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.WebLinkedServiceTypeProperties)
}

// A WebLinkedService that uses client certificate based authentication to communicate with an HTTP endpoint. This scheme
// follows mutual authentication; the server must also provide valid credentials to the client.
type WebClientCertificateAuthentication struct {
	WebLinkedServiceTypeProperties
	// Password for the PFX file.
	Password SecretBaseClassification `json:"password,omitempty"`

	// Base64-encoded contents of a PFX file.
	Pfx SecretBaseClassification `json:"pfx,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebClientCertificateAuthentication.
func (w WebClientCertificateAuthentication) MarshalJSON() ([]byte, error) {
	objectMap := w.WebLinkedServiceTypeProperties.marshalInternal(WebAuthenticationTypeClientCertificate)
	if w.Password != nil {
		objectMap["password"] = w.Password
	}
	if w.Pfx != nil {
		objectMap["pfx"] = w.Pfx
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebClientCertificateAuthentication.
func (w *WebClientCertificateAuthentication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			if val != nil {
				w.Password, err = unmarshalSecretBaseClassification(*val)
			}
		case "pfx":
			if val != nil {
				w.Pfx, err = unmarshalSecretBaseClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.WebLinkedServiceTypeProperties)
}

// WebHook activity.
type WebHookActivity struct {
	Activity
	// WebHook activity properties.
	TypeProperties *WebHookActivityTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebHookActivity.
func (w WebHookActivity) MarshalJSON() ([]byte, error) {
	objectMap := w.Activity.marshalInternal("WebHook")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebHookActivity.
func (w *WebHookActivity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.Activity)
}

// WebHook activity type properties.
type WebHookActivityTypeProperties struct {
	// Authentication method used for calling the endpoint.
	Authentication *WebActivityAuthentication `json:"authentication,omitempty"`

	// Represents the payload that will be sent to the endpoint. Required for POST/PUT method, not allowed for GET method Type:
	// string (or Expression with resultType string).
	Body *interface{} `json:"body,omitempty"`

	// Represents the headers that will be sent to the request. For example, to set the language and type on a request: "headers"
	// : { "Accept-Language": "en-us", "Content-Type": "application/json" }. Type: string (or Expression with resultType string).
	Headers *interface{} `json:"headers,omitempty"`

	// Rest API method for target endpoint.
	Method *string `json:"method,omitempty"`

	// When set to true, statusCode, output and error in callback request body will be consumed by activity. The activity can
	// be marked as failed by setting statusCode >= 400 in callback request. Default is false. Type: boolean (or Expression with
	// resultType boolean).
	ReportStatusOnCallBack *interface{} `json:"reportStatusOnCallBack,omitempty"`

	// The timeout within which the webhook should be called back. If there is no value specified, it defaults to 10 minutes.
	// Type: string. Pattern: ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
	Timeout *string `json:"timeout,omitempty"`

	// WebHook activity target endpoint and path. Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// Web linked service.
type WebLinkedService struct {
	LinkedService
	// Web linked service properties.
	TypeProperties WebLinkedServiceTypePropertiesClassification `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebLinkedService.
func (w WebLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := w.LinkedService.marshalInternal("Web")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedService.
func (w *WebLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				w.TypeProperties, err = unmarshalWebLinkedServiceTypePropertiesClassification(*val)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.LinkedService)
}

// WebLinkedServiceTypePropertiesClassification provides polymorphic access to related types.
type WebLinkedServiceTypePropertiesClassification interface {
	GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties
}

// Base definition of WebLinkedServiceTypeProperties, this typeProperties is polymorphic based on authenticationType, so not
// flattened in SDK models.
type WebLinkedServiceTypeProperties struct {
	// Type of authentication used to connect to the web table source.
	AuthenticationType *WebAuthenticationType `json:"authenticationType,omitempty"`

	// The URL of the web service endpoint, e.g. http://www.microsoft.com . Type: string (or Expression with resultType string).
	URL *interface{} `json:"url,omitempty"`
}

// GetWebLinkedServiceTypeProperties implements the WebLinkedServiceTypePropertiesClassification interface for type WebLinkedServiceTypeProperties.
func (w *WebLinkedServiceTypeProperties) GetWebLinkedServiceTypeProperties() *WebLinkedServiceTypeProperties {
	return w
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebLinkedServiceTypeProperties.
func (w *WebLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authenticationType":
			if val != nil {
				err = json.Unmarshal(*val, &w.AuthenticationType)
			}
		case "url":
			if val != nil {
				err = json.Unmarshal(*val, &w.URL)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (w WebLinkedServiceTypeProperties) marshalInternal(discValue WebAuthenticationType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	w.AuthenticationType = &discValue
	objectMap["authenticationType"] = w.AuthenticationType
	if w.URL != nil {
		objectMap["url"] = w.URL
	}
	return objectMap
}

// The dataset points to a HTML table in the web page.
type WebTableDataset struct {
	Dataset
	// Web table dataset properties.
	TypeProperties *WebTableDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WebTableDataset.
func (w WebTableDataset) MarshalJSON() ([]byte, error) {
	objectMap := w.Dataset.marshalInternal("WebTable")
	if w.TypeProperties != nil {
		objectMap["typeProperties"] = w.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebTableDataset.
func (w *WebTableDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &w.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &w.Dataset)
}

// Web table dataset properties.
type WebTableDatasetTypeProperties struct {
	// The zero-based index of the table in the web page. Type: integer (or Expression with resultType integer), minimum: 0.
	Index *interface{} `json:"index,omitempty"`

	// The relative URL to the web page from the linked service URL. Type: string (or Expression with resultType string).
	Path *interface{} `json:"path,omitempty"`
}

// Workspace resource type.
type Workspace struct {
	Resource
	// Contains additional key/value pairs not defined in the schema.
	AdditionalProperties *map[string]interface{}

	// Managed service identity of the workspace.
	IDentity *WorkspaceIDentity `json:"identity,omitempty"`

	// Properties of the workspace.
	Properties *WorkspaceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.ID != nil {
		objectMap["id"] = w.ID
	}
	if w.Name != nil {
		objectMap["name"] = w.Name
	}
	if w.Type != nil {
		objectMap["type"] = w.Type
	}
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	if w.ETag != nil {
		objectMap["eTag"] = w.ETag
	}
	if w.IDentity != nil {
		objectMap["identity"] = w.IDentity
	}
	if w.Properties != nil {
		objectMap["properties"] = w.Properties
	}
	if w.AdditionalProperties != nil {
		for key, val := range *w.AdditionalProperties {
			objectMap[key] = val
		}
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Workspace.
func (w *Workspace) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			if val != nil {
				err = json.Unmarshal(*val, &w.ID)
			}
		case "name":
			if val != nil {
				err = json.Unmarshal(*val, &w.Name)
			}
		case "type":
			if val != nil {
				err = json.Unmarshal(*val, &w.Type)
			}
		case "location":
			if val != nil {
				err = json.Unmarshal(*val, &w.Location)
			}
		case "tags":
			if val != nil {
				err = json.Unmarshal(*val, &w.Tags)
			}
		case "eTag":
			if val != nil {
				err = json.Unmarshal(*val, &w.ETag)
			}
		case "identity":
			if val != nil {
				err = json.Unmarshal(*val, &w.IDentity)
			}
		case "properties":
			if val != nil {
				err = json.Unmarshal(*val, &w.Properties)
			}
		default:
			if w.AdditionalProperties == nil {
				w.AdditionalProperties = &map[string]interface{}{}
			}
			if val != nil {
				var aux interface{}
				err = json.Unmarshal(*val, &aux)
				(*w.AdditionalProperties)[key] = aux
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Identity properties of the workspace resource.
type WorkspaceIDentity struct {
	// The principal id of the identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// The client tenant id of the identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`

	// The identity type. Currently the only supported type is 'SystemAssigned'.
	Type *string `json:"type,omitempty"`
}

// Workspace resource properties.
type WorkspaceProperties struct {
	// Time the workspace was created in ISO8601 format.
	CreateTime *time.Time `json:"createTime,omitempty" azure:"ro"`

	// Linked service reference.
	DefaultSQLServer *LinkedServiceReference `json:"defaultSqlServer,omitempty"`

	// Linked service reference.
	DefaultStorage *LinkedServiceReference `json:"defaultStorage,omitempty"`

	// Workspace provisioning state, example Succeeded.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// Version of the workspace.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceProperties.
func (w WorkspaceProperties) MarshalJSON() ([]byte, error) {
	type alias WorkspaceProperties
	aux := &struct {
		*alias
		CreateTime *timeRFC3339 `json:"createTime"`
	}{
		alias:      (*alias)(&w),
		CreateTime: (*timeRFC3339)(w.CreateTime),
	}
	return json.Marshal(aux)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceProperties.
func (w *WorkspaceProperties) UnmarshalJSON(data []byte) error {
	type alias WorkspaceProperties
	aux := &struct {
		*alias
		CreateTime *timeRFC3339 `json:"createTime"`
	}{
		alias: (*alias)(w),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	w.CreateTime = (*time.Time)(aux.CreateTime)
	return nil
}

// Parameters for updating a workspace resource.
type WorkspaceUpdateParameters struct {
	// Managed service identity of the workspace.
	IDentity *WorkspaceIDentity `json:"identity,omitempty"`

	// The resource tags.
	Tags *map[string]string `json:"tags,omitempty"`
}

// Xero Service linked service.
type XeroLinkedService struct {
	LinkedService
	// Xero Service linked service properties.
	TypeProperties *XeroLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XeroLinkedService.
func (x XeroLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := x.LinkedService.marshalInternal("Xero")
	if x.TypeProperties != nil {
		objectMap["typeProperties"] = x.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedService.
func (x *XeroLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &x.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &x.LinkedService)
}

// Xero Service linked service properties.
type XeroLinkedServiceTypeProperties struct {
	// The consumer key associated with the Xero application.
	ConsumerKey SecretBaseClassification `json:"consumerKey,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Xero server. (i.e. api.xero.com)
	Host *interface{} `json:"host,omitempty"`

	// The private key from the .pem file that was generated for your Xero private application. You must include all the text
	// from the .pem file, including the Unix line endings(
	// ).
	PrivateKey SecretBaseClassification `json:"privateKey,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroLinkedServiceTypeProperties.
func (x *XeroLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "consumerKey":
			if val != nil {
				x.ConsumerKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &x.EncryptedCredential)
			}
		case "host":
			if val != nil {
				err = json.Unmarshal(*val, &x.Host)
			}
		case "privateKey":
			if val != nil {
				x.PrivateKey, err = unmarshalSecretBaseClassification(*val)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &x.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &x.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &x.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Xero Service dataset.
type XeroObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type XeroObjectDataset.
func (x XeroObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := x.Dataset.marshalInternal("XeroObject")
	if x.TypeProperties != nil {
		objectMap["typeProperties"] = x.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type XeroObjectDataset.
func (x *XeroObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &x.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &x.Dataset)
}

// Zoho server linked service.
type ZohoLinkedService struct {
	LinkedService
	// Zoho server linked service properties.
	TypeProperties *ZohoLinkedServiceTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ZohoLinkedService.
func (z ZohoLinkedService) MarshalJSON() ([]byte, error) {
	objectMap := z.LinkedService.marshalInternal("Zoho")
	if z.TypeProperties != nil {
		objectMap["typeProperties"] = z.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedService.
func (z *ZohoLinkedService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &z.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &z.LinkedService)
}

// Zoho server linked service properties.
type ZohoLinkedServiceTypeProperties struct {
	// The access token for Zoho authentication.
	AccessToken SecretBaseClassification `json:"accessToken,omitempty"`

	// The encrypted credential used for authentication. Credentials are encrypted using the integration runtime credential manager.
	// Type: string (or Expression with resultType string).
	EncryptedCredential *interface{} `json:"encryptedCredential,omitempty"`

	// The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private)
	Endpoint *interface{} `json:"endpoint,omitempty"`

	// Specifies whether the data source endpoints are encrypted using HTTPS. The default value is true.
	UseEncryptedEndpoints *interface{} `json:"useEncryptedEndpoints,omitempty"`

	// Specifies whether to require the host name in the server's certificate to match the host name of the server when connecting
	// over SSL. The default value is true.
	UseHostVerification *interface{} `json:"useHostVerification,omitempty"`

	// Specifies whether to verify the identity of the server when connecting over SSL. The default value is true.
	UsePeerVerification *interface{} `json:"usePeerVerification,omitempty"`
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoLinkedServiceTypeProperties.
func (z *ZohoLinkedServiceTypeProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessToken":
			if val != nil {
				z.AccessToken, err = unmarshalSecretBaseClassification(*val)
			}
		case "encryptedCredential":
			if val != nil {
				err = json.Unmarshal(*val, &z.EncryptedCredential)
			}
		case "endpoint":
			if val != nil {
				err = json.Unmarshal(*val, &z.Endpoint)
			}
		case "useEncryptedEndpoints":
			if val != nil {
				err = json.Unmarshal(*val, &z.UseEncryptedEndpoints)
			}
		case "useHostVerification":
			if val != nil {
				err = json.Unmarshal(*val, &z.UseHostVerification)
			}
		case "usePeerVerification":
			if val != nil {
				err = json.Unmarshal(*val, &z.UsePeerVerification)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Zoho server dataset.
type ZohoObjectDataset struct {
	Dataset
	// Properties specific to this dataset type.
	TypeProperties *GenericDatasetTypeProperties `json:"typeProperties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ZohoObjectDataset.
func (z ZohoObjectDataset) MarshalJSON() ([]byte, error) {
	objectMap := z.Dataset.marshalInternal("ZohoObject")
	if z.TypeProperties != nil {
		objectMap["typeProperties"] = z.TypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ZohoObjectDataset.
func (z *ZohoObjectDataset) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "typeProperties":
			if val != nil {
				err = json.Unmarshal(*val, &z.TypeProperties)
			}
		}
		if err != nil {
			return err
		}
	}
	return json.Unmarshal(data, &z.Dataset)
}
