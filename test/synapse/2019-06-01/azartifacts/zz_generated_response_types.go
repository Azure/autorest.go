//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"time"
)

// bigDataPoolsClientGetResponse contains the response from method bigDataPoolsClient.Get.
type bigDataPoolsClientGetResponse struct {
	BigDataPoolResourceInfo
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// bigDataPoolsClientListResponse contains the response from method bigDataPoolsClient.List.
type bigDataPoolsClientListResponse struct {
	BigDataPoolResourceInfoListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowClientCreateOrUpdateDataFlowPollerResponse contains the response from method dataFlowClient.CreateOrUpdateDataFlow.
type dataFlowClientCreateOrUpdateDataFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *dataFlowClientCreateOrUpdateDataFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l dataFlowClientCreateOrUpdateDataFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientCreateOrUpdateDataFlowResponse, error) {
	respType := dataFlowClientCreateOrUpdateDataFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataFlowResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a dataFlowClientCreateOrUpdateDataFlowPollerResponse from the provided client and resume token.
func (l *dataFlowClientCreateOrUpdateDataFlowPollerResponse) Resume(ctx context.Context, client *dataFlowClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("dataFlowClient.CreateOrUpdateDataFlow", token, client.pl)
	if err != nil {
		return err
	}
	poller := &dataFlowClientCreateOrUpdateDataFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// dataFlowClientCreateOrUpdateDataFlowResponse contains the response from method dataFlowClient.CreateOrUpdateDataFlow.
type dataFlowClientCreateOrUpdateDataFlowResponse struct {
	DataFlowResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowClientDeleteDataFlowPollerResponse contains the response from method dataFlowClient.DeleteDataFlow.
type dataFlowClientDeleteDataFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *dataFlowClientDeleteDataFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l dataFlowClientDeleteDataFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientDeleteDataFlowResponse, error) {
	respType := dataFlowClientDeleteDataFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a dataFlowClientDeleteDataFlowPollerResponse from the provided client and resume token.
func (l *dataFlowClientDeleteDataFlowPollerResponse) Resume(ctx context.Context, client *dataFlowClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("dataFlowClient.DeleteDataFlow", token, client.pl)
	if err != nil {
		return err
	}
	poller := &dataFlowClientDeleteDataFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// dataFlowClientDeleteDataFlowResponse contains the response from method dataFlowClient.DeleteDataFlow.
type dataFlowClientDeleteDataFlowResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowClientGetDataFlowResponse contains the response from method dataFlowClient.GetDataFlow.
type dataFlowClientGetDataFlowResponse struct {
	DataFlowResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowClientGetDataFlowsByWorkspaceResponse contains the response from method dataFlowClient.GetDataFlowsByWorkspace.
type dataFlowClientGetDataFlowsByWorkspaceResponse struct {
	DataFlowListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowClientRenameDataFlowPollerResponse contains the response from method dataFlowClient.RenameDataFlow.
type dataFlowClientRenameDataFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *dataFlowClientRenameDataFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l dataFlowClientRenameDataFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowClientRenameDataFlowResponse, error) {
	respType := dataFlowClientRenameDataFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a dataFlowClientRenameDataFlowPollerResponse from the provided client and resume token.
func (l *dataFlowClientRenameDataFlowPollerResponse) Resume(ctx context.Context, client *dataFlowClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("dataFlowClient.RenameDataFlow", token, client.pl)
	if err != nil {
		return err
	}
	poller := &dataFlowClientRenameDataFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// dataFlowClientRenameDataFlowResponse contains the response from method dataFlowClient.RenameDataFlow.
type dataFlowClientRenameDataFlowResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowDebugSessionClientAddDataFlowResponse contains the response from method dataFlowDebugSessionClient.AddDataFlow.
type dataFlowDebugSessionClientAddDataFlowResponse struct {
	AddDataFlowToDebugSessionResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowDebugSessionClientCreateDataFlowDebugSessionPollerResponse contains the response from method dataFlowDebugSessionClient.CreateDataFlowDebugSession.
type dataFlowDebugSessionClientCreateDataFlowDebugSessionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l dataFlowDebugSessionClientCreateDataFlowDebugSessionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse, error) {
	respType := dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CreateDataFlowDebugSessionResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a dataFlowDebugSessionClientCreateDataFlowDebugSessionPollerResponse from the provided client and resume
// token.
func (l *dataFlowDebugSessionClientCreateDataFlowDebugSessionPollerResponse) Resume(ctx context.Context, client *dataFlowDebugSessionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("dataFlowDebugSessionClient.CreateDataFlowDebugSession", token, client.pl)
	if err != nil {
		return err
	}
	poller := &dataFlowDebugSessionClientCreateDataFlowDebugSessionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse contains the response from method dataFlowDebugSessionClient.CreateDataFlowDebugSession.
type dataFlowDebugSessionClientCreateDataFlowDebugSessionResponse struct {
	CreateDataFlowDebugSessionResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowDebugSessionClientDeleteDataFlowDebugSessionResponse contains the response from method dataFlowDebugSessionClient.DeleteDataFlowDebugSession.
type dataFlowDebugSessionClientDeleteDataFlowDebugSessionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowDebugSessionClientExecuteCommandPollerResponse contains the response from method dataFlowDebugSessionClient.ExecuteCommand.
type dataFlowDebugSessionClientExecuteCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *dataFlowDebugSessionClientExecuteCommandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l dataFlowDebugSessionClientExecuteCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (dataFlowDebugSessionClientExecuteCommandResponse, error) {
	respType := dataFlowDebugSessionClientExecuteCommandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataFlowDebugCommandResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a dataFlowDebugSessionClientExecuteCommandPollerResponse from the provided client and resume token.
func (l *dataFlowDebugSessionClientExecuteCommandPollerResponse) Resume(ctx context.Context, client *dataFlowDebugSessionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("dataFlowDebugSessionClient.ExecuteCommand", token, client.pl)
	if err != nil {
		return err
	}
	poller := &dataFlowDebugSessionClientExecuteCommandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// dataFlowDebugSessionClientExecuteCommandResponse contains the response from method dataFlowDebugSessionClient.ExecuteCommand.
type dataFlowDebugSessionClientExecuteCommandResponse struct {
	DataFlowDebugCommandResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspaceResponse contains the response from method dataFlowDebugSessionClient.QueryDataFlowDebugSessionsByWorkspace.
type dataFlowDebugSessionClientQueryDataFlowDebugSessionsByWorkspaceResponse struct {
	QueryDataFlowDebugSessionsResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// datasetClientCreateOrUpdateDatasetPollerResponse contains the response from method datasetClient.CreateOrUpdateDataset.
type datasetClientCreateOrUpdateDatasetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *datasetClientCreateOrUpdateDatasetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l datasetClientCreateOrUpdateDatasetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientCreateOrUpdateDatasetResponse, error) {
	respType := datasetClientCreateOrUpdateDatasetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatasetResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a datasetClientCreateOrUpdateDatasetPollerResponse from the provided client and resume token.
func (l *datasetClientCreateOrUpdateDatasetPollerResponse) Resume(ctx context.Context, client *datasetClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("datasetClient.CreateOrUpdateDataset", token, client.pl)
	if err != nil {
		return err
	}
	poller := &datasetClientCreateOrUpdateDatasetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// datasetClientCreateOrUpdateDatasetResponse contains the response from method datasetClient.CreateOrUpdateDataset.
type datasetClientCreateOrUpdateDatasetResponse struct {
	DatasetResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// datasetClientDeleteDatasetPollerResponse contains the response from method datasetClient.DeleteDataset.
type datasetClientDeleteDatasetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *datasetClientDeleteDatasetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l datasetClientDeleteDatasetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientDeleteDatasetResponse, error) {
	respType := datasetClientDeleteDatasetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a datasetClientDeleteDatasetPollerResponse from the provided client and resume token.
func (l *datasetClientDeleteDatasetPollerResponse) Resume(ctx context.Context, client *datasetClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("datasetClient.DeleteDataset", token, client.pl)
	if err != nil {
		return err
	}
	poller := &datasetClientDeleteDatasetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// datasetClientDeleteDatasetResponse contains the response from method datasetClient.DeleteDataset.
type datasetClientDeleteDatasetResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// datasetClientGetDatasetResponse contains the response from method datasetClient.GetDataset.
type datasetClientGetDatasetResponse struct {
	DatasetResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// datasetClientGetDatasetsByWorkspaceResponse contains the response from method datasetClient.GetDatasetsByWorkspace.
type datasetClientGetDatasetsByWorkspaceResponse struct {
	DatasetListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// datasetClientRenameDatasetPollerResponse contains the response from method datasetClient.RenameDataset.
type datasetClientRenameDatasetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *datasetClientRenameDatasetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l datasetClientRenameDatasetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (datasetClientRenameDatasetResponse, error) {
	respType := datasetClientRenameDatasetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a datasetClientRenameDatasetPollerResponse from the provided client and resume token.
func (l *datasetClientRenameDatasetPollerResponse) Resume(ctx context.Context, client *datasetClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("datasetClient.RenameDataset", token, client.pl)
	if err != nil {
		return err
	}
	poller := &datasetClientRenameDatasetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// datasetClientRenameDatasetResponse contains the response from method datasetClient.RenameDataset.
type datasetClientRenameDatasetResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// integrationRuntimesClientGetResponse contains the response from method integrationRuntimesClient.Get.
type integrationRuntimesClientGetResponse struct {
	IntegrationRuntimeResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// integrationRuntimesClientListResponse contains the response from method integrationRuntimesClient.List.
type integrationRuntimesClientListResponse struct {
	IntegrationRuntimeListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// libraryClientAppendResponse contains the response from method libraryClient.Append.
type libraryClientAppendResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// libraryClientCreatePollerResponse contains the response from method libraryClient.Create.
type libraryClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *libraryClientCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l libraryClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientCreateResponse, error) {
	respType := libraryClientCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LibraryResourceInfo)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a libraryClientCreatePollerResponse from the provided client and resume token.
func (l *libraryClientCreatePollerResponse) Resume(ctx context.Context, client *libraryClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("libraryClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &libraryClientCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// libraryClientCreateResponse contains the response from method libraryClient.Create.
type libraryClientCreateResponse struct {
	LibraryResourceInfo
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// libraryClientDeletePollerResponse contains the response from method libraryClient.Delete.
type libraryClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *libraryClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l libraryClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientDeleteResponse, error) {
	respType := libraryClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LibraryResourceInfo)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a libraryClientDeletePollerResponse from the provided client and resume token.
func (l *libraryClientDeletePollerResponse) Resume(ctx context.Context, client *libraryClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("libraryClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &libraryClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// libraryClientDeleteResponse contains the response from method libraryClient.Delete.
type libraryClientDeleteResponse struct {
	LibraryResourceInfo
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// libraryClientFlushPollerResponse contains the response from method libraryClient.Flush.
type libraryClientFlushPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *libraryClientFlushPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l libraryClientFlushPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (libraryClientFlushResponse, error) {
	respType := libraryClientFlushResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LibraryResourceInfo)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a libraryClientFlushPollerResponse from the provided client and resume token.
func (l *libraryClientFlushPollerResponse) Resume(ctx context.Context, client *libraryClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("libraryClient.Flush", token, client.pl)
	if err != nil {
		return err
	}
	poller := &libraryClientFlushPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// libraryClientFlushResponse contains the response from method libraryClient.Flush.
type libraryClientFlushResponse struct {
	LibraryResourceInfo
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// libraryClientGetOperationResultResponse contains the response from method libraryClient.GetOperationResult.
type libraryClientGetOperationResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// // Possible types are LibraryResource, OperationResult
	Value interface{}
}

// libraryClientGetResponse contains the response from method libraryClient.Get.
type libraryClientGetResponse struct {
	LibraryResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// libraryClientListResponse contains the response from method libraryClient.List.
type libraryClientListResponse struct {
	LibraryListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// linkedServiceClientCreateOrUpdateLinkedServicePollerResponse contains the response from method linkedServiceClient.CreateOrUpdateLinkedService.
type linkedServiceClientCreateOrUpdateLinkedServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *linkedServiceClientCreateOrUpdateLinkedServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l linkedServiceClientCreateOrUpdateLinkedServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientCreateOrUpdateLinkedServiceResponse, error) {
	respType := linkedServiceClientCreateOrUpdateLinkedServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LinkedServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a linkedServiceClientCreateOrUpdateLinkedServicePollerResponse from the provided client and resume token.
func (l *linkedServiceClientCreateOrUpdateLinkedServicePollerResponse) Resume(ctx context.Context, client *linkedServiceClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("linkedServiceClient.CreateOrUpdateLinkedService", token, client.pl)
	if err != nil {
		return err
	}
	poller := &linkedServiceClientCreateOrUpdateLinkedServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// linkedServiceClientCreateOrUpdateLinkedServiceResponse contains the response from method linkedServiceClient.CreateOrUpdateLinkedService.
type linkedServiceClientCreateOrUpdateLinkedServiceResponse struct {
	LinkedServiceResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// linkedServiceClientDeleteLinkedServicePollerResponse contains the response from method linkedServiceClient.DeleteLinkedService.
type linkedServiceClientDeleteLinkedServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *linkedServiceClientDeleteLinkedServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l linkedServiceClientDeleteLinkedServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientDeleteLinkedServiceResponse, error) {
	respType := linkedServiceClientDeleteLinkedServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a linkedServiceClientDeleteLinkedServicePollerResponse from the provided client and resume token.
func (l *linkedServiceClientDeleteLinkedServicePollerResponse) Resume(ctx context.Context, client *linkedServiceClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("linkedServiceClient.DeleteLinkedService", token, client.pl)
	if err != nil {
		return err
	}
	poller := &linkedServiceClientDeleteLinkedServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// linkedServiceClientDeleteLinkedServiceResponse contains the response from method linkedServiceClient.DeleteLinkedService.
type linkedServiceClientDeleteLinkedServiceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// linkedServiceClientGetLinkedServiceResponse contains the response from method linkedServiceClient.GetLinkedService.
type linkedServiceClientGetLinkedServiceResponse struct {
	LinkedServiceResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// linkedServiceClientGetLinkedServicesByWorkspaceResponse contains the response from method linkedServiceClient.GetLinkedServicesByWorkspace.
type linkedServiceClientGetLinkedServicesByWorkspaceResponse struct {
	LinkedServiceListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// linkedServiceClientRenameLinkedServicePollerResponse contains the response from method linkedServiceClient.RenameLinkedService.
type linkedServiceClientRenameLinkedServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *linkedServiceClientRenameLinkedServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l linkedServiceClientRenameLinkedServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (linkedServiceClientRenameLinkedServiceResponse, error) {
	respType := linkedServiceClientRenameLinkedServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a linkedServiceClientRenameLinkedServicePollerResponse from the provided client and resume token.
func (l *linkedServiceClientRenameLinkedServicePollerResponse) Resume(ctx context.Context, client *linkedServiceClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("linkedServiceClient.RenameLinkedService", token, client.pl)
	if err != nil {
		return err
	}
	poller := &linkedServiceClientRenameLinkedServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// linkedServiceClientRenameLinkedServiceResponse contains the response from method linkedServiceClient.RenameLinkedService.
type linkedServiceClientRenameLinkedServiceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// notebookClientCreateOrUpdateNotebookPollerResponse contains the response from method notebookClient.CreateOrUpdateNotebook.
type notebookClientCreateOrUpdateNotebookPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *notebookClientCreateOrUpdateNotebookPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l notebookClientCreateOrUpdateNotebookPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientCreateOrUpdateNotebookResponse, error) {
	respType := notebookClientCreateOrUpdateNotebookResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NotebookResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a notebookClientCreateOrUpdateNotebookPollerResponse from the provided client and resume token.
func (l *notebookClientCreateOrUpdateNotebookPollerResponse) Resume(ctx context.Context, client *notebookClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("notebookClient.CreateOrUpdateNotebook", token, client.pl)
	if err != nil {
		return err
	}
	poller := &notebookClientCreateOrUpdateNotebookPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// notebookClientCreateOrUpdateNotebookResponse contains the response from method notebookClient.CreateOrUpdateNotebook.
type notebookClientCreateOrUpdateNotebookResponse struct {
	NotebookResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// notebookClientDeleteNotebookPollerResponse contains the response from method notebookClient.DeleteNotebook.
type notebookClientDeleteNotebookPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *notebookClientDeleteNotebookPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l notebookClientDeleteNotebookPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientDeleteNotebookResponse, error) {
	respType := notebookClientDeleteNotebookResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a notebookClientDeleteNotebookPollerResponse from the provided client and resume token.
func (l *notebookClientDeleteNotebookPollerResponse) Resume(ctx context.Context, client *notebookClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("notebookClient.DeleteNotebook", token, client.pl)
	if err != nil {
		return err
	}
	poller := &notebookClientDeleteNotebookPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// notebookClientDeleteNotebookResponse contains the response from method notebookClient.DeleteNotebook.
type notebookClientDeleteNotebookResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// notebookClientGetNotebookResponse contains the response from method notebookClient.GetNotebook.
type notebookClientGetNotebookResponse struct {
	NotebookResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// notebookClientGetNotebookSummaryByWorkSpaceResponse contains the response from method notebookClient.GetNotebookSummaryByWorkSpace.
type notebookClientGetNotebookSummaryByWorkSpaceResponse struct {
	NotebookListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// notebookClientGetNotebooksByWorkspaceResponse contains the response from method notebookClient.GetNotebooksByWorkspace.
type notebookClientGetNotebooksByWorkspaceResponse struct {
	NotebookListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// notebookClientRenameNotebookPollerResponse contains the response from method notebookClient.RenameNotebook.
type notebookClientRenameNotebookPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *notebookClientRenameNotebookPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l notebookClientRenameNotebookPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (notebookClientRenameNotebookResponse, error) {
	respType := notebookClientRenameNotebookResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a notebookClientRenameNotebookPollerResponse from the provided client and resume token.
func (l *notebookClientRenameNotebookPollerResponse) Resume(ctx context.Context, client *notebookClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("notebookClient.RenameNotebook", token, client.pl)
	if err != nil {
		return err
	}
	poller := &notebookClientRenameNotebookPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// notebookClientRenameNotebookResponse contains the response from method notebookClient.RenameNotebook.
type notebookClientRenameNotebookResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineClientCreateOrUpdatePipelinePollerResponse contains the response from method pipelineClient.CreateOrUpdatePipeline.
type pipelineClientCreateOrUpdatePipelinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *pipelineClientCreateOrUpdatePipelinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l pipelineClientCreateOrUpdatePipelinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientCreateOrUpdatePipelineResponse, error) {
	respType := pipelineClientCreateOrUpdatePipelineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PipelineResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a pipelineClientCreateOrUpdatePipelinePollerResponse from the provided client and resume token.
func (l *pipelineClientCreateOrUpdatePipelinePollerResponse) Resume(ctx context.Context, client *pipelineClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("pipelineClient.CreateOrUpdatePipeline", token, client.pl)
	if err != nil {
		return err
	}
	poller := &pipelineClientCreateOrUpdatePipelinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// pipelineClientCreateOrUpdatePipelineResponse contains the response from method pipelineClient.CreateOrUpdatePipeline.
type pipelineClientCreateOrUpdatePipelineResponse struct {
	PipelineResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineClientCreatePipelineRunResponse contains the response from method pipelineClient.CreatePipelineRun.
type pipelineClientCreatePipelineRunResponse struct {
	CreateRunResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineClientDeletePipelinePollerResponse contains the response from method pipelineClient.DeletePipeline.
type pipelineClientDeletePipelinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *pipelineClientDeletePipelinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l pipelineClientDeletePipelinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientDeletePipelineResponse, error) {
	respType := pipelineClientDeletePipelineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a pipelineClientDeletePipelinePollerResponse from the provided client and resume token.
func (l *pipelineClientDeletePipelinePollerResponse) Resume(ctx context.Context, client *pipelineClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("pipelineClient.DeletePipeline", token, client.pl)
	if err != nil {
		return err
	}
	poller := &pipelineClientDeletePipelinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// pipelineClientDeletePipelineResponse contains the response from method pipelineClient.DeletePipeline.
type pipelineClientDeletePipelineResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineClientGetPipelineResponse contains the response from method pipelineClient.GetPipeline.
type pipelineClientGetPipelineResponse struct {
	PipelineResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineClientGetPipelinesByWorkspaceResponse contains the response from method pipelineClient.GetPipelinesByWorkspace.
type pipelineClientGetPipelinesByWorkspaceResponse struct {
	PipelineListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineClientRenamePipelinePollerResponse contains the response from method pipelineClient.RenamePipeline.
type pipelineClientRenamePipelinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *pipelineClientRenamePipelinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l pipelineClientRenamePipelinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (pipelineClientRenamePipelineResponse, error) {
	respType := pipelineClientRenamePipelineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a pipelineClientRenamePipelinePollerResponse from the provided client and resume token.
func (l *pipelineClientRenamePipelinePollerResponse) Resume(ctx context.Context, client *pipelineClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("pipelineClient.RenamePipeline", token, client.pl)
	if err != nil {
		return err
	}
	poller := &pipelineClientRenamePipelinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// pipelineClientRenamePipelineResponse contains the response from method pipelineClient.RenamePipeline.
type pipelineClientRenamePipelineResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineRunClientCancelPipelineRunResponse contains the response from method pipelineRunClient.CancelPipelineRun.
type pipelineRunClientCancelPipelineRunResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineRunClientGetPipelineRunResponse contains the response from method pipelineRunClient.GetPipelineRun.
type pipelineRunClientGetPipelineRunResponse struct {
	PipelineRun
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineRunClientQueryActivityRunsResponse contains the response from method pipelineRunClient.QueryActivityRuns.
type pipelineRunClientQueryActivityRunsResponse struct {
	ActivityRunsQueryResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// pipelineRunClientQueryPipelineRunsByWorkspaceResponse contains the response from method pipelineRunClient.QueryPipelineRunsByWorkspace.
type pipelineRunClientQueryPipelineRunsByWorkspaceResponse struct {
	PipelineRunsQueryResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPollerResponse contains the response from method sparkJobDefinitionClient.CreateOrUpdateSparkJobDefinition.
type sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SparkJobDefinitionResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPollerResponse from the provided client and
// resume token.
func (l *sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.CreateOrUpdateSparkJobDefinition", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse contains the response from method sparkJobDefinitionClient.CreateOrUpdateSparkJobDefinition.
type sparkJobDefinitionClientCreateOrUpdateSparkJobDefinitionResponse struct {
	SparkJobDefinitionResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientDebugSparkJobDefinitionPollerResponse contains the response from method sparkJobDefinitionClient.DebugSparkJobDefinition.
type sparkJobDefinitionClientDebugSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sparkJobDefinitionClientDebugSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sparkJobDefinitionClientDebugSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientDebugSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientDebugSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SparkBatchJob)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sparkJobDefinitionClientDebugSparkJobDefinitionPollerResponse from the provided client and resume token.
func (l *sparkJobDefinitionClientDebugSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.DebugSparkJobDefinition", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sparkJobDefinitionClientDebugSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sparkJobDefinitionClientDebugSparkJobDefinitionResponse contains the response from method sparkJobDefinitionClient.DebugSparkJobDefinition.
type sparkJobDefinitionClientDebugSparkJobDefinitionResponse struct {
	SparkBatchJob
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientDeleteSparkJobDefinitionPollerResponse contains the response from method sparkJobDefinitionClient.DeleteSparkJobDefinition.
type sparkJobDefinitionClientDeleteSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sparkJobDefinitionClientDeleteSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sparkJobDefinitionClientDeleteSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientDeleteSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientDeleteSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sparkJobDefinitionClientDeleteSparkJobDefinitionPollerResponse from the provided client and resume
// token.
func (l *sparkJobDefinitionClientDeleteSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.DeleteSparkJobDefinition", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sparkJobDefinitionClientDeleteSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sparkJobDefinitionClientDeleteSparkJobDefinitionResponse contains the response from method sparkJobDefinitionClient.DeleteSparkJobDefinition.
type sparkJobDefinitionClientDeleteSparkJobDefinitionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientExecuteSparkJobDefinitionPollerResponse contains the response from method sparkJobDefinitionClient.ExecuteSparkJobDefinition.
type sparkJobDefinitionClientExecuteSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sparkJobDefinitionClientExecuteSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sparkJobDefinitionClientExecuteSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientExecuteSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientExecuteSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SparkBatchJob)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sparkJobDefinitionClientExecuteSparkJobDefinitionPollerResponse from the provided client and resume
// token.
func (l *sparkJobDefinitionClientExecuteSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.ExecuteSparkJobDefinition", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sparkJobDefinitionClientExecuteSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sparkJobDefinitionClientExecuteSparkJobDefinitionResponse contains the response from method sparkJobDefinitionClient.ExecuteSparkJobDefinition.
type sparkJobDefinitionClientExecuteSparkJobDefinitionResponse struct {
	SparkBatchJob
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientGetSparkJobDefinitionResponse contains the response from method sparkJobDefinitionClient.GetSparkJobDefinition.
type sparkJobDefinitionClientGetSparkJobDefinitionResponse struct {
	SparkJobDefinitionResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspaceResponse contains the response from method sparkJobDefinitionClient.GetSparkJobDefinitionsByWorkspace.
type sparkJobDefinitionClientGetSparkJobDefinitionsByWorkspaceResponse struct {
	SparkJobDefinitionsListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sparkJobDefinitionClientRenameSparkJobDefinitionPollerResponse contains the response from method sparkJobDefinitionClient.RenameSparkJobDefinition.
type sparkJobDefinitionClientRenameSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sparkJobDefinitionClientRenameSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sparkJobDefinitionClientRenameSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sparkJobDefinitionClientRenameSparkJobDefinitionResponse, error) {
	respType := sparkJobDefinitionClientRenameSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sparkJobDefinitionClientRenameSparkJobDefinitionPollerResponse from the provided client and resume
// token.
func (l *sparkJobDefinitionClientRenameSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sparkJobDefinitionClient.RenameSparkJobDefinition", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sparkJobDefinitionClientRenameSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sparkJobDefinitionClientRenameSparkJobDefinitionResponse contains the response from method sparkJobDefinitionClient.RenameSparkJobDefinition.
type sparkJobDefinitionClientRenameSparkJobDefinitionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlPoolsClientGetResponse contains the response from method sqlPoolsClient.Get.
type sqlPoolsClientGetResponse struct {
	SQLPool
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlPoolsClientListResponse contains the response from method sqlPoolsClient.List.
type sqlPoolsClientListResponse struct {
	SQLPoolInfoListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlScriptClientCreateOrUpdateSQLScriptPollerResponse contains the response from method sqlScriptClient.CreateOrUpdateSQLScript.
type sqlScriptClientCreateOrUpdateSQLScriptPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sqlScriptClientCreateOrUpdateSQLScriptPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sqlScriptClientCreateOrUpdateSQLScriptPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientCreateOrUpdateSQLScriptResponse, error) {
	respType := sqlScriptClientCreateOrUpdateSQLScriptResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLScriptResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sqlScriptClientCreateOrUpdateSQLScriptPollerResponse from the provided client and resume token.
func (l *sqlScriptClientCreateOrUpdateSQLScriptPollerResponse) Resume(ctx context.Context, client *sqlScriptClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sqlScriptClient.CreateOrUpdateSQLScript", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sqlScriptClientCreateOrUpdateSQLScriptPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sqlScriptClientCreateOrUpdateSQLScriptResponse contains the response from method sqlScriptClient.CreateOrUpdateSQLScript.
type sqlScriptClientCreateOrUpdateSQLScriptResponse struct {
	SQLScriptResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlScriptClientDeleteSQLScriptPollerResponse contains the response from method sqlScriptClient.DeleteSQLScript.
type sqlScriptClientDeleteSQLScriptPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sqlScriptClientDeleteSQLScriptPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sqlScriptClientDeleteSQLScriptPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientDeleteSQLScriptResponse, error) {
	respType := sqlScriptClientDeleteSQLScriptResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sqlScriptClientDeleteSQLScriptPollerResponse from the provided client and resume token.
func (l *sqlScriptClientDeleteSQLScriptPollerResponse) Resume(ctx context.Context, client *sqlScriptClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sqlScriptClient.DeleteSQLScript", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sqlScriptClientDeleteSQLScriptPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sqlScriptClientDeleteSQLScriptResponse contains the response from method sqlScriptClient.DeleteSQLScript.
type sqlScriptClientDeleteSQLScriptResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlScriptClientGetSQLScriptResponse contains the response from method sqlScriptClient.GetSQLScript.
type sqlScriptClientGetSQLScriptResponse struct {
	SQLScriptResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlScriptClientGetSQLScriptsByWorkspaceResponse contains the response from method sqlScriptClient.GetSQLScriptsByWorkspace.
type sqlScriptClientGetSQLScriptsByWorkspaceResponse struct {
	SQLScriptsListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// sqlScriptClientRenameSQLScriptPollerResponse contains the response from method sqlScriptClient.RenameSQLScript.
type sqlScriptClientRenameSQLScriptPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *sqlScriptClientRenameSQLScriptPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l sqlScriptClientRenameSQLScriptPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (sqlScriptClientRenameSQLScriptResponse, error) {
	respType := sqlScriptClientRenameSQLScriptResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a sqlScriptClientRenameSQLScriptPollerResponse from the provided client and resume token.
func (l *sqlScriptClientRenameSQLScriptPollerResponse) Resume(ctx context.Context, client *sqlScriptClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("sqlScriptClient.RenameSQLScript", token, client.pl)
	if err != nil {
		return err
	}
	poller := &sqlScriptClientRenameSQLScriptPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// sqlScriptClientRenameSQLScriptResponse contains the response from method sqlScriptClient.RenameSQLScript.
type sqlScriptClientRenameSQLScriptResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientCreateOrUpdateTriggerPollerResponse contains the response from method triggerClient.CreateOrUpdateTrigger.
type triggerClientCreateOrUpdateTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *triggerClientCreateOrUpdateTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l triggerClientCreateOrUpdateTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientCreateOrUpdateTriggerResponse, error) {
	respType := triggerClientCreateOrUpdateTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a triggerClientCreateOrUpdateTriggerPollerResponse from the provided client and resume token.
func (l *triggerClientCreateOrUpdateTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("triggerClient.CreateOrUpdateTrigger", token, client.pl)
	if err != nil {
		return err
	}
	poller := &triggerClientCreateOrUpdateTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// triggerClientCreateOrUpdateTriggerResponse contains the response from method triggerClient.CreateOrUpdateTrigger.
type triggerClientCreateOrUpdateTriggerResponse struct {
	TriggerResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientDeleteTriggerPollerResponse contains the response from method triggerClient.DeleteTrigger.
type triggerClientDeleteTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *triggerClientDeleteTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l triggerClientDeleteTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientDeleteTriggerResponse, error) {
	respType := triggerClientDeleteTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a triggerClientDeleteTriggerPollerResponse from the provided client and resume token.
func (l *triggerClientDeleteTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("triggerClient.DeleteTrigger", token, client.pl)
	if err != nil {
		return err
	}
	poller := &triggerClientDeleteTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// triggerClientDeleteTriggerResponse contains the response from method triggerClient.DeleteTrigger.
type triggerClientDeleteTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientGetEventSubscriptionStatusResponse contains the response from method triggerClient.GetEventSubscriptionStatus.
type triggerClientGetEventSubscriptionStatusResponse struct {
	TriggerSubscriptionOperationStatus
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientGetTriggerResponse contains the response from method triggerClient.GetTrigger.
type triggerClientGetTriggerResponse struct {
	TriggerResource
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientGetTriggersByWorkspaceResponse contains the response from method triggerClient.GetTriggersByWorkspace.
type triggerClientGetTriggersByWorkspaceResponse struct {
	TriggerListResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientStartTriggerPollerResponse contains the response from method triggerClient.StartTrigger.
type triggerClientStartTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *triggerClientStartTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l triggerClientStartTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientStartTriggerResponse, error) {
	respType := triggerClientStartTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a triggerClientStartTriggerPollerResponse from the provided client and resume token.
func (l *triggerClientStartTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("triggerClient.StartTrigger", token, client.pl)
	if err != nil {
		return err
	}
	poller := &triggerClientStartTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// triggerClientStartTriggerResponse contains the response from method triggerClient.StartTrigger.
type triggerClientStartTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientStopTriggerPollerResponse contains the response from method triggerClient.StopTrigger.
type triggerClientStopTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *triggerClientStopTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l triggerClientStopTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientStopTriggerResponse, error) {
	respType := triggerClientStopTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a triggerClientStopTriggerPollerResponse from the provided client and resume token.
func (l *triggerClientStopTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("triggerClient.StopTrigger", token, client.pl)
	if err != nil {
		return err
	}
	poller := &triggerClientStopTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// triggerClientStopTriggerResponse contains the response from method triggerClient.StopTrigger.
type triggerClientStopTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientSubscribeTriggerToEventsPollerResponse contains the response from method triggerClient.SubscribeTriggerToEvents.
type triggerClientSubscribeTriggerToEventsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *triggerClientSubscribeTriggerToEventsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l triggerClientSubscribeTriggerToEventsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientSubscribeTriggerToEventsResponse, error) {
	respType := triggerClientSubscribeTriggerToEventsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a triggerClientSubscribeTriggerToEventsPollerResponse from the provided client and resume token.
func (l *triggerClientSubscribeTriggerToEventsPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("triggerClient.SubscribeTriggerToEvents", token, client.pl)
	if err != nil {
		return err
	}
	poller := &triggerClientSubscribeTriggerToEventsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// triggerClientSubscribeTriggerToEventsResponse contains the response from method triggerClient.SubscribeTriggerToEvents.
type triggerClientSubscribeTriggerToEventsResponse struct {
	TriggerSubscriptionOperationStatus
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerClientUnsubscribeTriggerFromEventsPollerResponse contains the response from method triggerClient.UnsubscribeTriggerFromEvents.
type triggerClientUnsubscribeTriggerFromEventsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *triggerClientUnsubscribeTriggerFromEventsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
func (l triggerClientUnsubscribeTriggerFromEventsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (triggerClientUnsubscribeTriggerFromEventsResponse, error) {
	respType := triggerClientUnsubscribeTriggerFromEventsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a triggerClientUnsubscribeTriggerFromEventsPollerResponse from the provided client and resume token.
func (l *triggerClientUnsubscribeTriggerFromEventsPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := runtime.NewPollerFromResumeToken("triggerClient.UnsubscribeTriggerFromEvents", token, client.pl)
	if err != nil {
		return err
	}
	poller := &triggerClientUnsubscribeTriggerFromEventsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// triggerClientUnsubscribeTriggerFromEventsResponse contains the response from method triggerClient.UnsubscribeTriggerFromEvents.
type triggerClientUnsubscribeTriggerFromEventsResponse struct {
	TriggerSubscriptionOperationStatus
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerRunClientCancelTriggerInstanceResponse contains the response from method triggerRunClient.CancelTriggerInstance.
type triggerRunClientCancelTriggerInstanceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerRunClientQueryTriggerRunsByWorkspaceResponse contains the response from method triggerRunClient.QueryTriggerRunsByWorkspace.
type triggerRunClientQueryTriggerRunsByWorkspaceResponse struct {
	TriggerRunsQueryResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// triggerRunClientRerunTriggerInstanceResponse contains the response from method triggerRunClient.RerunTriggerInstance.
type triggerRunClientRerunTriggerInstanceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// workspaceClientGetResponse contains the response from method workspaceClient.Get.
type workspaceClientGetResponse struct {
	Workspace
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// workspaceGitRepoManagementClientGetGitHubAccessTokenResponse contains the response from method workspaceGitRepoManagementClient.GetGitHubAccessToken.
type workspaceGitRepoManagementClientGetGitHubAccessTokenResponse struct {
	GitHubAccessTokenResponse
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}
