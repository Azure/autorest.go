//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azartifacts

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// BigDataPoolsGetResponse contains the response from method BigDataPools.Get.
type BigDataPoolsGetResponse struct {
	BigDataPoolsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BigDataPoolsGetResult contains the result from method BigDataPools.Get.
type BigDataPoolsGetResult struct {
	BigDataPoolResourceInfo
}

// BigDataPoolsListResponse contains the response from method BigDataPools.List.
type BigDataPoolsListResponse struct {
	BigDataPoolsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// BigDataPoolsListResult contains the result from method BigDataPools.List.
type BigDataPoolsListResult struct {
	BigDataPoolResourceInfoListResult
}

// DataFlowCreateOrUpdateDataFlowPollerResponse contains the response from method DataFlow.CreateOrUpdateDataFlow.
type DataFlowCreateOrUpdateDataFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataFlowCreateOrUpdateDataFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DataFlowCreateOrUpdateDataFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataFlowCreateOrUpdateDataFlowResponse, error) {
	respType := DataFlowCreateOrUpdateDataFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataFlowResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataFlowCreateOrUpdateDataFlowPollerResponse from the provided client and resume token.
func (l *DataFlowCreateOrUpdateDataFlowPollerResponse) Resume(ctx context.Context, client *dataFlowClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("dataFlowClient.CreateOrUpdateDataFlow", token, client.con.Pipeline(), client.createOrUpdateDataFlowHandleError)
	if err != nil {
		return err
	}
	poller := &DataFlowCreateOrUpdateDataFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataFlowCreateOrUpdateDataFlowResponse contains the response from method DataFlow.CreateOrUpdateDataFlow.
type DataFlowCreateOrUpdateDataFlowResponse struct {
	DataFlowCreateOrUpdateDataFlowResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowCreateOrUpdateDataFlowResult contains the result from method DataFlow.CreateOrUpdateDataFlow.
type DataFlowCreateOrUpdateDataFlowResult struct {
	DataFlowResource
}

// DataFlowDebugSessionAddDataFlowResponse contains the response from method DataFlowDebugSession.AddDataFlow.
type DataFlowDebugSessionAddDataFlowResponse struct {
	DataFlowDebugSessionAddDataFlowResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugSessionAddDataFlowResult contains the result from method DataFlowDebugSession.AddDataFlow.
type DataFlowDebugSessionAddDataFlowResult struct {
	AddDataFlowToDebugSessionResponse
}

// DataFlowDebugSessionCreateDataFlowDebugSessionPollerResponse contains the response from method DataFlowDebugSession.CreateDataFlowDebugSession.
type DataFlowDebugSessionCreateDataFlowDebugSessionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataFlowDebugSessionCreateDataFlowDebugSessionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DataFlowDebugSessionCreateDataFlowDebugSessionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataFlowDebugSessionCreateDataFlowDebugSessionResponse, error) {
	respType := DataFlowDebugSessionCreateDataFlowDebugSessionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CreateDataFlowDebugSessionResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataFlowDebugSessionCreateDataFlowDebugSessionPollerResponse from the provided client and resume token.
func (l *DataFlowDebugSessionCreateDataFlowDebugSessionPollerResponse) Resume(ctx context.Context, client *dataFlowDebugSessionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("dataFlowDebugSessionClient.CreateDataFlowDebugSession", token, client.con.Pipeline(), client.createDataFlowDebugSessionHandleError)
	if err != nil {
		return err
	}
	poller := &DataFlowDebugSessionCreateDataFlowDebugSessionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataFlowDebugSessionCreateDataFlowDebugSessionResponse contains the response from method DataFlowDebugSession.CreateDataFlowDebugSession.
type DataFlowDebugSessionCreateDataFlowDebugSessionResponse struct {
	DataFlowDebugSessionCreateDataFlowDebugSessionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugSessionCreateDataFlowDebugSessionResult contains the result from method DataFlowDebugSession.CreateDataFlowDebugSession.
type DataFlowDebugSessionCreateDataFlowDebugSessionResult struct {
	CreateDataFlowDebugSessionResponse
}

// DataFlowDebugSessionDeleteDataFlowDebugSessionResponse contains the response from method DataFlowDebugSession.DeleteDataFlowDebugSession.
type DataFlowDebugSessionDeleteDataFlowDebugSessionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugSessionExecuteCommandPollerResponse contains the response from method DataFlowDebugSession.ExecuteCommand.
type DataFlowDebugSessionExecuteCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataFlowDebugSessionExecuteCommandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DataFlowDebugSessionExecuteCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataFlowDebugSessionExecuteCommandResponse, error) {
	respType := DataFlowDebugSessionExecuteCommandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DataFlowDebugCommandResponse)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataFlowDebugSessionExecuteCommandPollerResponse from the provided client and resume token.
func (l *DataFlowDebugSessionExecuteCommandPollerResponse) Resume(ctx context.Context, client *dataFlowDebugSessionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("dataFlowDebugSessionClient.ExecuteCommand", token, client.con.Pipeline(), client.executeCommandHandleError)
	if err != nil {
		return err
	}
	poller := &DataFlowDebugSessionExecuteCommandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataFlowDebugSessionExecuteCommandResponse contains the response from method DataFlowDebugSession.ExecuteCommand.
type DataFlowDebugSessionExecuteCommandResponse struct {
	DataFlowDebugSessionExecuteCommandResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugSessionExecuteCommandResult contains the result from method DataFlowDebugSession.ExecuteCommand.
type DataFlowDebugSessionExecuteCommandResult struct {
	DataFlowDebugCommandResponse
}

// DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceResponse contains the response from method DataFlowDebugSession.QueryDataFlowDebugSessionsByWorkspace.
type DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceResponse struct {
	DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceResult contains the result from method DataFlowDebugSession.QueryDataFlowDebugSessionsByWorkspace.
type DataFlowDebugSessionQueryDataFlowDebugSessionsByWorkspaceResult struct {
	QueryDataFlowDebugSessionsResponse
}

// DataFlowDeleteDataFlowPollerResponse contains the response from method DataFlow.DeleteDataFlow.
type DataFlowDeleteDataFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataFlowDeleteDataFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DataFlowDeleteDataFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataFlowDeleteDataFlowResponse, error) {
	respType := DataFlowDeleteDataFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataFlowDeleteDataFlowPollerResponse from the provided client and resume token.
func (l *DataFlowDeleteDataFlowPollerResponse) Resume(ctx context.Context, client *dataFlowClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("dataFlowClient.DeleteDataFlow", token, client.con.Pipeline(), client.deleteDataFlowHandleError)
	if err != nil {
		return err
	}
	poller := &DataFlowDeleteDataFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataFlowDeleteDataFlowResponse contains the response from method DataFlow.DeleteDataFlow.
type DataFlowDeleteDataFlowResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowGetDataFlowResponse contains the response from method DataFlow.GetDataFlow.
type DataFlowGetDataFlowResponse struct {
	DataFlowGetDataFlowResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowGetDataFlowResult contains the result from method DataFlow.GetDataFlow.
type DataFlowGetDataFlowResult struct {
	DataFlowResource
}

// DataFlowGetDataFlowsByWorkspaceResponse contains the response from method DataFlow.GetDataFlowsByWorkspace.
type DataFlowGetDataFlowsByWorkspaceResponse struct {
	DataFlowGetDataFlowsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DataFlowGetDataFlowsByWorkspaceResult contains the result from method DataFlow.GetDataFlowsByWorkspace.
type DataFlowGetDataFlowsByWorkspaceResult struct {
	DataFlowListResponse
}

// DataFlowRenameDataFlowPollerResponse contains the response from method DataFlow.RenameDataFlow.
type DataFlowRenameDataFlowPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DataFlowRenameDataFlowPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DataFlowRenameDataFlowPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DataFlowRenameDataFlowResponse, error) {
	respType := DataFlowRenameDataFlowResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DataFlowRenameDataFlowPollerResponse from the provided client and resume token.
func (l *DataFlowRenameDataFlowPollerResponse) Resume(ctx context.Context, client *dataFlowClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("dataFlowClient.RenameDataFlow", token, client.con.Pipeline(), client.renameDataFlowHandleError)
	if err != nil {
		return err
	}
	poller := &DataFlowRenameDataFlowPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DataFlowRenameDataFlowResponse contains the response from method DataFlow.RenameDataFlow.
type DataFlowRenameDataFlowResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetCreateOrUpdateDatasetPollerResponse contains the response from method Dataset.CreateOrUpdateDataset.
type DatasetCreateOrUpdateDatasetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatasetCreateOrUpdateDatasetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DatasetCreateOrUpdateDatasetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatasetCreateOrUpdateDatasetResponse, error) {
	respType := DatasetCreateOrUpdateDatasetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatasetResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatasetCreateOrUpdateDatasetPollerResponse from the provided client and resume token.
func (l *DatasetCreateOrUpdateDatasetPollerResponse) Resume(ctx context.Context, client *datasetClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("datasetClient.CreateOrUpdateDataset", token, client.con.Pipeline(), client.createOrUpdateDatasetHandleError)
	if err != nil {
		return err
	}
	poller := &DatasetCreateOrUpdateDatasetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatasetCreateOrUpdateDatasetResponse contains the response from method Dataset.CreateOrUpdateDataset.
type DatasetCreateOrUpdateDatasetResponse struct {
	DatasetCreateOrUpdateDatasetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetCreateOrUpdateDatasetResult contains the result from method Dataset.CreateOrUpdateDataset.
type DatasetCreateOrUpdateDatasetResult struct {
	DatasetResource
}

// DatasetDeleteDatasetPollerResponse contains the response from method Dataset.DeleteDataset.
type DatasetDeleteDatasetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatasetDeleteDatasetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DatasetDeleteDatasetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatasetDeleteDatasetResponse, error) {
	respType := DatasetDeleteDatasetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatasetDeleteDatasetPollerResponse from the provided client and resume token.
func (l *DatasetDeleteDatasetPollerResponse) Resume(ctx context.Context, client *datasetClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("datasetClient.DeleteDataset", token, client.con.Pipeline(), client.deleteDatasetHandleError)
	if err != nil {
		return err
	}
	poller := &DatasetDeleteDatasetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatasetDeleteDatasetResponse contains the response from method Dataset.DeleteDataset.
type DatasetDeleteDatasetResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetGetDatasetResponse contains the response from method Dataset.GetDataset.
type DatasetGetDatasetResponse struct {
	DatasetGetDatasetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetGetDatasetResult contains the result from method Dataset.GetDataset.
type DatasetGetDatasetResult struct {
	DatasetResource
}

// DatasetGetDatasetsByWorkspaceResponse contains the response from method Dataset.GetDatasetsByWorkspace.
type DatasetGetDatasetsByWorkspaceResponse struct {
	DatasetGetDatasetsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatasetGetDatasetsByWorkspaceResult contains the result from method Dataset.GetDatasetsByWorkspace.
type DatasetGetDatasetsByWorkspaceResult struct {
	DatasetListResponse
}

// DatasetRenameDatasetPollerResponse contains the response from method Dataset.RenameDataset.
type DatasetRenameDatasetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatasetRenameDatasetPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l DatasetRenameDatasetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatasetRenameDatasetResponse, error) {
	respType := DatasetRenameDatasetResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatasetRenameDatasetPollerResponse from the provided client and resume token.
func (l *DatasetRenameDatasetPollerResponse) Resume(ctx context.Context, client *datasetClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("datasetClient.RenameDataset", token, client.con.Pipeline(), client.renameDatasetHandleError)
	if err != nil {
		return err
	}
	poller := &DatasetRenameDatasetPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatasetRenameDatasetResponse contains the response from method Dataset.RenameDataset.
type DatasetRenameDatasetResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IntegrationRuntimesGetResponse contains the response from method IntegrationRuntimes.Get.
type IntegrationRuntimesGetResponse struct {
	IntegrationRuntimesGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IntegrationRuntimesGetResult contains the result from method IntegrationRuntimes.Get.
type IntegrationRuntimesGetResult struct {
	IntegrationRuntimeResource
}

// IntegrationRuntimesListResponse contains the response from method IntegrationRuntimes.List.
type IntegrationRuntimesListResponse struct {
	IntegrationRuntimesListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// IntegrationRuntimesListResult contains the result from method IntegrationRuntimes.List.
type IntegrationRuntimesListResult struct {
	IntegrationRuntimeListResponse
}

// LibraryAppendResponse contains the response from method Library.Append.
type LibraryAppendResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LibraryCreatePollerResponse contains the response from method Library.Create.
type LibraryCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LibraryCreatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l LibraryCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LibraryCreateResponse, error) {
	respType := LibraryCreateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LibraryResourceInfo)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LibraryCreatePollerResponse from the provided client and resume token.
func (l *LibraryCreatePollerResponse) Resume(ctx context.Context, client *libraryClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("libraryClient.Create", token, client.con.Pipeline(), client.createHandleError)
	if err != nil {
		return err
	}
	poller := &LibraryCreatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LibraryCreateResponse contains the response from method Library.Create.
type LibraryCreateResponse struct {
	LibraryCreateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LibraryCreateResult contains the result from method Library.Create.
type LibraryCreateResult struct {
	LibraryResourceInfo
}

// LibraryDeletePollerResponse contains the response from method Library.Delete.
type LibraryDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LibraryDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l LibraryDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LibraryDeleteResponse, error) {
	respType := LibraryDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LibraryResourceInfo)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LibraryDeletePollerResponse from the provided client and resume token.
func (l *LibraryDeletePollerResponse) Resume(ctx context.Context, client *libraryClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("libraryClient.Delete", token, client.con.Pipeline(), client.deleteHandleError)
	if err != nil {
		return err
	}
	poller := &LibraryDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LibraryDeleteResponse contains the response from method Library.Delete.
type LibraryDeleteResponse struct {
	LibraryDeleteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LibraryDeleteResult contains the result from method Library.Delete.
type LibraryDeleteResult struct {
	LibraryResourceInfo
}

// LibraryFlushPollerResponse contains the response from method Library.Flush.
type LibraryFlushPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LibraryFlushPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l LibraryFlushPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LibraryFlushResponse, error) {
	respType := LibraryFlushResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LibraryResourceInfo)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LibraryFlushPollerResponse from the provided client and resume token.
func (l *LibraryFlushPollerResponse) Resume(ctx context.Context, client *libraryClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("libraryClient.Flush", token, client.con.Pipeline(), client.flushHandleError)
	if err != nil {
		return err
	}
	poller := &LibraryFlushPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LibraryFlushResponse contains the response from method Library.Flush.
type LibraryFlushResponse struct {
	LibraryFlushResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LibraryFlushResult contains the result from method Library.Flush.
type LibraryFlushResult struct {
	LibraryResourceInfo
}

// LibraryGetOperationResultResponse contains the response from method Library.GetOperationResult.
type LibraryGetOperationResultResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response

	// // Possible types are LibraryResource, OperationResult
	Value interface{}
}

// LibraryGetResponse contains the response from method Library.Get.
type LibraryGetResponse struct {
	LibraryGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LibraryGetResult contains the result from method Library.Get.
type LibraryGetResult struct {
	LibraryResource
}

// LibraryListResponseEnvelope contains the response from method Library.List.
type LibraryListResponseEnvelope struct {
	LibraryListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LibraryListResult contains the result from method Library.List.
type LibraryListResult struct {
	LibraryListResponse
}

// LinkedServiceCreateOrUpdateLinkedServicePollerResponse contains the response from method LinkedService.CreateOrUpdateLinkedService.
type LinkedServiceCreateOrUpdateLinkedServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkedServiceCreateOrUpdateLinkedServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l LinkedServiceCreateOrUpdateLinkedServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkedServiceCreateOrUpdateLinkedServiceResponse, error) {
	respType := LinkedServiceCreateOrUpdateLinkedServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LinkedServiceResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkedServiceCreateOrUpdateLinkedServicePollerResponse from the provided client and resume token.
func (l *LinkedServiceCreateOrUpdateLinkedServicePollerResponse) Resume(ctx context.Context, client *linkedServiceClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("linkedServiceClient.CreateOrUpdateLinkedService", token, client.con.Pipeline(), client.createOrUpdateLinkedServiceHandleError)
	if err != nil {
		return err
	}
	poller := &LinkedServiceCreateOrUpdateLinkedServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkedServiceCreateOrUpdateLinkedServiceResponse contains the response from method LinkedService.CreateOrUpdateLinkedService.
type LinkedServiceCreateOrUpdateLinkedServiceResponse struct {
	LinkedServiceCreateOrUpdateLinkedServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServiceCreateOrUpdateLinkedServiceResult contains the result from method LinkedService.CreateOrUpdateLinkedService.
type LinkedServiceCreateOrUpdateLinkedServiceResult struct {
	LinkedServiceResource
}

// LinkedServiceDeleteLinkedServicePollerResponse contains the response from method LinkedService.DeleteLinkedService.
type LinkedServiceDeleteLinkedServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkedServiceDeleteLinkedServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l LinkedServiceDeleteLinkedServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkedServiceDeleteLinkedServiceResponse, error) {
	respType := LinkedServiceDeleteLinkedServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkedServiceDeleteLinkedServicePollerResponse from the provided client and resume token.
func (l *LinkedServiceDeleteLinkedServicePollerResponse) Resume(ctx context.Context, client *linkedServiceClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("linkedServiceClient.DeleteLinkedService", token, client.con.Pipeline(), client.deleteLinkedServiceHandleError)
	if err != nil {
		return err
	}
	poller := &LinkedServiceDeleteLinkedServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkedServiceDeleteLinkedServiceResponse contains the response from method LinkedService.DeleteLinkedService.
type LinkedServiceDeleteLinkedServiceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServiceGetLinkedServiceResponse contains the response from method LinkedService.GetLinkedService.
type LinkedServiceGetLinkedServiceResponse struct {
	LinkedServiceGetLinkedServiceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServiceGetLinkedServiceResult contains the result from method LinkedService.GetLinkedService.
type LinkedServiceGetLinkedServiceResult struct {
	LinkedServiceResource
}

// LinkedServiceGetLinkedServicesByWorkspaceResponse contains the response from method LinkedService.GetLinkedServicesByWorkspace.
type LinkedServiceGetLinkedServicesByWorkspaceResponse struct {
	LinkedServiceGetLinkedServicesByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// LinkedServiceGetLinkedServicesByWorkspaceResult contains the result from method LinkedService.GetLinkedServicesByWorkspace.
type LinkedServiceGetLinkedServicesByWorkspaceResult struct {
	LinkedServiceListResponse
}

// LinkedServiceRenameLinkedServicePollerResponse contains the response from method LinkedService.RenameLinkedService.
type LinkedServiceRenameLinkedServicePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LinkedServiceRenameLinkedServicePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l LinkedServiceRenameLinkedServicePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LinkedServiceRenameLinkedServiceResponse, error) {
	respType := LinkedServiceRenameLinkedServiceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a LinkedServiceRenameLinkedServicePollerResponse from the provided client and resume token.
func (l *LinkedServiceRenameLinkedServicePollerResponse) Resume(ctx context.Context, client *linkedServiceClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("linkedServiceClient.RenameLinkedService", token, client.con.Pipeline(), client.renameLinkedServiceHandleError)
	if err != nil {
		return err
	}
	poller := &LinkedServiceRenameLinkedServicePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// LinkedServiceRenameLinkedServiceResponse contains the response from method LinkedService.RenameLinkedService.
type LinkedServiceRenameLinkedServiceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookCreateOrUpdateNotebookPollerResponse contains the response from method Notebook.CreateOrUpdateNotebook.
type NotebookCreateOrUpdateNotebookPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookCreateOrUpdateNotebookPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l NotebookCreateOrUpdateNotebookPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookCreateOrUpdateNotebookResponse, error) {
	respType := NotebookCreateOrUpdateNotebookResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NotebookResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookCreateOrUpdateNotebookPollerResponse from the provided client and resume token.
func (l *NotebookCreateOrUpdateNotebookPollerResponse) Resume(ctx context.Context, client *notebookClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("notebookClient.CreateOrUpdateNotebook", token, client.con.Pipeline(), client.createOrUpdateNotebookHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookCreateOrUpdateNotebookPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookCreateOrUpdateNotebookResponse contains the response from method Notebook.CreateOrUpdateNotebook.
type NotebookCreateOrUpdateNotebookResponse struct {
	NotebookCreateOrUpdateNotebookResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookCreateOrUpdateNotebookResult contains the result from method Notebook.CreateOrUpdateNotebook.
type NotebookCreateOrUpdateNotebookResult struct {
	NotebookResource
}

// NotebookDeleteNotebookPollerResponse contains the response from method Notebook.DeleteNotebook.
type NotebookDeleteNotebookPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookDeleteNotebookPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l NotebookDeleteNotebookPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookDeleteNotebookResponse, error) {
	respType := NotebookDeleteNotebookResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookDeleteNotebookPollerResponse from the provided client and resume token.
func (l *NotebookDeleteNotebookPollerResponse) Resume(ctx context.Context, client *notebookClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("notebookClient.DeleteNotebook", token, client.con.Pipeline(), client.deleteNotebookHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookDeleteNotebookPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookDeleteNotebookResponse contains the response from method Notebook.DeleteNotebook.
type NotebookDeleteNotebookResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookGetNotebookResponse contains the response from method Notebook.GetNotebook.
type NotebookGetNotebookResponse struct {
	NotebookGetNotebookResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookGetNotebookResult contains the result from method Notebook.GetNotebook.
type NotebookGetNotebookResult struct {
	NotebookResource
}

// NotebookGetNotebookSummaryByWorkSpaceResponse contains the response from method Notebook.GetNotebookSummaryByWorkSpace.
type NotebookGetNotebookSummaryByWorkSpaceResponse struct {
	NotebookGetNotebookSummaryByWorkSpaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookGetNotebookSummaryByWorkSpaceResult contains the result from method Notebook.GetNotebookSummaryByWorkSpace.
type NotebookGetNotebookSummaryByWorkSpaceResult struct {
	NotebookListResponse
}

// NotebookGetNotebooksByWorkspaceResponse contains the response from method Notebook.GetNotebooksByWorkspace.
type NotebookGetNotebooksByWorkspaceResponse struct {
	NotebookGetNotebooksByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NotebookGetNotebooksByWorkspaceResult contains the result from method Notebook.GetNotebooksByWorkspace.
type NotebookGetNotebooksByWorkspaceResult struct {
	NotebookListResponse
}

// NotebookRenameNotebookPollerResponse contains the response from method Notebook.RenameNotebook.
type NotebookRenameNotebookPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NotebookRenameNotebookPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l NotebookRenameNotebookPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NotebookRenameNotebookResponse, error) {
	respType := NotebookRenameNotebookResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NotebookRenameNotebookPollerResponse from the provided client and resume token.
func (l *NotebookRenameNotebookPollerResponse) Resume(ctx context.Context, client *notebookClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("notebookClient.RenameNotebook", token, client.con.Pipeline(), client.renameNotebookHandleError)
	if err != nil {
		return err
	}
	poller := &NotebookRenameNotebookPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NotebookRenameNotebookResponse contains the response from method Notebook.RenameNotebook.
type NotebookRenameNotebookResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineCreateOrUpdatePipelinePollerResponse contains the response from method Pipeline.CreateOrUpdatePipeline.
type PipelineCreateOrUpdatePipelinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PipelineCreateOrUpdatePipelinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l PipelineCreateOrUpdatePipelinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PipelineCreateOrUpdatePipelineResponse, error) {
	respType := PipelineCreateOrUpdatePipelineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PipelineResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PipelineCreateOrUpdatePipelinePollerResponse from the provided client and resume token.
func (l *PipelineCreateOrUpdatePipelinePollerResponse) Resume(ctx context.Context, client *pipelineClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("pipelineClient.CreateOrUpdatePipeline", token, client.con.Pipeline(), client.createOrUpdatePipelineHandleError)
	if err != nil {
		return err
	}
	poller := &PipelineCreateOrUpdatePipelinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PipelineCreateOrUpdatePipelineResponse contains the response from method Pipeline.CreateOrUpdatePipeline.
type PipelineCreateOrUpdatePipelineResponse struct {
	PipelineCreateOrUpdatePipelineResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineCreateOrUpdatePipelineResult contains the result from method Pipeline.CreateOrUpdatePipeline.
type PipelineCreateOrUpdatePipelineResult struct {
	PipelineResource
}

// PipelineCreatePipelineRunResponse contains the response from method Pipeline.CreatePipelineRun.
type PipelineCreatePipelineRunResponse struct {
	PipelineCreatePipelineRunResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineCreatePipelineRunResult contains the result from method Pipeline.CreatePipelineRun.
type PipelineCreatePipelineRunResult struct {
	CreateRunResponse
}

// PipelineDeletePipelinePollerResponse contains the response from method Pipeline.DeletePipeline.
type PipelineDeletePipelinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PipelineDeletePipelinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l PipelineDeletePipelinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PipelineDeletePipelineResponse, error) {
	respType := PipelineDeletePipelineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PipelineDeletePipelinePollerResponse from the provided client and resume token.
func (l *PipelineDeletePipelinePollerResponse) Resume(ctx context.Context, client *pipelineClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("pipelineClient.DeletePipeline", token, client.con.Pipeline(), client.deletePipelineHandleError)
	if err != nil {
		return err
	}
	poller := &PipelineDeletePipelinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PipelineDeletePipelineResponse contains the response from method Pipeline.DeletePipeline.
type PipelineDeletePipelineResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineGetPipelineResponse contains the response from method Pipeline.GetPipeline.
type PipelineGetPipelineResponse struct {
	PipelineGetPipelineResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineGetPipelineResult contains the result from method Pipeline.GetPipeline.
type PipelineGetPipelineResult struct {
	PipelineResource
}

// PipelineGetPipelinesByWorkspaceResponse contains the response from method Pipeline.GetPipelinesByWorkspace.
type PipelineGetPipelinesByWorkspaceResponse struct {
	PipelineGetPipelinesByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineGetPipelinesByWorkspaceResult contains the result from method Pipeline.GetPipelinesByWorkspace.
type PipelineGetPipelinesByWorkspaceResult struct {
	PipelineListResponse
}

// PipelineRenamePipelinePollerResponse contains the response from method Pipeline.RenamePipeline.
type PipelineRenamePipelinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PipelineRenamePipelinePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l PipelineRenamePipelinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PipelineRenamePipelineResponse, error) {
	respType := PipelineRenamePipelineResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a PipelineRenamePipelinePollerResponse from the provided client and resume token.
func (l *PipelineRenamePipelinePollerResponse) Resume(ctx context.Context, client *pipelineClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("pipelineClient.RenamePipeline", token, client.con.Pipeline(), client.renamePipelineHandleError)
	if err != nil {
		return err
	}
	poller := &PipelineRenamePipelinePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// PipelineRenamePipelineResponse contains the response from method Pipeline.RenamePipeline.
type PipelineRenamePipelineResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineRunCancelPipelineRunResponse contains the response from method PipelineRun.CancelPipelineRun.
type PipelineRunCancelPipelineRunResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineRunGetPipelineRunResponse contains the response from method PipelineRun.GetPipelineRun.
type PipelineRunGetPipelineRunResponse struct {
	PipelineRunGetPipelineRunResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineRunGetPipelineRunResult contains the result from method PipelineRun.GetPipelineRun.
type PipelineRunGetPipelineRunResult struct {
	PipelineRun
}

// PipelineRunQueryActivityRunsResponse contains the response from method PipelineRun.QueryActivityRuns.
type PipelineRunQueryActivityRunsResponse struct {
	PipelineRunQueryActivityRunsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineRunQueryActivityRunsResult contains the result from method PipelineRun.QueryActivityRuns.
type PipelineRunQueryActivityRunsResult struct {
	ActivityRunsQueryResponse
}

// PipelineRunQueryPipelineRunsByWorkspaceResponse contains the response from method PipelineRun.QueryPipelineRunsByWorkspace.
type PipelineRunQueryPipelineRunsByWorkspaceResponse struct {
	PipelineRunQueryPipelineRunsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PipelineRunQueryPipelineRunsByWorkspaceResult contains the result from method PipelineRun.QueryPipelineRunsByWorkspace.
type PipelineRunQueryPipelineRunsByWorkspaceResult struct {
	PipelineRunsQueryResponse
}

// SQLPoolsGetResponse contains the response from method SQLPools.Get.
type SQLPoolsGetResponse struct {
	SQLPoolsGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLPoolsGetResult contains the result from method SQLPools.Get.
type SQLPoolsGetResult struct {
	SQLPool
}

// SQLPoolsListResponse contains the response from method SQLPools.List.
type SQLPoolsListResponse struct {
	SQLPoolsListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLPoolsListResult contains the result from method SQLPools.List.
type SQLPoolsListResult struct {
	SQLPoolInfoListResult
}

// SQLScriptCreateOrUpdateSQLScriptPollerResponse contains the response from method SQLScript.CreateOrUpdateSQLScript.
type SQLScriptCreateOrUpdateSQLScriptPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLScriptCreateOrUpdateSQLScriptPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SQLScriptCreateOrUpdateSQLScriptPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLScriptCreateOrUpdateSQLScriptResponse, error) {
	respType := SQLScriptCreateOrUpdateSQLScriptResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLScriptResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLScriptCreateOrUpdateSQLScriptPollerResponse from the provided client and resume token.
func (l *SQLScriptCreateOrUpdateSQLScriptPollerResponse) Resume(ctx context.Context, client *sqlScriptClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sqlScriptClient.CreateOrUpdateSQLScript", token, client.con.Pipeline(), client.createOrUpdateSQLScriptHandleError)
	if err != nil {
		return err
	}
	poller := &SQLScriptCreateOrUpdateSQLScriptPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLScriptCreateOrUpdateSQLScriptResponse contains the response from method SQLScript.CreateOrUpdateSQLScript.
type SQLScriptCreateOrUpdateSQLScriptResponse struct {
	SQLScriptCreateOrUpdateSQLScriptResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLScriptCreateOrUpdateSQLScriptResult contains the result from method SQLScript.CreateOrUpdateSQLScript.
type SQLScriptCreateOrUpdateSQLScriptResult struct {
	SQLScriptResource
}

// SQLScriptDeleteSQLScriptPollerResponse contains the response from method SQLScript.DeleteSQLScript.
type SQLScriptDeleteSQLScriptPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLScriptDeleteSQLScriptPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SQLScriptDeleteSQLScriptPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLScriptDeleteSQLScriptResponse, error) {
	respType := SQLScriptDeleteSQLScriptResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLScriptDeleteSQLScriptPollerResponse from the provided client and resume token.
func (l *SQLScriptDeleteSQLScriptPollerResponse) Resume(ctx context.Context, client *sqlScriptClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sqlScriptClient.DeleteSQLScript", token, client.con.Pipeline(), client.deleteSQLScriptHandleError)
	if err != nil {
		return err
	}
	poller := &SQLScriptDeleteSQLScriptPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLScriptDeleteSQLScriptResponse contains the response from method SQLScript.DeleteSQLScript.
type SQLScriptDeleteSQLScriptResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLScriptGetSQLScriptResponse contains the response from method SQLScript.GetSQLScript.
type SQLScriptGetSQLScriptResponse struct {
	SQLScriptGetSQLScriptResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLScriptGetSQLScriptResult contains the result from method SQLScript.GetSQLScript.
type SQLScriptGetSQLScriptResult struct {
	SQLScriptResource
}

// SQLScriptGetSQLScriptsByWorkspaceResponse contains the response from method SQLScript.GetSQLScriptsByWorkspace.
type SQLScriptGetSQLScriptsByWorkspaceResponse struct {
	SQLScriptGetSQLScriptsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLScriptGetSQLScriptsByWorkspaceResult contains the result from method SQLScript.GetSQLScriptsByWorkspace.
type SQLScriptGetSQLScriptsByWorkspaceResult struct {
	SQLScriptsListResponse
}

// SQLScriptRenameSQLScriptPollerResponse contains the response from method SQLScript.RenameSQLScript.
type SQLScriptRenameSQLScriptPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLScriptRenameSQLScriptPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SQLScriptRenameSQLScriptPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLScriptRenameSQLScriptResponse, error) {
	respType := SQLScriptRenameSQLScriptResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLScriptRenameSQLScriptPollerResponse from the provided client and resume token.
func (l *SQLScriptRenameSQLScriptPollerResponse) Resume(ctx context.Context, client *sqlScriptClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sqlScriptClient.RenameSQLScript", token, client.con.Pipeline(), client.renameSQLScriptHandleError)
	if err != nil {
		return err
	}
	poller := &SQLScriptRenameSQLScriptPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLScriptRenameSQLScriptResponse contains the response from method SQLScript.RenameSQLScript.
type SQLScriptRenameSQLScriptResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPollerResponse contains the response from method SparkJobDefinition.CreateOrUpdateSparkJobDefinition.
type SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SparkJobDefinitionResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPollerResponse from the provided client and resume token.
func (l *SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sparkJobDefinitionClient.CreateOrUpdateSparkJobDefinition", token, client.con.Pipeline(), client.createOrUpdateSparkJobDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SparkJobDefinitionCreateOrUpdateSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse contains the response from method SparkJobDefinition.CreateOrUpdateSparkJobDefinition.
type SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResponse struct {
	SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResult contains the result from method SparkJobDefinition.CreateOrUpdateSparkJobDefinition.
type SparkJobDefinitionCreateOrUpdateSparkJobDefinitionResult struct {
	SparkJobDefinitionResource
}

// SparkJobDefinitionDebugSparkJobDefinitionPollerResponse contains the response from method SparkJobDefinition.DebugSparkJobDefinition.
type SparkJobDefinitionDebugSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SparkJobDefinitionDebugSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SparkJobDefinitionDebugSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SparkJobDefinitionDebugSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionDebugSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SparkBatchJob)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SparkJobDefinitionDebugSparkJobDefinitionPollerResponse from the provided client and resume token.
func (l *SparkJobDefinitionDebugSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sparkJobDefinitionClient.DebugSparkJobDefinition", token, client.con.Pipeline(), client.debugSparkJobDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SparkJobDefinitionDebugSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SparkJobDefinitionDebugSparkJobDefinitionResponse contains the response from method SparkJobDefinition.DebugSparkJobDefinition.
type SparkJobDefinitionDebugSparkJobDefinitionResponse struct {
	SparkJobDefinitionDebugSparkJobDefinitionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionDebugSparkJobDefinitionResult contains the result from method SparkJobDefinition.DebugSparkJobDefinition.
type SparkJobDefinitionDebugSparkJobDefinitionResult struct {
	SparkBatchJob
}

// SparkJobDefinitionDeleteSparkJobDefinitionPollerResponse contains the response from method SparkJobDefinition.DeleteSparkJobDefinition.
type SparkJobDefinitionDeleteSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SparkJobDefinitionDeleteSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SparkJobDefinitionDeleteSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SparkJobDefinitionDeleteSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionDeleteSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SparkJobDefinitionDeleteSparkJobDefinitionPollerResponse from the provided client and resume token.
func (l *SparkJobDefinitionDeleteSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sparkJobDefinitionClient.DeleteSparkJobDefinition", token, client.con.Pipeline(), client.deleteSparkJobDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SparkJobDefinitionDeleteSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SparkJobDefinitionDeleteSparkJobDefinitionResponse contains the response from method SparkJobDefinition.DeleteSparkJobDefinition.
type SparkJobDefinitionDeleteSparkJobDefinitionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionExecuteSparkJobDefinitionPollerResponse contains the response from method SparkJobDefinition.ExecuteSparkJobDefinition.
type SparkJobDefinitionExecuteSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SparkJobDefinitionExecuteSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SparkJobDefinitionExecuteSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SparkJobDefinitionExecuteSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionExecuteSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SparkBatchJob)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SparkJobDefinitionExecuteSparkJobDefinitionPollerResponse from the provided client and resume token.
func (l *SparkJobDefinitionExecuteSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sparkJobDefinitionClient.ExecuteSparkJobDefinition", token, client.con.Pipeline(), client.executeSparkJobDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SparkJobDefinitionExecuteSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SparkJobDefinitionExecuteSparkJobDefinitionResponse contains the response from method SparkJobDefinition.ExecuteSparkJobDefinition.
type SparkJobDefinitionExecuteSparkJobDefinitionResponse struct {
	SparkJobDefinitionExecuteSparkJobDefinitionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionExecuteSparkJobDefinitionResult contains the result from method SparkJobDefinition.ExecuteSparkJobDefinition.
type SparkJobDefinitionExecuteSparkJobDefinitionResult struct {
	SparkBatchJob
}

// SparkJobDefinitionGetSparkJobDefinitionResponse contains the response from method SparkJobDefinition.GetSparkJobDefinition.
type SparkJobDefinitionGetSparkJobDefinitionResponse struct {
	SparkJobDefinitionGetSparkJobDefinitionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionGetSparkJobDefinitionResult contains the result from method SparkJobDefinition.GetSparkJobDefinition.
type SparkJobDefinitionGetSparkJobDefinitionResult struct {
	SparkJobDefinitionResource
}

// SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceResponse contains the response from method SparkJobDefinition.GetSparkJobDefinitionsByWorkspace.
type SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceResponse struct {
	SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceResult contains the result from method SparkJobDefinition.GetSparkJobDefinitionsByWorkspace.
type SparkJobDefinitionGetSparkJobDefinitionsByWorkspaceResult struct {
	SparkJobDefinitionsListResponse
}

// SparkJobDefinitionRenameSparkJobDefinitionPollerResponse contains the response from method SparkJobDefinition.RenameSparkJobDefinition.
type SparkJobDefinitionRenameSparkJobDefinitionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SparkJobDefinitionRenameSparkJobDefinitionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l SparkJobDefinitionRenameSparkJobDefinitionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SparkJobDefinitionRenameSparkJobDefinitionResponse, error) {
	respType := SparkJobDefinitionRenameSparkJobDefinitionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SparkJobDefinitionRenameSparkJobDefinitionPollerResponse from the provided client and resume token.
func (l *SparkJobDefinitionRenameSparkJobDefinitionPollerResponse) Resume(ctx context.Context, client *sparkJobDefinitionClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("sparkJobDefinitionClient.RenameSparkJobDefinition", token, client.con.Pipeline(), client.renameSparkJobDefinitionHandleError)
	if err != nil {
		return err
	}
	poller := &SparkJobDefinitionRenameSparkJobDefinitionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SparkJobDefinitionRenameSparkJobDefinitionResponse contains the response from method SparkJobDefinition.RenameSparkJobDefinition.
type SparkJobDefinitionRenameSparkJobDefinitionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerCreateOrUpdateTriggerPollerResponse contains the response from method Trigger.CreateOrUpdateTrigger.
type TriggerCreateOrUpdateTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggerCreateOrUpdateTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l TriggerCreateOrUpdateTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggerCreateOrUpdateTriggerResponse, error) {
	respType := TriggerCreateOrUpdateTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerResource)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggerCreateOrUpdateTriggerPollerResponse from the provided client and resume token.
func (l *TriggerCreateOrUpdateTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("triggerClient.CreateOrUpdateTrigger", token, client.con.Pipeline(), client.createOrUpdateTriggerHandleError)
	if err != nil {
		return err
	}
	poller := &TriggerCreateOrUpdateTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggerCreateOrUpdateTriggerResponse contains the response from method Trigger.CreateOrUpdateTrigger.
type TriggerCreateOrUpdateTriggerResponse struct {
	TriggerCreateOrUpdateTriggerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerCreateOrUpdateTriggerResult contains the result from method Trigger.CreateOrUpdateTrigger.
type TriggerCreateOrUpdateTriggerResult struct {
	TriggerResource
}

// TriggerDeleteTriggerPollerResponse contains the response from method Trigger.DeleteTrigger.
type TriggerDeleteTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggerDeleteTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l TriggerDeleteTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggerDeleteTriggerResponse, error) {
	respType := TriggerDeleteTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggerDeleteTriggerPollerResponse from the provided client and resume token.
func (l *TriggerDeleteTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("triggerClient.DeleteTrigger", token, client.con.Pipeline(), client.deleteTriggerHandleError)
	if err != nil {
		return err
	}
	poller := &TriggerDeleteTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggerDeleteTriggerResponse contains the response from method Trigger.DeleteTrigger.
type TriggerDeleteTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerGetEventSubscriptionStatusResponse contains the response from method Trigger.GetEventSubscriptionStatus.
type TriggerGetEventSubscriptionStatusResponse struct {
	TriggerGetEventSubscriptionStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerGetEventSubscriptionStatusResult contains the result from method Trigger.GetEventSubscriptionStatus.
type TriggerGetEventSubscriptionStatusResult struct {
	TriggerSubscriptionOperationStatus
}

// TriggerGetTriggerResponse contains the response from method Trigger.GetTrigger.
type TriggerGetTriggerResponse struct {
	TriggerGetTriggerResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerGetTriggerResult contains the result from method Trigger.GetTrigger.
type TriggerGetTriggerResult struct {
	TriggerResource
}

// TriggerGetTriggersByWorkspaceResponse contains the response from method Trigger.GetTriggersByWorkspace.
type TriggerGetTriggersByWorkspaceResponse struct {
	TriggerGetTriggersByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerGetTriggersByWorkspaceResult contains the result from method Trigger.GetTriggersByWorkspace.
type TriggerGetTriggersByWorkspaceResult struct {
	TriggerListResponse
}

// TriggerRunCancelTriggerInstanceResponse contains the response from method TriggerRun.CancelTriggerInstance.
type TriggerRunCancelTriggerInstanceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerRunQueryTriggerRunsByWorkspaceResponse contains the response from method TriggerRun.QueryTriggerRunsByWorkspace.
type TriggerRunQueryTriggerRunsByWorkspaceResponse struct {
	TriggerRunQueryTriggerRunsByWorkspaceResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerRunQueryTriggerRunsByWorkspaceResult contains the result from method TriggerRun.QueryTriggerRunsByWorkspace.
type TriggerRunQueryTriggerRunsByWorkspaceResult struct {
	TriggerRunsQueryResponse
}

// TriggerRunRerunTriggerInstanceResponse contains the response from method TriggerRun.RerunTriggerInstance.
type TriggerRunRerunTriggerInstanceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerStartTriggerPollerResponse contains the response from method Trigger.StartTrigger.
type TriggerStartTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggerStartTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l TriggerStartTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggerStartTriggerResponse, error) {
	respType := TriggerStartTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggerStartTriggerPollerResponse from the provided client and resume token.
func (l *TriggerStartTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("triggerClient.StartTrigger", token, client.con.Pipeline(), client.startTriggerHandleError)
	if err != nil {
		return err
	}
	poller := &TriggerStartTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggerStartTriggerResponse contains the response from method Trigger.StartTrigger.
type TriggerStartTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerStopTriggerPollerResponse contains the response from method Trigger.StopTrigger.
type TriggerStopTriggerPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggerStopTriggerPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l TriggerStopTriggerPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggerStopTriggerResponse, error) {
	respType := TriggerStopTriggerResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggerStopTriggerPollerResponse from the provided client and resume token.
func (l *TriggerStopTriggerPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("triggerClient.StopTrigger", token, client.con.Pipeline(), client.stopTriggerHandleError)
	if err != nil {
		return err
	}
	poller := &TriggerStopTriggerPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggerStopTriggerResponse contains the response from method Trigger.StopTrigger.
type TriggerStopTriggerResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerSubscribeTriggerToEventsPollerResponse contains the response from method Trigger.SubscribeTriggerToEvents.
type TriggerSubscribeTriggerToEventsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggerSubscribeTriggerToEventsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l TriggerSubscribeTriggerToEventsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggerSubscribeTriggerToEventsResponse, error) {
	respType := TriggerSubscribeTriggerToEventsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggerSubscribeTriggerToEventsPollerResponse from the provided client and resume token.
func (l *TriggerSubscribeTriggerToEventsPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("triggerClient.SubscribeTriggerToEvents", token, client.con.Pipeline(), client.subscribeTriggerToEventsHandleError)
	if err != nil {
		return err
	}
	poller := &TriggerSubscribeTriggerToEventsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggerSubscribeTriggerToEventsResponse contains the response from method Trigger.SubscribeTriggerToEvents.
type TriggerSubscribeTriggerToEventsResponse struct {
	TriggerSubscribeTriggerToEventsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerSubscribeTriggerToEventsResult contains the result from method Trigger.SubscribeTriggerToEvents.
type TriggerSubscribeTriggerToEventsResult struct {
	TriggerSubscriptionOperationStatus
}

// TriggerUnsubscribeTriggerFromEventsPollerResponse contains the response from method Trigger.UnsubscribeTriggerFromEvents.
type TriggerUnsubscribeTriggerFromEventsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *TriggerUnsubscribeTriggerFromEventsPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
func (l TriggerUnsubscribeTriggerFromEventsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (TriggerUnsubscribeTriggerFromEventsResponse, error) {
	respType := TriggerUnsubscribeTriggerFromEventsResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.TriggerSubscriptionOperationStatus)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a TriggerUnsubscribeTriggerFromEventsPollerResponse from the provided client and resume token.
func (l *TriggerUnsubscribeTriggerFromEventsPollerResponse) Resume(ctx context.Context, client *triggerClient, token string) error {
	pt, err := azcore.NewLROPollerFromResumeToken("triggerClient.UnsubscribeTriggerFromEvents", token, client.con.Pipeline(), client.unsubscribeTriggerFromEventsHandleError)
	if err != nil {
		return err
	}
	poller := &TriggerUnsubscribeTriggerFromEventsPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// TriggerUnsubscribeTriggerFromEventsResponse contains the response from method Trigger.UnsubscribeTriggerFromEvents.
type TriggerUnsubscribeTriggerFromEventsResponse struct {
	TriggerUnsubscribeTriggerFromEventsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TriggerUnsubscribeTriggerFromEventsResult contains the result from method Trigger.UnsubscribeTriggerFromEvents.
type TriggerUnsubscribeTriggerFromEventsResult struct {
	TriggerSubscriptionOperationStatus
}

// WorkspaceGetResponse contains the response from method Workspace.Get.
type WorkspaceGetResponse struct {
	WorkspaceGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspaceGetResult contains the result from method Workspace.Get.
type WorkspaceGetResult struct {
	Workspace
}

// WorkspaceGitRepoManagementGetGitHubAccessTokenResponse contains the response from method WorkspaceGitRepoManagement.GetGitHubAccessToken.
type WorkspaceGitRepoManagementGetGitHubAccessTokenResponse struct {
	WorkspaceGitRepoManagementGetGitHubAccessTokenResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// WorkspaceGitRepoManagementGetGitHubAccessTokenResult contains the result from method WorkspaceGitRepoManagement.GetGitHubAccessToken.
type WorkspaceGitRepoManagementGetGitHubAccessTokenResult struct {
	GitHubAccessTokenResponse
}
