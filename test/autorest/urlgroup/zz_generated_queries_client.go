//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package urlgroup

import (
	"context"
	"encoding/base64"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

// QueriesClient contains the methods for the Queries group.
// Don't use this type directly, use NewQueriesClient() instead.
type QueriesClient struct {
	pl runtime.Pipeline
}

// NewQueriesClient creates a new instance of QueriesClient with the specified values.
// options - pass nil to accept the default values.
func NewQueriesClient(options *azcore.ClientOptions) *QueriesClient {
	cp := azcore.ClientOptions{}
	if options != nil {
		cp = *options
	}
	client := &QueriesClient{
		pl: runtime.NewPipeline(module, version, nil, nil, &cp),
	}
	return client
}

// ArrayStringCSVEmpty - Get an empty array [] of string using the csv-array format
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringCSVEmptyOptions contains the optional parameters for the Queries.ArrayStringCSVEmpty method.
func (client *QueriesClient) ArrayStringCSVEmpty(ctx context.Context, options *QueriesArrayStringCSVEmptyOptions) (QueriesArrayStringCSVEmptyResponse, error) {
	req, err := client.arrayStringCSVEmptyCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringCSVEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringCSVEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringCSVEmptyResponse{}, client.arrayStringCSVEmptyHandleError(resp)
	}
	return QueriesArrayStringCSVEmptyResponse{RawResponse: resp}, nil
}

// arrayStringCSVEmptyCreateRequest creates the ArrayStringCSVEmpty request.
func (client *QueriesClient) arrayStringCSVEmptyCreateRequest(ctx context.Context, options *QueriesArrayStringCSVEmptyOptions) (*policy.Request, error) {
	urlPath := "/queries/array/csv/string/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringCSVEmptyHandleError handles the ArrayStringCSVEmpty error response.
func (client *QueriesClient) arrayStringCSVEmptyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ArrayStringCSVNull - Get a null array of string using the csv-array format
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringCSVNullOptions contains the optional parameters for the Queries.ArrayStringCSVNull method.
func (client *QueriesClient) ArrayStringCSVNull(ctx context.Context, options *QueriesArrayStringCSVNullOptions) (QueriesArrayStringCSVNullResponse, error) {
	req, err := client.arrayStringCSVNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringCSVNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringCSVNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringCSVNullResponse{}, client.arrayStringCSVNullHandleError(resp)
	}
	return QueriesArrayStringCSVNullResponse{RawResponse: resp}, nil
}

// arrayStringCSVNullCreateRequest creates the ArrayStringCSVNull request.
func (client *QueriesClient) arrayStringCSVNullCreateRequest(ctx context.Context, options *QueriesArrayStringCSVNullOptions) (*policy.Request, error) {
	urlPath := "/queries/array/csv/string/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringCSVNullHandleError handles the ArrayStringCSVNull error response.
func (client *QueriesClient) arrayStringCSVNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ArrayStringCSVValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array
// format
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringCSVValidOptions contains the optional parameters for the Queries.ArrayStringCSVValid method.
func (client *QueriesClient) ArrayStringCSVValid(ctx context.Context, options *QueriesArrayStringCSVValidOptions) (QueriesArrayStringCSVValidResponse, error) {
	req, err := client.arrayStringCSVValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringCSVValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringCSVValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringCSVValidResponse{}, client.arrayStringCSVValidHandleError(resp)
	}
	return QueriesArrayStringCSVValidResponse{RawResponse: resp}, nil
}

// arrayStringCSVValidCreateRequest creates the ArrayStringCSVValid request.
func (client *QueriesClient) arrayStringCSVValidCreateRequest(ctx context.Context, options *QueriesArrayStringCSVValidOptions) (*policy.Request, error) {
	urlPath := "/queries/array/csv/string/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringCSVValidHandleError handles the ArrayStringCSVValid error response.
func (client *QueriesClient) arrayStringCSVValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ArrayStringNoCollectionFormatEmpty - Array query has no defined collection format, should default to csv. Pass in ['hello',
// 'nihao', 'bonjour'] for the 'arrayQuery' parameter to the service
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringNoCollectionFormatEmptyOptions contains the optional parameters for the Queries.ArrayStringNoCollectionFormatEmpty
// method.
func (client *QueriesClient) ArrayStringNoCollectionFormatEmpty(ctx context.Context, options *QueriesArrayStringNoCollectionFormatEmptyOptions) (QueriesArrayStringNoCollectionFormatEmptyResponse, error) {
	req, err := client.arrayStringNoCollectionFormatEmptyCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringNoCollectionFormatEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringNoCollectionFormatEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringNoCollectionFormatEmptyResponse{}, client.arrayStringNoCollectionFormatEmptyHandleError(resp)
	}
	return QueriesArrayStringNoCollectionFormatEmptyResponse{RawResponse: resp}, nil
}

// arrayStringNoCollectionFormatEmptyCreateRequest creates the ArrayStringNoCollectionFormatEmpty request.
func (client *QueriesClient) arrayStringNoCollectionFormatEmptyCreateRequest(ctx context.Context, options *QueriesArrayStringNoCollectionFormatEmptyOptions) (*policy.Request, error) {
	urlPath := "/queries/array/none/string/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringNoCollectionFormatEmptyHandleError handles the ArrayStringNoCollectionFormatEmpty error response.
func (client *QueriesClient) arrayStringNoCollectionFormatEmptyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ArrayStringPipesValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the pipes-array
// format
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringPipesValidOptions contains the optional parameters for the Queries.ArrayStringPipesValid method.
func (client *QueriesClient) ArrayStringPipesValid(ctx context.Context, options *QueriesArrayStringPipesValidOptions) (QueriesArrayStringPipesValidResponse, error) {
	req, err := client.arrayStringPipesValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringPipesValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringPipesValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringPipesValidResponse{}, client.arrayStringPipesValidHandleError(resp)
	}
	return QueriesArrayStringPipesValidResponse{RawResponse: resp}, nil
}

// arrayStringPipesValidCreateRequest creates the ArrayStringPipesValid request.
func (client *QueriesClient) arrayStringPipesValidCreateRequest(ctx context.Context, options *QueriesArrayStringPipesValidOptions) (*policy.Request, error) {
	urlPath := "/queries/array/pipes/string/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, "|"))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringPipesValidHandleError handles the ArrayStringPipesValid error response.
func (client *QueriesClient) arrayStringPipesValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ArrayStringSsvValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the ssv-array
// format
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringSsvValidOptions contains the optional parameters for the Queries.ArrayStringSsvValid method.
func (client *QueriesClient) ArrayStringSsvValid(ctx context.Context, options *QueriesArrayStringSsvValidOptions) (QueriesArrayStringSsvValidResponse, error) {
	req, err := client.arrayStringSsvValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringSsvValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringSsvValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringSsvValidResponse{}, client.arrayStringSsvValidHandleError(resp)
	}
	return QueriesArrayStringSsvValidResponse{RawResponse: resp}, nil
}

// arrayStringSsvValidCreateRequest creates the ArrayStringSsvValid request.
func (client *QueriesClient) arrayStringSsvValidCreateRequest(ctx context.Context, options *QueriesArrayStringSsvValidOptions) (*policy.Request, error) {
	urlPath := "/queries/array/ssv/string/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, " "))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringSsvValidHandleError handles the ArrayStringSsvValid error response.
func (client *QueriesClient) arrayStringSsvValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ArrayStringTsvValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the tsv-array
// format
// If the operation fails it returns the *Error error type.
// options - QueriesArrayStringTsvValidOptions contains the optional parameters for the Queries.ArrayStringTsvValid method.
func (client *QueriesClient) ArrayStringTsvValid(ctx context.Context, options *QueriesArrayStringTsvValidOptions) (QueriesArrayStringTsvValidResponse, error) {
	req, err := client.arrayStringTsvValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesArrayStringTsvValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesArrayStringTsvValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesArrayStringTsvValidResponse{}, client.arrayStringTsvValidHandleError(resp)
	}
	return QueriesArrayStringTsvValidResponse{RawResponse: resp}, nil
}

// arrayStringTsvValidCreateRequest creates the ArrayStringTsvValid request.
func (client *QueriesClient) arrayStringTsvValidCreateRequest(ctx context.Context, options *QueriesArrayStringTsvValidOptions) (*policy.Request, error) {
	urlPath := "/queries/array/tsv/string/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ArrayQuery != nil {
		reqQP.Set("arrayQuery", strings.Join(options.ArrayQuery, "\t"))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayStringTsvValidHandleError handles the ArrayStringTsvValid error response.
func (client *QueriesClient) arrayStringTsvValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ByteEmpty - Get '' as byte array
// If the operation fails it returns the *Error error type.
// options - QueriesByteEmptyOptions contains the optional parameters for the Queries.ByteEmpty method.
func (client *QueriesClient) ByteEmpty(ctx context.Context, options *QueriesByteEmptyOptions) (QueriesByteEmptyResponse, error) {
	req, err := client.byteEmptyCreateRequest(ctx, options)
	if err != nil {
		return QueriesByteEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesByteEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesByteEmptyResponse{}, client.byteEmptyHandleError(resp)
	}
	return QueriesByteEmptyResponse{RawResponse: resp}, nil
}

// byteEmptyCreateRequest creates the ByteEmpty request.
func (client *QueriesClient) byteEmptyCreateRequest(ctx context.Context, options *QueriesByteEmptyOptions) (*policy.Request, error) {
	urlPath := "/queries/byte/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("byteQuery", "")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// byteEmptyHandleError handles the ByteEmpty error response.
func (client *QueriesClient) byteEmptyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ByteMultiByte - Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
// If the operation fails it returns the *Error error type.
// options - QueriesByteMultiByteOptions contains the optional parameters for the Queries.ByteMultiByte method.
func (client *QueriesClient) ByteMultiByte(ctx context.Context, options *QueriesByteMultiByteOptions) (QueriesByteMultiByteResponse, error) {
	req, err := client.byteMultiByteCreateRequest(ctx, options)
	if err != nil {
		return QueriesByteMultiByteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesByteMultiByteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesByteMultiByteResponse{}, client.byteMultiByteHandleError(resp)
	}
	return QueriesByteMultiByteResponse{RawResponse: resp}, nil
}

// byteMultiByteCreateRequest creates the ByteMultiByte request.
func (client *QueriesClient) byteMultiByteCreateRequest(ctx context.Context, options *QueriesByteMultiByteOptions) (*policy.Request, error) {
	urlPath := "/queries/byte/multibyte"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ByteQuery != nil {
		reqQP.Set("byteQuery", base64.StdEncoding.EncodeToString(options.ByteQuery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// byteMultiByteHandleError handles the ByteMultiByte error response.
func (client *QueriesClient) byteMultiByteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ByteNull - Get null as byte array (no query parameters in uri)
// If the operation fails it returns the *Error error type.
// options - QueriesByteNullOptions contains the optional parameters for the Queries.ByteNull method.
func (client *QueriesClient) ByteNull(ctx context.Context, options *QueriesByteNullOptions) (QueriesByteNullResponse, error) {
	req, err := client.byteNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesByteNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesByteNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesByteNullResponse{}, client.byteNullHandleError(resp)
	}
	return QueriesByteNullResponse{RawResponse: resp}, nil
}

// byteNullCreateRequest creates the ByteNull request.
func (client *QueriesClient) byteNullCreateRequest(ctx context.Context, options *QueriesByteNullOptions) (*policy.Request, error) {
	urlPath := "/queries/byte/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.ByteQuery != nil {
		reqQP.Set("byteQuery", base64.StdEncoding.EncodeToString(options.ByteQuery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// byteNullHandleError handles the ByteNull error response.
func (client *QueriesClient) byteNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateNull - Get null as date - this should result in no query parameters in uri
// If the operation fails it returns the *Error error type.
// options - QueriesDateNullOptions contains the optional parameters for the Queries.DateNull method.
func (client *QueriesClient) DateNull(ctx context.Context, options *QueriesDateNullOptions) (QueriesDateNullResponse, error) {
	req, err := client.dateNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesDateNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDateNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDateNullResponse{}, client.dateNullHandleError(resp)
	}
	return QueriesDateNullResponse{RawResponse: resp}, nil
}

// dateNullCreateRequest creates the DateNull request.
func (client *QueriesClient) dateNullCreateRequest(ctx context.Context, options *QueriesDateNullOptions) (*policy.Request, error) {
	urlPath := "/queries/date/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DateQuery != nil {
		reqQP.Set("dateQuery", options.DateQuery.Format("2006-01-02"))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateNullHandleError handles the DateNull error response.
func (client *QueriesClient) dateNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateTimeNull - Get null as date-time, should result in no query parameters in uri
// If the operation fails it returns the *Error error type.
// options - QueriesDateTimeNullOptions contains the optional parameters for the Queries.DateTimeNull method.
func (client *QueriesClient) DateTimeNull(ctx context.Context, options *QueriesDateTimeNullOptions) (QueriesDateTimeNullResponse, error) {
	req, err := client.dateTimeNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesDateTimeNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDateTimeNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDateTimeNullResponse{}, client.dateTimeNullHandleError(resp)
	}
	return QueriesDateTimeNullResponse{RawResponse: resp}, nil
}

// dateTimeNullCreateRequest creates the DateTimeNull request.
func (client *QueriesClient) dateTimeNullCreateRequest(ctx context.Context, options *QueriesDateTimeNullOptions) (*policy.Request, error) {
	urlPath := "/queries/datetime/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DateTimeQuery != nil {
		reqQP.Set("dateTimeQuery", options.DateTimeQuery.Format(time.RFC3339Nano))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateTimeNullHandleError handles the DateTimeNull error response.
func (client *QueriesClient) dateTimeNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateTimeValid - Get '2012-01-01T01:01:01Z' as date-time
// If the operation fails it returns the *Error error type.
// options - QueriesDateTimeValidOptions contains the optional parameters for the Queries.DateTimeValid method.
func (client *QueriesClient) DateTimeValid(ctx context.Context, options *QueriesDateTimeValidOptions) (QueriesDateTimeValidResponse, error) {
	req, err := client.dateTimeValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesDateTimeValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDateTimeValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDateTimeValidResponse{}, client.dateTimeValidHandleError(resp)
	}
	return QueriesDateTimeValidResponse{RawResponse: resp}, nil
}

// dateTimeValidCreateRequest creates the DateTimeValid request.
func (client *QueriesClient) dateTimeValidCreateRequest(ctx context.Context, options *QueriesDateTimeValidOptions) (*policy.Request, error) {
	urlPath := "/queries/datetime/2012-01-01T01%3A01%3A01Z"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("dateTimeQuery", "2012-01-01T01:01:01Z")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateTimeValidHandleError handles the DateTimeValid error response.
func (client *QueriesClient) dateTimeValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateValid - Get '2012-01-01' as date
// If the operation fails it returns the *Error error type.
// options - QueriesDateValidOptions contains the optional parameters for the Queries.DateValid method.
func (client *QueriesClient) DateValid(ctx context.Context, options *QueriesDateValidOptions) (QueriesDateValidResponse, error) {
	req, err := client.dateValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesDateValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDateValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDateValidResponse{}, client.dateValidHandleError(resp)
	}
	return QueriesDateValidResponse{RawResponse: resp}, nil
}

// dateValidCreateRequest creates the DateValid request.
func (client *QueriesClient) dateValidCreateRequest(ctx context.Context, options *QueriesDateValidOptions) (*policy.Request, error) {
	urlPath := "/queries/date/2012-01-01"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("dateQuery", "2012-01-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateValidHandleError handles the DateValid error response.
func (client *QueriesClient) dateValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DoubleDecimalNegative - Get '-9999999.999' numeric value
// If the operation fails it returns the *Error error type.
// options - QueriesDoubleDecimalNegativeOptions contains the optional parameters for the Queries.DoubleDecimalNegative method.
func (client *QueriesClient) DoubleDecimalNegative(ctx context.Context, options *QueriesDoubleDecimalNegativeOptions) (QueriesDoubleDecimalNegativeResponse, error) {
	req, err := client.doubleDecimalNegativeCreateRequest(ctx, options)
	if err != nil {
		return QueriesDoubleDecimalNegativeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDoubleDecimalNegativeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDoubleDecimalNegativeResponse{}, client.doubleDecimalNegativeHandleError(resp)
	}
	return QueriesDoubleDecimalNegativeResponse{RawResponse: resp}, nil
}

// doubleDecimalNegativeCreateRequest creates the DoubleDecimalNegative request.
func (client *QueriesClient) doubleDecimalNegativeCreateRequest(ctx context.Context, options *QueriesDoubleDecimalNegativeOptions) (*policy.Request, error) {
	urlPath := "/queries/double/-9999999.999"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("doubleQuery", "-9999999.999")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// doubleDecimalNegativeHandleError handles the DoubleDecimalNegative error response.
func (client *QueriesClient) doubleDecimalNegativeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DoubleDecimalPositive - Get '9999999.999' numeric value
// If the operation fails it returns the *Error error type.
// options - QueriesDoubleDecimalPositiveOptions contains the optional parameters for the Queries.DoubleDecimalPositive method.
func (client *QueriesClient) DoubleDecimalPositive(ctx context.Context, options *QueriesDoubleDecimalPositiveOptions) (QueriesDoubleDecimalPositiveResponse, error) {
	req, err := client.doubleDecimalPositiveCreateRequest(ctx, options)
	if err != nil {
		return QueriesDoubleDecimalPositiveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDoubleDecimalPositiveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDoubleDecimalPositiveResponse{}, client.doubleDecimalPositiveHandleError(resp)
	}
	return QueriesDoubleDecimalPositiveResponse{RawResponse: resp}, nil
}

// doubleDecimalPositiveCreateRequest creates the DoubleDecimalPositive request.
func (client *QueriesClient) doubleDecimalPositiveCreateRequest(ctx context.Context, options *QueriesDoubleDecimalPositiveOptions) (*policy.Request, error) {
	urlPath := "/queries/double/9999999.999"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("doubleQuery", "9999999.999")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// doubleDecimalPositiveHandleError handles the DoubleDecimalPositive error response.
func (client *QueriesClient) doubleDecimalPositiveHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DoubleNull - Get null numeric value (no query parameter)
// If the operation fails it returns the *Error error type.
// options - QueriesDoubleNullOptions contains the optional parameters for the Queries.DoubleNull method.
func (client *QueriesClient) DoubleNull(ctx context.Context, options *QueriesDoubleNullOptions) (QueriesDoubleNullResponse, error) {
	req, err := client.doubleNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesDoubleNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesDoubleNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesDoubleNullResponse{}, client.doubleNullHandleError(resp)
	}
	return QueriesDoubleNullResponse{RawResponse: resp}, nil
}

// doubleNullCreateRequest creates the DoubleNull request.
func (client *QueriesClient) doubleNullCreateRequest(ctx context.Context, options *QueriesDoubleNullOptions) (*policy.Request, error) {
	urlPath := "/queries/double/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DoubleQuery != nil {
		reqQP.Set("doubleQuery", strconv.FormatFloat(*options.DoubleQuery, 'f', -1, 64))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// doubleNullHandleError handles the DoubleNull error response.
func (client *QueriesClient) doubleNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// EnumNull - Get null (no query parameter in url)
// If the operation fails it returns the *Error error type.
// options - QueriesEnumNullOptions contains the optional parameters for the Queries.EnumNull method.
func (client *QueriesClient) EnumNull(ctx context.Context, options *QueriesEnumNullOptions) (QueriesEnumNullResponse, error) {
	req, err := client.enumNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesEnumNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesEnumNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesEnumNullResponse{}, client.enumNullHandleError(resp)
	}
	return QueriesEnumNullResponse{RawResponse: resp}, nil
}

// enumNullCreateRequest creates the EnumNull request.
func (client *QueriesClient) enumNullCreateRequest(ctx context.Context, options *QueriesEnumNullOptions) (*policy.Request, error) {
	urlPath := "/queries/enum/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.EnumQuery != nil {
		reqQP.Set("enumQuery", string(*options.EnumQuery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// enumNullHandleError handles the EnumNull error response.
func (client *QueriesClient) enumNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// EnumValid - Get using uri with query parameter 'green color'
// If the operation fails it returns the *Error error type.
// options - QueriesEnumValidOptions contains the optional parameters for the Queries.EnumValid method.
func (client *QueriesClient) EnumValid(ctx context.Context, options *QueriesEnumValidOptions) (QueriesEnumValidResponse, error) {
	req, err := client.enumValidCreateRequest(ctx, options)
	if err != nil {
		return QueriesEnumValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesEnumValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesEnumValidResponse{}, client.enumValidHandleError(resp)
	}
	return QueriesEnumValidResponse{RawResponse: resp}, nil
}

// enumValidCreateRequest creates the EnumValid request.
func (client *QueriesClient) enumValidCreateRequest(ctx context.Context, options *QueriesEnumValidOptions) (*policy.Request, error) {
	urlPath := "/queries/enum/green%20color"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.EnumQuery != nil {
		reqQP.Set("enumQuery", string(*options.EnumQuery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// enumValidHandleError handles the EnumValid error response.
func (client *QueriesClient) enumValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// FloatNull - Get null numeric value (no query parameter)
// If the operation fails it returns the *Error error type.
// options - QueriesFloatNullOptions contains the optional parameters for the Queries.FloatNull method.
func (client *QueriesClient) FloatNull(ctx context.Context, options *QueriesFloatNullOptions) (QueriesFloatNullResponse, error) {
	req, err := client.floatNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesFloatNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesFloatNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesFloatNullResponse{}, client.floatNullHandleError(resp)
	}
	return QueriesFloatNullResponse{RawResponse: resp}, nil
}

// floatNullCreateRequest creates the FloatNull request.
func (client *QueriesClient) floatNullCreateRequest(ctx context.Context, options *QueriesFloatNullOptions) (*policy.Request, error) {
	urlPath := "/queries/float/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.FloatQuery != nil {
		reqQP.Set("floatQuery", strconv.FormatFloat(float64(*options.FloatQuery), 'f', -1, 32))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// floatNullHandleError handles the FloatNull error response.
func (client *QueriesClient) floatNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// FloatScientificNegative - Get '-1.034E-20' numeric value
// If the operation fails it returns the *Error error type.
// options - QueriesFloatScientificNegativeOptions contains the optional parameters for the Queries.FloatScientificNegative
// method.
func (client *QueriesClient) FloatScientificNegative(ctx context.Context, options *QueriesFloatScientificNegativeOptions) (QueriesFloatScientificNegativeResponse, error) {
	req, err := client.floatScientificNegativeCreateRequest(ctx, options)
	if err != nil {
		return QueriesFloatScientificNegativeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesFloatScientificNegativeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesFloatScientificNegativeResponse{}, client.floatScientificNegativeHandleError(resp)
	}
	return QueriesFloatScientificNegativeResponse{RawResponse: resp}, nil
}

// floatScientificNegativeCreateRequest creates the FloatScientificNegative request.
func (client *QueriesClient) floatScientificNegativeCreateRequest(ctx context.Context, options *QueriesFloatScientificNegativeOptions) (*policy.Request, error) {
	urlPath := "/queries/float/-1.034E-20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("floatQuery", "-1.034e-20")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// floatScientificNegativeHandleError handles the FloatScientificNegative error response.
func (client *QueriesClient) floatScientificNegativeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// FloatScientificPositive - Get '1.034E+20' numeric value
// If the operation fails it returns the *Error error type.
// options - QueriesFloatScientificPositiveOptions contains the optional parameters for the Queries.FloatScientificPositive
// method.
func (client *QueriesClient) FloatScientificPositive(ctx context.Context, options *QueriesFloatScientificPositiveOptions) (QueriesFloatScientificPositiveResponse, error) {
	req, err := client.floatScientificPositiveCreateRequest(ctx, options)
	if err != nil {
		return QueriesFloatScientificPositiveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesFloatScientificPositiveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesFloatScientificPositiveResponse{}, client.floatScientificPositiveHandleError(resp)
	}
	return QueriesFloatScientificPositiveResponse{RawResponse: resp}, nil
}

// floatScientificPositiveCreateRequest creates the FloatScientificPositive request.
func (client *QueriesClient) floatScientificPositiveCreateRequest(ctx context.Context, options *QueriesFloatScientificPositiveOptions) (*policy.Request, error) {
	urlPath := "/queries/float/1.034E+20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("floatQuery", "103400000000000000000")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// floatScientificPositiveHandleError handles the FloatScientificPositive error response.
func (client *QueriesClient) floatScientificPositiveHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBooleanFalse - Get false Boolean value on path
// If the operation fails it returns the *Error error type.
// options - QueriesGetBooleanFalseOptions contains the optional parameters for the Queries.GetBooleanFalse method.
func (client *QueriesClient) GetBooleanFalse(ctx context.Context, options *QueriesGetBooleanFalseOptions) (QueriesGetBooleanFalseResponse, error) {
	req, err := client.getBooleanFalseCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetBooleanFalseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetBooleanFalseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetBooleanFalseResponse{}, client.getBooleanFalseHandleError(resp)
	}
	return QueriesGetBooleanFalseResponse{RawResponse: resp}, nil
}

// getBooleanFalseCreateRequest creates the GetBooleanFalse request.
func (client *QueriesClient) getBooleanFalseCreateRequest(ctx context.Context, options *QueriesGetBooleanFalseOptions) (*policy.Request, error) {
	urlPath := "/queries/bool/false"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("boolQuery", "false")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanFalseHandleError handles the GetBooleanFalse error response.
func (client *QueriesClient) getBooleanFalseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBooleanNull - Get null Boolean value on query (query string should be absent)
// If the operation fails it returns the *Error error type.
// options - QueriesGetBooleanNullOptions contains the optional parameters for the Queries.GetBooleanNull method.
func (client *QueriesClient) GetBooleanNull(ctx context.Context, options *QueriesGetBooleanNullOptions) (QueriesGetBooleanNullResponse, error) {
	req, err := client.getBooleanNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetBooleanNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetBooleanNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetBooleanNullResponse{}, client.getBooleanNullHandleError(resp)
	}
	return QueriesGetBooleanNullResponse{RawResponse: resp}, nil
}

// getBooleanNullCreateRequest creates the GetBooleanNull request.
func (client *QueriesClient) getBooleanNullCreateRequest(ctx context.Context, options *QueriesGetBooleanNullOptions) (*policy.Request, error) {
	urlPath := "/queries/bool/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.BoolQuery != nil {
		reqQP.Set("boolQuery", strconv.FormatBool(*options.BoolQuery))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanNullHandleError handles the GetBooleanNull error response.
func (client *QueriesClient) getBooleanNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBooleanTrue - Get true Boolean value on path
// If the operation fails it returns the *Error error type.
// options - QueriesGetBooleanTrueOptions contains the optional parameters for the Queries.GetBooleanTrue method.
func (client *QueriesClient) GetBooleanTrue(ctx context.Context, options *QueriesGetBooleanTrueOptions) (QueriesGetBooleanTrueResponse, error) {
	req, err := client.getBooleanTrueCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetBooleanTrueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetBooleanTrueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetBooleanTrueResponse{}, client.getBooleanTrueHandleError(resp)
	}
	return QueriesGetBooleanTrueResponse{RawResponse: resp}, nil
}

// getBooleanTrueCreateRequest creates the GetBooleanTrue request.
func (client *QueriesClient) getBooleanTrueCreateRequest(ctx context.Context, options *QueriesGetBooleanTrueOptions) (*policy.Request, error) {
	urlPath := "/queries/bool/true"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("boolQuery", "true")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanTrueHandleError handles the GetBooleanTrue error response.
func (client *QueriesClient) getBooleanTrueHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetIntNegativeOneMillion - Get '-1000000' integer value
// If the operation fails it returns the *Error error type.
// options - QueriesGetIntNegativeOneMillionOptions contains the optional parameters for the Queries.GetIntNegativeOneMillion
// method.
func (client *QueriesClient) GetIntNegativeOneMillion(ctx context.Context, options *QueriesGetIntNegativeOneMillionOptions) (QueriesGetIntNegativeOneMillionResponse, error) {
	req, err := client.getIntNegativeOneMillionCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetIntNegativeOneMillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetIntNegativeOneMillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetIntNegativeOneMillionResponse{}, client.getIntNegativeOneMillionHandleError(resp)
	}
	return QueriesGetIntNegativeOneMillionResponse{RawResponse: resp}, nil
}

// getIntNegativeOneMillionCreateRequest creates the GetIntNegativeOneMillion request.
func (client *QueriesClient) getIntNegativeOneMillionCreateRequest(ctx context.Context, options *QueriesGetIntNegativeOneMillionOptions) (*policy.Request, error) {
	urlPath := "/queries/int/-1000000"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("intQuery", "-1000000")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntNegativeOneMillionHandleError handles the GetIntNegativeOneMillion error response.
func (client *QueriesClient) getIntNegativeOneMillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetIntNull - Get null integer value (no query parameter)
// If the operation fails it returns the *Error error type.
// options - QueriesGetIntNullOptions contains the optional parameters for the Queries.GetIntNull method.
func (client *QueriesClient) GetIntNull(ctx context.Context, options *QueriesGetIntNullOptions) (QueriesGetIntNullResponse, error) {
	req, err := client.getIntNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetIntNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetIntNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetIntNullResponse{}, client.getIntNullHandleError(resp)
	}
	return QueriesGetIntNullResponse{RawResponse: resp}, nil
}

// getIntNullCreateRequest creates the GetIntNull request.
func (client *QueriesClient) getIntNullCreateRequest(ctx context.Context, options *QueriesGetIntNullOptions) (*policy.Request, error) {
	urlPath := "/queries/int/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.IntQuery != nil {
		reqQP.Set("intQuery", strconv.FormatInt(int64(*options.IntQuery), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntNullHandleError handles the GetIntNull error response.
func (client *QueriesClient) getIntNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetIntOneMillion - Get '1000000' integer value
// If the operation fails it returns the *Error error type.
// options - QueriesGetIntOneMillionOptions contains the optional parameters for the Queries.GetIntOneMillion method.
func (client *QueriesClient) GetIntOneMillion(ctx context.Context, options *QueriesGetIntOneMillionOptions) (QueriesGetIntOneMillionResponse, error) {
	req, err := client.getIntOneMillionCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetIntOneMillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetIntOneMillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetIntOneMillionResponse{}, client.getIntOneMillionHandleError(resp)
	}
	return QueriesGetIntOneMillionResponse{RawResponse: resp}, nil
}

// getIntOneMillionCreateRequest creates the GetIntOneMillion request.
func (client *QueriesClient) getIntOneMillionCreateRequest(ctx context.Context, options *QueriesGetIntOneMillionOptions) (*policy.Request, error) {
	urlPath := "/queries/int/1000000"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("intQuery", "1000000")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntOneMillionHandleError handles the GetIntOneMillion error response.
func (client *QueriesClient) getIntOneMillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetLongNull - Get 'null 64 bit integer value (no query param in uri)
// If the operation fails it returns the *Error error type.
// options - QueriesGetLongNullOptions contains the optional parameters for the Queries.GetLongNull method.
func (client *QueriesClient) GetLongNull(ctx context.Context, options *QueriesGetLongNullOptions) (QueriesGetLongNullResponse, error) {
	req, err := client.getLongNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetLongNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetLongNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetLongNullResponse{}, client.getLongNullHandleError(resp)
	}
	return QueriesGetLongNullResponse{RawResponse: resp}, nil
}

// getLongNullCreateRequest creates the GetLongNull request.
func (client *QueriesClient) getLongNullCreateRequest(ctx context.Context, options *QueriesGetLongNullOptions) (*policy.Request, error) {
	urlPath := "/queries/long/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.LongQuery != nil {
		reqQP.Set("longQuery", strconv.FormatInt(*options.LongQuery, 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getLongNullHandleError handles the GetLongNull error response.
func (client *QueriesClient) getLongNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNegativeTenBillion - Get '-10000000000' 64 bit integer value
// If the operation fails it returns the *Error error type.
// options - QueriesGetNegativeTenBillionOptions contains the optional parameters for the Queries.GetNegativeTenBillion method.
func (client *QueriesClient) GetNegativeTenBillion(ctx context.Context, options *QueriesGetNegativeTenBillionOptions) (QueriesGetNegativeTenBillionResponse, error) {
	req, err := client.getNegativeTenBillionCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetNegativeTenBillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetNegativeTenBillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetNegativeTenBillionResponse{}, client.getNegativeTenBillionHandleError(resp)
	}
	return QueriesGetNegativeTenBillionResponse{RawResponse: resp}, nil
}

// getNegativeTenBillionCreateRequest creates the GetNegativeTenBillion request.
func (client *QueriesClient) getNegativeTenBillionCreateRequest(ctx context.Context, options *QueriesGetNegativeTenBillionOptions) (*policy.Request, error) {
	urlPath := "/queries/long/-10000000000"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("longQuery", "-10000000000")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNegativeTenBillionHandleError handles the GetNegativeTenBillion error response.
func (client *QueriesClient) getNegativeTenBillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetTenBillion - Get '10000000000' 64 bit integer value
// If the operation fails it returns the *Error error type.
// options - QueriesGetTenBillionOptions contains the optional parameters for the Queries.GetTenBillion method.
func (client *QueriesClient) GetTenBillion(ctx context.Context, options *QueriesGetTenBillionOptions) (QueriesGetTenBillionResponse, error) {
	req, err := client.getTenBillionCreateRequest(ctx, options)
	if err != nil {
		return QueriesGetTenBillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesGetTenBillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesGetTenBillionResponse{}, client.getTenBillionHandleError(resp)
	}
	return QueriesGetTenBillionResponse{RawResponse: resp}, nil
}

// getTenBillionCreateRequest creates the GetTenBillion request.
func (client *QueriesClient) getTenBillionCreateRequest(ctx context.Context, options *QueriesGetTenBillionOptions) (*policy.Request, error) {
	urlPath := "/queries/long/10000000000"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("longQuery", "10000000000")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTenBillionHandleError handles the GetTenBillion error response.
func (client *QueriesClient) getTenBillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringEmpty - Get ''
// If the operation fails it returns the *Error error type.
// options - QueriesStringEmptyOptions contains the optional parameters for the Queries.StringEmpty method.
func (client *QueriesClient) StringEmpty(ctx context.Context, options *QueriesStringEmptyOptions) (QueriesStringEmptyResponse, error) {
	req, err := client.stringEmptyCreateRequest(ctx, options)
	if err != nil {
		return QueriesStringEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesStringEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesStringEmptyResponse{}, client.stringEmptyHandleError(resp)
	}
	return QueriesStringEmptyResponse{RawResponse: resp}, nil
}

// stringEmptyCreateRequest creates the StringEmpty request.
func (client *QueriesClient) stringEmptyCreateRequest(ctx context.Context, options *QueriesStringEmptyOptions) (*policy.Request, error) {
	urlPath := "/queries/string/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("stringQuery", "")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringEmptyHandleError handles the StringEmpty error response.
func (client *QueriesClient) stringEmptyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringNull - Get null (no query parameter in url)
// If the operation fails it returns the *Error error type.
// options - QueriesStringNullOptions contains the optional parameters for the Queries.StringNull method.
func (client *QueriesClient) StringNull(ctx context.Context, options *QueriesStringNullOptions) (QueriesStringNullResponse, error) {
	req, err := client.stringNullCreateRequest(ctx, options)
	if err != nil {
		return QueriesStringNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesStringNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesStringNullResponse{}, client.stringNullHandleError(resp)
	}
	return QueriesStringNullResponse{RawResponse: resp}, nil
}

// stringNullCreateRequest creates the StringNull request.
func (client *QueriesClient) stringNullCreateRequest(ctx context.Context, options *QueriesStringNullOptions) (*policy.Request, error) {
	urlPath := "/queries/string/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.StringQuery != nil {
		reqQP.Set("stringQuery", *options.StringQuery)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringNullHandleError handles the StringNull error response.
func (client *QueriesClient) stringNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringURLEncoded - Get 'begin!*'();:@ &=+$,/?#[]end
// If the operation fails it returns the *Error error type.
// options - QueriesStringURLEncodedOptions contains the optional parameters for the Queries.StringURLEncoded method.
func (client *QueriesClient) StringURLEncoded(ctx context.Context, options *QueriesStringURLEncodedOptions) (QueriesStringURLEncodedResponse, error) {
	req, err := client.stringURLEncodedCreateRequest(ctx, options)
	if err != nil {
		return QueriesStringURLEncodedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesStringURLEncodedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesStringURLEncodedResponse{}, client.stringURLEncodedHandleError(resp)
	}
	return QueriesStringURLEncodedResponse{RawResponse: resp}, nil
}

// stringURLEncodedCreateRequest creates the StringURLEncoded request.
func (client *QueriesClient) stringURLEncodedCreateRequest(ctx context.Context, options *QueriesStringURLEncodedOptions) (*policy.Request, error) {
	urlPath := "/queries/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("stringQuery", "begin!*'();:@ &=+$,/?#[]end")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringURLEncodedHandleError handles the StringURLEncoded error response.
func (client *QueriesClient) stringURLEncodedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringUnicode - Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
// If the operation fails it returns the *Error error type.
// options - QueriesStringUnicodeOptions contains the optional parameters for the Queries.StringUnicode method.
func (client *QueriesClient) StringUnicode(ctx context.Context, options *QueriesStringUnicodeOptions) (QueriesStringUnicodeResponse, error) {
	req, err := client.stringUnicodeCreateRequest(ctx, options)
	if err != nil {
		return QueriesStringUnicodeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return QueriesStringUnicodeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return QueriesStringUnicodeResponse{}, client.stringUnicodeHandleError(resp)
	}
	return QueriesStringUnicodeResponse{RawResponse: resp}, nil
}

// stringUnicodeCreateRequest creates the StringUnicode request.
func (client *QueriesClient) stringUnicodeCreateRequest(ctx context.Context, options *QueriesStringUnicodeOptions) (*policy.Request, error) {
	urlPath := "/queries/string/unicode/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("stringQuery", "啊齄丂狛狜隣郎隣兀﨩")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringUnicodeHandleError handles the StringUnicode error response.
func (client *QueriesClient) stringUnicodeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
