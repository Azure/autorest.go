//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package urlgroup

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// PathsClient contains the methods for the Paths group.
// Don't use this type directly, use NewPathsClient() instead.
type PathsClient struct {
	pl runtime.Pipeline
}

// NewPathsClient creates a new instance of PathsClient with the specified values.
// options - pass nil to accept the default values.
func NewPathsClient(options *azcore.ClientOptions) *PathsClient {
	cp := azcore.ClientOptions{}
	if options != nil {
		cp = *options
	}
	client := &PathsClient{
		pl: runtime.NewPipeline(module, version, nil, nil, &cp),
	}
	return client
}

// ArrayCSVInPath - Get an array of string ['ArrayPath1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
// If the operation fails it returns the *Error error type.
// arrayPath - an array of string ['ArrayPath1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
// options - PathsClientArrayCSVInPathOptions contains the optional parameters for the PathsClient.ArrayCSVInPath method.
func (client *PathsClient) ArrayCSVInPath(ctx context.Context, arrayPath []string, options *PathsClientArrayCSVInPathOptions) (PathsClientArrayCSVInPathResponse, error) {
	req, err := client.arrayCSVInPathCreateRequest(ctx, arrayPath, options)
	if err != nil {
		return PathsClientArrayCSVInPathResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientArrayCSVInPathResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientArrayCSVInPathResponse{}, client.arrayCSVInPathHandleError(resp)
	}
	return PathsClientArrayCSVInPathResponse{RawResponse: resp}, nil
}

// arrayCSVInPathCreateRequest creates the ArrayCSVInPath request.
func (client *PathsClient) arrayCSVInPathCreateRequest(ctx context.Context, arrayPath []string, options *PathsClientArrayCSVInPathOptions) (*policy.Request, error) {
	urlPath := "/paths/array/ArrayPath1%2cbegin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend%2c%2c/{arrayPath}"
	urlPath = strings.ReplaceAll(urlPath, "{arrayPath}", url.PathEscape(strings.Join(arrayPath, ",")))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// arrayCSVInPathHandleError handles the ArrayCSVInPath error response.
func (client *PathsClient) arrayCSVInPathHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Base64URL - Get 'lorem' encoded value as 'bG9yZW0' (base64url)
// If the operation fails it returns the *Error error type.
// base64URLPath - base64url encoded value
// options - PathsClientBase64URLOptions contains the optional parameters for the PathsClient.Base64URL method.
func (client *PathsClient) Base64URL(ctx context.Context, base64URLPath []byte, options *PathsClientBase64URLOptions) (PathsClientBase64URLResponse, error) {
	req, err := client.base64URLCreateRequest(ctx, base64URLPath, options)
	if err != nil {
		return PathsClientBase64URLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientBase64URLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientBase64URLResponse{}, client.base64URLHandleError(resp)
	}
	return PathsClientBase64URLResponse{RawResponse: resp}, nil
}

// base64URLCreateRequest creates the Base64URL request.
func (client *PathsClient) base64URLCreateRequest(ctx context.Context, base64URLPath []byte, options *PathsClientBase64URLOptions) (*policy.Request, error) {
	urlPath := "/paths/string/bG9yZW0/{base64UrlPath}"
	urlPath = strings.ReplaceAll(urlPath, "{base64UrlPath}", url.PathEscape(base64.RawURLEncoding.EncodeToString(base64URLPath)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// base64URLHandleError handles the Base64URL error response.
func (client *PathsClient) base64URLHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ByteEmpty - Get '' as byte array
// If the operation fails it returns the *Error error type.
// options - PathsClientByteEmptyOptions contains the optional parameters for the PathsClient.ByteEmpty method.
func (client *PathsClient) ByteEmpty(ctx context.Context, options *PathsClientByteEmptyOptions) (PathsClientByteEmptyResponse, error) {
	req, err := client.byteEmptyCreateRequest(ctx, options)
	if err != nil {
		return PathsClientByteEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientByteEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientByteEmptyResponse{}, client.byteEmptyHandleError(resp)
	}
	return PathsClientByteEmptyResponse{RawResponse: resp}, nil
}

// byteEmptyCreateRequest creates the ByteEmpty request.
func (client *PathsClient) byteEmptyCreateRequest(ctx context.Context, options *PathsClientByteEmptyOptions) (*policy.Request, error) {
	urlPath := "/paths/byte/empty/{bytePath}"
	urlPath = strings.ReplaceAll(urlPath, "{bytePath}", url.PathEscape(""))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// byteEmptyHandleError handles the ByteEmpty error response.
func (client *PathsClient) byteEmptyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ByteMultiByte - Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
// If the operation fails it returns the *Error error type.
// bytePath - '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
// options - PathsClientByteMultiByteOptions contains the optional parameters for the PathsClient.ByteMultiByte method.
func (client *PathsClient) ByteMultiByte(ctx context.Context, bytePath []byte, options *PathsClientByteMultiByteOptions) (PathsClientByteMultiByteResponse, error) {
	req, err := client.byteMultiByteCreateRequest(ctx, bytePath, options)
	if err != nil {
		return PathsClientByteMultiByteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientByteMultiByteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientByteMultiByteResponse{}, client.byteMultiByteHandleError(resp)
	}
	return PathsClientByteMultiByteResponse{RawResponse: resp}, nil
}

// byteMultiByteCreateRequest creates the ByteMultiByte request.
func (client *PathsClient) byteMultiByteCreateRequest(ctx context.Context, bytePath []byte, options *PathsClientByteMultiByteOptions) (*policy.Request, error) {
	urlPath := "/paths/byte/multibyte/{bytePath}"
	urlPath = strings.ReplaceAll(urlPath, "{bytePath}", url.PathEscape(base64.StdEncoding.EncodeToString(bytePath)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// byteMultiByteHandleError handles the ByteMultiByte error response.
func (client *PathsClient) byteMultiByteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ByteNull - Get null as byte array (should throw)
// If the operation fails it returns the *Error error type.
// bytePath - null as byte array (should throw)
// options - PathsClientByteNullOptions contains the optional parameters for the PathsClient.ByteNull method.
func (client *PathsClient) ByteNull(ctx context.Context, bytePath []byte, options *PathsClientByteNullOptions) (PathsClientByteNullResponse, error) {
	req, err := client.byteNullCreateRequest(ctx, bytePath, options)
	if err != nil {
		return PathsClientByteNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientByteNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusBadRequest) {
		return PathsClientByteNullResponse{}, client.byteNullHandleError(resp)
	}
	return PathsClientByteNullResponse{RawResponse: resp}, nil
}

// byteNullCreateRequest creates the ByteNull request.
func (client *PathsClient) byteNullCreateRequest(ctx context.Context, bytePath []byte, options *PathsClientByteNullOptions) (*policy.Request, error) {
	urlPath := "/paths/byte/null/{bytePath}"
	urlPath = strings.ReplaceAll(urlPath, "{bytePath}", url.PathEscape(base64.StdEncoding.EncodeToString(bytePath)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// byteNullHandleError handles the ByteNull error response.
func (client *PathsClient) byteNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateNull - Get null as date - this should throw or be unusable on the client side, depending on date representation
// If the operation fails it returns the *Error error type.
// datePath - null as date (should throw)
// options - PathsClientDateNullOptions contains the optional parameters for the PathsClient.DateNull method.
func (client *PathsClient) DateNull(ctx context.Context, datePath time.Time, options *PathsClientDateNullOptions) (PathsClientDateNullResponse, error) {
	req, err := client.dateNullCreateRequest(ctx, datePath, options)
	if err != nil {
		return PathsClientDateNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientDateNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusBadRequest) {
		return PathsClientDateNullResponse{}, client.dateNullHandleError(resp)
	}
	return PathsClientDateNullResponse{RawResponse: resp}, nil
}

// dateNullCreateRequest creates the DateNull request.
func (client *PathsClient) dateNullCreateRequest(ctx context.Context, datePath time.Time, options *PathsClientDateNullOptions) (*policy.Request, error) {
	urlPath := "/paths/date/null/{datePath}"
	urlPath = strings.ReplaceAll(urlPath, "{datePath}", url.PathEscape(datePath.Format("2006-01-02")))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateNullHandleError handles the DateNull error response.
func (client *PathsClient) dateNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateTimeNull - Get null as date-time, should be disallowed or throw depending on representation of date-time
// If the operation fails it returns the *Error error type.
// dateTimePath - null as date-time
// options - PathsClientDateTimeNullOptions contains the optional parameters for the PathsClient.DateTimeNull method.
func (client *PathsClient) DateTimeNull(ctx context.Context, dateTimePath time.Time, options *PathsClientDateTimeNullOptions) (PathsClientDateTimeNullResponse, error) {
	req, err := client.dateTimeNullCreateRequest(ctx, dateTimePath, options)
	if err != nil {
		return PathsClientDateTimeNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientDateTimeNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusBadRequest) {
		return PathsClientDateTimeNullResponse{}, client.dateTimeNullHandleError(resp)
	}
	return PathsClientDateTimeNullResponse{RawResponse: resp}, nil
}

// dateTimeNullCreateRequest creates the DateTimeNull request.
func (client *PathsClient) dateTimeNullCreateRequest(ctx context.Context, dateTimePath time.Time, options *PathsClientDateTimeNullOptions) (*policy.Request, error) {
	urlPath := "/paths/datetime/null/{dateTimePath}"
	urlPath = strings.ReplaceAll(urlPath, "{dateTimePath}", url.PathEscape(dateTimePath.Format(time.RFC3339Nano)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateTimeNullHandleError handles the DateTimeNull error response.
func (client *PathsClient) dateTimeNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateTimeValid - Get '2012-01-01T01:01:01Z' as date-time
// If the operation fails it returns the *Error error type.
// options - PathsClientDateTimeValidOptions contains the optional parameters for the PathsClient.DateTimeValid method.
func (client *PathsClient) DateTimeValid(ctx context.Context, options *PathsClientDateTimeValidOptions) (PathsClientDateTimeValidResponse, error) {
	req, err := client.dateTimeValidCreateRequest(ctx, options)
	if err != nil {
		return PathsClientDateTimeValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientDateTimeValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientDateTimeValidResponse{}, client.dateTimeValidHandleError(resp)
	}
	return PathsClientDateTimeValidResponse{RawResponse: resp}, nil
}

// dateTimeValidCreateRequest creates the DateTimeValid request.
func (client *PathsClient) dateTimeValidCreateRequest(ctx context.Context, options *PathsClientDateTimeValidOptions) (*policy.Request, error) {
	urlPath := "/paths/datetime/2012-01-01T01%3A01%3A01Z/{dateTimePath}"
	urlPath = strings.ReplaceAll(urlPath, "{dateTimePath}", url.PathEscape("2012-01-01T01:01:01Z"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateTimeValidHandleError handles the DateTimeValid error response.
func (client *PathsClient) dateTimeValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DateValid - Get '2012-01-01' as date
// If the operation fails it returns the *Error error type.
// options - PathsClientDateValidOptions contains the optional parameters for the PathsClient.DateValid method.
func (client *PathsClient) DateValid(ctx context.Context, options *PathsClientDateValidOptions) (PathsClientDateValidResponse, error) {
	req, err := client.dateValidCreateRequest(ctx, options)
	if err != nil {
		return PathsClientDateValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientDateValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientDateValidResponse{}, client.dateValidHandleError(resp)
	}
	return PathsClientDateValidResponse{RawResponse: resp}, nil
}

// dateValidCreateRequest creates the DateValid request.
func (client *PathsClient) dateValidCreateRequest(ctx context.Context, options *PathsClientDateValidOptions) (*policy.Request, error) {
	urlPath := "/paths/date/2012-01-01/{datePath}"
	urlPath = strings.ReplaceAll(urlPath, "{datePath}", url.PathEscape("2012-01-01"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// dateValidHandleError handles the DateValid error response.
func (client *PathsClient) dateValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DoubleDecimalNegative - Get '-9999999.999' numeric value
// If the operation fails it returns the *Error error type.
// options - PathsClientDoubleDecimalNegativeOptions contains the optional parameters for the PathsClient.DoubleDecimalNegative
// method.
func (client *PathsClient) DoubleDecimalNegative(ctx context.Context, options *PathsClientDoubleDecimalNegativeOptions) (PathsClientDoubleDecimalNegativeResponse, error) {
	req, err := client.doubleDecimalNegativeCreateRequest(ctx, options)
	if err != nil {
		return PathsClientDoubleDecimalNegativeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientDoubleDecimalNegativeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientDoubleDecimalNegativeResponse{}, client.doubleDecimalNegativeHandleError(resp)
	}
	return PathsClientDoubleDecimalNegativeResponse{RawResponse: resp}, nil
}

// doubleDecimalNegativeCreateRequest creates the DoubleDecimalNegative request.
func (client *PathsClient) doubleDecimalNegativeCreateRequest(ctx context.Context, options *PathsClientDoubleDecimalNegativeOptions) (*policy.Request, error) {
	urlPath := "/paths/double/-9999999.999/{doublePath}"
	urlPath = strings.ReplaceAll(urlPath, "{doublePath}", url.PathEscape("-9999999.999"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// doubleDecimalNegativeHandleError handles the DoubleDecimalNegative error response.
func (client *PathsClient) doubleDecimalNegativeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DoubleDecimalPositive - Get '9999999.999' numeric value
// If the operation fails it returns the *Error error type.
// options - PathsClientDoubleDecimalPositiveOptions contains the optional parameters for the PathsClient.DoubleDecimalPositive
// method.
func (client *PathsClient) DoubleDecimalPositive(ctx context.Context, options *PathsClientDoubleDecimalPositiveOptions) (PathsClientDoubleDecimalPositiveResponse, error) {
	req, err := client.doubleDecimalPositiveCreateRequest(ctx, options)
	if err != nil {
		return PathsClientDoubleDecimalPositiveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientDoubleDecimalPositiveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientDoubleDecimalPositiveResponse{}, client.doubleDecimalPositiveHandleError(resp)
	}
	return PathsClientDoubleDecimalPositiveResponse{RawResponse: resp}, nil
}

// doubleDecimalPositiveCreateRequest creates the DoubleDecimalPositive request.
func (client *PathsClient) doubleDecimalPositiveCreateRequest(ctx context.Context, options *PathsClientDoubleDecimalPositiveOptions) (*policy.Request, error) {
	urlPath := "/paths/double/9999999.999/{doublePath}"
	urlPath = strings.ReplaceAll(urlPath, "{doublePath}", url.PathEscape("9999999.999"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// doubleDecimalPositiveHandleError handles the DoubleDecimalPositive error response.
func (client *PathsClient) doubleDecimalPositiveHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// EnumNull - Get null (should throw on the client before the request is sent on wire)
// If the operation fails it returns the *Error error type.
// enumPath - send null should throw
// options - PathsClientEnumNullOptions contains the optional parameters for the PathsClient.EnumNull method.
func (client *PathsClient) EnumNull(ctx context.Context, enumPath URIColor, options *PathsClientEnumNullOptions) (PathsClientEnumNullResponse, error) {
	req, err := client.enumNullCreateRequest(ctx, enumPath, options)
	if err != nil {
		return PathsClientEnumNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientEnumNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusBadRequest) {
		return PathsClientEnumNullResponse{}, client.enumNullHandleError(resp)
	}
	return PathsClientEnumNullResponse{RawResponse: resp}, nil
}

// enumNullCreateRequest creates the EnumNull request.
func (client *PathsClient) enumNullCreateRequest(ctx context.Context, enumPath URIColor, options *PathsClientEnumNullOptions) (*policy.Request, error) {
	urlPath := "/paths/string/null/{enumPath}"
	if enumPath == "" {
		return nil, errors.New("parameter enumPath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{enumPath}", url.PathEscape(string(enumPath)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// enumNullHandleError handles the EnumNull error response.
func (client *PathsClient) enumNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// EnumValid - Get using uri with 'green color' in path parameter
// If the operation fails it returns the *Error error type.
// enumPath - send the value green
// options - PathsClientEnumValidOptions contains the optional parameters for the PathsClient.EnumValid method.
func (client *PathsClient) EnumValid(ctx context.Context, enumPath URIColor, options *PathsClientEnumValidOptions) (PathsClientEnumValidResponse, error) {
	req, err := client.enumValidCreateRequest(ctx, enumPath, options)
	if err != nil {
		return PathsClientEnumValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientEnumValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientEnumValidResponse{}, client.enumValidHandleError(resp)
	}
	return PathsClientEnumValidResponse{RawResponse: resp}, nil
}

// enumValidCreateRequest creates the EnumValid request.
func (client *PathsClient) enumValidCreateRequest(ctx context.Context, enumPath URIColor, options *PathsClientEnumValidOptions) (*policy.Request, error) {
	urlPath := "/paths/enum/green%20color/{enumPath}"
	if enumPath == "" {
		return nil, errors.New("parameter enumPath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{enumPath}", url.PathEscape(string(enumPath)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// enumValidHandleError handles the EnumValid error response.
func (client *PathsClient) enumValidHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// FloatScientificNegative - Get '-1.034E-20' numeric value
// If the operation fails it returns the *Error error type.
// options - PathsClientFloatScientificNegativeOptions contains the optional parameters for the PathsClient.FloatScientificNegative
// method.
func (client *PathsClient) FloatScientificNegative(ctx context.Context, options *PathsClientFloatScientificNegativeOptions) (PathsClientFloatScientificNegativeResponse, error) {
	req, err := client.floatScientificNegativeCreateRequest(ctx, options)
	if err != nil {
		return PathsClientFloatScientificNegativeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientFloatScientificNegativeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientFloatScientificNegativeResponse{}, client.floatScientificNegativeHandleError(resp)
	}
	return PathsClientFloatScientificNegativeResponse{RawResponse: resp}, nil
}

// floatScientificNegativeCreateRequest creates the FloatScientificNegative request.
func (client *PathsClient) floatScientificNegativeCreateRequest(ctx context.Context, options *PathsClientFloatScientificNegativeOptions) (*policy.Request, error) {
	urlPath := "/paths/float/-1.034E-20/{floatPath}"
	urlPath = strings.ReplaceAll(urlPath, "{floatPath}", url.PathEscape("-1.034e-20"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// floatScientificNegativeHandleError handles the FloatScientificNegative error response.
func (client *PathsClient) floatScientificNegativeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// FloatScientificPositive - Get '1.034E+20' numeric value
// If the operation fails it returns the *Error error type.
// options - PathsClientFloatScientificPositiveOptions contains the optional parameters for the PathsClient.FloatScientificPositive
// method.
func (client *PathsClient) FloatScientificPositive(ctx context.Context, options *PathsClientFloatScientificPositiveOptions) (PathsClientFloatScientificPositiveResponse, error) {
	req, err := client.floatScientificPositiveCreateRequest(ctx, options)
	if err != nil {
		return PathsClientFloatScientificPositiveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientFloatScientificPositiveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientFloatScientificPositiveResponse{}, client.floatScientificPositiveHandleError(resp)
	}
	return PathsClientFloatScientificPositiveResponse{RawResponse: resp}, nil
}

// floatScientificPositiveCreateRequest creates the FloatScientificPositive request.
func (client *PathsClient) floatScientificPositiveCreateRequest(ctx context.Context, options *PathsClientFloatScientificPositiveOptions) (*policy.Request, error) {
	urlPath := "/paths/float/1.034E+20/{floatPath}"
	urlPath = strings.ReplaceAll(urlPath, "{floatPath}", url.PathEscape("103400000000000000000"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// floatScientificPositiveHandleError handles the FloatScientificPositive error response.
func (client *PathsClient) floatScientificPositiveHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBooleanFalse - Get false Boolean value on path
// If the operation fails it returns the *Error error type.
// options - PathsClientGetBooleanFalseOptions contains the optional parameters for the PathsClient.GetBooleanFalse method.
func (client *PathsClient) GetBooleanFalse(ctx context.Context, options *PathsClientGetBooleanFalseOptions) (PathsClientGetBooleanFalseResponse, error) {
	req, err := client.getBooleanFalseCreateRequest(ctx, options)
	if err != nil {
		return PathsClientGetBooleanFalseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientGetBooleanFalseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientGetBooleanFalseResponse{}, client.getBooleanFalseHandleError(resp)
	}
	return PathsClientGetBooleanFalseResponse{RawResponse: resp}, nil
}

// getBooleanFalseCreateRequest creates the GetBooleanFalse request.
func (client *PathsClient) getBooleanFalseCreateRequest(ctx context.Context, options *PathsClientGetBooleanFalseOptions) (*policy.Request, error) {
	urlPath := "/paths/bool/false/{boolPath}"
	urlPath = strings.ReplaceAll(urlPath, "{boolPath}", url.PathEscape("false"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanFalseHandleError handles the GetBooleanFalse error response.
func (client *PathsClient) getBooleanFalseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBooleanTrue - Get true Boolean value on path
// If the operation fails it returns the *Error error type.
// options - PathsClientGetBooleanTrueOptions contains the optional parameters for the PathsClient.GetBooleanTrue method.
func (client *PathsClient) GetBooleanTrue(ctx context.Context, options *PathsClientGetBooleanTrueOptions) (PathsClientGetBooleanTrueResponse, error) {
	req, err := client.getBooleanTrueCreateRequest(ctx, options)
	if err != nil {
		return PathsClientGetBooleanTrueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientGetBooleanTrueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientGetBooleanTrueResponse{}, client.getBooleanTrueHandleError(resp)
	}
	return PathsClientGetBooleanTrueResponse{RawResponse: resp}, nil
}

// getBooleanTrueCreateRequest creates the GetBooleanTrue request.
func (client *PathsClient) getBooleanTrueCreateRequest(ctx context.Context, options *PathsClientGetBooleanTrueOptions) (*policy.Request, error) {
	urlPath := "/paths/bool/true/{boolPath}"
	urlPath = strings.ReplaceAll(urlPath, "{boolPath}", url.PathEscape("true"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanTrueHandleError handles the GetBooleanTrue error response.
func (client *PathsClient) getBooleanTrueHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetIntNegativeOneMillion - Get '-1000000' integer value
// If the operation fails it returns the *Error error type.
// options - PathsClientGetIntNegativeOneMillionOptions contains the optional parameters for the PathsClient.GetIntNegativeOneMillion
// method.
func (client *PathsClient) GetIntNegativeOneMillion(ctx context.Context, options *PathsClientGetIntNegativeOneMillionOptions) (PathsClientGetIntNegativeOneMillionResponse, error) {
	req, err := client.getIntNegativeOneMillionCreateRequest(ctx, options)
	if err != nil {
		return PathsClientGetIntNegativeOneMillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientGetIntNegativeOneMillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientGetIntNegativeOneMillionResponse{}, client.getIntNegativeOneMillionHandleError(resp)
	}
	return PathsClientGetIntNegativeOneMillionResponse{RawResponse: resp}, nil
}

// getIntNegativeOneMillionCreateRequest creates the GetIntNegativeOneMillion request.
func (client *PathsClient) getIntNegativeOneMillionCreateRequest(ctx context.Context, options *PathsClientGetIntNegativeOneMillionOptions) (*policy.Request, error) {
	urlPath := "/paths/int/-1000000/{intPath}"
	urlPath = strings.ReplaceAll(urlPath, "{intPath}", url.PathEscape("-1000000"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntNegativeOneMillionHandleError handles the GetIntNegativeOneMillion error response.
func (client *PathsClient) getIntNegativeOneMillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetIntOneMillion - Get '1000000' integer value
// If the operation fails it returns the *Error error type.
// options - PathsClientGetIntOneMillionOptions contains the optional parameters for the PathsClient.GetIntOneMillion method.
func (client *PathsClient) GetIntOneMillion(ctx context.Context, options *PathsClientGetIntOneMillionOptions) (PathsClientGetIntOneMillionResponse, error) {
	req, err := client.getIntOneMillionCreateRequest(ctx, options)
	if err != nil {
		return PathsClientGetIntOneMillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientGetIntOneMillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientGetIntOneMillionResponse{}, client.getIntOneMillionHandleError(resp)
	}
	return PathsClientGetIntOneMillionResponse{RawResponse: resp}, nil
}

// getIntOneMillionCreateRequest creates the GetIntOneMillion request.
func (client *PathsClient) getIntOneMillionCreateRequest(ctx context.Context, options *PathsClientGetIntOneMillionOptions) (*policy.Request, error) {
	urlPath := "/paths/int/1000000/{intPath}"
	urlPath = strings.ReplaceAll(urlPath, "{intPath}", url.PathEscape("1000000"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntOneMillionHandleError handles the GetIntOneMillion error response.
func (client *PathsClient) getIntOneMillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNegativeTenBillion - Get '-10000000000' 64 bit integer value
// If the operation fails it returns the *Error error type.
// options - PathsClientGetNegativeTenBillionOptions contains the optional parameters for the PathsClient.GetNegativeTenBillion
// method.
func (client *PathsClient) GetNegativeTenBillion(ctx context.Context, options *PathsClientGetNegativeTenBillionOptions) (PathsClientGetNegativeTenBillionResponse, error) {
	req, err := client.getNegativeTenBillionCreateRequest(ctx, options)
	if err != nil {
		return PathsClientGetNegativeTenBillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientGetNegativeTenBillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientGetNegativeTenBillionResponse{}, client.getNegativeTenBillionHandleError(resp)
	}
	return PathsClientGetNegativeTenBillionResponse{RawResponse: resp}, nil
}

// getNegativeTenBillionCreateRequest creates the GetNegativeTenBillion request.
func (client *PathsClient) getNegativeTenBillionCreateRequest(ctx context.Context, options *PathsClientGetNegativeTenBillionOptions) (*policy.Request, error) {
	urlPath := "/paths/long/-10000000000/{longPath}"
	urlPath = strings.ReplaceAll(urlPath, "{longPath}", url.PathEscape("-10000000000"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNegativeTenBillionHandleError handles the GetNegativeTenBillion error response.
func (client *PathsClient) getNegativeTenBillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetTenBillion - Get '10000000000' 64 bit integer value
// If the operation fails it returns the *Error error type.
// options - PathsClientGetTenBillionOptions contains the optional parameters for the PathsClient.GetTenBillion method.
func (client *PathsClient) GetTenBillion(ctx context.Context, options *PathsClientGetTenBillionOptions) (PathsClientGetTenBillionResponse, error) {
	req, err := client.getTenBillionCreateRequest(ctx, options)
	if err != nil {
		return PathsClientGetTenBillionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientGetTenBillionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientGetTenBillionResponse{}, client.getTenBillionHandleError(resp)
	}
	return PathsClientGetTenBillionResponse{RawResponse: resp}, nil
}

// getTenBillionCreateRequest creates the GetTenBillion request.
func (client *PathsClient) getTenBillionCreateRequest(ctx context.Context, options *PathsClientGetTenBillionOptions) (*policy.Request, error) {
	urlPath := "/paths/long/10000000000/{longPath}"
	urlPath = strings.ReplaceAll(urlPath, "{longPath}", url.PathEscape("10000000000"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTenBillionHandleError handles the GetTenBillion error response.
func (client *PathsClient) getTenBillionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringEmpty - Get ''
// If the operation fails it returns the *Error error type.
// options - PathsClientStringEmptyOptions contains the optional parameters for the PathsClient.StringEmpty method.
func (client *PathsClient) StringEmpty(ctx context.Context, options *PathsClientStringEmptyOptions) (PathsClientStringEmptyResponse, error) {
	req, err := client.stringEmptyCreateRequest(ctx, options)
	if err != nil {
		return PathsClientStringEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientStringEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientStringEmptyResponse{}, client.stringEmptyHandleError(resp)
	}
	return PathsClientStringEmptyResponse{RawResponse: resp}, nil
}

// stringEmptyCreateRequest creates the StringEmpty request.
func (client *PathsClient) stringEmptyCreateRequest(ctx context.Context, options *PathsClientStringEmptyOptions) (*policy.Request, error) {
	urlPath := "/paths/string/empty/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape(""))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringEmptyHandleError handles the StringEmpty error response.
func (client *PathsClient) stringEmptyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringNull - Get null (should throw)
// If the operation fails it returns the *Error error type.
// stringPath - null string value
// options - PathsClientStringNullOptions contains the optional parameters for the PathsClient.StringNull method.
func (client *PathsClient) StringNull(ctx context.Context, stringPath string, options *PathsClientStringNullOptions) (PathsClientStringNullResponse, error) {
	req, err := client.stringNullCreateRequest(ctx, stringPath, options)
	if err != nil {
		return PathsClientStringNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientStringNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusBadRequest) {
		return PathsClientStringNullResponse{}, client.stringNullHandleError(resp)
	}
	return PathsClientStringNullResponse{RawResponse: resp}, nil
}

// stringNullCreateRequest creates the StringNull request.
func (client *PathsClient) stringNullCreateRequest(ctx context.Context, stringPath string, options *PathsClientStringNullOptions) (*policy.Request, error) {
	urlPath := "/paths/string/null/{stringPath}"
	if stringPath == "" {
		return nil, errors.New("parameter stringPath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape(stringPath))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringNullHandleError handles the StringNull error response.
func (client *PathsClient) stringNullHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringURLEncoded - Get 'begin!*'();:@ &=+$,/?#[]end
// If the operation fails it returns the *Error error type.
// options - PathsClientStringURLEncodedOptions contains the optional parameters for the PathsClient.StringURLEncoded method.
func (client *PathsClient) StringURLEncoded(ctx context.Context, options *PathsClientStringURLEncodedOptions) (PathsClientStringURLEncodedResponse, error) {
	req, err := client.stringURLEncodedCreateRequest(ctx, options)
	if err != nil {
		return PathsClientStringURLEncodedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientStringURLEncodedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientStringURLEncodedResponse{}, client.stringURLEncodedHandleError(resp)
	}
	return PathsClientStringURLEncodedResponse{RawResponse: resp}, nil
}

// stringURLEncodedCreateRequest creates the StringURLEncoded request.
func (client *PathsClient) stringURLEncodedCreateRequest(ctx context.Context, options *PathsClientStringURLEncodedOptions) (*policy.Request, error) {
	urlPath := "/paths/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape("begin!*'();:@ &=+$,/?#[]end"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringURLEncodedHandleError handles the StringURLEncoded error response.
func (client *PathsClient) stringURLEncodedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringURLNonEncoded - https://tools.ietf.org/html/rfc3986#appendix-A 'path' accept any 'pchar' not encoded
// If the operation fails it returns the *Error error type.
// options - PathsClientStringURLNonEncodedOptions contains the optional parameters for the PathsClient.StringURLNonEncoded
// method.
func (client *PathsClient) StringURLNonEncoded(ctx context.Context, options *PathsClientStringURLNonEncodedOptions) (PathsClientStringURLNonEncodedResponse, error) {
	req, err := client.stringURLNonEncodedCreateRequest(ctx, options)
	if err != nil {
		return PathsClientStringURLNonEncodedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientStringURLNonEncodedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientStringURLNonEncodedResponse{}, client.stringURLNonEncodedHandleError(resp)
	}
	return PathsClientStringURLNonEncodedResponse{RawResponse: resp}, nil
}

// stringURLNonEncodedCreateRequest creates the StringURLNonEncoded request.
func (client *PathsClient) stringURLNonEncodedCreateRequest(ctx context.Context, options *PathsClientStringURLNonEncodedOptions) (*policy.Request, error) {
	urlPath := "/paths/string/begin!*'();:@&=+$,end/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", "begin!*'();:@&=+$,end")
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringURLNonEncodedHandleError handles the StringURLNonEncoded error response.
func (client *PathsClient) stringURLNonEncodedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StringUnicode - Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
// If the operation fails it returns the *Error error type.
// options - PathsClientStringUnicodeOptions contains the optional parameters for the PathsClient.StringUnicode method.
func (client *PathsClient) StringUnicode(ctx context.Context, options *PathsClientStringUnicodeOptions) (PathsClientStringUnicodeResponse, error) {
	req, err := client.stringUnicodeCreateRequest(ctx, options)
	if err != nil {
		return PathsClientStringUnicodeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientStringUnicodeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientStringUnicodeResponse{}, client.stringUnicodeHandleError(resp)
	}
	return PathsClientStringUnicodeResponse{RawResponse: resp}, nil
}

// stringUnicodeCreateRequest creates the StringUnicode request.
func (client *PathsClient) stringUnicodeCreateRequest(ctx context.Context, options *PathsClientStringUnicodeOptions) (*policy.Request, error) {
	urlPath := "/paths/string/unicode/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape("啊齄丂狛狜隣郎隣兀﨩"))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stringUnicodeHandleError handles the StringUnicode error response.
func (client *PathsClient) stringUnicodeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UnixTimeURL - Get the date 2016-04-13 encoded value as '1460505600' (Unix time)
// If the operation fails it returns the *Error error type.
// unixTimeURLPath - Unix time encoded value
// options - PathsClientUnixTimeURLOptions contains the optional parameters for the PathsClient.UnixTimeURL method.
func (client *PathsClient) UnixTimeURL(ctx context.Context, unixTimeURLPath time.Time, options *PathsClientUnixTimeURLOptions) (PathsClientUnixTimeURLResponse, error) {
	req, err := client.unixTimeURLCreateRequest(ctx, unixTimeURLPath, options)
	if err != nil {
		return PathsClientUnixTimeURLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PathsClientUnixTimeURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PathsClientUnixTimeURLResponse{}, client.unixTimeURLHandleError(resp)
	}
	return PathsClientUnixTimeURLResponse{RawResponse: resp}, nil
}

// unixTimeURLCreateRequest creates the UnixTimeURL request.
func (client *PathsClient) unixTimeURLCreateRequest(ctx context.Context, unixTimeURLPath time.Time, options *PathsClientUnixTimeURLOptions) (*policy.Request, error) {
	urlPath := "/paths/int/1460505600/{unixTimeUrlPath}"
	urlPath = strings.ReplaceAll(urlPath, "{unixTimeUrlPath}", url.PathEscape(timeUnix(unixTimeURLPath).String()))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// unixTimeURLHandleError handles the UnixTimeURL error response.
func (client *PathsClient) unixTimeURLHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := Error{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
