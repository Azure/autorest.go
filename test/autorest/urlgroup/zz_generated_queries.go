// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package urlgroup

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"strconv"
	"strings"
	"time"
)

// QueriesOperations contains the methods for the Queries group.
type QueriesOperations interface {
	// ArrayStringCSVEmpty - Get an empty array [] of string using the csv-array format
	ArrayStringCSVEmpty(ctx context.Context, queriesArrayStringCsvEmptyOptions *QueriesArrayStringCSVEmptyOptions) (*http.Response, error)
	// ArrayStringCSVNull - Get a null array of string using the csv-array format
	ArrayStringCSVNull(ctx context.Context, queriesArrayStringCsvNullOptions *QueriesArrayStringCSVNullOptions) (*http.Response, error)
	// ArrayStringCSVValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
	ArrayStringCSVValid(ctx context.Context, queriesArrayStringCsvValidOptions *QueriesArrayStringCSVValidOptions) (*http.Response, error)
	// ArrayStringNoCollectionFormatEmpty - Array query has no defined collection format, should default to csv. Pass in ['hello', 'nihao', 'bonjour'] for the 'arrayQuery' parameter to the service
	ArrayStringNoCollectionFormatEmpty(ctx context.Context, queriesArrayStringNoCollectionFormatEmptyOptions *QueriesArrayStringNoCollectionFormatEmptyOptions) (*http.Response, error)
	// ArrayStringPipesValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the pipes-array format
	ArrayStringPipesValid(ctx context.Context, queriesArrayStringPipesValidOptions *QueriesArrayStringPipesValidOptions) (*http.Response, error)
	// ArrayStringSsvValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the ssv-array format
	ArrayStringSsvValid(ctx context.Context, queriesArrayStringSsvValidOptions *QueriesArrayStringSsvValidOptions) (*http.Response, error)
	// ArrayStringTsvValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the tsv-array format
	ArrayStringTsvValid(ctx context.Context, queriesArrayStringTsvValidOptions *QueriesArrayStringTsvValidOptions) (*http.Response, error)
	// ByteEmpty - Get '' as byte array
	ByteEmpty(ctx context.Context) (*http.Response, error)
	// ByteMultiByte - Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
	ByteMultiByte(ctx context.Context, queriesByteMultiByteOptions *QueriesByteMultiByteOptions) (*http.Response, error)
	// ByteNull - Get null as byte array (no query parameters in uri)
	ByteNull(ctx context.Context, queriesByteNullOptions *QueriesByteNullOptions) (*http.Response, error)
	// DateNull - Get null as date - this should result in no query parameters in uri
	DateNull(ctx context.Context, queriesDateNullOptions *QueriesDateNullOptions) (*http.Response, error)
	// DateTimeNull - Get null as date-time, should result in no query parameters in uri
	DateTimeNull(ctx context.Context, queriesDateTimeNullOptions *QueriesDateTimeNullOptions) (*http.Response, error)
	// DateTimeValid - Get '2012-01-01T01:01:01Z' as date-time
	DateTimeValid(ctx context.Context) (*http.Response, error)
	// DateValid - Get '2012-01-01' as date
	DateValid(ctx context.Context) (*http.Response, error)
	// DoubleDecimalNegative - Get '-9999999.999' numeric value
	DoubleDecimalNegative(ctx context.Context) (*http.Response, error)
	// DoubleDecimalPositive - Get '9999999.999' numeric value
	DoubleDecimalPositive(ctx context.Context) (*http.Response, error)
	// DoubleNull - Get null numeric value (no query parameter)
	DoubleNull(ctx context.Context, queriesDoubleNullOptions *QueriesDoubleNullOptions) (*http.Response, error)
	// EnumNull - Get null (no query parameter in url)
	EnumNull(ctx context.Context, queriesEnumNullOptions *QueriesEnumNullOptions) (*http.Response, error)
	// EnumValid - Get using uri with query parameter 'green color'
	EnumValid(ctx context.Context, queriesEnumValidOptions *QueriesEnumValidOptions) (*http.Response, error)
	// FloatNull - Get null numeric value (no query parameter)
	FloatNull(ctx context.Context, queriesFloatNullOptions *QueriesFloatNullOptions) (*http.Response, error)
	// FloatScientificNegative - Get '-1.034E-20' numeric value
	FloatScientificNegative(ctx context.Context) (*http.Response, error)
	// FloatScientificPositive - Get '1.034E+20' numeric value
	FloatScientificPositive(ctx context.Context) (*http.Response, error)
	// GetBooleanFalse - Get false Boolean value on path
	GetBooleanFalse(ctx context.Context) (*http.Response, error)
	// GetBooleanNull - Get null Boolean value on query (query string should be absent)
	GetBooleanNull(ctx context.Context, queriesGetBooleanNullOptions *QueriesGetBooleanNullOptions) (*http.Response, error)
	// GetBooleanTrue - Get true Boolean value on path
	GetBooleanTrue(ctx context.Context) (*http.Response, error)
	// GetIntNegativeOneMillion - Get '-1000000' integer value
	GetIntNegativeOneMillion(ctx context.Context) (*http.Response, error)
	// GetIntNull - Get null integer value (no query parameter)
	GetIntNull(ctx context.Context, queriesGetIntNullOptions *QueriesGetIntNullOptions) (*http.Response, error)
	// GetIntOneMillion - Get '1000000' integer value
	GetIntOneMillion(ctx context.Context) (*http.Response, error)
	// GetLongNull - Get 'null 64 bit integer value (no query param in uri)
	GetLongNull(ctx context.Context, queriesGetLongNullOptions *QueriesGetLongNullOptions) (*http.Response, error)
	// GetNegativeTenBillion - Get '-10000000000' 64 bit integer value
	GetNegativeTenBillion(ctx context.Context) (*http.Response, error)
	// GetTenBillion - Get '10000000000' 64 bit integer value
	GetTenBillion(ctx context.Context) (*http.Response, error)
	// StringEmpty - Get ''
	StringEmpty(ctx context.Context) (*http.Response, error)
	// StringNull - Get null (no query parameter in url)
	StringNull(ctx context.Context, queriesStringNullOptions *QueriesStringNullOptions) (*http.Response, error)
	// StringURLEncoded - Get 'begin!*'();:@ &=+$,/?#[]end
	StringURLEncoded(ctx context.Context) (*http.Response, error)
	// StringUnicode - Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
	StringUnicode(ctx context.Context) (*http.Response, error)
}

// QueriesClient implements the QueriesOperations interface.
// Don't use this type directly, use NewQueriesClient() instead.
type QueriesClient struct {
	*Client
}

// NewQueriesClient creates a new instance of QueriesClient with the specified values.
func NewQueriesClient(c *Client) QueriesOperations {
	return &QueriesClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *QueriesClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// ArrayStringCSVEmpty - Get an empty array [] of string using the csv-array format
func (client *QueriesClient) ArrayStringCSVEmpty(ctx context.Context, queriesArrayStringCsvEmptyOptions *QueriesArrayStringCSVEmptyOptions) (*http.Response, error) {
	req, err := client.ArrayStringCSVEmptyCreateRequest(ctx, queriesArrayStringCsvEmptyOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringCSVEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringCSVEmptyCreateRequest creates the ArrayStringCSVEmpty request.
func (client *QueriesClient) ArrayStringCSVEmptyCreateRequest(ctx context.Context, queriesArrayStringCsvEmptyOptions *QueriesArrayStringCSVEmptyOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/csv/string/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringCsvEmptyOptions != nil && queriesArrayStringCsvEmptyOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringCsvEmptyOptions.ArrayQuery, ","))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringCSVEmptyHandleError handles the ArrayStringCSVEmpty error response.
func (client *QueriesClient) ArrayStringCSVEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ArrayStringCSVNull - Get a null array of string using the csv-array format
func (client *QueriesClient) ArrayStringCSVNull(ctx context.Context, queriesArrayStringCsvNullOptions *QueriesArrayStringCSVNullOptions) (*http.Response, error) {
	req, err := client.ArrayStringCSVNullCreateRequest(ctx, queriesArrayStringCsvNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringCSVNullHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringCSVNullCreateRequest creates the ArrayStringCSVNull request.
func (client *QueriesClient) ArrayStringCSVNullCreateRequest(ctx context.Context, queriesArrayStringCsvNullOptions *QueriesArrayStringCSVNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/csv/string/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringCsvNullOptions != nil && queriesArrayStringCsvNullOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringCsvNullOptions.ArrayQuery, ","))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringCSVNullHandleError handles the ArrayStringCSVNull error response.
func (client *QueriesClient) ArrayStringCSVNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ArrayStringCSVValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
func (client *QueriesClient) ArrayStringCSVValid(ctx context.Context, queriesArrayStringCsvValidOptions *QueriesArrayStringCSVValidOptions) (*http.Response, error) {
	req, err := client.ArrayStringCSVValidCreateRequest(ctx, queriesArrayStringCsvValidOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringCSVValidHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringCSVValidCreateRequest creates the ArrayStringCSVValid request.
func (client *QueriesClient) ArrayStringCSVValidCreateRequest(ctx context.Context, queriesArrayStringCsvValidOptions *QueriesArrayStringCSVValidOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/csv/string/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringCsvValidOptions != nil && queriesArrayStringCsvValidOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringCsvValidOptions.ArrayQuery, ","))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringCSVValidHandleError handles the ArrayStringCSVValid error response.
func (client *QueriesClient) ArrayStringCSVValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ArrayStringNoCollectionFormatEmpty - Array query has no defined collection format, should default to csv. Pass in ['hello', 'nihao', 'bonjour'] for the 'arrayQuery' parameter to the service
func (client *QueriesClient) ArrayStringNoCollectionFormatEmpty(ctx context.Context, queriesArrayStringNoCollectionFormatEmptyOptions *QueriesArrayStringNoCollectionFormatEmptyOptions) (*http.Response, error) {
	req, err := client.ArrayStringNoCollectionFormatEmptyCreateRequest(ctx, queriesArrayStringNoCollectionFormatEmptyOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringNoCollectionFormatEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringNoCollectionFormatEmptyCreateRequest creates the ArrayStringNoCollectionFormatEmpty request.
func (client *QueriesClient) ArrayStringNoCollectionFormatEmptyCreateRequest(ctx context.Context, queriesArrayStringNoCollectionFormatEmptyOptions *QueriesArrayStringNoCollectionFormatEmptyOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/none/string/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringNoCollectionFormatEmptyOptions != nil && queriesArrayStringNoCollectionFormatEmptyOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringNoCollectionFormatEmptyOptions.ArrayQuery, ","))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringNoCollectionFormatEmptyHandleError handles the ArrayStringNoCollectionFormatEmpty error response.
func (client *QueriesClient) ArrayStringNoCollectionFormatEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ArrayStringPipesValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the pipes-array format
func (client *QueriesClient) ArrayStringPipesValid(ctx context.Context, queriesArrayStringPipesValidOptions *QueriesArrayStringPipesValidOptions) (*http.Response, error) {
	req, err := client.ArrayStringPipesValidCreateRequest(ctx, queriesArrayStringPipesValidOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringPipesValidHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringPipesValidCreateRequest creates the ArrayStringPipesValid request.
func (client *QueriesClient) ArrayStringPipesValidCreateRequest(ctx context.Context, queriesArrayStringPipesValidOptions *QueriesArrayStringPipesValidOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/pipes/string/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringPipesValidOptions != nil && queriesArrayStringPipesValidOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringPipesValidOptions.ArrayQuery, "|"))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringPipesValidHandleError handles the ArrayStringPipesValid error response.
func (client *QueriesClient) ArrayStringPipesValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ArrayStringSsvValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the ssv-array format
func (client *QueriesClient) ArrayStringSsvValid(ctx context.Context, queriesArrayStringSsvValidOptions *QueriesArrayStringSsvValidOptions) (*http.Response, error) {
	req, err := client.ArrayStringSsvValidCreateRequest(ctx, queriesArrayStringSsvValidOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringSsvValidHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringSsvValidCreateRequest creates the ArrayStringSsvValid request.
func (client *QueriesClient) ArrayStringSsvValidCreateRequest(ctx context.Context, queriesArrayStringSsvValidOptions *QueriesArrayStringSsvValidOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/ssv/string/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringSsvValidOptions != nil && queriesArrayStringSsvValidOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringSsvValidOptions.ArrayQuery, " "))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringSsvValidHandleError handles the ArrayStringSsvValid error response.
func (client *QueriesClient) ArrayStringSsvValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ArrayStringTsvValid - Get an array of string ['ArrayQuery1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the tsv-array format
func (client *QueriesClient) ArrayStringTsvValid(ctx context.Context, queriesArrayStringTsvValidOptions *QueriesArrayStringTsvValidOptions) (*http.Response, error) {
	req, err := client.ArrayStringTsvValidCreateRequest(ctx, queriesArrayStringTsvValidOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayStringTsvValidHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayStringTsvValidCreateRequest creates the ArrayStringTsvValid request.
func (client *QueriesClient) ArrayStringTsvValidCreateRequest(ctx context.Context, queriesArrayStringTsvValidOptions *QueriesArrayStringTsvValidOptions) (*azcore.Request, error) {
	urlPath := "/queries/array/tsv/string/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesArrayStringTsvValidOptions != nil && queriesArrayStringTsvValidOptions.ArrayQuery != nil {
		query.Set("arrayQuery", strings.Join(*queriesArrayStringTsvValidOptions.ArrayQuery, "\t"))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ArrayStringTsvValidHandleError handles the ArrayStringTsvValid error response.
func (client *QueriesClient) ArrayStringTsvValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ByteEmpty - Get '' as byte array
func (client *QueriesClient) ByteEmpty(ctx context.Context) (*http.Response, error) {
	req, err := client.ByteEmptyCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ByteEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// ByteEmptyCreateRequest creates the ByteEmpty request.
func (client *QueriesClient) ByteEmptyCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/byte/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("byteQuery", "")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ByteEmptyHandleError handles the ByteEmpty error response.
func (client *QueriesClient) ByteEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ByteMultiByte - Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
func (client *QueriesClient) ByteMultiByte(ctx context.Context, queriesByteMultiByteOptions *QueriesByteMultiByteOptions) (*http.Response, error) {
	req, err := client.ByteMultiByteCreateRequest(ctx, queriesByteMultiByteOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ByteMultiByteHandleError(resp)
	}
	return resp.Response, nil
}

// ByteMultiByteCreateRequest creates the ByteMultiByte request.
func (client *QueriesClient) ByteMultiByteCreateRequest(ctx context.Context, queriesByteMultiByteOptions *QueriesByteMultiByteOptions) (*azcore.Request, error) {
	urlPath := "/queries/byte/multibyte"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesByteMultiByteOptions != nil && queriesByteMultiByteOptions.ByteQuery != nil {
		query.Set("byteQuery", base64.StdEncoding.EncodeToString(*queriesByteMultiByteOptions.ByteQuery))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ByteMultiByteHandleError handles the ByteMultiByte error response.
func (client *QueriesClient) ByteMultiByteHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ByteNull - Get null as byte array (no query parameters in uri)
func (client *QueriesClient) ByteNull(ctx context.Context, queriesByteNullOptions *QueriesByteNullOptions) (*http.Response, error) {
	req, err := client.ByteNullCreateRequest(ctx, queriesByteNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ByteNullHandleError(resp)
	}
	return resp.Response, nil
}

// ByteNullCreateRequest creates the ByteNull request.
func (client *QueriesClient) ByteNullCreateRequest(ctx context.Context, queriesByteNullOptions *QueriesByteNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/byte/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesByteNullOptions != nil && queriesByteNullOptions.ByteQuery != nil {
		query.Set("byteQuery", base64.StdEncoding.EncodeToString(*queriesByteNullOptions.ByteQuery))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// ByteNullHandleError handles the ByteNull error response.
func (client *QueriesClient) ByteNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateNull - Get null as date - this should result in no query parameters in uri
func (client *QueriesClient) DateNull(ctx context.Context, queriesDateNullOptions *QueriesDateNullOptions) (*http.Response, error) {
	req, err := client.DateNullCreateRequest(ctx, queriesDateNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DateNullHandleError(resp)
	}
	return resp.Response, nil
}

// DateNullCreateRequest creates the DateNull request.
func (client *QueriesClient) DateNullCreateRequest(ctx context.Context, queriesDateNullOptions *QueriesDateNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/date/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesDateNullOptions != nil && queriesDateNullOptions.DateQuery != nil {
		query.Set("dateQuery", queriesDateNullOptions.DateQuery.Format("2006-01-02"))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DateNullHandleError handles the DateNull error response.
func (client *QueriesClient) DateNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateTimeNull - Get null as date-time, should result in no query parameters in uri
func (client *QueriesClient) DateTimeNull(ctx context.Context, queriesDateTimeNullOptions *QueriesDateTimeNullOptions) (*http.Response, error) {
	req, err := client.DateTimeNullCreateRequest(ctx, queriesDateTimeNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DateTimeNullHandleError(resp)
	}
	return resp.Response, nil
}

// DateTimeNullCreateRequest creates the DateTimeNull request.
func (client *QueriesClient) DateTimeNullCreateRequest(ctx context.Context, queriesDateTimeNullOptions *QueriesDateTimeNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/datetime/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesDateTimeNullOptions != nil && queriesDateTimeNullOptions.DateTimeQuery != nil {
		query.Set("dateTimeQuery", queriesDateTimeNullOptions.DateTimeQuery.Format(time.RFC3339Nano))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DateTimeNullHandleError handles the DateTimeNull error response.
func (client *QueriesClient) DateTimeNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateTimeValid - Get '2012-01-01T01:01:01Z' as date-time
func (client *QueriesClient) DateTimeValid(ctx context.Context) (*http.Response, error) {
	req, err := client.DateTimeValidCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DateTimeValidHandleError(resp)
	}
	return resp.Response, nil
}

// DateTimeValidCreateRequest creates the DateTimeValid request.
func (client *QueriesClient) DateTimeValidCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/datetime/2012-01-01T01%3A01%3A01Z"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("dateTimeQuery", "2012-01-01T01:01:01Z")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DateTimeValidHandleError handles the DateTimeValid error response.
func (client *QueriesClient) DateTimeValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateValid - Get '2012-01-01' as date
func (client *QueriesClient) DateValid(ctx context.Context) (*http.Response, error) {
	req, err := client.DateValidCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DateValidHandleError(resp)
	}
	return resp.Response, nil
}

// DateValidCreateRequest creates the DateValid request.
func (client *QueriesClient) DateValidCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/date/2012-01-01"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("dateQuery", "2012-01-01")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DateValidHandleError handles the DateValid error response.
func (client *QueriesClient) DateValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DoubleDecimalNegative - Get '-9999999.999' numeric value
func (client *QueriesClient) DoubleDecimalNegative(ctx context.Context) (*http.Response, error) {
	req, err := client.DoubleDecimalNegativeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DoubleDecimalNegativeHandleError(resp)
	}
	return resp.Response, nil
}

// DoubleDecimalNegativeCreateRequest creates the DoubleDecimalNegative request.
func (client *QueriesClient) DoubleDecimalNegativeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/double/-9999999.999"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("doubleQuery", "-9999999.999")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DoubleDecimalNegativeHandleError handles the DoubleDecimalNegative error response.
func (client *QueriesClient) DoubleDecimalNegativeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DoubleDecimalPositive - Get '9999999.999' numeric value
func (client *QueriesClient) DoubleDecimalPositive(ctx context.Context) (*http.Response, error) {
	req, err := client.DoubleDecimalPositiveCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DoubleDecimalPositiveHandleError(resp)
	}
	return resp.Response, nil
}

// DoubleDecimalPositiveCreateRequest creates the DoubleDecimalPositive request.
func (client *QueriesClient) DoubleDecimalPositiveCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/double/9999999.999"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("doubleQuery", "9999999.999")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DoubleDecimalPositiveHandleError handles the DoubleDecimalPositive error response.
func (client *QueriesClient) DoubleDecimalPositiveHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DoubleNull - Get null numeric value (no query parameter)
func (client *QueriesClient) DoubleNull(ctx context.Context, queriesDoubleNullOptions *QueriesDoubleNullOptions) (*http.Response, error) {
	req, err := client.DoubleNullCreateRequest(ctx, queriesDoubleNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DoubleNullHandleError(resp)
	}
	return resp.Response, nil
}

// DoubleNullCreateRequest creates the DoubleNull request.
func (client *QueriesClient) DoubleNullCreateRequest(ctx context.Context, queriesDoubleNullOptions *QueriesDoubleNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/double/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesDoubleNullOptions != nil && queriesDoubleNullOptions.DoubleQuery != nil {
		query.Set("doubleQuery", strconv.FormatFloat(*queriesDoubleNullOptions.DoubleQuery, 'f', -1, 64))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// DoubleNullHandleError handles the DoubleNull error response.
func (client *QueriesClient) DoubleNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// EnumNull - Get null (no query parameter in url)
func (client *QueriesClient) EnumNull(ctx context.Context, queriesEnumNullOptions *QueriesEnumNullOptions) (*http.Response, error) {
	req, err := client.EnumNullCreateRequest(ctx, queriesEnumNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.EnumNullHandleError(resp)
	}
	return resp.Response, nil
}

// EnumNullCreateRequest creates the EnumNull request.
func (client *QueriesClient) EnumNullCreateRequest(ctx context.Context, queriesEnumNullOptions *QueriesEnumNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/enum/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesEnumNullOptions != nil && queriesEnumNullOptions.EnumQuery != nil {
		query.Set("enumQuery", string(*queriesEnumNullOptions.EnumQuery))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// EnumNullHandleError handles the EnumNull error response.
func (client *QueriesClient) EnumNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// EnumValid - Get using uri with query parameter 'green color'
func (client *QueriesClient) EnumValid(ctx context.Context, queriesEnumValidOptions *QueriesEnumValidOptions) (*http.Response, error) {
	req, err := client.EnumValidCreateRequest(ctx, queriesEnumValidOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.EnumValidHandleError(resp)
	}
	return resp.Response, nil
}

// EnumValidCreateRequest creates the EnumValid request.
func (client *QueriesClient) EnumValidCreateRequest(ctx context.Context, queriesEnumValidOptions *QueriesEnumValidOptions) (*azcore.Request, error) {
	urlPath := "/queries/enum/green%20color"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesEnumValidOptions != nil && queriesEnumValidOptions.EnumQuery != nil {
		query.Set("enumQuery", string(*queriesEnumValidOptions.EnumQuery))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// EnumValidHandleError handles the EnumValid error response.
func (client *QueriesClient) EnumValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// FloatNull - Get null numeric value (no query parameter)
func (client *QueriesClient) FloatNull(ctx context.Context, queriesFloatNullOptions *QueriesFloatNullOptions) (*http.Response, error) {
	req, err := client.FloatNullCreateRequest(ctx, queriesFloatNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.FloatNullHandleError(resp)
	}
	return resp.Response, nil
}

// FloatNullCreateRequest creates the FloatNull request.
func (client *QueriesClient) FloatNullCreateRequest(ctx context.Context, queriesFloatNullOptions *QueriesFloatNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/float/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesFloatNullOptions != nil && queriesFloatNullOptions.FloatQuery != nil {
		query.Set("floatQuery", strconv.FormatFloat(float64(*queriesFloatNullOptions.FloatQuery), 'f', -1, 32))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// FloatNullHandleError handles the FloatNull error response.
func (client *QueriesClient) FloatNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// FloatScientificNegative - Get '-1.034E-20' numeric value
func (client *QueriesClient) FloatScientificNegative(ctx context.Context) (*http.Response, error) {
	req, err := client.FloatScientificNegativeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.FloatScientificNegativeHandleError(resp)
	}
	return resp.Response, nil
}

// FloatScientificNegativeCreateRequest creates the FloatScientificNegative request.
func (client *QueriesClient) FloatScientificNegativeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/float/-1.034E-20"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("floatQuery", "-1.034e-20")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// FloatScientificNegativeHandleError handles the FloatScientificNegative error response.
func (client *QueriesClient) FloatScientificNegativeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// FloatScientificPositive - Get '1.034E+20' numeric value
func (client *QueriesClient) FloatScientificPositive(ctx context.Context) (*http.Response, error) {
	req, err := client.FloatScientificPositiveCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.FloatScientificPositiveHandleError(resp)
	}
	return resp.Response, nil
}

// FloatScientificPositiveCreateRequest creates the FloatScientificPositive request.
func (client *QueriesClient) FloatScientificPositiveCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/float/1.034E+20"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("floatQuery", "103400000000000000000")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// FloatScientificPositiveHandleError handles the FloatScientificPositive error response.
func (client *QueriesClient) FloatScientificPositiveHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetBooleanFalse - Get false Boolean value on path
func (client *QueriesClient) GetBooleanFalse(ctx context.Context) (*http.Response, error) {
	req, err := client.GetBooleanFalseCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanFalseHandleError(resp)
	}
	return resp.Response, nil
}

// GetBooleanFalseCreateRequest creates the GetBooleanFalse request.
func (client *QueriesClient) GetBooleanFalseCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/bool/false"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("boolQuery", "false")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBooleanFalseHandleError handles the GetBooleanFalse error response.
func (client *QueriesClient) GetBooleanFalseHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetBooleanNull - Get null Boolean value on query (query string should be absent)
func (client *QueriesClient) GetBooleanNull(ctx context.Context, queriesGetBooleanNullOptions *QueriesGetBooleanNullOptions) (*http.Response, error) {
	req, err := client.GetBooleanNullCreateRequest(ctx, queriesGetBooleanNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanNullHandleError(resp)
	}
	return resp.Response, nil
}

// GetBooleanNullCreateRequest creates the GetBooleanNull request.
func (client *QueriesClient) GetBooleanNullCreateRequest(ctx context.Context, queriesGetBooleanNullOptions *QueriesGetBooleanNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/bool/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesGetBooleanNullOptions != nil && queriesGetBooleanNullOptions.BoolQuery != nil {
		query.Set("boolQuery", strconv.FormatBool(*queriesGetBooleanNullOptions.BoolQuery))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBooleanNullHandleError handles the GetBooleanNull error response.
func (client *QueriesClient) GetBooleanNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetBooleanTrue - Get true Boolean value on path
func (client *QueriesClient) GetBooleanTrue(ctx context.Context) (*http.Response, error) {
	req, err := client.GetBooleanTrueCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanTrueHandleError(resp)
	}
	return resp.Response, nil
}

// GetBooleanTrueCreateRequest creates the GetBooleanTrue request.
func (client *QueriesClient) GetBooleanTrueCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/bool/true"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("boolQuery", "true")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBooleanTrueHandleError handles the GetBooleanTrue error response.
func (client *QueriesClient) GetBooleanTrueHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetIntNegativeOneMillion - Get '-1000000' integer value
func (client *QueriesClient) GetIntNegativeOneMillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetIntNegativeOneMillionCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntNegativeOneMillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetIntNegativeOneMillionCreateRequest creates the GetIntNegativeOneMillion request.
func (client *QueriesClient) GetIntNegativeOneMillionCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/int/-1000000"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("intQuery", "-1000000")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetIntNegativeOneMillionHandleError handles the GetIntNegativeOneMillion error response.
func (client *QueriesClient) GetIntNegativeOneMillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetIntNull - Get null integer value (no query parameter)
func (client *QueriesClient) GetIntNull(ctx context.Context, queriesGetIntNullOptions *QueriesGetIntNullOptions) (*http.Response, error) {
	req, err := client.GetIntNullCreateRequest(ctx, queriesGetIntNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntNullHandleError(resp)
	}
	return resp.Response, nil
}

// GetIntNullCreateRequest creates the GetIntNull request.
func (client *QueriesClient) GetIntNullCreateRequest(ctx context.Context, queriesGetIntNullOptions *QueriesGetIntNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/int/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesGetIntNullOptions != nil && queriesGetIntNullOptions.IntQuery != nil {
		query.Set("intQuery", strconv.FormatInt(int64(*queriesGetIntNullOptions.IntQuery), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetIntNullHandleError handles the GetIntNull error response.
func (client *QueriesClient) GetIntNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetIntOneMillion - Get '1000000' integer value
func (client *QueriesClient) GetIntOneMillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetIntOneMillionCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntOneMillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetIntOneMillionCreateRequest creates the GetIntOneMillion request.
func (client *QueriesClient) GetIntOneMillionCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/int/1000000"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("intQuery", "1000000")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetIntOneMillionHandleError handles the GetIntOneMillion error response.
func (client *QueriesClient) GetIntOneMillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLongNull - Get 'null 64 bit integer value (no query param in uri)
func (client *QueriesClient) GetLongNull(ctx context.Context, queriesGetLongNullOptions *QueriesGetLongNullOptions) (*http.Response, error) {
	req, err := client.GetLongNullCreateRequest(ctx, queriesGetLongNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetLongNullHandleError(resp)
	}
	return resp.Response, nil
}

// GetLongNullCreateRequest creates the GetLongNull request.
func (client *QueriesClient) GetLongNullCreateRequest(ctx context.Context, queriesGetLongNullOptions *QueriesGetLongNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/long/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesGetLongNullOptions != nil && queriesGetLongNullOptions.LongQuery != nil {
		query.Set("longQuery", strconv.FormatInt(*queriesGetLongNullOptions.LongQuery, 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLongNullHandleError handles the GetLongNull error response.
func (client *QueriesClient) GetLongNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetNegativeTenBillion - Get '-10000000000' 64 bit integer value
func (client *QueriesClient) GetNegativeTenBillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetNegativeTenBillionCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNegativeTenBillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetNegativeTenBillionCreateRequest creates the GetNegativeTenBillion request.
func (client *QueriesClient) GetNegativeTenBillionCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/long/-10000000000"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("longQuery", "-10000000000")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNegativeTenBillionHandleError handles the GetNegativeTenBillion error response.
func (client *QueriesClient) GetNegativeTenBillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetTenBillion - Get '10000000000' 64 bit integer value
func (client *QueriesClient) GetTenBillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetTenBillionCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetTenBillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetTenBillionCreateRequest creates the GetTenBillion request.
func (client *QueriesClient) GetTenBillionCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/long/10000000000"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("longQuery", "10000000000")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetTenBillionHandleError handles the GetTenBillion error response.
func (client *QueriesClient) GetTenBillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringEmpty - Get ''
func (client *QueriesClient) StringEmpty(ctx context.Context) (*http.Response, error) {
	req, err := client.StringEmptyCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// StringEmptyCreateRequest creates the StringEmpty request.
func (client *QueriesClient) StringEmptyCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/string/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("stringQuery", "")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// StringEmptyHandleError handles the StringEmpty error response.
func (client *QueriesClient) StringEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringNull - Get null (no query parameter in url)
func (client *QueriesClient) StringNull(ctx context.Context, queriesStringNullOptions *QueriesStringNullOptions) (*http.Response, error) {
	req, err := client.StringNullCreateRequest(ctx, queriesStringNullOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringNullHandleError(resp)
	}
	return resp.Response, nil
}

// StringNullCreateRequest creates the StringNull request.
func (client *QueriesClient) StringNullCreateRequest(ctx context.Context, queriesStringNullOptions *QueriesStringNullOptions) (*azcore.Request, error) {
	urlPath := "/queries/string/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	if queriesStringNullOptions != nil && queriesStringNullOptions.StringQuery != nil {
		query.Set("stringQuery", *queriesStringNullOptions.StringQuery)
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// StringNullHandleError handles the StringNull error response.
func (client *QueriesClient) StringNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringURLEncoded - Get 'begin!*'();:@ &=+$,/?#[]end
func (client *QueriesClient) StringURLEncoded(ctx context.Context) (*http.Response, error) {
	req, err := client.StringURLEncodedCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringURLEncodedHandleError(resp)
	}
	return resp.Response, nil
}

// StringURLEncodedCreateRequest creates the StringURLEncoded request.
func (client *QueriesClient) StringURLEncodedCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("stringQuery", "begin!*'();:@ &=+$,/?#[]end")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// StringURLEncodedHandleError handles the StringURLEncoded error response.
func (client *QueriesClient) StringURLEncodedHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringUnicode - Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
func (client *QueriesClient) StringUnicode(ctx context.Context) (*http.Response, error) {
	req, err := client.StringUnicodeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringUnicodeHandleError(resp)
	}
	return resp.Response, nil
}

// StringUnicodeCreateRequest creates the StringUnicode request.
func (client *QueriesClient) StringUnicodeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/queries/string/unicode/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("stringQuery", "啊齄丂狛狜隣郎隣兀﨩")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// StringUnicodeHandleError handles the StringUnicode error response.
func (client *QueriesClient) StringUnicodeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
