// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"strconv"
)

// LrOSOperations contains the methods for the LrOS group.
type LrOSOperations interface {
	// BeginDelete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginDelete202NoRetry204(ctx context.Context) (LrOSdelete202NoRetry204Poller, error)
	// BeginDelete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginDelete202Retry200(ctx context.Context) (LrOSdelete202Retry200Poller, error)
	// BeginDelete204Succeeded - Long running delete succeeds and returns right away
	BeginDelete204Succeeded(ctx context.Context) (LrOSdelete204SucceededPoller, error)
	// BeginDeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
	BeginDeleteAsyncNoHeaderInRetry(ctx context.Context) (LrOSdeleteAsyncNoHeaderInRetryPoller, error)
	// BeginDeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncNoRetrySucceeded(ctx context.Context) (LrOSdeleteAsyncNoRetrySucceededPoller, error)
	// BeginDeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRetryFailed(ctx context.Context) (LrOSdeleteAsyncRetryFailedPoller, error)
	// BeginDeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRetrySucceeded(ctx context.Context) (LrOSdeleteAsyncRetrySucceededPoller, error)
	// BeginDeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRetrycanceled(ctx context.Context) (LrOSdeleteAsyncRetrycanceledPoller, error)
	// BeginDeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
	BeginDeleteNoHeaderInRetry(ctx context.Context) (LrOSdeleteNoHeaderInRetryPoller, error)
	// BeginDeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context) (LrOSdeleteProvisioning202Accepted200SucceededPoller, error)
	// BeginDeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
	BeginDeleteProvisioning202DeletingFailed200(ctx context.Context) (LrOSdeleteProvisioning202DeletingFailed200Poller, error)
	// BeginDeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
	BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context) (LrOSdeleteProvisioning202Deletingcanceled200Poller, error)
	// BeginPost200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
	BeginPost200WithPayload(ctx context.Context) (LrOSpost200WithPayloadPoller, error)
	// BeginPost202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
	BeginPost202NoRetry204(ctx context.Context, options *LrOSPost202NoRetry204Options) (LrOSpost202NoRetry204Poller, error)
	// BeginPost202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
	BeginPost202Retry200(ctx context.Context, options *LrOSPost202Retry200Options) (LrOSpost202Retry200Poller, error)
	// BeginPostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPostAsyncNoRetrySucceededOptions) (LrOSpostAsyncNoRetrySucceededPoller, error)
	// BeginPostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncRetryFailed(ctx context.Context, options *LrOSPostAsyncRetryFailedOptions) (LrOSpostAsyncRetryFailedPoller, error)
	// BeginPostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncRetrySucceeded(ctx context.Context, options *LrOSPostAsyncRetrySucceededOptions) (LrOSpostAsyncRetrySucceededPoller, error)
	// BeginPostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncRetrycanceled(ctx context.Context, options *LrOSPostAsyncRetrycanceledOptions) (LrOSpostAsyncRetrycanceledPoller, error)
	// BeginPostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
	BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context) (LrOSpostDoubleHeadersFinalAzureHeaderGetPoller, error)
	// BeginPostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support initial Autorest behavior.
	BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context) (LrOSpostDoubleHeadersFinalAzureHeaderGetDefaultPoller, error)
	// BeginPostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
	BeginPostDoubleHeadersFinalLocationGet(ctx context.Context) (LrOSpostDoubleHeadersFinalLocationGetPoller, error)
	// BeginPut200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
	BeginPut200Acceptedcanceled200(ctx context.Context, options *LrOSPut200Acceptedcanceled200Options) (LrOSput200Acceptedcanceled200Poller, error)
	// BeginPut200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
	BeginPut200Succeeded(ctx context.Context, options *LrOSPut200SucceededOptions) (LrOSput200SucceededPoller, error)
	// BeginPut200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
	BeginPut200SucceededNoState(ctx context.Context, options *LrOSPut200SucceededNoStateOptions) (LrOSput200SucceededNoStatePoller, error)
	// BeginPut200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginPut200UpdatingSucceeded204(ctx context.Context, options *LrOSPut200UpdatingSucceeded204Options) (LrOSput200UpdatingSucceeded204Poller, error)
	// BeginPut201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
	BeginPut201CreatingFailed200(ctx context.Context, options *LrOSPut201CreatingFailed200Options) (LrOSput201CreatingFailed200Poller, error)
	// BeginPut201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	BeginPut201CreatingSucceeded200(ctx context.Context, options *LrOSPut201CreatingSucceeded200Options) (LrOSput201CreatingSucceeded200Poller, error)
	// BeginPut202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
	BeginPut202Retry200(ctx context.Context, options *LrOSPut202Retry200Options) (LrOSput202Retry200Poller, error)
	// BeginPutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
	BeginPutAsyncNoHeaderInRetry(ctx context.Context, options *LrOSPutAsyncNoHeaderInRetryOptions) (LrOSputAsyncNoHeaderInRetryPoller, error)
	// BeginPutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPutAsyncNoRetrySucceededOptions) (LrOSputAsyncNoRetrySucceededPoller, error)
	// BeginPutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncNoRetrycanceled(ctx context.Context, options *LrOSPutAsyncNoRetrycanceledOptions) (LrOSputAsyncNoRetrycanceledPoller, error)
	// BeginPutAsyncNonResource - Long running put request with non resource.
	BeginPutAsyncNonResource(ctx context.Context, options *LrOSPutAsyncNonResourceOptions) (LrOSputAsyncNonResourcePoller, error)
	// BeginPutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncRetryFailed(ctx context.Context, options *LrOSPutAsyncRetryFailedOptions) (LrOSputAsyncRetryFailedPoller, error)
	// BeginPutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncRetrySucceeded(ctx context.Context, options *LrOSPutAsyncRetrySucceededOptions) (LrOSputAsyncRetrySucceededPoller, error)
	// BeginPutAsyncSubResource - Long running put request with sub resource.
	BeginPutAsyncSubResource(ctx context.Context, options *LrOSPutAsyncSubResourceOptions) (LrOSputAsyncSubResourcePoller, error)
	// BeginPutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
	BeginPutNoHeaderInRetry(ctx context.Context, options *LrOSPutNoHeaderInRetryOptions) (LrOSputNoHeaderInRetryPoller, error)
	// BeginPutNonResource - Long running put request with non resource.
	BeginPutNonResource(ctx context.Context, options *LrOSPutNonResourceOptions) (LrOSputNonResourcePoller, error)
	// BeginPutSubResource - Long running put request with sub resource.
	BeginPutSubResource(ctx context.Context, options *LrOSPutSubResourceOptions) (LrOSputSubResourcePoller, error)
}

// lrOSOperations implements the LrOSOperations interface.
type lrOSOperations struct {
	*Client
}

// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) BeginDelete202NoRetry204(ctx context.Context) (LrOSdelete202NoRetry204Poller, error) {
	return &lrOSdelete202NoRetry204Poller{
		client: client,
	}, nil
}

// delete202NoRetry204CreateRequest creates the Delete202NoRetry204 request.
func (client *lrOSOperations) delete202NoRetry204CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/202/noretry/204"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete202NoRetry204HandleResponse handles the Delete202NoRetry204 response.
func (client *lrOSOperations) delete202NoRetry204HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) BeginDelete202Retry200(ctx context.Context) (LrOSdelete202Retry200Poller, error) {
	return &lrOSdelete202Retry200Poller{
		client: client,
	}, nil
}

// delete202Retry200CreateRequest creates the Delete202Retry200 request.
func (client *lrOSOperations) delete202Retry200CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/202/retry/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete202Retry200HandleResponse handles the Delete202Retry200 response.
func (client *lrOSOperations) delete202Retry200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Delete204Succeeded - Long running delete succeeds and returns right away
func (client *lrOSOperations) BeginDelete204Succeeded(ctx context.Context) (LrOSdelete204SucceededPoller, error) {
	return &lrOSdelete204SucceededPoller{
		client: client,
	}, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *lrOSOperations) delete204SucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/204/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete204SucceededHandleResponse handles the Delete204Succeeded response.
func (client *lrOSOperations) delete204SucceededHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, newCloudError(resp)
	}
	return resp.Response, nil
}

// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
func (client *lrOSOperations) BeginDeleteAsyncNoHeaderInRetry(ctx context.Context) (LrOSdeleteAsyncNoHeaderInRetryPoller, error) {
	return &lrOSdeleteAsyncNoHeaderInRetryPoller{
		client: client,
	}, nil
}

// deleteAsyncNoHeaderInRetryCreateRequest creates the DeleteAsyncNoHeaderInRetry request.
func (client *lrOSOperations) deleteAsyncNoHeaderInRetryCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noheader/202/204"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncNoHeaderInRetryHandleResponse handles the DeleteAsyncNoHeaderInRetry response.
func (client *lrOSOperations) deleteAsyncNoHeaderInRetryHandleResponse(resp *azcore.Response) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSDeleteAsyncNoHeaderInRetryResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	return &result, nil
}

// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginDeleteAsyncNoRetrySucceeded(ctx context.Context) (LrOSdeleteAsyncNoRetrySucceededPoller, error) {
	return &lrOSdeleteAsyncNoRetrySucceededPoller{
		client: client,
	}, nil
}

// deleteAsyncNoRetrySucceededCreateRequest creates the DeleteAsyncNoRetrySucceeded request.
func (client *lrOSOperations) deleteAsyncNoRetrySucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noretry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncNoRetrySucceededHandleResponse handles the DeleteAsyncNoRetrySucceeded response.
func (client *lrOSOperations) deleteAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (*LrOSDeleteAsyncNoRetrySucceededResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSDeleteAsyncNoRetrySucceededResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginDeleteAsyncRetryFailed(ctx context.Context) (LrOSdeleteAsyncRetryFailedPoller, error) {
	return &lrOSdeleteAsyncRetryFailedPoller{
		client: client,
	}, nil
}

// deleteAsyncRetryFailedCreateRequest creates the DeleteAsyncRetryFailed request.
func (client *lrOSOperations) deleteAsyncRetryFailedCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRetryFailedHandleResponse handles the DeleteAsyncRetryFailed response.
func (client *lrOSOperations) deleteAsyncRetryFailedHandleResponse(resp *azcore.Response) (*LrOSDeleteAsyncRetryFailedResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSDeleteAsyncRetryFailedResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginDeleteAsyncRetrySucceeded(ctx context.Context) (LrOSdeleteAsyncRetrySucceededPoller, error) {
	return &lrOSdeleteAsyncRetrySucceededPoller{
		client: client,
	}, nil
}

// deleteAsyncRetrySucceededCreateRequest creates the DeleteAsyncRetrySucceeded request.
func (client *lrOSOperations) deleteAsyncRetrySucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRetrySucceededHandleResponse handles the DeleteAsyncRetrySucceeded response.
func (client *lrOSOperations) deleteAsyncRetrySucceededHandleResponse(resp *azcore.Response) (*LrOSDeleteAsyncRetrySucceededResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSDeleteAsyncRetrySucceededResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginDeleteAsyncRetrycanceled(ctx context.Context) (LrOSdeleteAsyncRetrycanceledPoller, error) {
	return &lrOSdeleteAsyncRetrycanceledPoller{
		client: client,
	}, nil
}

// deleteAsyncRetrycanceledCreateRequest creates the DeleteAsyncRetrycanceled request.
func (client *lrOSOperations) deleteAsyncRetrycanceledCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRetrycanceledHandleResponse handles the DeleteAsyncRetrycanceled response.
func (client *lrOSOperations) deleteAsyncRetrycanceledHandleResponse(resp *azcore.Response) (*LrOSDeleteAsyncRetrycanceledResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSDeleteAsyncRetrycanceledResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
func (client *lrOSOperations) BeginDeleteNoHeaderInRetry(ctx context.Context) (LrOSdeleteNoHeaderInRetryPoller, error) {
	return &lrOSdeleteNoHeaderInRetryPoller{
		client: client,
	}, nil
}

// deleteNoHeaderInRetryCreateRequest creates the DeleteNoHeaderInRetry request.
func (client *lrOSOperations) deleteNoHeaderInRetryCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/noheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteNoHeaderInRetryHandleResponse handles the DeleteNoHeaderInRetry response.
func (client *lrOSOperations) deleteNoHeaderInRetryHandleResponse(resp *azcore.Response) (*LrOSDeleteNoHeaderInRetryResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSDeleteNoHeaderInRetryResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	return &result, nil
}

// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) BeginDeleteProvisioning202Accepted200Succeeded(ctx context.Context) (LrOSdeleteProvisioning202Accepted200SucceededPoller, error) {
	return &lrOSdeleteProvisioning202Accepted200SucceededPoller{
		client: client,
	}, nil
}

// deleteProvisioning202Accepted200SucceededCreateRequest creates the DeleteProvisioning202Accepted200Succeeded request.
func (client *lrOSOperations) deleteProvisioning202Accepted200SucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/accepted/200/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteProvisioning202Accepted200SucceededHandleResponse handles the DeleteProvisioning202Accepted200Succeeded response.
func (client *lrOSOperations) deleteProvisioning202Accepted200SucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
func (client *lrOSOperations) BeginDeleteProvisioning202DeletingFailed200(ctx context.Context) (LrOSdeleteProvisioning202DeletingFailed200Poller, error) {
	return &lrOSdeleteProvisioning202DeletingFailed200Poller{
		client: client,
	}, nil
}

// deleteProvisioning202DeletingFailed200CreateRequest creates the DeleteProvisioning202DeletingFailed200 request.
func (client *lrOSOperations) deleteProvisioning202DeletingFailed200CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteProvisioning202DeletingFailed200HandleResponse handles the DeleteProvisioning202DeletingFailed200 response.
func (client *lrOSOperations) deleteProvisioning202DeletingFailed200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
func (client *lrOSOperations) BeginDeleteProvisioning202Deletingcanceled200(ctx context.Context) (LrOSdeleteProvisioning202Deletingcanceled200Poller, error) {
	return &lrOSdeleteProvisioning202Deletingcanceled200Poller{
		client: client,
	}, nil
}

// deleteProvisioning202Deletingcanceled200CreateRequest creates the DeleteProvisioning202Deletingcanceled200 request.
func (client *lrOSOperations) deleteProvisioning202Deletingcanceled200CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteProvisioning202Deletingcanceled200HandleResponse handles the DeleteProvisioning202Deletingcanceled200 response.
func (client *lrOSOperations) deleteProvisioning202Deletingcanceled200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
func (client *lrOSOperations) BeginPost200WithPayload(ctx context.Context) (LrOSpost200WithPayloadPoller, error) {
	return &lrOSpost200WithPayloadPoller{
		client: client,
	}, nil
}

// post200WithPayloadCreateRequest creates the Post200WithPayload request.
func (client *lrOSOperations) post200WithPayloadCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/post/payload/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// post200WithPayloadHandleResponse handles the Post200WithPayload response.
func (client *lrOSOperations) post200WithPayloadHandleResponse(resp *azcore.Response) (*SkuResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := SkuResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Sku)
}

// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
func (client *lrOSOperations) BeginPost202NoRetry204(ctx context.Context, options *LrOSPost202NoRetry204Options) (LrOSpost202NoRetry204Poller, error) {
	return &lrOSpost202NoRetry204Poller{
		client: client,
	}, nil
}

// post202NoRetry204CreateRequest creates the Post202NoRetry204 request.
func (client *lrOSOperations) post202NoRetry204CreateRequest(options *LrOSPost202NoRetry204Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/noretry/204"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// post202NoRetry204HandleResponse handles the Post202NoRetry204 response.
func (client *lrOSOperations) post202NoRetry204HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
func (client *lrOSOperations) BeginPost202Retry200(ctx context.Context, options *LrOSPost202Retry200Options) (LrOSpost202Retry200Poller, error) {
	return &lrOSpost202Retry200Poller{
		client: client,
	}, nil
}

// post202Retry200CreateRequest creates the Post202Retry200 request.
func (client *lrOSOperations) post202Retry200CreateRequest(options *LrOSPost202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/retry/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// post202Retry200HandleResponse handles the Post202Retry200 response.
func (client *lrOSOperations) post202Retry200HandleResponse(resp *azcore.Response) (*LrOSPost202Retry200Response, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSPost202Retry200Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPostAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPostAsyncNoRetrySucceededOptions) (LrOSpostAsyncNoRetrySucceededPoller, error) {
	return &lrOSpostAsyncNoRetrySucceededPoller{
		client: client,
	}, nil
}

// postAsyncNoRetrySucceededCreateRequest creates the PostAsyncNoRetrySucceeded request.
func (client *lrOSOperations) postAsyncNoRetrySucceededCreateRequest(options *LrOSPostAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/noretry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncNoRetrySucceededHandleResponse handles the PostAsyncNoRetrySucceeded response.
func (client *lrOSOperations) postAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPostAsyncRetryFailed(ctx context.Context, options *LrOSPostAsyncRetryFailedOptions) (LrOSpostAsyncRetryFailedPoller, error) {
	return &lrOSpostAsyncRetryFailedPoller{
		client: client,
	}, nil
}

// postAsyncRetryFailedCreateRequest creates the PostAsyncRetryFailed request.
func (client *lrOSOperations) postAsyncRetryFailedCreateRequest(options *LrOSPostAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncRetryFailedHandleResponse handles the PostAsyncRetryFailed response.
func (client *lrOSOperations) postAsyncRetryFailedHandleResponse(resp *azcore.Response) (*LrOSPostAsyncRetryFailedResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSPostAsyncRetryFailedResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPostAsyncRetrySucceeded(ctx context.Context, options *LrOSPostAsyncRetrySucceededOptions) (LrOSpostAsyncRetrySucceededPoller, error) {
	return &lrOSpostAsyncRetrySucceededPoller{
		client: client,
	}, nil
}

// postAsyncRetrySucceededCreateRequest creates the PostAsyncRetrySucceeded request.
func (client *lrOSOperations) postAsyncRetrySucceededCreateRequest(options *LrOSPostAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncRetrySucceededHandleResponse handles the PostAsyncRetrySucceeded response.
func (client *lrOSOperations) postAsyncRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPostAsyncRetrycanceled(ctx context.Context, options *LrOSPostAsyncRetrycanceledOptions) (LrOSpostAsyncRetrycanceledPoller, error) {
	return &lrOSpostAsyncRetrycanceledPoller{
		client: client,
	}, nil
}

// postAsyncRetrycanceledCreateRequest creates the PostAsyncRetrycanceled request.
func (client *lrOSOperations) postAsyncRetrycanceledCreateRequest(options *LrOSPostAsyncRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// postAsyncRetrycanceledHandleResponse handles the PostAsyncRetrycanceled response.
func (client *lrOSOperations) postAsyncRetrycanceledHandleResponse(resp *azcore.Response) (*LrOSPostAsyncRetrycanceledResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := LrOSPostAsyncRetrycanceledResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
func (client *lrOSOperations) BeginPostDoubleHeadersFinalAzureHeaderGet(ctx context.Context) (LrOSpostDoubleHeadersFinalAzureHeaderGetPoller, error) {
	return &lrOSpostDoubleHeadersFinalAzureHeaderGetPoller{
		client: client,
	}, nil
}

// postDoubleHeadersFinalAzureHeaderGetCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGet request.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGet"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// postDoubleHeadersFinalAzureHeaderGetHandleResponse handles the PostDoubleHeadersFinalAzureHeaderGet response.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support initial Autorest behavior.
func (client *lrOSOperations) BeginPostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context) (LrOSpostDoubleHeadersFinalAzureHeaderGetDefaultPoller, error) {
	return &lrOSpostDoubleHeadersFinalAzureHeaderGetDefaultPoller{
		client: client,
	}, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGetDefault request.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse handles the PostDoubleHeadersFinalAzureHeaderGetDefault response.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
func (client *lrOSOperations) BeginPostDoubleHeadersFinalLocationGet(ctx context.Context) (LrOSpostDoubleHeadersFinalLocationGetPoller, error) {
	return &lrOSpostDoubleHeadersFinalLocationGetPoller{
		client: client,
	}, nil
}

// postDoubleHeadersFinalLocationGetCreateRequest creates the PostDoubleHeadersFinalLocationGet request.
func (client *lrOSOperations) postDoubleHeadersFinalLocationGetCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalLocationGet"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// postDoubleHeadersFinalLocationGetHandleResponse handles the PostDoubleHeadersFinalLocationGet response.
func (client *lrOSOperations) postDoubleHeadersFinalLocationGetHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
func (client *lrOSOperations) BeginPut200Acceptedcanceled200(ctx context.Context, options *LrOSPut200Acceptedcanceled200Options) (LrOSput200Acceptedcanceled200Poller, error) {
	return &lrOSput200Acceptedcanceled200Poller{
		client: client,
	}, nil
}

// put200Acceptedcanceled200CreateRequest creates the Put200Acceptedcanceled200 request.
func (client *lrOSOperations) put200Acceptedcanceled200CreateRequest(options *LrOSPut200Acceptedcanceled200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/accepted/canceled/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200Acceptedcanceled200HandleResponse handles the Put200Acceptedcanceled200 response.
func (client *lrOSOperations) put200Acceptedcanceled200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
func (client *lrOSOperations) BeginPut200Succeeded(ctx context.Context, options *LrOSPut200SucceededOptions) (LrOSput200SucceededPoller, error) {
	return &lrOSput200SucceededPoller{
		client: client,
	}, nil
}

// put200SucceededCreateRequest creates the Put200Succeeded request.
func (client *lrOSOperations) put200SucceededCreateRequest(options *LrOSPut200SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200SucceededHandleResponse handles the Put200Succeeded response.
func (client *lrOSOperations) put200SucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
func (client *lrOSOperations) BeginPut200SucceededNoState(ctx context.Context, options *LrOSPut200SucceededNoStateOptions) (LrOSput200SucceededNoStatePoller, error) {
	return &lrOSput200SucceededNoStatePoller{
		client: client,
	}, nil
}

// put200SucceededNoStateCreateRequest creates the Put200SucceededNoState request.
func (client *lrOSOperations) put200SucceededNoStateCreateRequest(options *LrOSPut200SucceededNoStateOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded/nostate"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200SucceededNoStateHandleResponse handles the Put200SucceededNoState response.
func (client *lrOSOperations) put200SucceededNoStateHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) BeginPut200UpdatingSucceeded204(ctx context.Context, options *LrOSPut200UpdatingSucceeded204Options) (LrOSput200UpdatingSucceeded204Poller, error) {
	return &lrOSput200UpdatingSucceeded204Poller{
		client: client,
	}, nil
}

// put200UpdatingSucceeded204CreateRequest creates the Put200UpdatingSucceeded204 request.
func (client *lrOSOperations) put200UpdatingSucceeded204CreateRequest(options *LrOSPut200UpdatingSucceeded204Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/updating/succeeded/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put200UpdatingSucceeded204HandleResponse handles the Put200UpdatingSucceeded204 response.
func (client *lrOSOperations) put200UpdatingSucceeded204HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
func (client *lrOSOperations) BeginPut201CreatingFailed200(ctx context.Context, options *LrOSPut201CreatingFailed200Options) (LrOSput201CreatingFailed200Poller, error) {
	return &lrOSput201CreatingFailed200Poller{
		client: client,
	}, nil
}

// put201CreatingFailed200CreateRequest creates the Put201CreatingFailed200 request.
func (client *lrOSOperations) put201CreatingFailed200CreateRequest(options *LrOSPut201CreatingFailed200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/created/failed/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put201CreatingFailed200HandleResponse handles the Put201CreatingFailed200 response.
func (client *lrOSOperations) put201CreatingFailed200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) BeginPut201CreatingSucceeded200(ctx context.Context, options *LrOSPut201CreatingSucceeded200Options) (LrOSput201CreatingSucceeded200Poller, error) {
	return &lrOSput201CreatingSucceeded200Poller{
		client: client,
	}, nil
}

// put201CreatingSucceeded200CreateRequest creates the Put201CreatingSucceeded200 request.
func (client *lrOSOperations) put201CreatingSucceeded200CreateRequest(options *LrOSPut201CreatingSucceeded200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/creating/succeeded/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put201CreatingSucceeded200HandleResponse handles the Put201CreatingSucceeded200 response.
func (client *lrOSOperations) put201CreatingSucceeded200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
func (client *lrOSOperations) BeginPut202Retry200(ctx context.Context, options *LrOSPut202Retry200Options) (LrOSput202Retry200Poller, error) {
	return &lrOSput202Retry200Poller{
		client: client,
	}, nil
}

// put202Retry200CreateRequest creates the Put202Retry200 request.
func (client *lrOSOperations) put202Retry200CreateRequest(options *LrOSPut202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/202/retry/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// put202Retry200HandleResponse handles the Put202Retry200 response.
func (client *lrOSOperations) put202Retry200HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
func (client *lrOSOperations) BeginPutAsyncNoHeaderInRetry(ctx context.Context, options *LrOSPutAsyncNoHeaderInRetryOptions) (LrOSputAsyncNoHeaderInRetryPoller, error) {
	return &lrOSputAsyncNoHeaderInRetryPoller{
		client: client,
	}, nil
}

// putAsyncNoHeaderInRetryCreateRequest creates the PutAsyncNoHeaderInRetry request.
func (client *lrOSOperations) putAsyncNoHeaderInRetryCreateRequest(options *LrOSPutAsyncNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noheader/201/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncNoHeaderInRetryHandleResponse handles the PutAsyncNoHeaderInRetry response.
func (client *lrOSOperations) putAsyncNoHeaderInRetryHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPutAsyncNoRetrySucceeded(ctx context.Context, options *LrOSPutAsyncNoRetrySucceededOptions) (LrOSputAsyncNoRetrySucceededPoller, error) {
	return &lrOSputAsyncNoRetrySucceededPoller{
		client: client,
	}, nil
}

// putAsyncNoRetrySucceededCreateRequest creates the PutAsyncNoRetrySucceeded request.
func (client *lrOSOperations) putAsyncNoRetrySucceededCreateRequest(options *LrOSPutAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncNoRetrySucceededHandleResponse handles the PutAsyncNoRetrySucceeded response.
func (client *lrOSOperations) putAsyncNoRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPutAsyncNoRetrycanceled(ctx context.Context, options *LrOSPutAsyncNoRetrycanceledOptions) (LrOSputAsyncNoRetrycanceledPoller, error) {
	return &lrOSputAsyncNoRetrycanceledPoller{
		client: client,
	}, nil
}

// putAsyncNoRetrycanceledCreateRequest creates the PutAsyncNoRetrycanceled request.
func (client *lrOSOperations) putAsyncNoRetrycanceledCreateRequest(options *LrOSPutAsyncNoRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncNoRetrycanceledHandleResponse handles the PutAsyncNoRetrycanceled response.
func (client *lrOSOperations) putAsyncNoRetrycanceledHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncNonResource - Long running put request with non resource.
func (client *lrOSOperations) BeginPutAsyncNonResource(ctx context.Context, options *LrOSPutAsyncNonResourceOptions) (LrOSputAsyncNonResourcePoller, error) {
	return &lrOSputAsyncNonResourcePoller{
		client: client,
	}, nil
}

// putAsyncNonResourceCreateRequest creates the PutAsyncNonResource request.
func (client *lrOSOperations) putAsyncNonResourceCreateRequest(options *LrOSPutAsyncNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresourceasync/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Sku)
	}
	return req, nil
}

// putAsyncNonResourceHandleResponse handles the PutAsyncNonResource response.
func (client *lrOSOperations) putAsyncNonResourceHandleResponse(resp *azcore.Response) (*SkuResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := SkuResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Sku)
}

// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPutAsyncRetryFailed(ctx context.Context, options *LrOSPutAsyncRetryFailedOptions) (LrOSputAsyncRetryFailedPoller, error) {
	return &lrOSputAsyncRetryFailedPoller{
		client: client,
	}, nil
}

// putAsyncRetryFailedCreateRequest creates the PutAsyncRetryFailed request.
func (client *lrOSOperations) putAsyncRetryFailedCreateRequest(options *LrOSPutAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncRetryFailedHandleResponse handles the PutAsyncRetryFailed response.
func (client *lrOSOperations) putAsyncRetryFailedHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) BeginPutAsyncRetrySucceeded(ctx context.Context, options *LrOSPutAsyncRetrySucceededOptions) (LrOSputAsyncRetrySucceededPoller, error) {
	return &lrOSputAsyncRetrySucceededPoller{
		client: client,
	}, nil
}

// putAsyncRetrySucceededCreateRequest creates the PutAsyncRetrySucceeded request.
func (client *lrOSOperations) putAsyncRetrySucceededCreateRequest(options *LrOSPutAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncRetrySucceededHandleResponse handles the PutAsyncRetrySucceeded response.
func (client *lrOSOperations) putAsyncRetrySucceededHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncSubResource - Long running put request with sub resource.
func (client *lrOSOperations) BeginPutAsyncSubResource(ctx context.Context, options *LrOSPutAsyncSubResourceOptions) (LrOSputAsyncSubResourcePoller, error) {
	return &lrOSputAsyncSubResourcePoller{
		client: client,
	}, nil
}

// putAsyncSubResourceCreateRequest creates the PutAsyncSubResource request.
func (client *lrOSOperations) putAsyncSubResourceCreateRequest(options *LrOSPutAsyncSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresourceasync/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putAsyncSubResourceHandleResponse handles the PutAsyncSubResource response.
func (client *lrOSOperations) putAsyncSubResourceHandleResponse(resp *azcore.Response) (*SubProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := SubProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SubProduct)
}

// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
func (client *lrOSOperations) BeginPutNoHeaderInRetry(ctx context.Context, options *LrOSPutNoHeaderInRetryOptions) (LrOSputNoHeaderInRetryPoller, error) {
	return &lrOSputNoHeaderInRetryPoller{
		client: client,
	}, nil
}

// putNoHeaderInRetryCreateRequest creates the PutNoHeaderInRetry request.
func (client *lrOSOperations) putNoHeaderInRetryCreateRequest(options *LrOSPutNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/noheader/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putNoHeaderInRetryHandleResponse handles the PutNoHeaderInRetry response.
func (client *lrOSOperations) putNoHeaderInRetryHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutNonResource - Long running put request with non resource.
func (client *lrOSOperations) BeginPutNonResource(ctx context.Context, options *LrOSPutNonResourceOptions) (LrOSputNonResourcePoller, error) {
	return &lrOSputNonResourcePoller{
		client: client,
	}, nil
}

// putNonResourceCreateRequest creates the PutNonResource request.
func (client *lrOSOperations) putNonResourceCreateRequest(options *LrOSPutNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresource/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Sku)
	}
	return req, nil
}

// putNonResourceHandleResponse handles the PutNonResource response.
func (client *lrOSOperations) putNonResourceHandleResponse(resp *azcore.Response) (*SkuResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := SkuResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Sku)
}

// PutSubResource - Long running put request with sub resource.
func (client *lrOSOperations) BeginPutSubResource(ctx context.Context, options *LrOSPutSubResourceOptions) (LrOSputSubResourcePoller, error) {
	return &lrOSputSubResourcePoller{
		client: client,
	}, nil
}

// putSubResourceCreateRequest creates the PutSubResource request.
func (client *lrOSOperations) putSubResourceCreateRequest(options *LrOSPutSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresource/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil {
		return req, req.MarshalAsJSON(options.Product)
	}
	return req, nil
}

// putSubResourceHandleResponse handles the PutSubResource response.
func (client *lrOSOperations) putSubResourceHandleResponse(resp *azcore.Response) (*SubProductResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newCloudError(resp)
	}
	result := SubProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.SubProduct)
}
