// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// LrOSOperations contains the methods for the LrOS group.
type LrOSOperations interface {
	// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	Delete202NoRetry204(ctx context.Context) (*ProductResponse, error)
	// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	Delete202Retry200(ctx context.Context) (*ProductResponse, error)
	// Delete204Succeeded - Long running delete succeeds and returns right away
	Delete204Succeeded(ctx context.Context) (*HTTPResponse, error)
	// ResumeHttpPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeHttpPoller(id string) (HttpPoller, error)
	// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
	DeleteAsyncNoHeaderInRetry(ctx context.Context) (*HTTPResponse, error)
	// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	DeleteAsyncNoRetrySucceeded(ctx context.Context) (*HTTPResponse, error)
	// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	DeleteAsyncRetryFailed(ctx context.Context) (*HTTPResponse, error)
	// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	DeleteAsyncRetrySucceeded(ctx context.Context) (*HTTPResponse, error)
	// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	DeleteAsyncRetrycanceled(ctx context.Context) (*HTTPResponse, error)
	// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
	DeleteNoHeaderInRetry(ctx context.Context) (*HTTPResponse, error)
	// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	DeleteProvisioning202Accepted200Succeeded(ctx context.Context) (*ProductResponse, error)
	// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
	DeleteProvisioning202DeletingFailed200(ctx context.Context) (*ProductResponse, error)
	// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
	DeleteProvisioning202Deletingcanceled200(ctx context.Context) (*ProductResponse, error)
	// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
	Post200WithPayload(ctx context.Context) (*SkuResponse, error)
	// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
	Post202NoRetry204(ctx context.Context, lrOSPost202NoRetry204Options *LrOSPost202NoRetry204Options) (*ProductResponse, error)
	// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
	Post202Retry200(ctx context.Context, lrOSPost202Retry200Options *LrOSPost202Retry200Options) (*HTTPResponse, error)
	// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PostAsyncNoRetrySucceeded(ctx context.Context, lrOSPostAsyncNoRetrySucceededOptions *LrOSPostAsyncNoRetrySucceededOptions) (*ProductResponse, error)
	// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PostAsyncRetryFailed(ctx context.Context, lrOSPostAsyncRetryFailedOptions *LrOSPostAsyncRetryFailedOptions) (*HTTPResponse, error)
	// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PostAsyncRetrySucceeded(ctx context.Context, lrOSPostAsyncRetrySucceededOptions *LrOSPostAsyncRetrySucceededOptions) (*ProductResponse, error)
	// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PostAsyncRetrycanceled(ctx context.Context, lrOSPostAsyncRetrycanceledOptions *LrOSPostAsyncRetrycanceledOptions) (*HTTPResponse, error)
	// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
	PostDoubleHeadersFinalAzureHeaderGet(ctx context.Context) (*ProductResponse, error)
	// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support initial Autorest behavior.
	PostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context) (*ProductResponse, error)
	// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
	PostDoubleHeadersFinalLocationGet(ctx context.Context) (*ProductResponse, error)
	// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
	Put200Acceptedcanceled200(ctx context.Context, lrOSPut200Acceptedcanceled200Options *LrOSPut200Acceptedcanceled200Options) (*ProductResponse, error)
	// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
	Put200Succeeded(ctx context.Context, lrOSPut200SucceededOptions *LrOSPut200SucceededOptions) (*ProductResponse, error)
	// ResumeProductPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeProductPoller(id string) (ProductPoller, error)
	// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
	Put200SucceededNoState(ctx context.Context, lrOSPut200SucceededNoStateOptions *LrOSPut200SucceededNoStateOptions) (*ProductResponse, error)
	// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	Put200UpdatingSucceeded204(ctx context.Context, lrOSPut200UpdatingSucceeded204Options *LrOSPut200UpdatingSucceeded204Options) (*ProductResponse, error)
	// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
	Put201CreatingFailed200(ctx context.Context, lrOSPut201CreatingFailed200Options *LrOSPut201CreatingFailed200Options) (*ProductResponse, error)
	// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
	Put201CreatingSucceeded200(ctx context.Context, lrOSPut201CreatingSucceeded200Options *LrOSPut201CreatingSucceeded200Options) (*ProductResponse, error)
	// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
	Put202Retry200(ctx context.Context, lrOSPut202Retry200Options *LrOSPut202Retry200Options) (*ProductResponse, error)
	// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
	PutAsyncNoHeaderInRetry(ctx context.Context, lrOSPutAsyncNoHeaderInRetryOptions *LrOSPutAsyncNoHeaderInRetryOptions) (*ProductResponse, error)
	// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PutAsyncNoRetrySucceeded(ctx context.Context, lrOSPutAsyncNoRetrySucceededOptions *LrOSPutAsyncNoRetrySucceededOptions) (*ProductResponse, error)
	// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PutAsyncNoRetrycanceled(ctx context.Context, lrOSPutAsyncNoRetrycanceledOptions *LrOSPutAsyncNoRetrycanceledOptions) (*ProductResponse, error)
	// PutAsyncNonResource - Long running put request with non resource.
	PutAsyncNonResource(ctx context.Context, lrOSPutAsyncNonResourceOptions *LrOSPutAsyncNonResourceOptions) (*SkuResponse, error)
	// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PutAsyncRetryFailed(ctx context.Context, lrOSPutAsyncRetryFailedOptions *LrOSPutAsyncRetryFailedOptions) (*ProductResponse, error)
	// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	PutAsyncRetrySucceeded(ctx context.Context, lrOSPutAsyncRetrySucceededOptions *LrOSPutAsyncRetrySucceededOptions) (*ProductResponse, error)
	// PutAsyncSubResource - Long running put request with sub resource.
	PutAsyncSubResource(ctx context.Context, lrOSPutAsyncSubResourceOptions *LrOSPutAsyncSubResourceOptions) (*SubProductResponse, error)
	// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
	PutNoHeaderInRetry(ctx context.Context, lrOSPutNoHeaderInRetryOptions *LrOSPutNoHeaderInRetryOptions) (*ProductResponse, error)
	// PutNonResource - Long running put request with non resource.
	PutNonResource(ctx context.Context, lrOSPutNonResourceOptions *LrOSPutNonResourceOptions) (*SkuResponse, error)
	// ResumeSkuPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeSkuPoller(id string) (SkuPoller, error)
	// PutSubResource - Long running put request with sub resource.
	PutSubResource(ctx context.Context, lrOSPutSubResourceOptions *LrOSPutSubResourceOptions) (*SubProductResponse, error)
	// ResumeSubProductPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeSubProductPoller(id string) (SubProductPoller, error)
}

// lrOSOperations implements the LrOSOperations interface.
type lrOSOperations struct {
	*Client
}

// Delete202NoRetry204 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) Delete202NoRetry204(ctx context.Context) (*ProductResponse, error) {
	req, err := client.delete202NoRetry204CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.delete202NoRetry204HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// delete202NoRetry204CreateRequest creates the Delete202NoRetry204 request.
func (client *lrOSOperations) delete202NoRetry204CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/202/noretry/204"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete202NoRetry204HandleError handles the Delete202NoRetry204 error response.
func (client *lrOSOperations) delete202NoRetry204HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Delete202Retry200 - Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) Delete202Retry200(ctx context.Context) (*ProductResponse, error) {
	req, err := client.delete202Retry200CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.delete202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// delete202Retry200CreateRequest creates the Delete202Retry200 request.
func (client *lrOSOperations) delete202Retry200CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/202/retry/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete202Retry200HandleError handles the Delete202Retry200 error response.
func (client *lrOSOperations) delete202Retry200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Delete204Succeeded - Long running delete succeeds and returns right away
func (client *lrOSOperations) Delete204Succeeded(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.delete204SucceededCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.delete204SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

func (client *lrOSOperations) ResumeHttpPoller(token string) (HttpPoller, error) {
	pt, err := resumePollingTracker("httpPoller", token, client.delete204SucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &httpPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *lrOSOperations) delete204SucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/204/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete204SucceededHandleError handles the Delete204Succeeded error response.
func (client *lrOSOperations) delete204SucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteAsyncNoHeaderInRetry - Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
func (client *lrOSOperations) DeleteAsyncNoHeaderInRetry(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.deleteAsyncNoHeaderInRetryCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.deleteAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteAsyncNoHeaderInRetryCreateRequest creates the DeleteAsyncNoHeaderInRetry request.
func (client *lrOSOperations) deleteAsyncNoHeaderInRetryCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noheader/202/204"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncNoHeaderInRetryHandleError handles the DeleteAsyncNoHeaderInRetry error response.
func (client *lrOSOperations) deleteAsyncNoHeaderInRetryHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteAsyncNoRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) DeleteAsyncNoRetrySucceeded(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.deleteAsyncNoRetrySucceededCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.deleteAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteAsyncNoRetrySucceededCreateRequest creates the DeleteAsyncNoRetrySucceeded request.
func (client *lrOSOperations) deleteAsyncNoRetrySucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/noretry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncNoRetrySucceededHandleError handles the DeleteAsyncNoRetrySucceeded error response.
func (client *lrOSOperations) deleteAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteAsyncRetryFailed - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) DeleteAsyncRetryFailed(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.deleteAsyncRetryFailedCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.deleteAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteAsyncRetryFailedCreateRequest creates the DeleteAsyncRetryFailed request.
func (client *lrOSOperations) deleteAsyncRetryFailedCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRetryFailedHandleError handles the DeleteAsyncRetryFailed error response.
func (client *lrOSOperations) deleteAsyncRetryFailedHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteAsyncRetrySucceeded - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) DeleteAsyncRetrySucceeded(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.deleteAsyncRetrySucceededCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.deleteAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteAsyncRetrySucceededCreateRequest creates the DeleteAsyncRetrySucceeded request.
func (client *lrOSOperations) deleteAsyncRetrySucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRetrySucceededHandleError handles the DeleteAsyncRetrySucceeded error response.
func (client *lrOSOperations) deleteAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteAsyncRetrycanceled - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) DeleteAsyncRetrycanceled(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.deleteAsyncRetrycanceledCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.deleteAsyncRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteAsyncRetrycanceledCreateRequest creates the DeleteAsyncRetrycanceled request.
func (client *lrOSOperations) deleteAsyncRetrycanceledCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/deleteasync/retry/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRetrycanceledHandleError handles the DeleteAsyncRetrycanceled error response.
func (client *lrOSOperations) deleteAsyncRetrycanceledHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteNoHeaderInRetry - Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
func (client *lrOSOperations) DeleteNoHeaderInRetry(ctx context.Context) (*HTTPResponse, error) {
	req, err := client.deleteNoHeaderInRetryCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.deleteNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteNoHeaderInRetryCreateRequest creates the DeleteNoHeaderInRetry request.
func (client *lrOSOperations) deleteNoHeaderInRetryCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/noheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteNoHeaderInRetryHandleError handles the DeleteNoHeaderInRetry error response.
func (client *lrOSOperations) deleteNoHeaderInRetryHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteProvisioning202Accepted200Succeeded - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) DeleteProvisioning202Accepted200Succeeded(ctx context.Context) (*ProductResponse, error) {
	req, err := client.deleteProvisioning202Accepted200SucceededCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.deleteProvisioning202Accepted200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteProvisioning202Accepted200SucceededCreateRequest creates the DeleteProvisioning202Accepted200Succeeded request.
func (client *lrOSOperations) deleteProvisioning202Accepted200SucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/accepted/200/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteProvisioning202Accepted200SucceededHandleError handles the DeleteProvisioning202Accepted200Succeeded error response.
func (client *lrOSOperations) deleteProvisioning202Accepted200SucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteProvisioning202DeletingFailed200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
func (client *lrOSOperations) DeleteProvisioning202DeletingFailed200(ctx context.Context) (*ProductResponse, error) {
	req, err := client.deleteProvisioning202DeletingFailed200CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.deleteProvisioning202DeletingFailed200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteProvisioning202DeletingFailed200CreateRequest creates the DeleteProvisioning202DeletingFailed200 request.
func (client *lrOSOperations) deleteProvisioning202DeletingFailed200CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteProvisioning202DeletingFailed200HandleError handles the DeleteProvisioning202DeletingFailed200 error response.
func (client *lrOSOperations) deleteProvisioning202DeletingFailed200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DeleteProvisioning202Deletingcanceled200 - Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
func (client *lrOSOperations) DeleteProvisioning202Deletingcanceled200(ctx context.Context) (*ProductResponse, error) {
	req, err := client.deleteProvisioning202Deletingcanceled200CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.deleteProvisioning202Deletingcanceled200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// deleteProvisioning202Deletingcanceled200CreateRequest creates the DeleteProvisioning202Deletingcanceled200 request.
func (client *lrOSOperations) deleteProvisioning202Deletingcanceled200CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/delete/provisioning/202/deleting/200/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteProvisioning202Deletingcanceled200HandleError handles the DeleteProvisioning202Deletingcanceled200 error response.
func (client *lrOSOperations) deleteProvisioning202Deletingcanceled200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Post200WithPayload - Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
func (client *lrOSOperations) Post200WithPayload(ctx context.Context) (*SkuResponse, error) {
	req, err := client.post200WithPayloadCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("skuPoller", resp, client.post200WithPayloadHandleError)
	if err != nil {
		return nil, err
	}
	poller := &skuPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// post200WithPayloadCreateRequest creates the Post200WithPayload request.
func (client *lrOSOperations) post200WithPayloadCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/post/payload/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// post200WithPayloadHandleError handles the Post200WithPayload error response.
func (client *lrOSOperations) post200WithPayloadHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Post202NoRetry204 - Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
func (client *lrOSOperations) Post202NoRetry204(ctx context.Context, lrOSPost202NoRetry204Options *LrOSPost202NoRetry204Options) (*ProductResponse, error) {
	req, err := client.post202NoRetry204CreateRequest(lrOSPost202NoRetry204Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.post202NoRetry204HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// post202NoRetry204CreateRequest creates the Post202NoRetry204 request.
func (client *lrOSOperations) post202NoRetry204CreateRequest(lrOSPost202NoRetry204Options *LrOSPost202NoRetry204Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/noretry/204"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrOSPost202NoRetry204Options != nil {
		return req, req.MarshalAsJSON(lrOSPost202NoRetry204Options.Product)
	}
	return req, nil
}

// post202NoRetry204HandleError handles the Post202NoRetry204 error response.
func (client *lrOSOperations) post202NoRetry204HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Post202Retry200 - Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
func (client *lrOSOperations) Post202Retry200(ctx context.Context, lrOSPost202Retry200Options *LrOSPost202Retry200Options) (*HTTPResponse, error) {
	req, err := client.post202Retry200CreateRequest(lrOSPost202Retry200Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.post202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// post202Retry200CreateRequest creates the Post202Retry200 request.
func (client *lrOSOperations) post202Retry200CreateRequest(lrOSPost202Retry200Options *LrOSPost202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/post/202/retry/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrOSPost202Retry200Options != nil {
		return req, req.MarshalAsJSON(lrOSPost202Retry200Options.Product)
	}
	return req, nil
}

// post202Retry200HandleError handles the Post202Retry200 error response.
func (client *lrOSOperations) post202Retry200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostAsyncNoRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PostAsyncNoRetrySucceeded(ctx context.Context, lrOSPostAsyncNoRetrySucceededOptions *LrOSPostAsyncNoRetrySucceededOptions) (*ProductResponse, error) {
	req, err := client.postAsyncNoRetrySucceededCreateRequest(lrOSPostAsyncNoRetrySucceededOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.postAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postAsyncNoRetrySucceededCreateRequest creates the PostAsyncNoRetrySucceeded request.
func (client *lrOSOperations) postAsyncNoRetrySucceededCreateRequest(lrOSPostAsyncNoRetrySucceededOptions *LrOSPostAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/noretry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrOSPostAsyncNoRetrySucceededOptions != nil {
		return req, req.MarshalAsJSON(lrOSPostAsyncNoRetrySucceededOptions.Product)
	}
	return req, nil
}

// postAsyncNoRetrySucceededHandleError handles the PostAsyncNoRetrySucceeded error response.
func (client *lrOSOperations) postAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostAsyncRetryFailed - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PostAsyncRetryFailed(ctx context.Context, lrOSPostAsyncRetryFailedOptions *LrOSPostAsyncRetryFailedOptions) (*HTTPResponse, error) {
	req, err := client.postAsyncRetryFailedCreateRequest(lrOSPostAsyncRetryFailedOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.postAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postAsyncRetryFailedCreateRequest creates the PostAsyncRetryFailed request.
func (client *lrOSOperations) postAsyncRetryFailedCreateRequest(lrOSPostAsyncRetryFailedOptions *LrOSPostAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrOSPostAsyncRetryFailedOptions != nil {
		return req, req.MarshalAsJSON(lrOSPostAsyncRetryFailedOptions.Product)
	}
	return req, nil
}

// postAsyncRetryFailedHandleError handles the PostAsyncRetryFailed error response.
func (client *lrOSOperations) postAsyncRetryFailedHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostAsyncRetrySucceeded - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PostAsyncRetrySucceeded(ctx context.Context, lrOSPostAsyncRetrySucceededOptions *LrOSPostAsyncRetrySucceededOptions) (*ProductResponse, error) {
	req, err := client.postAsyncRetrySucceededCreateRequest(lrOSPostAsyncRetrySucceededOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.postAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postAsyncRetrySucceededCreateRequest creates the PostAsyncRetrySucceeded request.
func (client *lrOSOperations) postAsyncRetrySucceededCreateRequest(lrOSPostAsyncRetrySucceededOptions *LrOSPostAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrOSPostAsyncRetrySucceededOptions != nil {
		return req, req.MarshalAsJSON(lrOSPostAsyncRetrySucceededOptions.Product)
	}
	return req, nil
}

// postAsyncRetrySucceededHandleError handles the PostAsyncRetrySucceeded error response.
func (client *lrOSOperations) postAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostAsyncRetrycanceled - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PostAsyncRetrycanceled(ctx context.Context, lrOSPostAsyncRetrycanceledOptions *LrOSPostAsyncRetrycanceledOptions) (*HTTPResponse, error) {
	req, err := client.postAsyncRetrycanceledCreateRequest(lrOSPostAsyncRetrycanceledOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("httpPoller", resp, client.postAsyncRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	poller := &httpPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postAsyncRetrycanceledCreateRequest creates the PostAsyncRetrycanceled request.
func (client *lrOSOperations) postAsyncRetrycanceledCreateRequest(lrOSPostAsyncRetrycanceledOptions *LrOSPostAsyncRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/postasync/retry/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrOSPostAsyncRetrycanceledOptions != nil {
		return req, req.MarshalAsJSON(lrOSPostAsyncRetrycanceledOptions.Product)
	}
	return req, nil
}

// postAsyncRetrycanceledHandleError handles the PostAsyncRetrycanceled error response.
func (client *lrOSOperations) postAsyncRetrycanceledHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostDoubleHeadersFinalAzureHeaderGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object
func (client *lrOSOperations) PostDoubleHeadersFinalAzureHeaderGet(ctx context.Context) (*ProductResponse, error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.postDoubleHeadersFinalAzureHeaderGetHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postDoubleHeadersFinalAzureHeaderGetCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGet request.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGet"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// postDoubleHeadersFinalAzureHeaderGetHandleError handles the PostDoubleHeadersFinalAzureHeaderGet error response.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostDoubleHeadersFinalAzureHeaderGetDefault - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support initial Autorest behavior.
func (client *lrOSOperations) PostDoubleHeadersFinalAzureHeaderGetDefault(ctx context.Context) (*ProductResponse, error) {
	req, err := client.postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest creates the PostDoubleHeadersFinalAzureHeaderGetDefault request.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetDefaultCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// postDoubleHeadersFinalAzureHeaderGetDefaultHandleError handles the PostDoubleHeadersFinalAzureHeaderGetDefault error response.
func (client *lrOSOperations) postDoubleHeadersFinalAzureHeaderGetDefaultHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PostDoubleHeadersFinalLocationGet - Long running post request, service returns a 202 to the initial request with both Location and Azure-Async header. Poll Azure-Async and it's success. Should poll Location to get the final object
func (client *lrOSOperations) PostDoubleHeadersFinalLocationGet(ctx context.Context) (*ProductResponse, error) {
	req, err := client.postDoubleHeadersFinalLocationGetCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.postDoubleHeadersFinalLocationGetHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// postDoubleHeadersFinalLocationGetCreateRequest creates the PostDoubleHeadersFinalLocationGet request.
func (client *lrOSOperations) postDoubleHeadersFinalLocationGetCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/LROPostDoubleHeadersFinalLocationGet"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, nil
}

// postDoubleHeadersFinalLocationGetHandleError handles the PostDoubleHeadersFinalLocationGet error response.
func (client *lrOSOperations) postDoubleHeadersFinalLocationGetHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put200Acceptedcanceled200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
func (client *lrOSOperations) Put200Acceptedcanceled200(ctx context.Context, lrOSPut200Acceptedcanceled200Options *LrOSPut200Acceptedcanceled200Options) (*ProductResponse, error) {
	req, err := client.put200Acceptedcanceled200CreateRequest(lrOSPut200Acceptedcanceled200Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put200Acceptedcanceled200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// put200Acceptedcanceled200CreateRequest creates the Put200Acceptedcanceled200 request.
func (client *lrOSOperations) put200Acceptedcanceled200CreateRequest(lrOSPut200Acceptedcanceled200Options *LrOSPut200Acceptedcanceled200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/accepted/canceled/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut200Acceptedcanceled200Options != nil {
		return req, req.MarshalAsJSON(lrOSPut200Acceptedcanceled200Options.Product)
	}
	return req, nil
}

// put200Acceptedcanceled200HandleError handles the Put200Acceptedcanceled200 error response.
func (client *lrOSOperations) put200Acceptedcanceled200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put200Succeeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
func (client *lrOSOperations) Put200Succeeded(ctx context.Context, lrOSPut200SucceededOptions *LrOSPut200SucceededOptions) (*ProductResponse, error) {
	req, err := client.put200SucceededCreateRequest(lrOSPut200SucceededOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

func (client *lrOSOperations) ResumeProductPoller(token string) (ProductPoller, error) {
	pt, err := resumePollingTracker("productPoller", token, client.put200SucceededHandleError)
	if err != nil {
		return nil, err
	}
	return &productPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// put200SucceededCreateRequest creates the Put200Succeeded request.
func (client *lrOSOperations) put200SucceededCreateRequest(lrOSPut200SucceededOptions *LrOSPut200SucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut200SucceededOptions != nil {
		return req, req.MarshalAsJSON(lrOSPut200SucceededOptions.Product)
	}
	return req, nil
}

// put200SucceededHandleError handles the Put200Succeeded error response.
func (client *lrOSOperations) put200SucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put200SucceededNoState - Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
func (client *lrOSOperations) Put200SucceededNoState(ctx context.Context, lrOSPut200SucceededNoStateOptions *LrOSPut200SucceededNoStateOptions) (*ProductResponse, error) {
	req, err := client.put200SucceededNoStateCreateRequest(lrOSPut200SucceededNoStateOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put200SucceededNoStateHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// put200SucceededNoStateCreateRequest creates the Put200SucceededNoState request.
func (client *lrOSOperations) put200SucceededNoStateCreateRequest(lrOSPut200SucceededNoStateOptions *LrOSPut200SucceededNoStateOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/200/succeeded/nostate"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut200SucceededNoStateOptions != nil {
		return req, req.MarshalAsJSON(lrOSPut200SucceededNoStateOptions.Product)
	}
	return req, nil
}

// put200SucceededNoStateHandleError handles the Put200SucceededNoState error response.
func (client *lrOSOperations) put200SucceededNoStateHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put200UpdatingSucceeded204 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) Put200UpdatingSucceeded204(ctx context.Context, lrOSPut200UpdatingSucceeded204Options *LrOSPut200UpdatingSucceeded204Options) (*ProductResponse, error) {
	req, err := client.put200UpdatingSucceeded204CreateRequest(lrOSPut200UpdatingSucceeded204Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put200UpdatingSucceeded204HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// put200UpdatingSucceeded204CreateRequest creates the Put200UpdatingSucceeded204 request.
func (client *lrOSOperations) put200UpdatingSucceeded204CreateRequest(lrOSPut200UpdatingSucceeded204Options *LrOSPut200UpdatingSucceeded204Options) (*azcore.Request, error) {
	urlPath := "/lro/put/200/updating/succeeded/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut200UpdatingSucceeded204Options != nil {
		return req, req.MarshalAsJSON(lrOSPut200UpdatingSucceeded204Options.Product)
	}
	return req, nil
}

// put200UpdatingSucceeded204HandleError handles the Put200UpdatingSucceeded204 error response.
func (client *lrOSOperations) put200UpdatingSucceeded204HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put201CreatingFailed200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
func (client *lrOSOperations) Put201CreatingFailed200(ctx context.Context, lrOSPut201CreatingFailed200Options *LrOSPut201CreatingFailed200Options) (*ProductResponse, error) {
	req, err := client.put201CreatingFailed200CreateRequest(lrOSPut201CreatingFailed200Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put201CreatingFailed200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// put201CreatingFailed200CreateRequest creates the Put201CreatingFailed200 request.
func (client *lrOSOperations) put201CreatingFailed200CreateRequest(lrOSPut201CreatingFailed200Options *LrOSPut201CreatingFailed200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/created/failed/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut201CreatingFailed200Options != nil {
		return req, req.MarshalAsJSON(lrOSPut201CreatingFailed200Options.Product)
	}
	return req, nil
}

// put201CreatingFailed200HandleError handles the Put201CreatingFailed200 error response.
func (client *lrOSOperations) put201CreatingFailed200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put201CreatingSucceeded200 - Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
func (client *lrOSOperations) Put201CreatingSucceeded200(ctx context.Context, lrOSPut201CreatingSucceeded200Options *LrOSPut201CreatingSucceeded200Options) (*ProductResponse, error) {
	req, err := client.put201CreatingSucceeded200CreateRequest(lrOSPut201CreatingSucceeded200Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put201CreatingSucceeded200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// put201CreatingSucceeded200CreateRequest creates the Put201CreatingSucceeded200 request.
func (client *lrOSOperations) put201CreatingSucceeded200CreateRequest(lrOSPut201CreatingSucceeded200Options *LrOSPut201CreatingSucceeded200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/201/creating/succeeded/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut201CreatingSucceeded200Options != nil {
		return req, req.MarshalAsJSON(lrOSPut201CreatingSucceeded200Options.Product)
	}
	return req, nil
}

// put201CreatingSucceeded200HandleError handles the Put201CreatingSucceeded200 error response.
func (client *lrOSOperations) put201CreatingSucceeded200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Put202Retry200 - Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
func (client *lrOSOperations) Put202Retry200(ctx context.Context, lrOSPut202Retry200Options *LrOSPut202Retry200Options) (*ProductResponse, error) {
	req, err := client.put202Retry200CreateRequest(lrOSPut202Retry200Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.put202Retry200HandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// put202Retry200CreateRequest creates the Put202Retry200 request.
func (client *lrOSOperations) put202Retry200CreateRequest(lrOSPut202Retry200Options *LrOSPut202Retry200Options) (*azcore.Request, error) {
	urlPath := "/lro/put/202/retry/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPut202Retry200Options != nil {
		return req, req.MarshalAsJSON(lrOSPut202Retry200Options.Product)
	}
	return req, nil
}

// put202Retry200HandleError handles the Put202Retry200 error response.
func (client *lrOSOperations) put202Retry200HandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
func (client *lrOSOperations) PutAsyncNoHeaderInRetry(ctx context.Context, lrOSPutAsyncNoHeaderInRetryOptions *LrOSPutAsyncNoHeaderInRetryOptions) (*ProductResponse, error) {
	req, err := client.putAsyncNoHeaderInRetryCreateRequest(lrOSPutAsyncNoHeaderInRetryOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.putAsyncNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncNoHeaderInRetryCreateRequest creates the PutAsyncNoHeaderInRetry request.
func (client *lrOSOperations) putAsyncNoHeaderInRetryCreateRequest(lrOSPutAsyncNoHeaderInRetryOptions *LrOSPutAsyncNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noheader/201/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncNoHeaderInRetryOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncNoHeaderInRetryOptions.Product)
	}
	return req, nil
}

// putAsyncNoHeaderInRetryHandleError handles the PutAsyncNoHeaderInRetry error response.
func (client *lrOSOperations) putAsyncNoHeaderInRetryHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncNoRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PutAsyncNoRetrySucceeded(ctx context.Context, lrOSPutAsyncNoRetrySucceededOptions *LrOSPutAsyncNoRetrySucceededOptions) (*ProductResponse, error) {
	req, err := client.putAsyncNoRetrySucceededCreateRequest(lrOSPutAsyncNoRetrySucceededOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.putAsyncNoRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncNoRetrySucceededCreateRequest creates the PutAsyncNoRetrySucceeded request.
func (client *lrOSOperations) putAsyncNoRetrySucceededCreateRequest(lrOSPutAsyncNoRetrySucceededOptions *LrOSPutAsyncNoRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncNoRetrySucceededOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncNoRetrySucceededOptions.Product)
	}
	return req, nil
}

// putAsyncNoRetrySucceededHandleError handles the PutAsyncNoRetrySucceeded error response.
func (client *lrOSOperations) putAsyncNoRetrySucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncNoRetrycanceled - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PutAsyncNoRetrycanceled(ctx context.Context, lrOSPutAsyncNoRetrycanceledOptions *LrOSPutAsyncNoRetrycanceledOptions) (*ProductResponse, error) {
	req, err := client.putAsyncNoRetrycanceledCreateRequest(lrOSPutAsyncNoRetrycanceledOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.putAsyncNoRetrycanceledHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncNoRetrycanceledCreateRequest creates the PutAsyncNoRetrycanceled request.
func (client *lrOSOperations) putAsyncNoRetrycanceledCreateRequest(lrOSPutAsyncNoRetrycanceledOptions *LrOSPutAsyncNoRetrycanceledOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/noretry/canceled"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncNoRetrycanceledOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncNoRetrycanceledOptions.Product)
	}
	return req, nil
}

// putAsyncNoRetrycanceledHandleError handles the PutAsyncNoRetrycanceled error response.
func (client *lrOSOperations) putAsyncNoRetrycanceledHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncNonResource - Long running put request with non resource.
func (client *lrOSOperations) PutAsyncNonResource(ctx context.Context, lrOSPutAsyncNonResourceOptions *LrOSPutAsyncNonResourceOptions) (*SkuResponse, error) {
	req, err := client.putAsyncNonResourceCreateRequest(lrOSPutAsyncNonResourceOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("skuPoller", resp, client.putAsyncNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &skuPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncNonResourceCreateRequest creates the PutAsyncNonResource request.
func (client *lrOSOperations) putAsyncNonResourceCreateRequest(lrOSPutAsyncNonResourceOptions *LrOSPutAsyncNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresourceasync/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncNonResourceOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncNonResourceOptions.Sku)
	}
	return req, nil
}

// putAsyncNonResourceHandleError handles the PutAsyncNonResource error response.
func (client *lrOSOperations) putAsyncNonResourceHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncRetryFailed - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PutAsyncRetryFailed(ctx context.Context, lrOSPutAsyncRetryFailedOptions *LrOSPutAsyncRetryFailedOptions) (*ProductResponse, error) {
	req, err := client.putAsyncRetryFailedCreateRequest(lrOSPutAsyncRetryFailedOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.putAsyncRetryFailedHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncRetryFailedCreateRequest creates the PutAsyncRetryFailed request.
func (client *lrOSOperations) putAsyncRetryFailedCreateRequest(lrOSPutAsyncRetryFailedOptions *LrOSPutAsyncRetryFailedOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/failed"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncRetryFailedOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncRetryFailedOptions.Product)
	}
	return req, nil
}

// putAsyncRetryFailedHandleError handles the PutAsyncRetryFailed error response.
func (client *lrOSOperations) putAsyncRetryFailedHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncRetrySucceeded - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrOSOperations) PutAsyncRetrySucceeded(ctx context.Context, lrOSPutAsyncRetrySucceededOptions *LrOSPutAsyncRetrySucceededOptions) (*ProductResponse, error) {
	req, err := client.putAsyncRetrySucceededCreateRequest(lrOSPutAsyncRetrySucceededOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.putAsyncRetrySucceededHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncRetrySucceededCreateRequest creates the PutAsyncRetrySucceeded request.
func (client *lrOSOperations) putAsyncRetrySucceededCreateRequest(lrOSPutAsyncRetrySucceededOptions *LrOSPutAsyncRetrySucceededOptions) (*azcore.Request, error) {
	urlPath := "/lro/putasync/retry/succeeded"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncRetrySucceededOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncRetrySucceededOptions.Product)
	}
	return req, nil
}

// putAsyncRetrySucceededHandleError handles the PutAsyncRetrySucceeded error response.
func (client *lrOSOperations) putAsyncRetrySucceededHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutAsyncSubResource - Long running put request with sub resource.
func (client *lrOSOperations) PutAsyncSubResource(ctx context.Context, lrOSPutAsyncSubResourceOptions *LrOSPutAsyncSubResourceOptions) (*SubProductResponse, error) {
	req, err := client.putAsyncSubResourceCreateRequest(lrOSPutAsyncSubResourceOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("subProductPoller", resp, client.putAsyncSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &subProductPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putAsyncSubResourceCreateRequest creates the PutAsyncSubResource request.
func (client *lrOSOperations) putAsyncSubResourceCreateRequest(lrOSPutAsyncSubResourceOptions *LrOSPutAsyncSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresourceasync/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutAsyncSubResourceOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutAsyncSubResourceOptions.Product)
	}
	return req, nil
}

// putAsyncSubResourceHandleError handles the PutAsyncSubResource error response.
func (client *lrOSOperations) putAsyncSubResourceHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutNoHeaderInRetry - Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
func (client *lrOSOperations) PutNoHeaderInRetry(ctx context.Context, lrOSPutNoHeaderInRetryOptions *LrOSPutNoHeaderInRetryOptions) (*ProductResponse, error) {
	req, err := client.putNoHeaderInRetryCreateRequest(lrOSPutNoHeaderInRetryOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("productPoller", resp, client.putNoHeaderInRetryHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

// putNoHeaderInRetryCreateRequest creates the PutNoHeaderInRetry request.
func (client *lrOSOperations) putNoHeaderInRetryCreateRequest(lrOSPutNoHeaderInRetryOptions *LrOSPutNoHeaderInRetryOptions) (*azcore.Request, error) {
	urlPath := "/lro/put/noheader/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutNoHeaderInRetryOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutNoHeaderInRetryOptions.Product)
	}
	return req, nil
}

// putNoHeaderInRetryHandleError handles the PutNoHeaderInRetry error response.
func (client *lrOSOperations) putNoHeaderInRetryHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutNonResource - Long running put request with non resource.
func (client *lrOSOperations) PutNonResource(ctx context.Context, lrOSPutNonResourceOptions *LrOSPutNonResourceOptions) (*SkuResponse, error) {
	req, err := client.putNonResourceCreateRequest(lrOSPutNonResourceOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("skuPoller", resp, client.putNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &skuPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

func (client *lrOSOperations) ResumeSkuPoller(token string) (SkuPoller, error) {
	pt, err := resumePollingTracker("skuPoller", token, client.putNonResourceHandleError)
	if err != nil {
		return nil, err
	}
	return &skuPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// putNonResourceCreateRequest creates the PutNonResource request.
func (client *lrOSOperations) putNonResourceCreateRequest(lrOSPutNonResourceOptions *LrOSPutNonResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putnonresource/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutNonResourceOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutNonResourceOptions.Sku)
	}
	return req, nil
}

// putNonResourceHandleError handles the PutNonResource error response.
func (client *lrOSOperations) putNonResourceHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutSubResource - Long running put request with sub resource.
func (client *lrOSOperations) PutSubResource(ctx context.Context, lrOSPutSubResourceOptions *LrOSPutSubResourceOptions) (*SubProductResponse, error) {
	req, err := client.putSubResourceCreateRequest(lrOSPutSubResourceOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker("subProductPoller", resp, client.putSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	poller := &subProductPoller{
		pt:       pt,
		pipeline: client.p,
	}
	return poller.FinalResponse(ctx)
}

func (client *lrOSOperations) ResumeSubProductPoller(token string) (SubProductPoller, error) {
	pt, err := resumePollingTracker("subProductPoller", token, client.putSubResourceHandleError)
	if err != nil {
		return nil, err
	}
	return &subProductPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// putSubResourceCreateRequest creates the PutSubResource request.
func (client *lrOSOperations) putSubResourceCreateRequest(lrOSPutSubResourceOptions *LrOSPutSubResourceOptions) (*azcore.Request, error) {
	urlPath := "/lro/putsubresource/202/200"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrOSPutSubResourceOptions != nil {
		return req, req.MarshalAsJSON(lrOSPutSubResourceOptions.Product)
	}
	return req, nil
}

// putSubResourceHandleError handles the PutSubResource error response.
func (client *lrOSOperations) putSubResourceHandleError(resp *azcore.Response) error {
	err := CloudError{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
