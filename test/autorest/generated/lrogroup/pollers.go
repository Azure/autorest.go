// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"encoding/json"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// LrOSCustomHeaderPost202Retry200Poller provides polling facilities until the operation completes
type LrOSCustomHeaderPost202Retry200Poller interface {
	Poll(context.Context) bool
	Response() (*LrOSCustomHeaderPost202Retry200Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPost202Retry200Response, error)
}

type lrOSCustomHeaderPost202Retry200Poller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSCustomHeaderPost202Retry200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSCustomHeaderPost202Retry200Poller) Response() (*LrOSCustomHeaderPost202Retry200Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSCustomHeaderPost202Retry200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSCustomHeaderPost202Retry200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPost202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPost202Retry200Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSCustomHeaderPost202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPost202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSCustomHeaderPostAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSCustomHeaderPostAsyncRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error)
}

type lrOSCustomHeaderPostAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) Response() (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSCustomHeaderPostAsyncRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSCustomHeaderPut201CreatingSucceeded200Poller provides polling facilities until the operation completes
type LrOSCustomHeaderPut201CreatingSucceeded200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSCustomHeaderPut201CreatingSucceeded200Poller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put201CreatingSucceeded200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSCustomHeaderPut201CreatingSucceeded200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSCustomHeaderPutAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSCustomHeaderPutAsyncRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSCustomHeaderPutAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSCustomHeaderPutAsyncRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDelete202NoRetry204Poller provides polling facilities until the operation completes
type LrOSDelete202NoRetry204Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDelete202NoRetry204Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDelete202NoRetry204Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDelete202NoRetry204Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete202NoRetry204HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDelete202NoRetry204Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDelete202NoRetry204Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDelete202NoRetry204Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDelete202NoRetry204Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDelete202NoRetry204Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDelete202Retry200Poller provides polling facilities until the operation completes
type LrOSDelete202Retry200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDelete202Retry200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDelete202Retry200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDelete202Retry200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDelete202Retry200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDelete202Retry200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDelete202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDelete202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDelete202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDelete204SucceededPoller provides polling facilities until the operation completes
type LrOSDelete204SucceededPoller interface {
	Poll(context.Context) bool
	Response() (*http.Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error)
}

type lrOSDelete204SucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDelete204SucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDelete204SucceededPoller) Response() (*http.Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete204SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDelete204SucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDelete204SucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDelete204SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDelete204SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDelete204SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncNoHeaderInRetryPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSDeleteAsyncNoHeaderInRetryResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error)
}

type lrOSDeleteAsyncNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) Response() (*LrOSDeleteAsyncNoHeaderInRetryResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteAsyncNoHeaderInRetryPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncNoRetrySucceededPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncNoRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSDeleteAsyncNoRetrySucceededResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoRetrySucceededResponse, error)
}

type lrOSDeleteAsyncNoRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) Response() (*LrOSDeleteAsyncNoRetrySucceededResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncNoRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteAsyncNoRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoRetrySucceededResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncRetryFailedPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncRetryFailedPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSDeleteAsyncRetryFailedResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetryFailedResponse, error)
}

type lrOSDeleteAsyncRetryFailedPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteAsyncRetryFailedPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteAsyncRetryFailedPoller) Response() (*LrOSDeleteAsyncRetryFailedResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRetryFailedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteAsyncRetryFailedPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteAsyncRetryFailedPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncRetryFailedPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetryFailedResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteAsyncRetryFailedPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncRetryFailedPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSDeleteAsyncRetrySucceededResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrySucceededResponse, error)
}

type lrOSDeleteAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteAsyncRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteAsyncRetrySucceededPoller) Response() (*LrOSDeleteAsyncRetrySucceededResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteAsyncRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrySucceededResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncRetrycanceledPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncRetrycanceledPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSDeleteAsyncRetrycanceledResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrycanceledResponse, error)
}

type lrOSDeleteAsyncRetrycanceledPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteAsyncRetrycanceledPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteAsyncRetrycanceledPoller) Response() (*LrOSDeleteAsyncRetrycanceledResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRetrycanceledHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteAsyncRetrycanceledPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteAsyncRetrycanceledPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncRetrycanceledPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrycanceledResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteAsyncRetrycanceledPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncRetrycanceledPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSDeleteNoHeaderInRetryPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSDeleteNoHeaderInRetryResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteNoHeaderInRetryResponse, error)
}

type lrOSDeleteNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteNoHeaderInRetryPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteNoHeaderInRetryPoller) Response() (*LrOSDeleteNoHeaderInRetryResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteNoHeaderInRetryPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteNoHeaderInRetryPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteNoHeaderInRetryResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation completes
type LrOSDeleteProvisioning202Accepted200SucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDeleteProvisioning202Accepted200SucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteProvisioning202Accepted200SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteProvisioning202Accepted200SucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteProvisioning202DeletingFailed200Poller provides polling facilities until the operation completes
type LrOSDeleteProvisioning202DeletingFailed200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDeleteProvisioning202DeletingFailed200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteProvisioning202DeletingFailed200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteProvisioning202DeletingFailed200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteProvisioning202Deletingcanceled200Poller provides polling facilities until the operation completes
type LrOSDeleteProvisioning202Deletingcanceled200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDeleteProvisioning202Deletingcanceled200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteProvisioning202Deletingcanceled200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSDeleteProvisioning202Deletingcanceled200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPost200WithPayloadPoller provides polling facilities until the operation completes
type LrOSPost200WithPayloadPoller interface {
	Poll(context.Context) bool
	Response() (*SkuResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error)
}

type lrOSPost200WithPayloadPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPost200WithPayloadPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPost200WithPayloadPoller) Response() (*SkuResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post200WithPayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPost200WithPayloadPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPost200WithPayloadPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPost200WithPayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPost200WithPayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPost200WithPayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPost202NoRetry204Poller provides polling facilities until the operation completes
type LrOSPost202NoRetry204Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPost202NoRetry204Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPost202NoRetry204Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPost202NoRetry204Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202NoRetry204HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPost202NoRetry204Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPost202NoRetry204Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPost202NoRetry204Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPost202NoRetry204Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPost202NoRetry204Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPost202Retry200Poller provides polling facilities until the operation completes
type LrOSPost202Retry200Poller interface {
	Poll(context.Context) bool
	Response() (*LrOSPost202Retry200Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPost202Retry200Response, error)
}

type lrOSPost202Retry200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPost202Retry200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPost202Retry200Poller) Response() (*LrOSPost202Retry200Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPost202Retry200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPost202Retry200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPost202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPost202Retry200Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPost202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPost202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncNoRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPostAsyncNoRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostAsyncNoRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostAsyncNoRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostAsyncNoRetrySucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncNoRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostAsyncNoRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncNoRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostAsyncNoRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncNoRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncRetryFailedPoller provides polling facilities until the operation completes
type LrOSPostAsyncRetryFailedPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSPostAsyncRetryFailedResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetryFailedResponse, error)
}

type lrOSPostAsyncRetryFailedPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostAsyncRetryFailedPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostAsyncRetryFailedPoller) Response() (*LrOSPostAsyncRetryFailedResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRetryFailedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostAsyncRetryFailedPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostAsyncRetryFailedPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncRetryFailedPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetryFailedResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostAsyncRetryFailedPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncRetryFailedPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPostAsyncRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostAsyncRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostAsyncRetrySucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostAsyncRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncRetrycanceledPoller provides polling facilities until the operation completes
type LrOSPostAsyncRetrycanceledPoller interface {
	Poll(context.Context) bool
	Response() (*LrOSPostAsyncRetrycanceledResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetrycanceledResponse, error)
}

type lrOSPostAsyncRetrycanceledPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostAsyncRetrycanceledPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostAsyncRetrycanceledPoller) Response() (*LrOSPostAsyncRetrycanceledResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRetrycanceledHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostAsyncRetrycanceledPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostAsyncRetrycanceledPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncRetrycanceledPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetrycanceledResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostAsyncRetrycanceledPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncRetrycanceledPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller provides polling facilities until the operation completes
type LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostDoubleHeadersFinalAzureHeaderGetPoller provides polling facilities until the operation completes
type LrOSPostDoubleHeadersFinalAzureHeaderGetPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostDoubleHeadersFinalAzureHeaderGetPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postDoubleHeadersFinalAzureHeaderGetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostDoubleHeadersFinalAzureHeaderGetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostDoubleHeadersFinalLocationGetPoller provides polling facilities until the operation completes
type LrOSPostDoubleHeadersFinalLocationGetPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostDoubleHeadersFinalLocationGetPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postDoubleHeadersFinalLocationGetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPostDoubleHeadersFinalLocationGetPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200Acceptedcanceled200Poller provides polling facilities until the operation completes
type LrOSPut200Acceptedcanceled200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200Acceptedcanceled200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut200Acceptedcanceled200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut200Acceptedcanceled200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put200Acceptedcanceled200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut200Acceptedcanceled200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut200Acceptedcanceled200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200Acceptedcanceled200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut200Acceptedcanceled200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200Acceptedcanceled200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200SucceededNoStatePoller provides polling facilities until the operation completes
type LrOSPut200SucceededNoStatePoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200SucceededNoStatePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut200SucceededNoStatePoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut200SucceededNoStatePoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put200SucceededNoStateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut200SucceededNoStatePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut200SucceededNoStatePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200SucceededNoStatePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut200SucceededNoStatePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200SucceededNoStatePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200SucceededPoller provides polling facilities until the operation completes
type LrOSPut200SucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200SucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut200SucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut200SucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put200SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut200SucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut200SucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut200SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200UpdatingSucceeded204Poller provides polling facilities until the operation completes
type LrOSPut200UpdatingSucceeded204Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200UpdatingSucceeded204Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut200UpdatingSucceeded204Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut200UpdatingSucceeded204Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put200UpdatingSucceeded204HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut200UpdatingSucceeded204Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut200UpdatingSucceeded204Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200UpdatingSucceeded204Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut200UpdatingSucceeded204Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200UpdatingSucceeded204Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut201CreatingFailed200Poller provides polling facilities until the operation completes
type LrOSPut201CreatingFailed200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut201CreatingFailed200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut201CreatingFailed200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut201CreatingFailed200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put201CreatingFailed200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut201CreatingFailed200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut201CreatingFailed200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut201CreatingFailed200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut201CreatingFailed200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut201CreatingFailed200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut201CreatingSucceeded200Poller provides polling facilities until the operation completes
type LrOSPut201CreatingSucceeded200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut201CreatingSucceeded200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut201CreatingSucceeded200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut201CreatingSucceeded200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put201CreatingSucceeded200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut201CreatingSucceeded200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut201CreatingSucceeded200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut201CreatingSucceeded200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut201CreatingSucceeded200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut202Retry200Poller provides polling facilities until the operation completes
type LrOSPut202Retry200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut202Retry200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPut202Retry200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPut202Retry200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPut202Retry200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPut202Retry200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPut202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSPutAsyncNoHeaderInRetryPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncNoHeaderInRetryPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncNoHeaderInRetryPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncNoHeaderInRetryPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNoRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPutAsyncNoRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncNoRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncNoRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncNoRetrySucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncNoRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncNoRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncNoRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNoRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncNoRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNoRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNoRetrycanceledPoller provides polling facilities until the operation completes
type LrOSPutAsyncNoRetrycanceledPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncNoRetrycanceledPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncNoRetrycanceledPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncNoRetrycanceledPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncNoRetrycanceledHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncNoRetrycanceledPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncNoRetrycanceledPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNoRetrycanceledPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncNoRetrycanceledPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNoRetrycanceledPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNonResourcePoller provides polling facilities until the operation completes
type LrOSPutAsyncNonResourcePoller interface {
	Poll(context.Context) bool
	Response() (*SkuResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error)
}

type lrOSPutAsyncNonResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncNonResourcePoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncNonResourcePoller) Response() (*SkuResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncNonResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncNonResourcePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncNonResourcePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNonResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncNonResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNonResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncRetryFailedPoller provides polling facilities until the operation completes
type LrOSPutAsyncRetryFailedPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncRetryFailedPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncRetryFailedPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncRetryFailedPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRetryFailedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncRetryFailedPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncRetryFailedPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncRetryFailedPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncRetryFailedPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncRetryFailedPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPutAsyncRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncRetrySucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncSubResourcePoller provides polling facilities until the operation completes
type LrOSPutAsyncSubResourcePoller interface {
	Poll(context.Context) bool
	Response() (*SubProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error)
}

type lrOSPutAsyncSubResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutAsyncSubResourcePoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutAsyncSubResourcePoller) Response() (*SubProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncSubResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutAsyncSubResourcePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutAsyncSubResourcePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncSubResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutAsyncSubResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncSubResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSPutNoHeaderInRetryPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutNoHeaderInRetryPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutNoHeaderInRetryPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutNoHeaderInRetryPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutNoHeaderInRetryPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutNonResourcePoller provides polling facilities until the operation completes
type LrOSPutNonResourcePoller interface {
	Poll(context.Context) bool
	Response() (*SkuResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error)
}

type lrOSPutNonResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutNonResourcePoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutNonResourcePoller) Response() (*SkuResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putNonResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutNonResourcePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutNonResourcePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutNonResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutNonResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutNonResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutSubResourcePoller provides polling facilities until the operation completes
type LrOSPutSubResourcePoller interface {
	Poll(context.Context) bool
	Response() (*SubProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error)
}

type lrOSPutSubResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrOSPutSubResourcePoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrOSPutSubResourcePoller) Response() (*SubProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putSubResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrOSPutSubResourcePoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrOSPutSubResourcePoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutSubResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrOSPutSubResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutSubResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysDelete202Retry200Poller provides polling facilities until the operation completes
type LroRetrysDelete202Retry200Poller interface {
	Poll(context.Context) bool
	Response() (*LroRetrysDelete202Retry200Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDelete202Retry200Response, error)
}

type lroRetrysDelete202Retry200Poller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysDelete202Retry200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysDelete202Retry200Poller) Response() (*LroRetrysDelete202Retry200Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysDelete202Retry200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysDelete202Retry200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysDelete202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDelete202Retry200Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysDelete202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysDelete202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysDeleteAsyncRelativeRetrySucceededPoller provides polling facilities until the operation completes
type LroRetrysDeleteAsyncRelativeRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error)
}

type lroRetrysDeleteAsyncRelativeRetrySucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) Response() (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRelativeRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysDeleteAsyncRelativeRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation completes
type LroRetrysDeleteProvisioning202Accepted200SucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lroRetrysDeleteProvisioning202Accepted200SucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteProvisioning202Accepted200SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysDeleteProvisioning202Accepted200SucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPost202Retry200Poller provides polling facilities until the operation completes
type LroRetrysPost202Retry200Poller interface {
	Poll(context.Context) bool
	Response() (*LroRetrysPost202Retry200Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPost202Retry200Response, error)
}

type lroRetrysPost202Retry200Poller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysPost202Retry200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysPost202Retry200Poller) Response() (*LroRetrysPost202Retry200Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysPost202Retry200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysPost202Retry200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPost202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPost202Retry200Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysPost202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPost202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPostAsyncRelativeRetrySucceededPoller provides polling facilities until the operation completes
type LroRetrysPostAsyncRelativeRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error)
}

type lroRetrysPostAsyncRelativeRetrySucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) Response() (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRelativeRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysPostAsyncRelativeRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPut201CreatingSucceeded200Poller provides polling facilities until the operation completes
type LroRetrysPut201CreatingSucceeded200Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lroRetrysPut201CreatingSucceeded200Poller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysPut201CreatingSucceeded200Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysPut201CreatingSucceeded200Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put201CreatingSucceeded200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysPut201CreatingSucceeded200Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysPut201CreatingSucceeded200Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPut201CreatingSucceeded200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysPut201CreatingSucceeded200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPut201CreatingSucceeded200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPutAsyncRelativeRetrySucceededPoller provides polling facilities until the operation completes
type LroRetrysPutAsyncRelativeRetrySucceededPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lroRetrysPutAsyncRelativeRetrySucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRelativeRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLroRetrysPutAsyncRelativeRetrySucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDelete202NonRetry400Poller provides polling facilities until the operation completes
type LrosaDsDelete202NonRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDelete202NonRetry400Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202NonRetry400Response, error)
}

type lrosaDsDelete202NonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDelete202NonRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDelete202NonRetry400Poller) Response() (*LrosaDsDelete202NonRetry400Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete202NonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDelete202NonRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDelete202NonRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDelete202NonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202NonRetry400Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDelete202NonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDelete202NonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDelete202RetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsDelete202RetryInvalidHeaderPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDelete202RetryInvalidHeaderResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202RetryInvalidHeaderResponse, error)
}

type lrosaDsDelete202RetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) Response() (*LrosaDsDelete202RetryInvalidHeaderResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete202RetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDelete202RetryInvalidHeaderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202RetryInvalidHeaderResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDelete204SucceededPoller provides polling facilities until the operation completes
type LrosaDsDelete204SucceededPoller interface {
	Poll(context.Context) bool
	Response() (*http.Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error)
}

type lrosaDsDelete204SucceededPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDelete204SucceededPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDelete204SucceededPoller) Response() (*http.Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.delete204SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDelete204SucceededPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDelete204SucceededPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDelete204SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDelete204SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDelete204SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetry400Poller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDeleteAsyncRelativeRetry400Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetry400Response, error)
}

type lrosaDsDeleteAsyncRelativeRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) Response() (*LrosaDsDeleteAsyncRelativeRetry400Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRelativeRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDeleteAsyncRelativeRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetry400Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error)
}

type lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) Response() (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRelativeRetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error)
}

type lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Response() (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetryNoStatusPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error)
}

type lrosaDsDeleteAsyncRelativeRetryNoStatusPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) Response() (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteAsyncRelativeRetryNoStatusHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDeleteAsyncRelativeRetryNoStatusPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteNonRetry400Poller provides polling facilities until the operation completes
type LrosaDsDeleteNonRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsDeleteNonRetry400Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteNonRetry400Response, error)
}

type lrosaDsDeleteNonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsDeleteNonRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsDeleteNonRetry400Poller) Response() (*LrosaDsDeleteNonRetry400Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.deleteNonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsDeleteNonRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsDeleteNonRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteNonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteNonRetry400Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsDeleteNonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteNonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPost202NoLocationPoller provides polling facilities until the operation completes
type LrosaDsPost202NoLocationPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPost202NoLocationResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NoLocationResponse, error)
}

type lrosaDsPost202NoLocationPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPost202NoLocationPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPost202NoLocationPoller) Response() (*LrosaDsPost202NoLocationResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202NoLocationHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPost202NoLocationPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPost202NoLocationPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPost202NoLocationPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NoLocationResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPost202NoLocationPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPost202NoLocationPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPost202NonRetry400Poller provides polling facilities until the operation completes
type LrosaDsPost202NonRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPost202NonRetry400Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NonRetry400Response, error)
}

type lrosaDsPost202NonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPost202NonRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPost202NonRetry400Poller) Response() (*LrosaDsPost202NonRetry400Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202NonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPost202NonRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPost202NonRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPost202NonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NonRetry400Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPost202NonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPost202NonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPost202RetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsPost202RetryInvalidHeaderPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPost202RetryInvalidHeaderResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202RetryInvalidHeaderResponse, error)
}

type lrosaDsPost202RetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPost202RetryInvalidHeaderPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPost202RetryInvalidHeaderPoller) Response() (*LrosaDsPost202RetryInvalidHeaderResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.post202RetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPost202RetryInvalidHeaderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPost202RetryInvalidHeaderPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPost202RetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202RetryInvalidHeaderResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPost202RetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPost202RetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetry400Poller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPostAsyncRelativeRetry400Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetry400Response, error)
}

type lrosaDsPostAsyncRelativeRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPostAsyncRelativeRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPostAsyncRelativeRetry400Poller) Response() (*LrosaDsPostAsyncRelativeRetry400Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRelativeRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPostAsyncRelativeRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPostAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetry400Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error)
}

type lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) Response() (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRelativeRetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPostAsyncRelativeRetryInvalidHeaderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error)
}

type lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) Response() (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetryNoPayloadPoller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetryNoPayloadPoller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error)
}

type lrosaDsPostAsyncRelativeRetryNoPayloadPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) Response() (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postAsyncRelativeRetryNoPayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPostAsyncRelativeRetryNoPayloadPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostNonRetry400Poller provides polling facilities until the operation completes
type LrosaDsPostNonRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*LrosaDsPostNonRetry400Response, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostNonRetry400Response, error)
}

type lrosaDsPostNonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPostNonRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPostNonRetry400Poller) Response() (*LrosaDsPostNonRetry400Response, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.postNonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPostNonRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPostNonRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostNonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostNonRetry400Response, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPostNonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostNonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPut200InvalidJsonPoller provides polling facilities until the operation completes
type LrosaDsPut200InvalidJsonPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPut200InvalidJSONPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPut200InvalidJSONPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPut200InvalidJSONPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.put200InvalidJsonHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPut200InvalidJsonPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPut200InvalidJSONPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPut200InvalidJSONPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPut200InvalidJSONPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPut200InvalidJSONPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetry400Poller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutAsyncRelativeRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutAsyncRelativeRetry400Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRelativeRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutAsyncRelativeRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutAsyncRelativeRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRelativeRetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutAsyncRelativeRetryInvalidHeaderPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRelativeRetryNoStatusPayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryNoStatusPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryNoStatusPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putAsyncRelativeRetryNoStatusHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutAsyncRelativeRetryNoStatusPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutError201NoProvisioningStatePayloadPoller provides polling facilities until the operation completes
type LrosaDsPutError201NoProvisioningStatePayloadPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutError201NoProvisioningStatePayloadPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putError201NoProvisioningStatePayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutError201NoProvisioningStatePayloadPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutNonRetry201Creating400InvalidJsonPoller provides polling facilities until the operation completes
type LrosaDsPutNonRetry201Creating400InvalidJsonPoller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutNonRetry201Creating400InvalidJSONPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putNonRetry201Creating400InvalidJsonHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutNonRetry201Creating400InvalidJsonPoller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutNonRetry201Creating400Poller provides polling facilities until the operation completes
type LrosaDsPutNonRetry201Creating400Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutNonRetry201Creating400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutNonRetry201Creating400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutNonRetry201Creating400Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putNonRetry201Creating400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutNonRetry201Creating400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutNonRetry201Creating400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutNonRetry201Creating400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutNonRetry201Creating400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutNonRetry201Creating400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutNonRetry400Poller provides polling facilities until the operation completes
type LrosaDsPutNonRetry400Poller interface {
	Poll(context.Context) bool
	Response() (*ProductResponse, error)
	ResumeToken() (string, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutNonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Poll returns false if there was an error or polling has reached a terminal state
func (p *lrosaDsPutNonRetry400Poller) Poll(ctx context.Context) bool {
	done, err := p.done(ctx)
	if err != nil {
		return false
	}
	return !done
}

// Response returns the latest response that is stored from the latest polling operation
func (p *lrosaDsPutNonRetry400Poller) Response() (*ProductResponse, error) {
	resp := p.response()
	if resp == nil {
		return nil, errors.New("did not find a response on the poller")
	}
	result, err := p.client.putNonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ResumeToken generates the string token that can be used with the ResumeLrosaDsPutNonRetry400Poller method
// on the client to create a new poller from the data held in the current poller type
func (p *lrosaDsPutNonRetry400Poller) ResumeToken() (string, error) {
	if p.pt.hasTerminated() {
		return "", errors.New("cannot create a ResumeToken from a poller in a terminal state")
	}
	js, err := json.Marshal(p.pt)
	if err != nil {
		return "", err
	}
	return string(js), nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutNonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for p.Poll(context.Background()) {
		if delay := p.response().RetryAfter(); delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
	return p.Response()
}

// response returns the last HTTP response.
func (p *lrosaDsPutNonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutNonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}
