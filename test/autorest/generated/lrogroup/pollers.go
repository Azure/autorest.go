// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// LrOSCustomHeaderPost202Retry200Poller provides polling facilities until the operation completes
type LrOSCustomHeaderPost202Retry200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSCustomHeaderPost202Retry200Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPost202Retry200Response, error)
}

type lrOSCustomHeaderPost202Retry200Poller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSCustomHeaderPost202Retry200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSCustomHeaderPost202Retry200Poller) ID() string {
	return ""
}

func (p *lrOSCustomHeaderPost202Retry200Poller) Poll(ctx context.Context) (*LrOSCustomHeaderPost202Retry200Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPost202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPost202Retry200Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSCustomHeaderPost202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPost202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSCustomHeaderPostAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSCustomHeaderPostAsyncRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error)
}

type lrOSCustomHeaderPostAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) Poll(ctx context.Context) (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSCustomHeaderPostAsyncRetrySucceededResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPostAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSCustomHeaderPut201CreatingSucceeded200Poller provides polling facilities until the operation completes
type LrOSCustomHeaderPut201CreatingSucceeded200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSCustomHeaderPut201CreatingSucceeded200Poller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) ID() string {
	return ""
}

func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put201CreatingSucceeded200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPut201CreatingSucceeded200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSCustomHeaderPutAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSCustomHeaderPutAsyncRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSCustomHeaderPutAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSCustomHeaderOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSCustomHeaderPutAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDelete202NoRetry204Poller provides polling facilities until the operation completes
type LrOSDelete202NoRetry204Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDelete202NoRetry204Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDelete202NoRetry204Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDelete202NoRetry204Poller) ID() string {
	return ""
}

func (p *lrOSDelete202NoRetry204Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete202NoRetry204HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDelete202NoRetry204Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDelete202NoRetry204Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDelete202NoRetry204Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDelete202Retry200Poller provides polling facilities until the operation completes
type LrOSDelete202Retry200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDelete202Retry200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDelete202Retry200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDelete202Retry200Poller) ID() string {
	return ""
}

func (p *lrOSDelete202Retry200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDelete202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDelete202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDelete202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDelete204SucceededPoller provides polling facilities until the operation completes
type LrOSDelete204SucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*http.Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error)
}

type lrOSDelete204SucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDelete204SucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDelete204SucceededPoller) ID() string {
	return ""
}

func (p *lrOSDelete204SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete204SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDelete204SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDelete204SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDelete204SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncNoHeaderInRetryPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error)
}

type lrOSDeleteAsyncNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) ID() string {
	return ""
}

func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoHeaderInRetryResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncNoRetrySucceededPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncNoRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSDeleteAsyncNoRetrySucceededResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoRetrySucceededResponse, error)
}

type lrOSDeleteAsyncNoRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSDeleteAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*LrOSDeleteAsyncNoRetrySucceededResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncNoRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncNoRetrySucceededResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncNoRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncRetryFailedPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncRetryFailedPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSDeleteAsyncRetryFailedResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetryFailedResponse, error)
}

type lrOSDeleteAsyncRetryFailedPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteAsyncRetryFailedPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteAsyncRetryFailedPoller) ID() string {
	return ""
}

func (p *lrOSDeleteAsyncRetryFailedPoller) Poll(ctx context.Context) (*LrOSDeleteAsyncRetryFailedResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRetryFailedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncRetryFailedPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetryFailedResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteAsyncRetryFailedPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncRetryFailedPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSDeleteAsyncRetrySucceededResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrySucceededResponse, error)
}

type lrOSDeleteAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteAsyncRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteAsyncRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSDeleteAsyncRetrySucceededPoller) Poll(ctx context.Context) (*LrOSDeleteAsyncRetrySucceededResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrySucceededResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteAsyncRetrycanceledPoller provides polling facilities until the operation completes
type LrOSDeleteAsyncRetrycanceledPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSDeleteAsyncRetrycanceledResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrycanceledResponse, error)
}

type lrOSDeleteAsyncRetrycanceledPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteAsyncRetrycanceledPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteAsyncRetrycanceledPoller) ID() string {
	return ""
}

func (p *lrOSDeleteAsyncRetrycanceledPoller) Poll(ctx context.Context) (*LrOSDeleteAsyncRetrycanceledResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRetrycanceledHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteAsyncRetrycanceledPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteAsyncRetrycanceledResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteAsyncRetrycanceledPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteAsyncRetrycanceledPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSDeleteNoHeaderInRetryPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSDeleteNoHeaderInRetryResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteNoHeaderInRetryResponse, error)
}

type lrOSDeleteNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteNoHeaderInRetryPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteNoHeaderInRetryPoller) ID() string {
	return ""
}

func (p *lrOSDeleteNoHeaderInRetryPoller) Poll(ctx context.Context) (*LrOSDeleteNoHeaderInRetryResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSDeleteNoHeaderInRetryResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation completes
type LrOSDeleteProvisioning202Accepted200SucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDeleteProvisioning202Accepted200SucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) ID() string {
	return ""
}

func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteProvisioning202Accepted200SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteProvisioning202Accepted200SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteProvisioning202DeletingFailed200Poller provides polling facilities until the operation completes
type LrOSDeleteProvisioning202DeletingFailed200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDeleteProvisioning202DeletingFailed200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) ID() string {
	return ""
}

func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteProvisioning202DeletingFailed200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteProvisioning202DeletingFailed200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSDeleteProvisioning202Deletingcanceled200Poller provides polling facilities until the operation completes
type LrOSDeleteProvisioning202Deletingcanceled200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSDeleteProvisioning202Deletingcanceled200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) ID() string {
	return ""
}

func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteProvisioning202Deletingcanceled200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSDeleteProvisioning202Deletingcanceled200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPost200WithPayloadPoller provides polling facilities until the operation completes
type LrOSPost200WithPayloadPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*SkuResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error)
}

type lrOSPost200WithPayloadPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPost200WithPayloadPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPost200WithPayloadPoller) ID() string {
	return ""
}

func (p *lrOSPost200WithPayloadPoller) Poll(ctx context.Context) (*SkuResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post200WithPayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPost200WithPayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPost200WithPayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPost200WithPayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPost202NoRetry204Poller provides polling facilities until the operation completes
type LrOSPost202NoRetry204Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPost202NoRetry204Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPost202NoRetry204Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPost202NoRetry204Poller) ID() string {
	return ""
}

func (p *lrOSPost202NoRetry204Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202NoRetry204HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPost202NoRetry204Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPost202NoRetry204Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPost202NoRetry204Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPost202Retry200Poller provides polling facilities until the operation completes
type LrOSPost202Retry200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSPost202Retry200Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPost202Retry200Response, error)
}

type lrOSPost202Retry200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPost202Retry200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPost202Retry200Poller) ID() string {
	return ""
}

func (p *lrOSPost202Retry200Poller) Poll(ctx context.Context) (*LrOSPost202Retry200Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPost202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPost202Retry200Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPost202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPost202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncNoRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPostAsyncNoRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostAsyncNoRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostAsyncNoRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSPostAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncNoRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncNoRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostAsyncNoRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncNoRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncRetryFailedPoller provides polling facilities until the operation completes
type LrOSPostAsyncRetryFailedPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSPostAsyncRetryFailedResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetryFailedResponse, error)
}

type lrOSPostAsyncRetryFailedPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostAsyncRetryFailedPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostAsyncRetryFailedPoller) ID() string {
	return ""
}

func (p *lrOSPostAsyncRetryFailedPoller) Poll(ctx context.Context) (*LrOSPostAsyncRetryFailedResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRetryFailedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncRetryFailedPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetryFailedResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostAsyncRetryFailedPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncRetryFailedPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPostAsyncRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostAsyncRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostAsyncRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSPostAsyncRetrySucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostAsyncRetrycanceledPoller provides polling facilities until the operation completes
type LrOSPostAsyncRetrycanceledPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrOSPostAsyncRetrycanceledResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetrycanceledResponse, error)
}

type lrOSPostAsyncRetrycanceledPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostAsyncRetrycanceledPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostAsyncRetrycanceledPoller) ID() string {
	return ""
}

func (p *lrOSPostAsyncRetrycanceledPoller) Poll(ctx context.Context) (*LrOSPostAsyncRetrycanceledResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRetrycanceledHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostAsyncRetrycanceledPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrOSPostAsyncRetrycanceledResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostAsyncRetrycanceledPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostAsyncRetrycanceledPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller provides polling facilities until the operation completes
type LrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) ID() string {
	return ""
}

func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postDoubleHeadersFinalAzureHeaderGetDefaultHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetDefaultPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostDoubleHeadersFinalAzureHeaderGetPoller provides polling facilities until the operation completes
type LrOSPostDoubleHeadersFinalAzureHeaderGetPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostDoubleHeadersFinalAzureHeaderGetPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) ID() string {
	return ""
}

func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postDoubleHeadersFinalAzureHeaderGetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostDoubleHeadersFinalAzureHeaderGetPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPostDoubleHeadersFinalLocationGetPoller provides polling facilities until the operation completes
type LrOSPostDoubleHeadersFinalLocationGetPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPostDoubleHeadersFinalLocationGetPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) ID() string {
	return ""
}

func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postDoubleHeadersFinalLocationGetHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPostDoubleHeadersFinalLocationGetPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200Acceptedcanceled200Poller provides polling facilities until the operation completes
type LrOSPut200Acceptedcanceled200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200Acceptedcanceled200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut200Acceptedcanceled200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut200Acceptedcanceled200Poller) ID() string {
	return ""
}

func (p *lrOSPut200Acceptedcanceled200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put200Acceptedcanceled200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200Acceptedcanceled200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut200Acceptedcanceled200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200Acceptedcanceled200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200SucceededNoStatePoller provides polling facilities until the operation completes
type LrOSPut200SucceededNoStatePoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200SucceededNoStatePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut200SucceededNoStatePoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut200SucceededNoStatePoller) ID() string {
	return ""
}

func (p *lrOSPut200SucceededNoStatePoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put200SucceededNoStateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200SucceededNoStatePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut200SucceededNoStatePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200SucceededNoStatePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200SucceededPoller provides polling facilities until the operation completes
type LrOSPut200SucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200SucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut200SucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut200SucceededPoller) ID() string {
	return ""
}

func (p *lrOSPut200SucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put200SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut200SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut200UpdatingSucceeded204Poller provides polling facilities until the operation completes
type LrOSPut200UpdatingSucceeded204Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut200UpdatingSucceeded204Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut200UpdatingSucceeded204Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut200UpdatingSucceeded204Poller) ID() string {
	return ""
}

func (p *lrOSPut200UpdatingSucceeded204Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put200UpdatingSucceeded204HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut200UpdatingSucceeded204Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut200UpdatingSucceeded204Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut200UpdatingSucceeded204Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut201CreatingFailed200Poller provides polling facilities until the operation completes
type LrOSPut201CreatingFailed200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut201CreatingFailed200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut201CreatingFailed200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut201CreatingFailed200Poller) ID() string {
	return ""
}

func (p *lrOSPut201CreatingFailed200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put201CreatingFailed200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut201CreatingFailed200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut201CreatingFailed200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut201CreatingFailed200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut201CreatingSucceeded200Poller provides polling facilities until the operation completes
type LrOSPut201CreatingSucceeded200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut201CreatingSucceeded200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut201CreatingSucceeded200Poller) ID() string {
	return ""
}

func (p *lrOSPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put201CreatingSucceeded200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut201CreatingSucceeded200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut201CreatingSucceeded200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut201CreatingSucceeded200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPut202Retry200Poller provides polling facilities until the operation completes
type LrOSPut202Retry200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPut202Retry200Poller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPut202Retry200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPut202Retry200Poller) ID() string {
	return ""
}

func (p *lrOSPut202Retry200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPut202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPut202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPut202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSPutAsyncNoHeaderInRetryPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncNoHeaderInRetryPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncNoHeaderInRetryPoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncNoHeaderInRetryPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNoRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPutAsyncNoRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncNoRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncNoRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncNoRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncNoRetrySucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncNoRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNoRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncNoRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNoRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNoRetrycanceledPoller provides polling facilities until the operation completes
type LrOSPutAsyncNoRetrycanceledPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncNoRetrycanceledPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncNoRetrycanceledPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncNoRetrycanceledPoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncNoRetrycanceledPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncNoRetrycanceledHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNoRetrycanceledPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncNoRetrycanceledPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNoRetrycanceledPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncNonResourcePoller provides polling facilities until the operation completes
type LrOSPutAsyncNonResourcePoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*SkuResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error)
}

type lrOSPutAsyncNonResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncNonResourcePoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncNonResourcePoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncNonResourcePoller) Poll(ctx context.Context) (*SkuResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncNonResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncNonResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncNonResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncNonResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncRetryFailedPoller provides polling facilities until the operation completes
type LrOSPutAsyncRetryFailedPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncRetryFailedPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncRetryFailedPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncRetryFailedPoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncRetryFailedPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRetryFailedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncRetryFailedPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncRetryFailedPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncRetryFailedPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncRetrySucceededPoller provides polling facilities until the operation completes
type LrOSPutAsyncRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutAsyncRetrySucceededPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncRetrySucceededPoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncRetrySucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutAsyncSubResourcePoller provides polling facilities until the operation completes
type LrOSPutAsyncSubResourcePoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*SubProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error)
}

type lrOSPutAsyncSubResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutAsyncSubResourcePoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutAsyncSubResourcePoller) ID() string {
	return ""
}

func (p *lrOSPutAsyncSubResourcePoller) Poll(ctx context.Context) (*SubProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncSubResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutAsyncSubResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutAsyncSubResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutAsyncSubResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutNoHeaderInRetryPoller provides polling facilities until the operation completes
type LrOSPutNoHeaderInRetryPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrOSPutNoHeaderInRetryPoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutNoHeaderInRetryPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutNoHeaderInRetryPoller) ID() string {
	return ""
}

func (p *lrOSPutNoHeaderInRetryPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putNoHeaderInRetryHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutNoHeaderInRetryPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutNoHeaderInRetryPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutNoHeaderInRetryPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutNonResourcePoller provides polling facilities until the operation completes
type LrOSPutNonResourcePoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*SkuResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error)
}

type lrOSPutNonResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutNonResourcePoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutNonResourcePoller) ID() string {
	return ""
}

func (p *lrOSPutNonResourcePoller) Poll(ctx context.Context) (*SkuResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putNonResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutNonResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SkuResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutNonResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutNonResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrOSPutSubResourcePoller provides polling facilities until the operation completes
type LrOSPutSubResourcePoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*SubProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error)
}

type lrOSPutSubResourcePoller struct {
	// the client for making the request
	client *lrOSOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrOSPutSubResourcePoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrOSPutSubResourcePoller) ID() string {
	return ""
}

func (p *lrOSPutSubResourcePoller) Poll(ctx context.Context) (*SubProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putSubResourceHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrOSPutSubResourcePoller) Wait(ctx context.Context, pollingInterval time.Duration) (*SubProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrOSPutSubResourcePoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrOSPutSubResourcePoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysDelete202Retry200Poller provides polling facilities until the operation completes
type LroRetrysDelete202Retry200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LroRetrysDelete202Retry200Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDelete202Retry200Response, error)
}

type lroRetrysDelete202Retry200Poller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysDelete202Retry200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysDelete202Retry200Poller) ID() string {
	return ""
}

func (p *lroRetrysDelete202Retry200Poller) Poll(ctx context.Context) (*LroRetrysDelete202Retry200Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysDelete202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDelete202Retry200Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysDelete202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysDelete202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysDeleteAsyncRelativeRetrySucceededPoller provides polling facilities until the operation completes
type LroRetrysDeleteAsyncRelativeRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error)
}

type lroRetrysDeleteAsyncRelativeRetrySucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) ID() string {
	return ""
}

func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRelativeRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysDeleteAsyncRelativeRetrySucceededResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysDeleteAsyncRelativeRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysDeleteProvisioning202Accepted200SucceededPoller provides polling facilities until the operation completes
type LroRetrysDeleteProvisioning202Accepted200SucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lroRetrysDeleteProvisioning202Accepted200SucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) ID() string {
	return ""
}

func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteProvisioning202Accepted200SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysDeleteProvisioning202Accepted200SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPost202Retry200Poller provides polling facilities until the operation completes
type LroRetrysPost202Retry200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LroRetrysPost202Retry200Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPost202Retry200Response, error)
}

type lroRetrysPost202Retry200Poller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysPost202Retry200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysPost202Retry200Poller) ID() string {
	return ""
}

func (p *lroRetrysPost202Retry200Poller) Poll(ctx context.Context) (*LroRetrysPost202Retry200Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202Retry200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPost202Retry200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPost202Retry200Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysPost202Retry200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPost202Retry200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPostAsyncRelativeRetrySucceededPoller provides polling facilities until the operation completes
type LroRetrysPostAsyncRelativeRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error)
}

type lroRetrysPostAsyncRelativeRetrySucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) ID() string {
	return ""
}

func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRelativeRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LroRetrysPostAsyncRelativeRetrySucceededResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPostAsyncRelativeRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPut201CreatingSucceeded200Poller provides polling facilities until the operation completes
type LroRetrysPut201CreatingSucceeded200Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lroRetrysPut201CreatingSucceeded200Poller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysPut201CreatingSucceeded200Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysPut201CreatingSucceeded200Poller) ID() string {
	return ""
}

func (p *lroRetrysPut201CreatingSucceeded200Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put201CreatingSucceeded200HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPut201CreatingSucceeded200Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysPut201CreatingSucceeded200Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPut201CreatingSucceeded200Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LroRetrysPutAsyncRelativeRetrySucceededPoller provides polling facilities until the operation completes
type LroRetrysPutAsyncRelativeRetrySucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lroRetrysPutAsyncRelativeRetrySucceededPoller struct {
	// the client for making the request
	client *lroRetrysOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) ID() string {
	return ""
}

func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRelativeRetrySucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lroRetrysPutAsyncRelativeRetrySucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDelete202NonRetry400Poller provides polling facilities until the operation completes
type LrosaDsDelete202NonRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDelete202NonRetry400Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202NonRetry400Response, error)
}

type lrosaDsDelete202NonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDelete202NonRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDelete202NonRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsDelete202NonRetry400Poller) Poll(ctx context.Context) (*LrosaDsDelete202NonRetry400Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete202NonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDelete202NonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202NonRetry400Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDelete202NonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDelete202NonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDelete202RetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsDelete202RetryInvalidHeaderPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDelete202RetryInvalidHeaderResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202RetryInvalidHeaderResponse, error)
}

type lrosaDsDelete202RetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) ID() string {
	return ""
}

func (p *lrosaDsDelete202RetryInvalidHeaderPoller) Poll(ctx context.Context) (*LrosaDsDelete202RetryInvalidHeaderResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete202RetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDelete202RetryInvalidHeaderResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDelete202RetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDelete204SucceededPoller provides polling facilities until the operation completes
type LrosaDsDelete204SucceededPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*http.Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error)
}

type lrosaDsDelete204SucceededPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDelete204SucceededPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDelete204SucceededPoller) ID() string {
	return ""
}

func (p *lrosaDsDelete204SucceededPoller) Poll(ctx context.Context) (*http.Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.delete204SucceededHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDelete204SucceededPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*http.Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDelete204SucceededPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDelete204SucceededPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetry400Poller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDeleteAsyncRelativeRetry400Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetry400Response, error)
}

type lrosaDsDeleteAsyncRelativeRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*LrosaDsDeleteAsyncRelativeRetry400Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRelativeRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetry400Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error)
}

type lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) ID() string {
	return ""
}

func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRelativeRetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error)
}

type lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) ID() string {
	return ""
}

func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation completes
type LrosaDsDeleteAsyncRelativeRetryNoStatusPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error)
}

type lrosaDsDeleteAsyncRelativeRetryNoStatusPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) ID() string {
	return ""
}

func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteAsyncRelativeRetryNoStatusHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteAsyncRelativeRetryNoStatusPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsDeleteNonRetry400Poller provides polling facilities until the operation completes
type LrosaDsDeleteNonRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsDeleteNonRetry400Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteNonRetry400Response, error)
}

type lrosaDsDeleteNonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsDeleteNonRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsDeleteNonRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsDeleteNonRetry400Poller) Poll(ctx context.Context) (*LrosaDsDeleteNonRetry400Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.deleteNonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsDeleteNonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsDeleteNonRetry400Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsDeleteNonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsDeleteNonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPost202NoLocationPoller provides polling facilities until the operation completes
type LrosaDsPost202NoLocationPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPost202NoLocationResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NoLocationResponse, error)
}

type lrosaDsPost202NoLocationPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPost202NoLocationPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPost202NoLocationPoller) ID() string {
	return ""
}

func (p *lrosaDsPost202NoLocationPoller) Poll(ctx context.Context) (*LrosaDsPost202NoLocationResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202NoLocationHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPost202NoLocationPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NoLocationResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPost202NoLocationPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPost202NoLocationPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPost202NonRetry400Poller provides polling facilities until the operation completes
type LrosaDsPost202NonRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPost202NonRetry400Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NonRetry400Response, error)
}

type lrosaDsPost202NonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPost202NonRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPost202NonRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsPost202NonRetry400Poller) Poll(ctx context.Context) (*LrosaDsPost202NonRetry400Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202NonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPost202NonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202NonRetry400Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPost202NonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPost202NonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPost202RetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsPost202RetryInvalidHeaderPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPost202RetryInvalidHeaderResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202RetryInvalidHeaderResponse, error)
}

type lrosaDsPost202RetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPost202RetryInvalidHeaderPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPost202RetryInvalidHeaderPoller) ID() string {
	return ""
}

func (p *lrosaDsPost202RetryInvalidHeaderPoller) Poll(ctx context.Context) (*LrosaDsPost202RetryInvalidHeaderResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.post202RetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPost202RetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPost202RetryInvalidHeaderResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPost202RetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPost202RetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetry400Poller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPostAsyncRelativeRetry400Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetry400Response, error)
}

type lrosaDsPostAsyncRelativeRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPostAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPostAsyncRelativeRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsPostAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*LrosaDsPostAsyncRelativeRetry400Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRelativeRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetry400Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error)
}

type lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) ID() string {
	return ""
}

func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRelativeRetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error)
}

type lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) ID() string {
	return ""
}

func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostAsyncRelativeRetryNoPayloadPoller provides polling facilities until the operation completes
type LrosaDsPostAsyncRelativeRetryNoPayloadPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error)
}

type lrosaDsPostAsyncRelativeRetryNoPayloadPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) ID() string {
	return ""
}

func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) Poll(ctx context.Context) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postAsyncRelativeRetryNoPayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostAsyncRelativeRetryNoPayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPostNonRetry400Poller provides polling facilities until the operation completes
type LrosaDsPostNonRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*LrosaDsPostNonRetry400Response, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostNonRetry400Response, error)
}

type lrosaDsPostNonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPostNonRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPostNonRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsPostNonRetry400Poller) Poll(ctx context.Context) (*LrosaDsPostNonRetry400Response, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.postNonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPostNonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*LrosaDsPostNonRetry400Response, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPostNonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPostNonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPut200InvalidJsonPoller provides polling facilities until the operation completes
type LrosaDsPut200InvalidJsonPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPut200InvalidJSONPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPut200InvalidJSONPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPut200InvalidJSONPoller) ID() string {
	return ""
}

func (p *lrosaDsPut200InvalidJSONPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.put200InvalidJsonHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPut200InvalidJSONPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPut200InvalidJSONPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPut200InvalidJSONPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetry400Poller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutAsyncRelativeRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutAsyncRelativeRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsPutAsyncRelativeRetry400Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRelativeRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) ID() string {
	return ""
}

func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRelativeRetryInvalidHeaderHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) ID() string {
	return ""
}

func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) ID() string {
	return ""
}

func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRelativeRetryNoStatusPayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutAsyncRelativeRetryNoStatusPoller provides polling facilities until the operation completes
type LrosaDsPutAsyncRelativeRetryNoStatusPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutAsyncRelativeRetryNoStatusPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) ID() string {
	return ""
}

func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putAsyncRelativeRetryNoStatusHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutAsyncRelativeRetryNoStatusPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutError201NoProvisioningStatePayloadPoller provides polling facilities until the operation completes
type LrosaDsPutError201NoProvisioningStatePayloadPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutError201NoProvisioningStatePayloadPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) ID() string {
	return ""
}

func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putError201NoProvisioningStatePayloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutError201NoProvisioningStatePayloadPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutNonRetry201Creating400InvalidJsonPoller provides polling facilities until the operation completes
type LrosaDsPutNonRetry201Creating400InvalidJsonPoller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutNonRetry201Creating400InvalidJSONPoller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) ID() string {
	return ""
}

func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putNonRetry201Creating400InvalidJsonHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutNonRetry201Creating400InvalidJSONPoller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutNonRetry201Creating400Poller provides polling facilities until the operation completes
type LrosaDsPutNonRetry201Creating400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutNonRetry201Creating400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutNonRetry201Creating400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutNonRetry201Creating400Poller) ID() string {
	return ""
}

func (p *lrosaDsPutNonRetry201Creating400Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putNonRetry201Creating400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutNonRetry201Creating400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutNonRetry201Creating400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutNonRetry201Creating400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}

// LrosaDsPutNonRetry400Poller provides polling facilities until the operation completes
type LrosaDsPutNonRetry400Poller interface {
	Done() bool
	ID() string
	Poll(context.Context) (*ProductResponse, error)
	Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error)
}

type lrosaDsPutNonRetry400Poller struct {
	// the client for making the request
	client *lrosaDsOperations
	// polling tracker
	pt pollingTracker
}

// Done returns true if the polling operation has terminated either in a success case or failure case,
// otherwise it will return false
func (p *lrosaDsPutNonRetry400Poller) Done() bool {
	return p.pt.hasTerminated()
}

// ID ...
func (p *lrosaDsPutNonRetry400Poller) ID() string {
	return ""
}

func (p *lrosaDsPutNonRetry400Poller) Poll(ctx context.Context) (*ProductResponse, error) {
	if done, err := p.done(ctx); !done || err != nil {
		return nil, err
	}
	resp := p.response()
	result, err := p.client.putNonRetry400HandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Wait will continue to poll until a terminal state is reached or an error is encountered. Wait will use the
// duration specified in the retry-after header, if the header is not specified then the pollingInterval that
// is specified will be used to wait between polling requests.
func (p *lrosaDsPutNonRetry400Poller) Wait(ctx context.Context, pollingInterval time.Duration) (*ProductResponse, error) {
	for {
		resp, err := p.Poll(context.Background())
		if err != nil {
			return nil, err
		}
		if p.Done() {
			return resp, err
		}
		if delay, found := p.response().RetryAfter(); found && delay > 0 {
			time.Sleep(delay)
		} else {
			time.Sleep(pollingInterval)
		}
	}
}

// Response returns the last HTTP response.
func (p *lrosaDsPutNonRetry400Poller) response() *azcore.Response {
	return p.pt.latestResponse()
}

// done queries the service to see if the operation has completed.
func (p *lrosaDsPutNonRetry400Poller) done(ctx context.Context) (done bool, err error) {
	if p.pt.hasTerminated() {
		return true, p.pt.pollingError()
	}
	if err := p.pt.pollForStatus(ctx, p.client.p); err != nil {
		return false, err
	}
	if err := p.pt.checkForErrors(); err != nil {
		return p.pt.hasTerminated(), err
	}
	if err := p.pt.updatePollingState(p.pt.provisioningStateApplicable()); err != nil {
		return false, err
	}
	if err := p.pt.initPollingMethod(); err != nil {
		return false, err
	}
	if err := p.pt.updatePollingMethod(); err != nil {
		return false, err
	}
	return p.pt.hasTerminated(), p.pt.pollingError()
}
