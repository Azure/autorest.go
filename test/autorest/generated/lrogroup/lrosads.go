// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package lrogroup

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"strconv"
	"strings"
)

// LrosaDsOperations contains the methods for the LrosaDs group.
type LrosaDsOperations interface {
	// BeginDelete202NonRetry400 - Long running delete request, service returns a 202 with a location header
	BeginDelete202NonRetry400(ctx context.Context) (LrosaDsDelete202NonRetry400Poller, error)
	// ResumeLrosaDsDelete202NonRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDelete202NonRetry400Poller(id string) (LrosaDsDelete202NonRetry400Poller, error)
	// BeginDelete202RetryInvalidHeader - Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers
	BeginDelete202RetryInvalidHeader(ctx context.Context) (LrosaDsDelete202RetryInvalidHeaderPoller, error)
	// ResumeLrosaDsDelete202RetryInvalidHeaderPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDelete202RetryInvalidHeaderPoller(id string) (LrosaDsDelete202RetryInvalidHeaderPoller, error)
	// BeginDelete204Succeeded - Long running delete request, service returns a 204 to the initial request, indicating success.
	BeginDelete204Succeeded(ctx context.Context) (LrosaDsDelete204SucceededPoller, error)
	// ResumeLrosaDsDelete204SucceededPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDelete204SucceededPoller(id string) (LrosaDsDelete204SucceededPoller, error)
	// BeginDeleteAsyncRelativeRetry400 - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRelativeRetry400(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetry400Poller, error)
	// ResumeLrosaDsDeleteAsyncRelativeRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDeleteAsyncRelativeRetry400Poller(id string) (LrosaDsDeleteAsyncRelativeRetry400Poller, error)
	// BeginDeleteAsyncRelativeRetryInvalidHeader - Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid
	BeginDeleteAsyncRelativeRetryInvalidHeader(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller, error)
	// ResumeLrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller(id string) (LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller, error)
	// BeginDeleteAsyncRelativeRetryInvalidJSONPolling - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller, error)
	// ResumeLrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller(id string) (LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller, error)
	// BeginDeleteAsyncRelativeRetryNoStatus - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginDeleteAsyncRelativeRetryNoStatus(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetryNoStatusPoller, error)
	// ResumeLrosaDsDeleteAsyncRelativeRetryNoStatusPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDeleteAsyncRelativeRetryNoStatusPoller(id string) (LrosaDsDeleteAsyncRelativeRetryNoStatusPoller, error)
	// BeginDeleteNonRetry400 - Long running delete request, service returns a 400 with an error body
	BeginDeleteNonRetry400(ctx context.Context) (LrosaDsDeleteNonRetry400Poller, error)
	// ResumeLrosaDsDeleteNonRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsDeleteNonRetry400Poller(id string) (LrosaDsDeleteNonRetry400Poller, error)
	// BeginPost202NoLocation - Long running post request, service returns a 202 to the initial request, without a location header.
	BeginPost202NoLocation(ctx context.Context, lrosaDsPost202NoLocationOptions *LrosaDsPost202NoLocationOptions) (LrosaDsPost202NoLocationPoller, error)
	// ResumeLrosaDsPost202NoLocationPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPost202NoLocationPoller(id string) (LrosaDsPost202NoLocationPoller, error)
	// BeginPost202NonRetry400 - Long running post request, service returns a 202 with a location header
	BeginPost202NonRetry400(ctx context.Context, lrosaDsPost202NonRetry400Options *LrosaDsPost202NonRetry400Options) (LrosaDsPost202NonRetry400Poller, error)
	// ResumeLrosaDsPost202NonRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPost202NonRetry400Poller(id string) (LrosaDsPost202NonRetry400Poller, error)
	// BeginPost202RetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
	BeginPost202RetryInvalidHeader(ctx context.Context, lrosaDsPost202RetryInvalidHeaderOptions *LrosaDsPost202RetryInvalidHeaderOptions) (LrosaDsPost202RetryInvalidHeaderPoller, error)
	// ResumeLrosaDsPost202RetryInvalidHeaderPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPost202RetryInvalidHeaderPoller(id string) (LrosaDsPost202RetryInvalidHeaderPoller, error)
	// BeginPostAsyncRelativeRetry400 - Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncRelativeRetry400(ctx context.Context, lrosaDsPostAsyncRelativeRetry400Options *LrosaDsPostAsyncRelativeRetry400Options) (LrosaDsPostAsyncRelativeRetry400Poller, error)
	// ResumeLrosaDsPostAsyncRelativeRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPostAsyncRelativeRetry400Poller(id string) (LrosaDsPostAsyncRelativeRetry400Poller, error)
	// BeginPostAsyncRelativeRetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
	BeginPostAsyncRelativeRetryInvalidHeader(ctx context.Context, lrosaDsPostAsyncRelativeRetryInvalidHeaderOptions *LrosaDsPostAsyncRelativeRetryInvalidHeaderOptions) (LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller, error)
	// ResumeLrosaDsPostAsyncRelativeRetryInvalidHeaderPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPostAsyncRelativeRetryInvalidHeaderPoller(id string) (LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller, error)
	// BeginPostAsyncRelativeRetryInvalidJSONPolling - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, lrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptions *LrosaDsPostAsyncRelativeRetryInvalidJSONPollingOptions) (LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller, error)
	// ResumeLrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller(id string) (LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller, error)
	// BeginPostAsyncRelativeRetryNoPayload - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPostAsyncRelativeRetryNoPayload(ctx context.Context, lrosaDsPostAsyncRelativeRetryNoPayloadOptions *LrosaDsPostAsyncRelativeRetryNoPayloadOptions) (LrosaDsPostAsyncRelativeRetryNoPayloadPoller, error)
	// ResumeLrosaDsPostAsyncRelativeRetryNoPayloadPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPostAsyncRelativeRetryNoPayloadPoller(id string) (LrosaDsPostAsyncRelativeRetryNoPayloadPoller, error)
	// BeginPostNonRetry400 - Long running post request, service returns a 400 with no error body
	BeginPostNonRetry400(ctx context.Context, lrosaDsPostNonRetry400Options *LrosaDsPostNonRetry400Options) (LrosaDsPostNonRetry400Poller, error)
	// ResumeLrosaDsPostNonRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPostNonRetry400Poller(id string) (LrosaDsPostNonRetry400Poller, error)
	// BeginPut200InvalidJSON - Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json
	BeginPut200InvalidJSON(ctx context.Context, lrosaDsPut200InvalidJsonOptions *LrosaDsPut200InvalidJSONOptions) (LrosaDsPut200InvalidJsonPoller, error)
	// ResumeLrosaDsPut200InvalidJsonPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPut200InvalidJsonPoller(id string) (LrosaDsPut200InvalidJsonPoller, error)
	// BeginPutAsyncRelativeRetry400 - Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncRelativeRetry400(ctx context.Context, lrosaDsPutAsyncRelativeRetry400Options *LrosaDsPutAsyncRelativeRetry400Options) (LrosaDsPutAsyncRelativeRetry400Poller, error)
	// ResumeLrosaDsPutAsyncRelativeRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutAsyncRelativeRetry400Poller(id string) (LrosaDsPutAsyncRelativeRetry400Poller, error)
	// BeginPutAsyncRelativeRetryInvalidHeader - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
	BeginPutAsyncRelativeRetryInvalidHeader(ctx context.Context, lrosaDsPutAsyncRelativeRetryInvalidHeaderOptions *LrosaDsPutAsyncRelativeRetryInvalidHeaderOptions) (LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller, error)
	// ResumeLrosaDsPutAsyncRelativeRetryInvalidHeaderPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutAsyncRelativeRetryInvalidHeaderPoller(id string) (LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller, error)
	// BeginPutAsyncRelativeRetryInvalidJSONPolling - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, lrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptions *LrosaDsPutAsyncRelativeRetryInvalidJSONPollingOptions) (LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller, error)
	// ResumeLrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller(id string) (LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller, error)
	// BeginPutAsyncRelativeRetryNoStatus - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncRelativeRetryNoStatus(ctx context.Context, lrosaDsPutAsyncRelativeRetryNoStatusOptions *LrosaDsPutAsyncRelativeRetryNoStatusOptions) (LrosaDsPutAsyncRelativeRetryNoStatusPoller, error)
	// ResumeLrosaDsPutAsyncRelativeRetryNoStatusPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutAsyncRelativeRetryNoStatusPoller(id string) (LrosaDsPutAsyncRelativeRetryNoStatusPoller, error)
	// BeginPutAsyncRelativeRetryNoStatusPayload - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
	BeginPutAsyncRelativeRetryNoStatusPayload(ctx context.Context, lrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions *LrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions) (LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller, error)
	// ResumeLrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller(id string) (LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller, error)
	// BeginPutError201NoProvisioningStatePayload - Long running put request, service returns a 201 to the initial request with no payload
	BeginPutError201NoProvisioningStatePayload(ctx context.Context, lrosaDsPutError201NoProvisioningStatePayloadOptions *LrosaDsPutError201NoProvisioningStatePayloadOptions) (LrosaDsPutError201NoProvisioningStatePayloadPoller, error)
	// ResumeLrosaDsPutError201NoProvisioningStatePayloadPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutError201NoProvisioningStatePayloadPoller(id string) (LrosaDsPutError201NoProvisioningStatePayloadPoller, error)
	// BeginPutNonRetry201Creating400 - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code
	BeginPutNonRetry201Creating400(ctx context.Context, lrosaDsPutNonRetry201Creating400Options *LrosaDsPutNonRetry201Creating400Options) (LrosaDsPutNonRetry201Creating400Poller, error)
	// ResumeLrosaDsPutNonRetry201Creating400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutNonRetry201Creating400Poller(id string) (LrosaDsPutNonRetry201Creating400Poller, error)
	// BeginPutNonRetry201Creating400InvalidJSON - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code
	BeginPutNonRetry201Creating400InvalidJSON(ctx context.Context, lrosaDsPutNonRetry201Creating400InvalidJsonOptions *LrosaDsPutNonRetry201Creating400InvalidJSONOptions) (LrosaDsPutNonRetry201Creating400InvalidJsonPoller, error)
	// ResumeLrosaDsPutNonRetry201Creating400InvalidJsonPoller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutNonRetry201Creating400InvalidJsonPoller(id string) (LrosaDsPutNonRetry201Creating400InvalidJsonPoller, error)
	// BeginPutNonRetry400 - Long running put request, service returns a 400 to the initial request
	BeginPutNonRetry400(ctx context.Context, lrosaDsPutNonRetry400Options *LrosaDsPutNonRetry400Options) (LrosaDsPutNonRetry400Poller, error)
	// ResumeLrosaDsPutNonRetry400Poller - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeLrosaDsPutNonRetry400Poller(id string) (LrosaDsPutNonRetry400Poller, error)
}

// lrosaDsOperations implements the LrosaDsOperations interface.
type lrosaDsOperations struct {
	*Client
}

// Delete202NonRetry400 - Long running delete request, service returns a 202 with a location header
func (client *lrosaDsOperations) BeginDelete202NonRetry400(ctx context.Context) (LrosaDsDelete202NonRetry400Poller, error) {
	req, err := client.delete202NonRetry400CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDelete202NonRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDelete202NonRetry400Poller(id string) (LrosaDsDelete202NonRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDelete202NonRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDelete202NonRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDelete202NonRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// delete202NonRetry400CreateRequest creates the Delete202NonRetry400 request.
func (client *lrosaDsOperations) delete202NonRetry400CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/delete/202/retry/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete202NonRetry400HandleResponse handles the Delete202NonRetry400 response.
func (client *lrosaDsOperations) delete202NonRetry400HandleResponse(resp *azcore.Response) (*LrosaDsDelete202NonRetry400Response, error) {
	result := LrosaDsDelete202NonRetry400Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// Delete202RetryInvalidHeader - Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers
func (client *lrosaDsOperations) BeginDelete202RetryInvalidHeader(ctx context.Context) (LrosaDsDelete202RetryInvalidHeaderPoller, error) {
	req, err := client.delete202RetryInvalidHeaderCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDelete202RetryInvalidHeaderPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDelete202RetryInvalidHeaderPoller(id string) (LrosaDsDelete202RetryInvalidHeaderPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDelete202RetryInvalidHeaderPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDelete202RetryInvalidHeaderPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDelete202RetryInvalidHeaderPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// delete202RetryInvalidHeaderCreateRequest creates the Delete202RetryInvalidHeader request.
func (client *lrosaDsOperations) delete202RetryInvalidHeaderCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/error/delete/202/retry/invalidheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete202RetryInvalidHeaderHandleResponse handles the Delete202RetryInvalidHeader response.
func (client *lrosaDsOperations) delete202RetryInvalidHeaderHandleResponse(resp *azcore.Response) (*LrosaDsDelete202RetryInvalidHeaderResponse, error) {
	result := LrosaDsDelete202RetryInvalidHeaderResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// Delete204Succeeded - Long running delete request, service returns a 204 to the initial request, indicating success.
func (client *lrosaDsOperations) BeginDelete204Succeeded(ctx context.Context) (LrosaDsDelete204SucceededPoller, error) {
	req, err := client.delete204SucceededCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDelete204SucceededPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDelete204SucceededPoller(id string) (LrosaDsDelete204SucceededPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDelete204SucceededPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDelete204SucceededPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDelete204SucceededPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// delete204SucceededCreateRequest creates the Delete204Succeeded request.
func (client *lrosaDsOperations) delete204SucceededCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/error/delete/204/nolocation"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// delete204SucceededHandleResponse handles the Delete204Succeeded response.
func (client *lrosaDsOperations) delete204SucceededHandleResponse(resp *azcore.Response) (*http.Response, error) {
	return resp.Response, nil
}

// DeleteAsyncRelativeRetry400 - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginDeleteAsyncRelativeRetry400(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetry400Poller, error) {
	req, err := client.deleteAsyncRelativeRetry400CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDeleteAsyncRelativeRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDeleteAsyncRelativeRetry400Poller(id string) (LrosaDsDeleteAsyncRelativeRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDeleteAsyncRelativeRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// deleteAsyncRelativeRetry400CreateRequest creates the DeleteAsyncRelativeRetry400 request.
func (client *lrosaDsOperations) deleteAsyncRelativeRetry400CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/deleteasync/retry/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRelativeRetry400HandleResponse handles the DeleteAsyncRelativeRetry400 response.
func (client *lrosaDsOperations) deleteAsyncRelativeRetry400HandleResponse(resp *azcore.Response) (*LrosaDsDeleteAsyncRelativeRetry400Response, error) {
	result := LrosaDsDeleteAsyncRelativeRetry400Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteAsyncRelativeRetryInvalidHeader - Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid
func (client *lrosaDsOperations) BeginDeleteAsyncRelativeRetryInvalidHeader(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller, error) {
	req, err := client.deleteAsyncRelativeRetryInvalidHeaderCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller(id string) (LrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetryInvalidHeaderPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// deleteAsyncRelativeRetryInvalidHeaderCreateRequest creates the DeleteAsyncRelativeRetryInvalidHeader request.
func (client *lrosaDsOperations) deleteAsyncRelativeRetryInvalidHeaderCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/invalidheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRelativeRetryInvalidHeaderHandleResponse handles the DeleteAsyncRelativeRetryInvalidHeader response.
func (client *lrosaDsOperations) deleteAsyncRelativeRetryInvalidHeaderHandleResponse(resp *azcore.Response) (*LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse, error) {
	result := LrosaDsDeleteAsyncRelativeRetryInvalidHeaderResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteAsyncRelativeRetryInvalidJSONPolling - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginDeleteAsyncRelativeRetryInvalidJSONPolling(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller, error) {
	req, err := client.deleteAsyncRelativeRetryInvalidJsonPollingCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller(id string) (LrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetryInvalidJsonPollingPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// deleteAsyncRelativeRetryInvalidJsonPollingCreateRequest creates the DeleteAsyncRelativeRetryInvalidJSONPolling request.
func (client *lrosaDsOperations) deleteAsyncRelativeRetryInvalidJsonPollingCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/invalidjsonpolling"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRelativeRetryInvalidJsonPollingHandleResponse handles the DeleteAsyncRelativeRetryInvalidJSONPolling response.
func (client *lrosaDsOperations) deleteAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp *azcore.Response) (*LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	result := LrosaDsDeleteAsyncRelativeRetryInvalidJSONPollingResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteAsyncRelativeRetryNoStatus - Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginDeleteAsyncRelativeRetryNoStatus(ctx context.Context) (LrosaDsDeleteAsyncRelativeRetryNoStatusPoller, error) {
	req, err := client.deleteAsyncRelativeRetryNoStatusCreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDeleteAsyncRelativeRetryNoStatusPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDeleteAsyncRelativeRetryNoStatusPoller(id string) (LrosaDsDeleteAsyncRelativeRetryNoStatusPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetryNoStatusPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDeleteAsyncRelativeRetryNoStatusPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDeleteAsyncRelativeRetryNoStatusPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// deleteAsyncRelativeRetryNoStatusCreateRequest creates the DeleteAsyncRelativeRetryNoStatus request.
func (client *lrosaDsOperations) deleteAsyncRelativeRetryNoStatusCreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/error/deleteasync/retry/nostatus"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteAsyncRelativeRetryNoStatusHandleResponse handles the DeleteAsyncRelativeRetryNoStatus response.
func (client *lrosaDsOperations) deleteAsyncRelativeRetryNoStatusHandleResponse(resp *azcore.Response) (*LrosaDsDeleteAsyncRelativeRetryNoStatusResponse, error) {
	result := LrosaDsDeleteAsyncRelativeRetryNoStatusResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// DeleteNonRetry400 - Long running delete request, service returns a 400 with an error body
func (client *lrosaDsOperations) BeginDeleteNonRetry400(ctx context.Context) (LrosaDsDeleteNonRetry400Poller, error) {
	req, err := client.deleteNonRetry400CreateRequest()
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsDeleteNonRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsDeleteNonRetry400Poller(id string) (LrosaDsDeleteNonRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsDeleteNonRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsDeleteNonRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsDeleteNonRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// deleteNonRetry400CreateRequest creates the DeleteNonRetry400 request.
func (client *lrosaDsOperations) deleteNonRetry400CreateRequest() (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/delete/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteNonRetry400HandleResponse handles the DeleteNonRetry400 response.
func (client *lrosaDsOperations) deleteNonRetry400HandleResponse(resp *azcore.Response) (*LrosaDsDeleteNonRetry400Response, error) {
	result := LrosaDsDeleteNonRetry400Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// Post202NoLocation - Long running post request, service returns a 202 to the initial request, without a location header.
func (client *lrosaDsOperations) BeginPost202NoLocation(ctx context.Context, lrosaDsPost202NoLocationOptions *LrosaDsPost202NoLocationOptions) (LrosaDsPost202NoLocationPoller, error) {
	req, err := client.post202NoLocationCreateRequest(lrosaDsPost202NoLocationOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPost202NoLocationPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPost202NoLocationPoller(id string) (LrosaDsPost202NoLocationPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPost202NoLocationPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPost202NoLocationPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPost202NoLocationPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// post202NoLocationCreateRequest creates the Post202NoLocation request.
func (client *lrosaDsOperations) post202NoLocationCreateRequest(lrosaDsPost202NoLocationOptions *LrosaDsPost202NoLocationOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/post/202/nolocation"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPost202NoLocationOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPost202NoLocationOptions.Product)
	}
	return req, nil
}

// post202NoLocationHandleResponse handles the Post202NoLocation response.
func (client *lrosaDsOperations) post202NoLocationHandleResponse(resp *azcore.Response) (*LrosaDsPost202NoLocationResponse, error) {
	result := LrosaDsPost202NoLocationResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// Post202NonRetry400 - Long running post request, service returns a 202 with a location header
func (client *lrosaDsOperations) BeginPost202NonRetry400(ctx context.Context, lrosaDsPost202NonRetry400Options *LrosaDsPost202NonRetry400Options) (LrosaDsPost202NonRetry400Poller, error) {
	req, err := client.post202NonRetry400CreateRequest(lrosaDsPost202NonRetry400Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPost202NonRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPost202NonRetry400Poller(id string) (LrosaDsPost202NonRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPost202NonRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPost202NonRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPost202NonRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// post202NonRetry400CreateRequest creates the Post202NonRetry400 request.
func (client *lrosaDsOperations) post202NonRetry400CreateRequest(lrosaDsPost202NonRetry400Options *LrosaDsPost202NonRetry400Options) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/post/202/retry/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPost202NonRetry400Options != nil {
		return req, req.MarshalAsJSON(lrosaDsPost202NonRetry400Options.Product)
	}
	return req, nil
}

// post202NonRetry400HandleResponse handles the Post202NonRetry400 response.
func (client *lrosaDsOperations) post202NonRetry400HandleResponse(resp *azcore.Response) (*LrosaDsPost202NonRetry400Response, error) {
	result := LrosaDsPost202NonRetry400Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// Post202RetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
func (client *lrosaDsOperations) BeginPost202RetryInvalidHeader(ctx context.Context, lrosaDsPost202RetryInvalidHeaderOptions *LrosaDsPost202RetryInvalidHeaderOptions) (LrosaDsPost202RetryInvalidHeaderPoller, error) {
	req, err := client.post202RetryInvalidHeaderCreateRequest(lrosaDsPost202RetryInvalidHeaderOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPost202RetryInvalidHeaderPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPost202RetryInvalidHeaderPoller(id string) (LrosaDsPost202RetryInvalidHeaderPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPost202RetryInvalidHeaderPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPost202RetryInvalidHeaderPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPost202RetryInvalidHeaderPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// post202RetryInvalidHeaderCreateRequest creates the Post202RetryInvalidHeader request.
func (client *lrosaDsOperations) post202RetryInvalidHeaderCreateRequest(lrosaDsPost202RetryInvalidHeaderOptions *LrosaDsPost202RetryInvalidHeaderOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/post/202/retry/invalidheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPost202RetryInvalidHeaderOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPost202RetryInvalidHeaderOptions.Product)
	}
	return req, nil
}

// post202RetryInvalidHeaderHandleResponse handles the Post202RetryInvalidHeader response.
func (client *lrosaDsOperations) post202RetryInvalidHeaderHandleResponse(resp *azcore.Response) (*LrosaDsPost202RetryInvalidHeaderResponse, error) {
	result := LrosaDsPost202RetryInvalidHeaderResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostAsyncRelativeRetry400 - Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPostAsyncRelativeRetry400(ctx context.Context, lrosaDsPostAsyncRelativeRetry400Options *LrosaDsPostAsyncRelativeRetry400Options) (LrosaDsPostAsyncRelativeRetry400Poller, error) {
	req, err := client.postAsyncRelativeRetry400CreateRequest(lrosaDsPostAsyncRelativeRetry400Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPostAsyncRelativeRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPostAsyncRelativeRetry400Poller(id string) (LrosaDsPostAsyncRelativeRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPostAsyncRelativeRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// postAsyncRelativeRetry400CreateRequest creates the PostAsyncRelativeRetry400 request.
func (client *lrosaDsOperations) postAsyncRelativeRetry400CreateRequest(lrosaDsPostAsyncRelativeRetry400Options *LrosaDsPostAsyncRelativeRetry400Options) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/postasync/retry/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPostAsyncRelativeRetry400Options != nil {
		return req, req.MarshalAsJSON(lrosaDsPostAsyncRelativeRetry400Options.Product)
	}
	return req, nil
}

// postAsyncRelativeRetry400HandleResponse handles the PostAsyncRelativeRetry400 response.
func (client *lrosaDsOperations) postAsyncRelativeRetry400HandleResponse(resp *azcore.Response) (*LrosaDsPostAsyncRelativeRetry400Response, error) {
	result := LrosaDsPostAsyncRelativeRetry400Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostAsyncRelativeRetryInvalidHeader - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
func (client *lrosaDsOperations) BeginPostAsyncRelativeRetryInvalidHeader(ctx context.Context, lrosaDsPostAsyncRelativeRetryInvalidHeaderOptions *LrosaDsPostAsyncRelativeRetryInvalidHeaderOptions) (LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller, error) {
	req, err := client.postAsyncRelativeRetryInvalidHeaderCreateRequest(lrosaDsPostAsyncRelativeRetryInvalidHeaderOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPostAsyncRelativeRetryInvalidHeaderPoller(id string) (LrosaDsPostAsyncRelativeRetryInvalidHeaderPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetryInvalidHeaderPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPostAsyncRelativeRetryInvalidHeaderPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetryInvalidHeaderPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// postAsyncRelativeRetryInvalidHeaderCreateRequest creates the PostAsyncRelativeRetryInvalidHeader request.
func (client *lrosaDsOperations) postAsyncRelativeRetryInvalidHeaderCreateRequest(lrosaDsPostAsyncRelativeRetryInvalidHeaderOptions *LrosaDsPostAsyncRelativeRetryInvalidHeaderOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/postasync/retry/invalidheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPostAsyncRelativeRetryInvalidHeaderOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPostAsyncRelativeRetryInvalidHeaderOptions.Product)
	}
	return req, nil
}

// postAsyncRelativeRetryInvalidHeaderHandleResponse handles the PostAsyncRelativeRetryInvalidHeader response.
func (client *lrosaDsOperations) postAsyncRelativeRetryInvalidHeaderHandleResponse(resp *azcore.Response) (*LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse, error) {
	result := LrosaDsPostAsyncRelativeRetryInvalidHeaderResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostAsyncRelativeRetryInvalidJSONPolling - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPostAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, lrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptions *LrosaDsPostAsyncRelativeRetryInvalidJSONPollingOptions) (LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller, error) {
	req, err := client.postAsyncRelativeRetryInvalidJsonPollingCreateRequest(lrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller(id string) (LrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPostAsyncRelativeRetryInvalidJSONPollingPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetryInvalidJsonPollingPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// postAsyncRelativeRetryInvalidJsonPollingCreateRequest creates the PostAsyncRelativeRetryInvalidJSONPolling request.
func (client *lrosaDsOperations) postAsyncRelativeRetryInvalidJsonPollingCreateRequest(lrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptions *LrosaDsPostAsyncRelativeRetryInvalidJSONPollingOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/postasync/retry/invalidjsonpolling"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPostAsyncRelativeRetryInvalidJsonPollingOptions.Product)
	}
	return req, nil
}

// postAsyncRelativeRetryInvalidJsonPollingHandleResponse handles the PostAsyncRelativeRetryInvalidJSONPolling response.
func (client *lrosaDsOperations) postAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp *azcore.Response) (*LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse, error) {
	result := LrosaDsPostAsyncRelativeRetryInvalidJSONPollingResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostAsyncRelativeRetryNoPayload - Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPostAsyncRelativeRetryNoPayload(ctx context.Context, lrosaDsPostAsyncRelativeRetryNoPayloadOptions *LrosaDsPostAsyncRelativeRetryNoPayloadOptions) (LrosaDsPostAsyncRelativeRetryNoPayloadPoller, error) {
	req, err := client.postAsyncRelativeRetryNoPayloadCreateRequest(lrosaDsPostAsyncRelativeRetryNoPayloadOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPostAsyncRelativeRetryNoPayloadPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPostAsyncRelativeRetryNoPayloadPoller(id string) (LrosaDsPostAsyncRelativeRetryNoPayloadPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetryNoPayloadPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPostAsyncRelativeRetryNoPayloadPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPostAsyncRelativeRetryNoPayloadPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// postAsyncRelativeRetryNoPayloadCreateRequest creates the PostAsyncRelativeRetryNoPayload request.
func (client *lrosaDsOperations) postAsyncRelativeRetryNoPayloadCreateRequest(lrosaDsPostAsyncRelativeRetryNoPayloadOptions *LrosaDsPostAsyncRelativeRetryNoPayloadOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/postasync/retry/nopayload"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPostAsyncRelativeRetryNoPayloadOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPostAsyncRelativeRetryNoPayloadOptions.Product)
	}
	return req, nil
}

// postAsyncRelativeRetryNoPayloadHandleResponse handles the PostAsyncRelativeRetryNoPayload response.
func (client *lrosaDsOperations) postAsyncRelativeRetryNoPayloadHandleResponse(resp *azcore.Response) (*LrosaDsPostAsyncRelativeRetryNoPayloadResponse, error) {
	result := LrosaDsPostAsyncRelativeRetryNoPayloadResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Azure-AsyncOperation"); val != "" {
		result.AzureAsyncOperation = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// PostNonRetry400 - Long running post request, service returns a 400 with no error body
func (client *lrosaDsOperations) BeginPostNonRetry400(ctx context.Context, lrosaDsPostNonRetry400Options *LrosaDsPostNonRetry400Options) (LrosaDsPostNonRetry400Poller, error) {
	req, err := client.postNonRetry400CreateRequest(lrosaDsPostNonRetry400Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPostNonRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPostNonRetry400Poller(id string) (LrosaDsPostNonRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPostNonRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPostNonRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPostNonRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// postNonRetry400CreateRequest creates the PostNonRetry400 request.
func (client *lrosaDsOperations) postNonRetry400CreateRequest(lrosaDsPostNonRetry400Options *LrosaDsPostNonRetry400Options) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/post/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if lrosaDsPostNonRetry400Options != nil {
		return req, req.MarshalAsJSON(lrosaDsPostNonRetry400Options.Product)
	}
	return req, nil
}

// postNonRetry400HandleResponse handles the PostNonRetry400 response.
func (client *lrosaDsOperations) postNonRetry400HandleResponse(resp *azcore.Response) (*LrosaDsPostNonRetry400Response, error) {
	result := LrosaDsPostNonRetry400Response{RawResponse: resp.Response}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Retry-After"); val != "" {
		retryAfter32, err := strconv.ParseInt(val, 10, 32)
		retryAfter := int32(retryAfter32)
		if err != nil {
			return nil, err
		}
		result.RetryAfter = &retryAfter
	}
	return &result, nil
}

// Put200InvalidJSON - Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json
func (client *lrosaDsOperations) BeginPut200InvalidJSON(ctx context.Context, lrosaDsPut200InvalidJsonOptions *LrosaDsPut200InvalidJSONOptions) (LrosaDsPut200InvalidJsonPoller, error) {
	req, err := client.put200InvalidJsonCreateRequest(lrosaDsPut200InvalidJsonOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPut200InvalidJSONPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPut200InvalidJsonPoller(id string) (LrosaDsPut200InvalidJsonPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPut200InvalidJsonPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPut200InvalidJSONPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPut200InvalidJsonPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// put200InvalidJsonCreateRequest creates the Put200InvalidJSON request.
func (client *lrosaDsOperations) put200InvalidJsonCreateRequest(lrosaDsPut200InvalidJsonOptions *LrosaDsPut200InvalidJSONOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/put/200/invalidjson"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPut200InvalidJsonOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPut200InvalidJsonOptions.Product)
	}
	return req, nil
}

// put200InvalidJsonHandleResponse handles the Put200InvalidJSON response.
func (client *lrosaDsOperations) put200InvalidJsonHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRelativeRetry400 - Long running put request, service returns a 200 with ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPutAsyncRelativeRetry400(ctx context.Context, lrosaDsPutAsyncRelativeRetry400Options *LrosaDsPutAsyncRelativeRetry400Options) (LrosaDsPutAsyncRelativeRetry400Poller, error) {
	req, err := client.putAsyncRelativeRetry400CreateRequest(lrosaDsPutAsyncRelativeRetry400Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutAsyncRelativeRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutAsyncRelativeRetry400Poller(id string) (LrosaDsPutAsyncRelativeRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutAsyncRelativeRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putAsyncRelativeRetry400CreateRequest creates the PutAsyncRelativeRetry400 request.
func (client *lrosaDsOperations) putAsyncRelativeRetry400CreateRequest(lrosaDsPutAsyncRelativeRetry400Options *LrosaDsPutAsyncRelativeRetry400Options) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/putasync/retry/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutAsyncRelativeRetry400Options != nil {
		return req, req.MarshalAsJSON(lrosaDsPutAsyncRelativeRetry400Options.Product)
	}
	return req, nil
}

// putAsyncRelativeRetry400HandleResponse handles the PutAsyncRelativeRetry400 response.
func (client *lrosaDsOperations) putAsyncRelativeRetry400HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRelativeRetryInvalidHeader - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. The endpoint indicated in the Azure-AsyncOperation header is invalid.
func (client *lrosaDsOperations) BeginPutAsyncRelativeRetryInvalidHeader(ctx context.Context, lrosaDsPutAsyncRelativeRetryInvalidHeaderOptions *LrosaDsPutAsyncRelativeRetryInvalidHeaderOptions) (LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller, error) {
	req, err := client.putAsyncRelativeRetryInvalidHeaderCreateRequest(lrosaDsPutAsyncRelativeRetryInvalidHeaderOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutAsyncRelativeRetryInvalidHeaderPoller(id string) (LrosaDsPutAsyncRelativeRetryInvalidHeaderPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryInvalidHeaderPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutAsyncRelativeRetryInvalidHeaderPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryInvalidHeaderPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putAsyncRelativeRetryInvalidHeaderCreateRequest creates the PutAsyncRelativeRetryInvalidHeader request.
func (client *lrosaDsOperations) putAsyncRelativeRetryInvalidHeaderCreateRequest(lrosaDsPutAsyncRelativeRetryInvalidHeaderOptions *LrosaDsPutAsyncRelativeRetryInvalidHeaderOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/putasync/retry/invalidheader"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutAsyncRelativeRetryInvalidHeaderOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPutAsyncRelativeRetryInvalidHeaderOptions.Product)
	}
	return req, nil
}

// putAsyncRelativeRetryInvalidHeaderHandleResponse handles the PutAsyncRelativeRetryInvalidHeader response.
func (client *lrosaDsOperations) putAsyncRelativeRetryInvalidHeaderHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRelativeRetryInvalidJSONPolling - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPutAsyncRelativeRetryInvalidJSONPolling(ctx context.Context, lrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptions *LrosaDsPutAsyncRelativeRetryInvalidJSONPollingOptions) (LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller, error) {
	req, err := client.putAsyncRelativeRetryInvalidJsonPollingCreateRequest(lrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller(id string) (LrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutAsyncRelativeRetryInvalidJSONPollingPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryInvalidJsonPollingPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putAsyncRelativeRetryInvalidJsonPollingCreateRequest creates the PutAsyncRelativeRetryInvalidJSONPolling request.
func (client *lrosaDsOperations) putAsyncRelativeRetryInvalidJsonPollingCreateRequest(lrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptions *LrosaDsPutAsyncRelativeRetryInvalidJSONPollingOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/putasync/retry/invalidjsonpolling"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPutAsyncRelativeRetryInvalidJsonPollingOptions.Product)
	}
	return req, nil
}

// putAsyncRelativeRetryInvalidJsonPollingHandleResponse handles the PutAsyncRelativeRetryInvalidJSONPolling response.
func (client *lrosaDsOperations) putAsyncRelativeRetryInvalidJsonPollingHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRelativeRetryNoStatus - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPutAsyncRelativeRetryNoStatus(ctx context.Context, lrosaDsPutAsyncRelativeRetryNoStatusOptions *LrosaDsPutAsyncRelativeRetryNoStatusOptions) (LrosaDsPutAsyncRelativeRetryNoStatusPoller, error) {
	req, err := client.putAsyncRelativeRetryNoStatusCreateRequest(lrosaDsPutAsyncRelativeRetryNoStatusOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutAsyncRelativeRetryNoStatusPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutAsyncRelativeRetryNoStatusPoller(id string) (LrosaDsPutAsyncRelativeRetryNoStatusPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryNoStatusPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutAsyncRelativeRetryNoStatusPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryNoStatusPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putAsyncRelativeRetryNoStatusCreateRequest creates the PutAsyncRelativeRetryNoStatus request.
func (client *lrosaDsOperations) putAsyncRelativeRetryNoStatusCreateRequest(lrosaDsPutAsyncRelativeRetryNoStatusOptions *LrosaDsPutAsyncRelativeRetryNoStatusOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/putasync/retry/nostatus"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutAsyncRelativeRetryNoStatusOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPutAsyncRelativeRetryNoStatusOptions.Product)
	}
	return req, nil
}

// putAsyncRelativeRetryNoStatusHandleResponse handles the PutAsyncRelativeRetryNoStatus response.
func (client *lrosaDsOperations) putAsyncRelativeRetryNoStatusHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutAsyncRelativeRetryNoStatusPayload - Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
func (client *lrosaDsOperations) BeginPutAsyncRelativeRetryNoStatusPayload(ctx context.Context, lrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions *LrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions) (LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller, error) {
	req, err := client.putAsyncRelativeRetryNoStatusPayloadCreateRequest(lrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller(id string) (LrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutAsyncRelativeRetryNoStatusPayloadPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putAsyncRelativeRetryNoStatusPayloadCreateRequest creates the PutAsyncRelativeRetryNoStatusPayload request.
func (client *lrosaDsOperations) putAsyncRelativeRetryNoStatusPayloadCreateRequest(lrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions *LrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/putasync/retry/nostatuspayload"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPutAsyncRelativeRetryNoStatusPayloadOptions.Product)
	}
	return req, nil
}

// putAsyncRelativeRetryNoStatusPayloadHandleResponse handles the PutAsyncRelativeRetryNoStatusPayload response.
func (client *lrosaDsOperations) putAsyncRelativeRetryNoStatusPayloadHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutError201NoProvisioningStatePayload - Long running put request, service returns a 201 to the initial request with no payload
func (client *lrosaDsOperations) BeginPutError201NoProvisioningStatePayload(ctx context.Context, lrosaDsPutError201NoProvisioningStatePayloadOptions *LrosaDsPutError201NoProvisioningStatePayloadOptions) (LrosaDsPutError201NoProvisioningStatePayloadPoller, error) {
	req, err := client.putError201NoProvisioningStatePayloadCreateRequest(lrosaDsPutError201NoProvisioningStatePayloadOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutError201NoProvisioningStatePayloadPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutError201NoProvisioningStatePayloadPoller(id string) (LrosaDsPutError201NoProvisioningStatePayloadPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutError201NoProvisioningStatePayloadPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutError201NoProvisioningStatePayloadPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutError201NoProvisioningStatePayloadPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putError201NoProvisioningStatePayloadCreateRequest creates the PutError201NoProvisioningStatePayload request.
func (client *lrosaDsOperations) putError201NoProvisioningStatePayloadCreateRequest(lrosaDsPutError201NoProvisioningStatePayloadOptions *LrosaDsPutError201NoProvisioningStatePayloadOptions) (*azcore.Request, error) {
	urlPath := "/lro/error/put/201/noprovisioningstatepayload"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutError201NoProvisioningStatePayloadOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPutError201NoProvisioningStatePayloadOptions.Product)
	}
	return req, nil
}

// putError201NoProvisioningStatePayloadHandleResponse handles the PutError201NoProvisioningStatePayload response.
func (client *lrosaDsOperations) putError201NoProvisioningStatePayloadHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutNonRetry201Creating400 - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code
func (client *lrosaDsOperations) BeginPutNonRetry201Creating400(ctx context.Context, lrosaDsPutNonRetry201Creating400Options *LrosaDsPutNonRetry201Creating400Options) (LrosaDsPutNonRetry201Creating400Poller, error) {
	req, err := client.putNonRetry201Creating400CreateRequest(lrosaDsPutNonRetry201Creating400Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutNonRetry201Creating400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutNonRetry201Creating400Poller(id string) (LrosaDsPutNonRetry201Creating400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutNonRetry201Creating400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutNonRetry201Creating400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutNonRetry201Creating400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putNonRetry201Creating400CreateRequest creates the PutNonRetry201Creating400 request.
func (client *lrosaDsOperations) putNonRetry201Creating400CreateRequest(lrosaDsPutNonRetry201Creating400Options *LrosaDsPutNonRetry201Creating400Options) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/put/201/creating/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutNonRetry201Creating400Options != nil {
		return req, req.MarshalAsJSON(lrosaDsPutNonRetry201Creating400Options.Product)
	}
	return req, nil
}

// putNonRetry201Creating400HandleResponse handles the PutNonRetry201Creating400 response.
func (client *lrosaDsOperations) putNonRetry201Creating400HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutNonRetry201Creating400InvalidJSON - Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code
func (client *lrosaDsOperations) BeginPutNonRetry201Creating400InvalidJSON(ctx context.Context, lrosaDsPutNonRetry201Creating400InvalidJsonOptions *LrosaDsPutNonRetry201Creating400InvalidJSONOptions) (LrosaDsPutNonRetry201Creating400InvalidJsonPoller, error) {
	req, err := client.putNonRetry201Creating400InvalidJsonCreateRequest(lrosaDsPutNonRetry201Creating400InvalidJsonOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutNonRetry201Creating400InvalidJSONPoller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutNonRetry201Creating400InvalidJsonPoller(id string) (LrosaDsPutNonRetry201Creating400InvalidJsonPoller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutNonRetry201Creating400InvalidJsonPoller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutNonRetry201Creating400InvalidJSONPoller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutNonRetry201Creating400InvalidJsonPoller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putNonRetry201Creating400InvalidJsonCreateRequest creates the PutNonRetry201Creating400InvalidJSON request.
func (client *lrosaDsOperations) putNonRetry201Creating400InvalidJsonCreateRequest(lrosaDsPutNonRetry201Creating400InvalidJsonOptions *LrosaDsPutNonRetry201Creating400InvalidJSONOptions) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/put/201/creating/400/invalidjson"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutNonRetry201Creating400InvalidJsonOptions != nil {
		return req, req.MarshalAsJSON(lrosaDsPutNonRetry201Creating400InvalidJsonOptions.Product)
	}
	return req, nil
}

// putNonRetry201Creating400InvalidJsonHandleResponse handles the PutNonRetry201Creating400InvalidJSON response.
func (client *lrosaDsOperations) putNonRetry201Creating400InvalidJsonHandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}

// PutNonRetry400 - Long running put request, service returns a 400 to the initial request
func (client *lrosaDsOperations) BeginPutNonRetry400(ctx context.Context, lrosaDsPutNonRetry400Options *LrosaDsPutNonRetry400Options) (LrosaDsPutNonRetry400Poller, error) {
	req, err := client.putNonRetry400CreateRequest(lrosaDsPutNonRetry400Options)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	pt, err := createPollingTracker(resp)
	if err != nil {
		return nil, err
	}
	return &lrosaDsPutNonRetry400Poller{
		pt:     pt,
		client: client,
	}, nil
}

func (client *lrosaDsOperations) ResumeLrosaDsPutNonRetry400Poller(id string) (LrosaDsPutNonRetry400Poller, error) {
	// unmarshal into JSON object to determine the tracker type
	obj := map[string]interface{}{}
	err := json.Unmarshal([]byte(id), &obj)
	if err != nil {
		return nil, err
	}
	if obj["method"] == nil {
		return nil, fmt.Errorf("ResumeLrosaDsPutNonRetry400Poller: missing 'method' property")
	}
	method := obj["method"].(string)
	poller := &lrosaDsPutNonRetry400Poller{
		client: client,
	}
	switch strings.ToUpper(method) {
	case http.MethodDelete:
		poller.pt = &pollingTrackerDelete{}
	case http.MethodPatch:
		poller.pt = &pollingTrackerPatch{}
	case http.MethodPost:
		poller.pt = &pollingTrackerPost{}
	case http.MethodPut:
		poller.pt = &pollingTrackerPut{}
	default:
		return nil, fmt.Errorf("ResumeLrosaDsPutNonRetry400Poller: unsupported method '%s'", method)
	}
	// now unmarshal into the tracker
	err = json.Unmarshal([]byte(id), &poller.pt)
	if err != nil {
		return nil, err
	}
	return poller, nil
}

// putNonRetry400CreateRequest creates the PutNonRetry400 request.
func (client *lrosaDsOperations) putNonRetry400CreateRequest(lrosaDsPutNonRetry400Options *LrosaDsPutNonRetry400Options) (*azcore.Request, error) {
	urlPath := "/lro/nonretryerror/put/400"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	if lrosaDsPutNonRetry400Options != nil {
		return req, req.MarshalAsJSON(lrosaDsPutNonRetry400Options.Product)
	}
	return req, nil
}

// putNonRetry400HandleResponse handles the PutNonRetry400 response.
func (client *lrosaDsOperations) putNonRetry400HandleResponse(resp *azcore.Response) (*ProductResponse, error) {
	result := ProductResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Product)
}
