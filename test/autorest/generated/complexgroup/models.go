// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package complexgroup

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

type ArrayWrapper struct {
	Array *[]string `json:"array,omitempty"`
}

// ArrayWrapperResponse is the response envelope for operations that return a ArrayWrapper type.
type ArrayWrapperResponse struct {
	ArrayWrapper *ArrayWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type Basic struct {
	Color *CMYKColors `json:"color,omitempty"`

	// Basic Id
	ID *int32 `json:"id,omitempty"`

	// Name property with a very long description that does not fit on a single line and a line break.
	Name *string `json:"name,omitempty"`
}

// BasicResponse is the response envelope for operations that return a Basic type.
type BasicResponse struct {
	Basic *Basic

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type BooleanWrapper struct {
	FieldFalse *bool `json:"field_false,omitempty"`
	FieldTrue  *bool `json:"field_true,omitempty"`
}

// BooleanWrapperResponse is the response envelope for operations that return a BooleanWrapper type.
type BooleanWrapperResponse struct {
	BooleanWrapper *BooleanWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type ByteWrapper struct {
	Field *[]byte `json:"field,omitempty"`
}

// ByteWrapperResponse is the response envelope for operations that return a ByteWrapper type.
type ByteWrapperResponse struct {
	ByteWrapper *ByteWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type Cat struct {
	Color *string `json:"color,omitempty"`
	Hates *[]Dog  `json:"hates,omitempty"`
	ID    *int32  `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
}

type Cookiecuttershark struct {
	Age      *int32      `json:"age,omitempty"`
	Birthday *time.Time  `json:"birthday,omitempty"`
	Fishtype *string     `json:"fishtype,omitempty"`
	Length   *float32    `json:"length,omitempty"`
	Siblings *[]FishType `json:"siblings,omitempty"`
	Species  *string     `json:"species,omitempty"`
}

func (c Cookiecuttershark) MarshalJSON() ([]byte, error) {
	c.Fishtype = strptr(fishTypeCookiecuttershark)
	type alias Cookiecuttershark
	aux := &struct {
		*alias
		Birthday *timeRFC3339 `json:"birthday"`
	}{
		alias:    (*alias)(&c),
		Birthday: (*timeRFC3339)(c.Birthday),
	}
	return json.Marshal(aux)
}

func (c *Cookiecuttershark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "age":
			if v != nil {
				err = json.Unmarshal(*v, &c.Age)
			}
		case "birthday":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				c.Birthday = (*time.Time)(&aux)
			}
		case "fishtype":
			if v != nil {
				err = json.Unmarshal(*v, &c.Fishtype)
			}
		case "length":
			if v != nil {
				err = json.Unmarshal(*v, &c.Length)
			}
		case "siblings":
			if v != nil {
				c.Siblings, err = unmarshalFishTypeArray(*v)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &c.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*Cookiecuttershark) fishType() {}

func (*Cookiecuttershark) sharkType() {}

type DateWrapper struct {
	Field *time.Time `json:"field,omitempty"`
	Leap  *time.Time `json:"leap,omitempty"`
}

// DateWrapperResponse is the response envelope for operations that return a DateWrapper type.
type DateWrapperResponse struct {
	DateWrapper *DateWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type DatetimeWrapper struct {
	Field *time.Time `json:"field,omitempty"`
	Now   *time.Time `json:"now,omitempty"`
}

func (d DatetimeWrapper) MarshalJSON() ([]byte, error) {
	type alias DatetimeWrapper
	aux := &struct {
		*alias
		Field *timeRFC3339 `json:"field"`
		Now   *timeRFC3339 `json:"now"`
	}{
		alias: (*alias)(&d),
		Field: (*timeRFC3339)(d.Field),
		Now:   (*timeRFC3339)(d.Now),
	}
	return json.Marshal(aux)
}

func (d *DatetimeWrapper) UnmarshalJSON(data []byte) error {
	type alias DatetimeWrapper
	aux := &struct {
		*alias
		Field *timeRFC3339 `json:"field"`
		Now   *timeRFC3339 `json:"now"`
	}{
		alias: (*alias)(d),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	d.Field = (*time.Time)(aux.Field)
	d.Now = (*time.Time)(aux.Now)
	return nil
}

// DatetimeWrapperResponse is the response envelope for operations that return a DatetimeWrapper type.
type DatetimeWrapperResponse struct {
	DatetimeWrapper *DatetimeWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type Datetimerfc1123Wrapper struct {
	Field *time.Time `json:"field,omitempty"`
	Now   *time.Time `json:"now,omitempty"`
}

func (d Datetimerfc1123Wrapper) MarshalJSON() ([]byte, error) {
	type alias Datetimerfc1123Wrapper
	aux := &struct {
		*alias
		Field *timeRFC1123 `json:"field"`
		Now   *timeRFC1123 `json:"now"`
	}{
		alias: (*alias)(&d),
		Field: (*timeRFC1123)(d.Field),
		Now:   (*timeRFC1123)(d.Now),
	}
	return json.Marshal(aux)
}

func (d *Datetimerfc1123Wrapper) UnmarshalJSON(data []byte) error {
	type alias Datetimerfc1123Wrapper
	aux := &struct {
		*alias
		Field *timeRFC1123 `json:"field"`
		Now   *timeRFC1123 `json:"now"`
	}{
		alias: (*alias)(d),
	}
	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}
	d.Field = (*time.Time)(aux.Field)
	d.Now = (*time.Time)(aux.Now)
	return nil
}

// Datetimerfc1123WrapperResponse is the response envelope for operations that return a Datetimerfc1123Wrapper type.
type Datetimerfc1123WrapperResponse struct {
	Datetimerfc1123Wrapper *Datetimerfc1123Wrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type DictionaryWrapper struct {
	// Dictionary of <string>
	DefaultProgram *map[string]string `json:"defaultProgram,omitempty"`
}

// DictionaryWrapperResponse is the response envelope for operations that return a DictionaryWrapper type.
type DictionaryWrapperResponse struct {
	DictionaryWrapper *DictionaryWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type Dog struct {
	Food *string `json:"food,omitempty"`
	ID   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// DotFishType provides polymorphic access to related types.
type DotFishType interface {
	dotFishType()
}

type DotFish struct {
	FishType *string `json:"fish.type,omitempty"`
	Species  *string `json:"species,omitempty"`
}

func (*DotFish) dotFishType() {}

type DotFishMarket struct {
	Fishes       *[]DotFishType `json:"fishes,omitempty"`
	Salmons      *[]DotSalmon   `json:"salmons,omitempty"`
	SampleFish   DotFishType    `json:"sampleFish,omitempty"`
	SampleSalmon *DotSalmon     `json:"sampleSalmon,omitempty"`
}

func (d *DotFishMarket) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "fishes":
			if v != nil {
				d.Fishes, err = unmarshalDotFishTypeArray(*v)
			}
		case "salmons":
			if v != nil {
				err = json.Unmarshal(*v, &d.Salmons)
			}
		case "sampleFish":
			if v != nil {
				d.SampleFish, err = unmarshalDotFishType(*v)
			}
		case "sampleSalmon":
			if v != nil {
				err = json.Unmarshal(*v, &d.SampleSalmon)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DotFishMarketResponse is the response envelope for operations that return a DotFishMarket type.
type DotFishMarketResponse struct {
	DotFishMarket *DotFishMarket

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DotFishResponse is the response envelope for operations that return a DotFish type.
type DotFishResponse struct {
	DotFish DotFishType

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

func (d *DotFishResponse) UnmarshalJSON(data []byte) error {
	t, err := unmarshalDotFishType(data)
	if err != nil {
		return err
	}
	d.DotFish = t
	return nil
}

type DotSalmon struct {
	FishType *string `json:"fish.type,omitempty"`
	Iswild   *bool   `json:"iswild,omitempty"`
	Location *string `json:"location,omitempty"`
	Species  *string `json:"species,omitempty"`
}

func (d DotSalmon) MarshalJSON() ([]byte, error) {
	d.FishType = strptr(dotFishTypeDotSalmon)
	type alias DotSalmon
	aux := &struct {
		*alias
	}{
		alias: (*alias)(&d),
	}
	return json.Marshal(aux)
}

func (d *DotSalmon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "fish.type":
			if v != nil {
				err = json.Unmarshal(*v, &d.FishType)
			}
		case "iswild":
			if v != nil {
				err = json.Unmarshal(*v, &d.Iswild)
			}
		case "location":
			if v != nil {
				err = json.Unmarshal(*v, &d.Location)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &d.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*DotSalmon) dotFishType() {}

type DoubleWrapper struct {
	Field1                                                                          *float64 `json:"field1,omitempty"`
	Field56ZerosAfterTheDotAndNegativeZeroBeforeDotAndThisIsALongFieldNameOnPurpose *float64 `json:"field_56_zeros_after_the_dot_and_negative_zero_before_dot_and_this_is_a_long_field_name_on_purpose,omitempty"`
}

// DoubleWrapperResponse is the response envelope for operations that return a DoubleWrapper type.
type DoubleWrapperResponse struct {
	DoubleWrapper *DoubleWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type DurationWrapper struct {
	Field *time.Duration `json:"field,omitempty"`
}

// DurationWrapperResponse is the response envelope for operations that return a DurationWrapper type.
type DurationWrapperResponse struct {
	DurationWrapper *DurationWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type Error struct {
	Message *string `json:"message,omitempty"`
	Status  *int32  `json:"status,omitempty"`
}

func newError(resp *azcore.Response) error {
	err := Error{}
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

func (e Error) Error() string {
	msg := ""
	if e.Message != nil {
		msg += fmt.Sprintf("Message: %v\n", *e.Message)
	}
	if e.Status != nil {
		msg += fmt.Sprintf("Status: %v\n", *e.Status)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

// FishType provides polymorphic access to related types.
type FishType interface {
	fishType()
}

type Fish struct {
	Fishtype *string     `json:"fishtype,omitempty"`
	Length   *float32    `json:"length,omitempty"`
	Siblings *[]FishType `json:"siblings,omitempty"`
	Species  *string     `json:"species,omitempty"`
}

func (*Fish) fishType() {}

// FishResponse is the response envelope for operations that return a Fish type.
type FishResponse struct {
	Fish FishType

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

func (f *FishResponse) UnmarshalJSON(data []byte) error {
	t, err := unmarshalFishType(data)
	if err != nil {
		return err
	}
	f.Fish = t
	return nil
}

type FloatWrapper struct {
	Field1 *float32 `json:"field1,omitempty"`
	Field2 *float32 `json:"field2,omitempty"`
}

// FloatWrapperResponse is the response envelope for operations that return a FloatWrapper type.
type FloatWrapperResponse struct {
	FloatWrapper *FloatWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type Goblinshark struct {
	Age      *int32     `json:"age,omitempty"`
	Birthday *time.Time `json:"birthday,omitempty"`

	// Colors possible
	Color    *GoblinSharkColor `json:"color,omitempty"`
	Fishtype *string           `json:"fishtype,omitempty"`
	Jawsize  *int32            `json:"jawsize,omitempty"`
	Length   *float32          `json:"length,omitempty"`
	Siblings *[]FishType       `json:"siblings,omitempty"`
	Species  *string           `json:"species,omitempty"`
}

func (g Goblinshark) MarshalJSON() ([]byte, error) {
	g.Fishtype = strptr(fishTypeGoblin)
	type alias Goblinshark
	aux := &struct {
		*alias
		Birthday *timeRFC3339 `json:"birthday"`
	}{
		alias:    (*alias)(&g),
		Birthday: (*timeRFC3339)(g.Birthday),
	}
	return json.Marshal(aux)
}

func (g *Goblinshark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "age":
			if v != nil {
				err = json.Unmarshal(*v, &g.Age)
			}
		case "birthday":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				g.Birthday = (*time.Time)(&aux)
			}
		case "color":
			if v != nil {
				err = json.Unmarshal(*v, &g.Color)
			}
		case "fishtype":
			if v != nil {
				err = json.Unmarshal(*v, &g.Fishtype)
			}
		case "jawsize":
			if v != nil {
				err = json.Unmarshal(*v, &g.Jawsize)
			}
		case "length":
			if v != nil {
				err = json.Unmarshal(*v, &g.Length)
			}
		case "siblings":
			if v != nil {
				g.Siblings, err = unmarshalFishTypeArray(*v)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &g.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*Goblinshark) fishType() {}

func (*Goblinshark) sharkType() {}

type IntWrapper struct {
	Field1 *int32 `json:"field1,omitempty"`
	Field2 *int32 `json:"field2,omitempty"`
}

// IntWrapperResponse is the response envelope for operations that return a IntWrapper type.
type IntWrapperResponse struct {
	IntWrapper *IntWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type LongWrapper struct {
	Field1 *int64 `json:"field1,omitempty"`
	Field2 *int64 `json:"field2,omitempty"`
}

// LongWrapperResponse is the response envelope for operations that return a LongWrapper type.
type LongWrapperResponse struct {
	LongWrapper *LongWrapper

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

type MyBaseHelperType struct {
	PropBh1 *string `json:"propBH1,omitempty"`
}

// MyBaseTypeType provides polymorphic access to related types.
type MyBaseTypeType interface {
	myBaseType()
}

type MyBaseType struct {
	Helper *MyBaseHelperType `json:"helper,omitempty"`
	Kind   *string           `json:"kind,omitempty"`
	PropB1 *string           `json:"propB1,omitempty"`
}

func (*MyBaseType) myBaseType() {}

// MyBaseTypeResponse is the response envelope for operations that return a MyBaseType type.
type MyBaseTypeResponse struct {
	MyBaseType MyBaseTypeType

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

func (m *MyBaseTypeResponse) UnmarshalJSON(data []byte) error {
	t, err := unmarshalMyBaseTypeType(data)
	if err != nil {
		return err
	}
	m.MyBaseType = t
	return nil
}

type MyDerivedType struct {
	Helper *MyBaseHelperType `json:"helper,omitempty"`
	Kind   *string           `json:"kind,omitempty"`
	PropB1 *string           `json:"propB1,omitempty"`
	PropD1 *string           `json:"propD1,omitempty"`
}

func (m MyDerivedType) MarshalJSON() ([]byte, error) {
	m.Kind = strptr(myBaseTypeKind1)
	type alias MyDerivedType
	aux := &struct {
		*alias
	}{
		alias: (*alias)(&m),
	}
	return json.Marshal(aux)
}

func (m *MyDerivedType) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "helper":
			if v != nil {
				err = json.Unmarshal(*v, &m.Helper)
			}
		case "kind":
			if v != nil {
				err = json.Unmarshal(*v, &m.Kind)
			}
		case "propB1":
			if v != nil {
				err = json.Unmarshal(*v, &m.PropB1)
			}
		case "propD1":
			if v != nil {
				err = json.Unmarshal(*v, &m.PropD1)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*MyDerivedType) myBaseType() {}

type Pet struct {
	ID   *int32  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type ReadonlyObj struct {
	ID   *string `json:"id,omitempty"`
	Size *int32  `json:"size,omitempty"`
}

// ReadonlyObjResponse is the response envelope for operations that return a ReadonlyObj type.
type ReadonlyObjResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	ReadonlyObj *ReadonlyObj
}

// SalmonType provides polymorphic access to related types.
type SalmonType interface {
	FishType
	salmonType()
}

type Salmon struct {
	Fishtype *string     `json:"fishtype,omitempty"`
	Iswild   *bool       `json:"iswild,omitempty"`
	Length   *float32    `json:"length,omitempty"`
	Location *string     `json:"location,omitempty"`
	Siblings *[]FishType `json:"siblings,omitempty"`
	Species  *string     `json:"species,omitempty"`
}

func (s Salmon) MarshalJSON() ([]byte, error) {
	s.Fishtype = strptr(fishTypeSalmon)
	type alias Salmon
	aux := &struct {
		*alias
	}{
		alias: (*alias)(&s),
	}
	return json.Marshal(aux)
}

func (s *Salmon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "fishtype":
			if v != nil {
				err = json.Unmarshal(*v, &s.Fishtype)
			}
		case "iswild":
			if v != nil {
				err = json.Unmarshal(*v, &s.Iswild)
			}
		case "length":
			if v != nil {
				err = json.Unmarshal(*v, &s.Length)
			}
		case "location":
			if v != nil {
				err = json.Unmarshal(*v, &s.Location)
			}
		case "siblings":
			if v != nil {
				s.Siblings, err = unmarshalFishTypeArray(*v)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &s.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*Salmon) fishType() {}

func (*Salmon) salmonType() {}

// SalmonResponse is the response envelope for operations that return a Salmon type.
type SalmonResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Salmon      SalmonType
}

func (s *SalmonResponse) UnmarshalJSON(data []byte) error {
	t, err := unmarshalSalmonType(data)
	if err != nil {
		return err
	}
	s.Salmon = t
	return nil
}

type Sawshark struct {
	Age      *int32      `json:"age,omitempty"`
	Birthday *time.Time  `json:"birthday,omitempty"`
	Fishtype *string     `json:"fishtype,omitempty"`
	Length   *float32    `json:"length,omitempty"`
	Picture  *[]byte     `json:"picture,omitempty"`
	Siblings *[]FishType `json:"siblings,omitempty"`
	Species  *string     `json:"species,omitempty"`
}

func (s Sawshark) MarshalJSON() ([]byte, error) {
	s.Fishtype = strptr(fishTypeSawshark)
	type alias Sawshark
	aux := &struct {
		*alias
		Birthday *timeRFC3339 `json:"birthday"`
	}{
		alias:    (*alias)(&s),
		Birthday: (*timeRFC3339)(s.Birthday),
	}
	return json.Marshal(aux)
}

func (s *Sawshark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "age":
			if v != nil {
				err = json.Unmarshal(*v, &s.Age)
			}
		case "birthday":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				s.Birthday = (*time.Time)(&aux)
			}
		case "fishtype":
			if v != nil {
				err = json.Unmarshal(*v, &s.Fishtype)
			}
		case "length":
			if v != nil {
				err = json.Unmarshal(*v, &s.Length)
			}
		case "picture":
			if v != nil {
				err = json.Unmarshal(*v, &s.Picture)
			}
		case "siblings":
			if v != nil {
				s.Siblings, err = unmarshalFishTypeArray(*v)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &s.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*Sawshark) fishType() {}

func (*Sawshark) sharkType() {}

// SharkType provides polymorphic access to related types.
type SharkType interface {
	FishType
	sharkType()
}

type Shark struct {
	Age      *int32      `json:"age,omitempty"`
	Birthday *time.Time  `json:"birthday,omitempty"`
	Fishtype *string     `json:"fishtype,omitempty"`
	Length   *float32    `json:"length,omitempty"`
	Siblings *[]FishType `json:"siblings,omitempty"`
	Species  *string     `json:"species,omitempty"`
}

func (s Shark) MarshalJSON() ([]byte, error) {
	s.Fishtype = strptr(fishTypeShark)
	type alias Shark
	aux := &struct {
		*alias
		Birthday *timeRFC3339 `json:"birthday"`
	}{
		alias:    (*alias)(&s),
		Birthday: (*timeRFC3339)(s.Birthday),
	}
	return json.Marshal(aux)
}

func (s *Shark) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "age":
			if v != nil {
				err = json.Unmarshal(*v, &s.Age)
			}
		case "birthday":
			if v != nil {
				var aux timeRFC3339
				err = json.Unmarshal(*v, &aux)
				s.Birthday = (*time.Time)(&aux)
			}
		case "fishtype":
			if v != nil {
				err = json.Unmarshal(*v, &s.Fishtype)
			}
		case "length":
			if v != nil {
				err = json.Unmarshal(*v, &s.Length)
			}
		case "siblings":
			if v != nil {
				s.Siblings, err = unmarshalFishTypeArray(*v)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &s.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*Shark) fishType() {}

func (*Shark) sharkType() {}

type Siamese struct {
	Breed *string `json:"breed,omitempty"`
	Color *string `json:"color,omitempty"`
	Hates *[]Dog  `json:"hates,omitempty"`
	ID    *int32  `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
}

// SiameseResponse is the response envelope for operations that return a Siamese type.
type SiameseResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
	Siamese     *Siamese
}

type SmartSalmon struct {
	CollegeDegree *string     `json:"college_degree,omitempty"`
	Fishtype      *string     `json:"fishtype,omitempty"`
	Iswild        *bool       `json:"iswild,omitempty"`
	Length        *float32    `json:"length,omitempty"`
	Location      *string     `json:"location,omitempty"`
	Siblings      *[]FishType `json:"siblings,omitempty"`
	Species       *string     `json:"species,omitempty"`
}

func (s SmartSalmon) MarshalJSON() ([]byte, error) {
	s.Fishtype = strptr(fishTypeSmartSalmon)
	type alias SmartSalmon
	aux := &struct {
		*alias
	}{
		alias: (*alias)(&s),
	}
	return json.Marshal(aux)
}

func (s *SmartSalmon) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]*json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for k, v := range rawMsg {
		var err error
		switch k {
		case "college_degree":
			if v != nil {
				err = json.Unmarshal(*v, &s.CollegeDegree)
			}
		case "fishtype":
			if v != nil {
				err = json.Unmarshal(*v, &s.Fishtype)
			}
		case "iswild":
			if v != nil {
				err = json.Unmarshal(*v, &s.Iswild)
			}
		case "length":
			if v != nil {
				err = json.Unmarshal(*v, &s.Length)
			}
		case "location":
			if v != nil {
				err = json.Unmarshal(*v, &s.Location)
			}
		case "siblings":
			if v != nil {
				s.Siblings, err = unmarshalFishTypeArray(*v)
			}
		case "species":
			if v != nil {
				err = json.Unmarshal(*v, &s.Species)
			}
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func (*SmartSalmon) fishType() {}

func (*SmartSalmon) salmonType() {}

type StringWrapper struct {
	Empty *string `json:"empty,omitempty"`
	Field *string `json:"field,omitempty"`
	Null  *string `json:"null,omitempty"`
}

// StringWrapperResponse is the response envelope for operations that return a StringWrapper type.
type StringWrapperResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse   *http.Response
	StringWrapper *StringWrapper
}
