// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package complexgroup

import "encoding/json"

const (
	dotFishClassificationDotSalmon = "DotSalmon"
)

func unmarshalDotFishClassification(body []byte) (DotFishClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DotFishClassification
	switch m["fish.type"] {
	case dotFishClassificationDotSalmon:
		b = &DotSalmon{}
	default:
		b = &DotFish{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDotFishClassificationArray(body []byte) (*[]DotFishClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DotFishClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDotFishClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

const (
	fishClassificationCookiecuttershark = "cookiecuttershark"
	fishClassificationGoblin            = "goblin"
	fishClassificationSalmon            = "salmon"
	fishClassificationSawshark          = "sawshark"
	fishClassificationShark             = "shark"
	fishClassificationSmartSalmon       = "smart_salmon"
)

func unmarshalFishClassification(body []byte) (FishClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b FishClassification
	switch m["fishtype"] {
	case fishClassificationCookiecuttershark:
		b = &Cookiecuttershark{}
	case fishClassificationGoblin:
		b = &Goblinshark{}
	case fishClassificationSalmon:
		b = &Salmon{}
	case fishClassificationSawshark:
		b = &Sawshark{}
	case fishClassificationShark:
		b = &Shark{}
	case fishClassificationSmartSalmon:
		b = &SmartSalmon{}
	default:
		b = &Fish{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalFishClassificationArray(body []byte) (*[]FishClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]FishClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalFishClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalSalmonClassification(body []byte) (SalmonClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b SalmonClassification
	switch m["fishtype"] {
	case fishClassificationSmartSalmon:
		b = &SmartSalmon{}
	default:
		b = &Salmon{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalSalmonClassificationArray(body []byte) (*[]SalmonClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SalmonClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSalmonClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalSharkClassification(body []byte) (SharkClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b SharkClassification
	switch m["fishtype"] {
	case fishClassificationCookiecuttershark:
		b = &Cookiecuttershark{}
	case fishClassificationGoblin:
		b = &Goblinshark{}
	case fishClassificationSawshark:
		b = &Sawshark{}
	default:
		b = &Shark{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalSharkClassificationArray(body []byte) (*[]SharkClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SharkClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSharkClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

const (
	myBaseTypeClassificationKind1 = "Kind1"
)

func unmarshalMyBaseTypeClassification(body []byte) (MyBaseTypeClassification, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b MyBaseTypeClassification
	switch m["kind"] {
	case myBaseTypeClassificationKind1:
		b = &MyDerivedType{}
	default:
		b = &MyBaseType{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalMyBaseTypeClassificationArray(body []byte) (*[]MyBaseTypeClassification, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MyBaseTypeClassification, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMyBaseTypeClassification(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func strptr(s string) *string {
	return &s
}
