// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package complexgroup

import "encoding/json"

const (
	dotFishTypeDotSalmon = "DotSalmon"
)

func unmarshalDotFishType(body []byte) (DotFishType, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b DotFishType
	switch m["fish.type"] {
	case dotFishTypeDotSalmon:
		b = &DotSalmon{}
	default:
		b = &DotFish{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalDotFishTypeArray(body []byte) (*[]DotFishType, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]DotFishType, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalDotFishType(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

const (
	fishTypeCookiecuttershark = "cookiecuttershark"
	fishTypeGoblin            = "goblin"
	fishTypeSalmon            = "salmon"
	fishTypeSawshark          = "sawshark"
	fishTypeShark             = "shark"
	fishTypeSmartSalmon       = "smart_salmon"
)

func unmarshalFishType(body []byte) (FishType, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b FishType
	switch m["fishtype"] {
	case fishTypeCookiecuttershark:
		b = &Cookiecuttershark{}
	case fishTypeGoblin:
		b = &Goblinshark{}
	case fishTypeSalmon:
		b = &Salmon{}
	case fishTypeSawshark:
		b = &Sawshark{}
	case fishTypeShark:
		b = &Shark{}
	case fishTypeSmartSalmon:
		b = &SmartSalmon{}
	default:
		b = &Fish{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalFishTypeArray(body []byte) (*[]FishType, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]FishType, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalFishType(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalSalmonType(body []byte) (SalmonType, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b SalmonType
	switch m["fishtype"] {
	case fishTypeSmartSalmon:
		b = &SmartSalmon{}
	default:
		b = &Salmon{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalSalmonTypeArray(body []byte) (*[]SalmonType, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SalmonType, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSalmonType(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func unmarshalSharkType(body []byte) (SharkType, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b SharkType
	switch m["fishtype"] {
	case fishTypeCookiecuttershark:
		b = &Cookiecuttershark{}
	case fishTypeGoblin:
		b = &Goblinshark{}
	case fishTypeSawshark:
		b = &Sawshark{}
	default:
		b = &Shark{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalSharkTypeArray(body []byte) (*[]SharkType, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]SharkType, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalSharkType(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

const (
	myBaseTypeKind1 = "Kind1"
)

func unmarshalMyBaseTypeType(body []byte) (MyBaseTypeType, error) {
	var m map[string]interface{}
	if err := json.Unmarshal(body, &m); err != nil {
		return nil, err
	}
	var b MyBaseTypeType
	switch m["kind"] {
	case myBaseTypeKind1:
		b = &MyDerivedType{}
	default:
		b = &MyBaseType{}
	}
	return b, json.Unmarshal(body, &b)
}

func unmarshalMyBaseTypeTypeArray(body []byte) (*[]MyBaseTypeType, error) {
	var rawMessages []*json.RawMessage
	if err := json.Unmarshal(body, &rawMessages); err != nil {
		return nil, err
	}
	fArray := make([]MyBaseTypeType, len(rawMessages))
	for index, rawMessage := range rawMessages {
		f, err := unmarshalMyBaseTypeType(*rawMessage)
		if err != nil {
			return nil, err
		}
		fArray[index] = f
	}
	return &fArray, nil
}

func strptr(s string) *string {
	return &s
}
