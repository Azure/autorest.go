// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"path"
)

// XMLOperations contains the methods for the XML group.
type XMLOperations interface {
	// GetACLs - Gets storage ACLs for a container.
	GetACLs(ctx context.Context) (*SignedIDentifierArrayResponse, error)
	// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
	GetComplexTypeRefNoMeta(ctx context.Context) (*RootWithRefAndNoMetaResponse, error)
	// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
	GetComplexTypeRefWithMeta(ctx context.Context) (*RootWithRefAndMetaResponse, error)
	// GetEmptyChildElement - Gets an XML document with an empty child element.
	GetEmptyChildElement(ctx context.Context) (*BananaResponse, error)
	// GetEmptyList - Get an empty list.
	GetEmptyList(ctx context.Context) (*SlideshowResponse, error)
	// GetEmptyRootList - Gets an empty list as the root element.
	GetEmptyRootList(ctx context.Context) (*BananaArrayResponse, error)
	// GetEmptyWrappedLists - Gets some empty wrapped lists.
	GetEmptyWrappedLists(ctx context.Context) (*AppleBarrelResponse, error)
	// GetHeaders - Get strongly-typed response headers.
	GetHeaders(ctx context.Context) (*XMLGetHeadersResponse, error)
	// GetRootList - Gets a list as the root element.
	GetRootList(ctx context.Context) (*BananaArrayResponse, error)
	// GetRootListSingleItem - Gets a list with a single item.
	GetRootListSingleItem(ctx context.Context) (*BananaArrayResponse, error)
	// GetServiceProperties - Gets storage service properties.
	GetServiceProperties(ctx context.Context) (*StorageServicePropertiesResponse, error)
	// GetSimple - Get a simple XML document
	GetSimple(ctx context.Context) (*SlideshowResponse, error)
	// GetWrappedLists - Get an XML document with multiple wrapped lists
	GetWrappedLists(ctx context.Context) (*AppleBarrelResponse, error)
	// GetXMSText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language' property being 'english' and its 'content' property being 'I am text'
	GetXMSText(ctx context.Context) (*ObjectWithXMSTextPropertyResponse, error)
	// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
	JSONInput(ctx context.Context, properties JSONInput) (*http.Response, error)
	// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
	JSONOutput(ctx context.Context) (*JSONOutputResponse, error)
	// ListBlobs - Lists blobs in a storage container.
	ListBlobs(ctx context.Context) (*ListBlobsResponseResponse, error)
	// ListContainers - Lists containers in a storage account.
	ListContainers(ctx context.Context) (*ListContainersResponseResponse, error)
	// PutACLs - Puts storage ACLs for a container.
	PutACLs(ctx context.Context, properties []SignedIDentifier) (*http.Response, error)
	// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
	PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta) (*http.Response, error)
	// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
	PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta) (*http.Response, error)
	// PutEmptyChildElement - Puts a value with an empty child element.
	PutEmptyChildElement(ctx context.Context, banana Banana) (*http.Response, error)
	// PutEmptyList - Puts an empty list.
	PutEmptyList(ctx context.Context, slideshow Slideshow) (*http.Response, error)
	// PutEmptyRootList - Puts an empty list as the root element.
	PutEmptyRootList(ctx context.Context, bananas []Banana) (*http.Response, error)
	// PutEmptyWrappedLists - Puts some empty wrapped lists.
	PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel) (*http.Response, error)
	// PutRootList - Puts a list as the root element.
	PutRootList(ctx context.Context, bananas []Banana) (*http.Response, error)
	// PutRootListSingleItem - Puts a list with a single item.
	PutRootListSingleItem(ctx context.Context, bananas []Banana) (*http.Response, error)
	// PutServiceProperties - Puts storage service properties.
	PutServiceProperties(ctx context.Context, properties StorageServiceProperties) (*http.Response, error)
	// PutSimple - Put a simple XML document
	PutSimple(ctx context.Context, slideshow Slideshow) (*http.Response, error)
	// PutWrappedLists - Put an XML document with multiple wrapped lists
	PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel) (*http.Response, error)
}

// xmlOperations implements the XMLOperations interface.
type xmlOperations struct {
	*Client
}

// GetACLs - Gets storage ACLs for a container.
func (client *xmlOperations) GetACLs(ctx context.Context) (*SignedIDentifierArrayResponse, error) {
	req, err := client.getAcLsCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAcLsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAcLsCreateRequest creates the GetACLs request.
func (client *xmlOperations) getAcLsCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "acl")
	query.Set("restype", "container")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getAcLsHandleResponse handles the GetACLs response.
func (client *xmlOperations) getAcLsHandleResponse(resp *azcore.Response) (*SignedIDentifierArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getAcLsHandleError(resp)
	}
	result := SignedIDentifierArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// getAcLsHandleError handles the GetACLs error response.
func (client *xmlOperations) getAcLsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
func (client *xmlOperations) GetComplexTypeRefNoMeta(ctx context.Context) (*RootWithRefAndNoMetaResponse, error) {
	req, err := client.getComplexTypeRefNoMetaCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getComplexTypeRefNoMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *xmlOperations) getComplexTypeRefNoMetaCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *xmlOperations) getComplexTypeRefNoMetaHandleResponse(resp *azcore.Response) (*RootWithRefAndNoMetaResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getComplexTypeRefNoMetaHandleError(resp)
	}
	result := RootWithRefAndNoMetaResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.RootWithRefAndNoMeta)
}

// getComplexTypeRefNoMetaHandleError handles the GetComplexTypeRefNoMeta error response.
func (client *xmlOperations) getComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
func (client *xmlOperations) GetComplexTypeRefWithMeta(ctx context.Context) (*RootWithRefAndMetaResponse, error) {
	req, err := client.getComplexTypeRefWithMetaCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getComplexTypeRefWithMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *xmlOperations) getComplexTypeRefWithMetaCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *xmlOperations) getComplexTypeRefWithMetaHandleResponse(resp *azcore.Response) (*RootWithRefAndMetaResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getComplexTypeRefWithMetaHandleError(resp)
	}
	result := RootWithRefAndMetaResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.RootWithRefAndMeta)
}

// getComplexTypeRefWithMetaHandleError handles the GetComplexTypeRefWithMeta error response.
func (client *xmlOperations) getComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
func (client *xmlOperations) GetEmptyChildElement(ctx context.Context) (*BananaResponse, error) {
	req, err := client.getEmptyChildElementCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getEmptyChildElementHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *xmlOperations) getEmptyChildElementCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *xmlOperations) getEmptyChildElementHandleResponse(resp *azcore.Response) (*BananaResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getEmptyChildElementHandleError(resp)
	}
	result := BananaResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Banana)
}

// getEmptyChildElementHandleError handles the GetEmptyChildElement error response.
func (client *xmlOperations) getEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyList - Get an empty list.
func (client *xmlOperations) GetEmptyList(ctx context.Context) (*SlideshowResponse, error) {
	req, err := client.getEmptyListCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getEmptyListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getEmptyListCreateRequest creates the GetEmptyList request.
func (client *xmlOperations) getEmptyListCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getEmptyListHandleResponse handles the GetEmptyList response.
func (client *xmlOperations) getEmptyListHandleResponse(resp *azcore.Response) (*SlideshowResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getEmptyListHandleError(resp)
	}
	result := SlideshowResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Slideshow)
}

// getEmptyListHandleError handles the GetEmptyList error response.
func (client *xmlOperations) getEmptyListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyRootList - Gets an empty list as the root element.
func (client *xmlOperations) GetEmptyRootList(ctx context.Context) (*BananaArrayResponse, error) {
	req, err := client.getEmptyRootListCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getEmptyRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *xmlOperations) getEmptyRootListCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *xmlOperations) getEmptyRootListHandleResponse(resp *azcore.Response) (*BananaArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getEmptyRootListHandleError(resp)
	}
	result := BananaArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// getEmptyRootListHandleError handles the GetEmptyRootList error response.
func (client *xmlOperations) getEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
func (client *xmlOperations) GetEmptyWrappedLists(ctx context.Context) (*AppleBarrelResponse, error) {
	req, err := client.getEmptyWrappedListsCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getEmptyWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *xmlOperations) getEmptyWrappedListsCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *xmlOperations) getEmptyWrappedListsHandleResponse(resp *azcore.Response) (*AppleBarrelResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getEmptyWrappedListsHandleError(resp)
	}
	result := AppleBarrelResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.AppleBarrel)
}

// getEmptyWrappedListsHandleError handles the GetEmptyWrappedLists error response.
func (client *xmlOperations) getEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetHeaders - Get strongly-typed response headers.
func (client *xmlOperations) GetHeaders(ctx context.Context) (*XMLGetHeadersResponse, error) {
	req, err := client.getHeadersCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHeadersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getHeadersCreateRequest creates the GetHeaders request.
func (client *xmlOperations) getHeadersCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/headers"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHeadersHandleResponse handles the GetHeaders response.
func (client *xmlOperations) getHeadersHandleResponse(resp *azcore.Response) (*XMLGetHeadersResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHeadersHandleError(resp)
	}
	result := XMLGetHeadersResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return &result, nil
}

// getHeadersHandleError handles the GetHeaders error response.
func (client *xmlOperations) getHeadersHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetRootList - Gets a list as the root element.
func (client *xmlOperations) GetRootList(ctx context.Context) (*BananaArrayResponse, error) {
	req, err := client.getRootListCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getRootListCreateRequest creates the GetRootList request.
func (client *xmlOperations) getRootListCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getRootListHandleResponse handles the GetRootList response.
func (client *xmlOperations) getRootListHandleResponse(resp *azcore.Response) (*BananaArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getRootListHandleError(resp)
	}
	result := BananaArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// getRootListHandleError handles the GetRootList error response.
func (client *xmlOperations) getRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetRootListSingleItem - Gets a list with a single item.
func (client *xmlOperations) GetRootListSingleItem(ctx context.Context) (*BananaArrayResponse, error) {
	req, err := client.getRootListSingleItemCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getRootListSingleItemHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *xmlOperations) getRootListSingleItemCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *xmlOperations) getRootListSingleItemHandleResponse(resp *azcore.Response) (*BananaArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getRootListSingleItemHandleError(resp)
	}
	result := BananaArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// getRootListSingleItemHandleError handles the GetRootListSingleItem error response.
func (client *xmlOperations) getRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetServiceProperties - Gets storage service properties.
func (client *xmlOperations) GetServiceProperties(ctx context.Context) (*StorageServicePropertiesResponse, error) {
	req, err := client.getServicePropertiesCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getServicePropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *xmlOperations) getServicePropertiesCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "properties")
	query.Set("restype", "service")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *xmlOperations) getServicePropertiesHandleResponse(resp *azcore.Response) (*StorageServicePropertiesResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getServicePropertiesHandleError(resp)
	}
	result := StorageServicePropertiesResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.StorageServiceProperties)
}

// getServicePropertiesHandleError handles the GetServiceProperties error response.
func (client *xmlOperations) getServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetSimple - Get a simple XML document
func (client *xmlOperations) GetSimple(ctx context.Context) (*SlideshowResponse, error) {
	req, err := client.getSimpleCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getSimpleHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getSimpleCreateRequest creates the GetSimple request.
func (client *xmlOperations) getSimpleCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/simple"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getSimpleHandleResponse handles the GetSimple response.
func (client *xmlOperations) getSimpleHandleResponse(resp *azcore.Response) (*SlideshowResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getSimpleHandleError(resp)
	}
	result := SlideshowResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Slideshow)
}

// getSimpleHandleError handles the GetSimple error response.
func (client *xmlOperations) getSimpleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
func (client *xmlOperations) GetWrappedLists(ctx context.Context) (*AppleBarrelResponse, error) {
	req, err := client.getWrappedListsCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *xmlOperations) getWrappedListsCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *xmlOperations) getWrappedListsHandleResponse(resp *azcore.Response) (*AppleBarrelResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getWrappedListsHandleError(resp)
	}
	result := AppleBarrelResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.AppleBarrel)
}

// getWrappedListsHandleError handles the GetWrappedLists error response.
func (client *xmlOperations) getWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetXMSText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language' property being 'english' and its 'content' property being 'I am text'
func (client *xmlOperations) GetXMSText(ctx context.Context) (*ObjectWithXMSTextPropertyResponse, error) {
	req, err := client.getXmsTextCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getXmsTextHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getXmsTextCreateRequest creates the GetXMSText request.
func (client *xmlOperations) getXmsTextCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/x-ms-text"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getXmsTextHandleResponse handles the GetXMSText response.
func (client *xmlOperations) getXmsTextHandleResponse(resp *azcore.Response) (*ObjectWithXMSTextPropertyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getXmsTextHandleError(resp)
	}
	result := ObjectWithXMSTextPropertyResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Data)
}

// getXmsTextHandleError handles the GetXMSText error response.
func (client *xmlOperations) getXmsTextHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
func (client *xmlOperations) JSONInput(ctx context.Context, properties JSONInput) (*http.Response, error) {
	req, err := client.jsonInputCreateRequest(properties)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.jsonInputHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// jsonInputCreateRequest creates the JSONInput request.
func (client *xmlOperations) jsonInputCreateRequest(properties JSONInput) (*azcore.Request, error) {
	urlPath := "/xml/jsoninput"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(properties)
}

// jsonInputHandleResponse handles the JSONInput response.
func (client *xmlOperations) jsonInputHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.jsonInputHandleError(resp)
	}
	return resp.Response, nil
}

// jsonInputHandleError handles the JSONInput error response.
func (client *xmlOperations) jsonInputHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
func (client *xmlOperations) JSONOutput(ctx context.Context) (*JSONOutputResponse, error) {
	req, err := client.jsonOutputCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.jsonOutputHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// jsonOutputCreateRequest creates the JSONOutput request.
func (client *xmlOperations) jsonOutputCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/jsonoutput"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// jsonOutputHandleResponse handles the JSONOutput response.
func (client *xmlOperations) jsonOutputHandleResponse(resp *azcore.Response) (*JSONOutputResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.jsonOutputHandleError(resp)
	}
	result := JSONOutputResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.JSONOutput)
}

// jsonOutputHandleError handles the JSONOutput error response.
func (client *xmlOperations) jsonOutputHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListBlobs - Lists blobs in a storage container.
func (client *xmlOperations) ListBlobs(ctx context.Context) (*ListBlobsResponseResponse, error) {
	req, err := client.listBlobsCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listBlobsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listBlobsCreateRequest creates the ListBlobs request.
func (client *xmlOperations) listBlobsCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "list")
	query.Set("restype", "container")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listBlobsHandleResponse handles the ListBlobs response.
func (client *xmlOperations) listBlobsHandleResponse(resp *azcore.Response) (*ListBlobsResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listBlobsHandleError(resp)
	}
	result := ListBlobsResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// listBlobsHandleError handles the ListBlobs error response.
func (client *xmlOperations) listBlobsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListContainers - Lists containers in a storage account.
func (client *xmlOperations) ListContainers(ctx context.Context) (*ListContainersResponseResponse, error) {
	req, err := client.listContainersCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.listContainersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// listContainersCreateRequest creates the ListContainers request.
func (client *xmlOperations) listContainersCreateRequest() (*azcore.Request, error) {
	urlPath := "/xml/"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "list")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listContainersHandleResponse handles the ListContainers response.
func (client *xmlOperations) listContainersHandleResponse(resp *azcore.Response) (*ListContainersResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listContainersHandleError(resp)
	}
	result := ListContainersResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// listContainersHandleError handles the ListContainers error response.
func (client *xmlOperations) listContainersHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutACLs - Puts storage ACLs for a container.
func (client *xmlOperations) PutACLs(ctx context.Context, properties []SignedIDentifier) (*http.Response, error) {
	req, err := client.putAcLsCreateRequest(properties)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putAcLsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putAcLsCreateRequest creates the PutACLs request.
func (client *xmlOperations) putAcLsCreateRequest(properties []SignedIDentifier) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "acl")
	query.Set("restype", "container")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	type wrapper struct {
		XMLName    xml.Name            `xml:"SignedIdentifiers"`
		Properties *[]SignedIDentifier `xml:"SignedIdentifier"`
	}
	return req, req.MarshalAsXML(wrapper{Properties: &properties})
}

// putAcLsHandleResponse handles the PutACLs response.
func (client *xmlOperations) putAcLsHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putAcLsHandleError(resp)
	}
	return resp.Response, nil
}

// putAcLsHandleError handles the PutACLs error response.
func (client *xmlOperations) putAcLsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
func (client *xmlOperations) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta) (*http.Response, error) {
	req, err := client.putComplexTypeRefNoMetaCreateRequest(model)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putComplexTypeRefNoMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *xmlOperations) putComplexTypeRefNoMetaCreateRequest(model RootWithRefAndNoMeta) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(model)
}

// putComplexTypeRefNoMetaHandleResponse handles the PutComplexTypeRefNoMeta response.
func (client *xmlOperations) putComplexTypeRefNoMetaHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putComplexTypeRefNoMetaHandleError(resp)
	}
	return resp.Response, nil
}

// putComplexTypeRefNoMetaHandleError handles the PutComplexTypeRefNoMeta error response.
func (client *xmlOperations) putComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
func (client *xmlOperations) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta) (*http.Response, error) {
	req, err := client.putComplexTypeRefWithMetaCreateRequest(model)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putComplexTypeRefWithMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *xmlOperations) putComplexTypeRefWithMetaCreateRequest(model RootWithRefAndMeta) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(model)
}

// putComplexTypeRefWithMetaHandleResponse handles the PutComplexTypeRefWithMeta response.
func (client *xmlOperations) putComplexTypeRefWithMetaHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putComplexTypeRefWithMetaHandleError(resp)
	}
	return resp.Response, nil
}

// putComplexTypeRefWithMetaHandleError handles the PutComplexTypeRefWithMeta error response.
func (client *xmlOperations) putComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyChildElement - Puts a value with an empty child element.
func (client *xmlOperations) PutEmptyChildElement(ctx context.Context, banana Banana) (*http.Response, error) {
	req, err := client.putEmptyChildElementCreateRequest(banana)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putEmptyChildElementHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *xmlOperations) putEmptyChildElementCreateRequest(banana Banana) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(banana)
}

// putEmptyChildElementHandleResponse handles the PutEmptyChildElement response.
func (client *xmlOperations) putEmptyChildElementHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyChildElementHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyChildElementHandleError handles the PutEmptyChildElement error response.
func (client *xmlOperations) putEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyList - Puts an empty list.
func (client *xmlOperations) PutEmptyList(ctx context.Context, slideshow Slideshow) (*http.Response, error) {
	req, err := client.putEmptyListCreateRequest(slideshow)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putEmptyListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putEmptyListCreateRequest creates the PutEmptyList request.
func (client *xmlOperations) putEmptyListCreateRequest(slideshow Slideshow) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(slideshow)
}

// putEmptyListHandleResponse handles the PutEmptyList response.
func (client *xmlOperations) putEmptyListHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyListHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyListHandleError handles the PutEmptyList error response.
func (client *xmlOperations) putEmptyListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyRootList - Puts an empty list as the root element.
func (client *xmlOperations) PutEmptyRootList(ctx context.Context, bananas []Banana) (*http.Response, error) {
	req, err := client.putEmptyRootListCreateRequest(bananas)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putEmptyRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *xmlOperations) putEmptyRootListCreateRequest(bananas []Banana) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	type wrapper struct {
		XMLName xml.Name  `xml:"bananas"`
		Bananas *[]Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putEmptyRootListHandleResponse handles the PutEmptyRootList response.
func (client *xmlOperations) putEmptyRootListHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyRootListHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyRootListHandleError handles the PutEmptyRootList error response.
func (client *xmlOperations) putEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
func (client *xmlOperations) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel) (*http.Response, error) {
	req, err := client.putEmptyWrappedListsCreateRequest(appleBarrel)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putEmptyWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *xmlOperations) putEmptyWrappedListsCreateRequest(appleBarrel AppleBarrel) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(appleBarrel)
}

// putEmptyWrappedListsHandleResponse handles the PutEmptyWrappedLists response.
func (client *xmlOperations) putEmptyWrappedListsHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyWrappedListsHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyWrappedListsHandleError handles the PutEmptyWrappedLists error response.
func (client *xmlOperations) putEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutRootList - Puts a list as the root element.
func (client *xmlOperations) PutRootList(ctx context.Context, bananas []Banana) (*http.Response, error) {
	req, err := client.putRootListCreateRequest(bananas)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putRootListCreateRequest creates the PutRootList request.
func (client *xmlOperations) putRootListCreateRequest(bananas []Banana) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	type wrapper struct {
		XMLName xml.Name  `xml:"bananas"`
		Bananas *[]Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putRootListHandleResponse handles the PutRootList response.
func (client *xmlOperations) putRootListHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putRootListHandleError(resp)
	}
	return resp.Response, nil
}

// putRootListHandleError handles the PutRootList error response.
func (client *xmlOperations) putRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutRootListSingleItem - Puts a list with a single item.
func (client *xmlOperations) PutRootListSingleItem(ctx context.Context, bananas []Banana) (*http.Response, error) {
	req, err := client.putRootListSingleItemCreateRequest(bananas)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putRootListSingleItemHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *xmlOperations) putRootListSingleItemCreateRequest(bananas []Banana) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	type wrapper struct {
		XMLName xml.Name  `xml:"bananas"`
		Bananas *[]Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putRootListSingleItemHandleResponse handles the PutRootListSingleItem response.
func (client *xmlOperations) putRootListSingleItemHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putRootListSingleItemHandleError(resp)
	}
	return resp.Response, nil
}

// putRootListSingleItemHandleError handles the PutRootListSingleItem error response.
func (client *xmlOperations) putRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutServiceProperties - Puts storage service properties.
func (client *xmlOperations) PutServiceProperties(ctx context.Context, properties StorageServiceProperties) (*http.Response, error) {
	req, err := client.putServicePropertiesCreateRequest(properties)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putServicePropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *xmlOperations) putServicePropertiesCreateRequest(properties StorageServiceProperties) (*azcore.Request, error) {
	urlPath := "/xml/"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("comp", "properties")
	query.Set("restype", "service")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(properties)
}

// putServicePropertiesHandleResponse handles the PutServiceProperties response.
func (client *xmlOperations) putServicePropertiesHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putServicePropertiesHandleError(resp)
	}
	return resp.Response, nil
}

// putServicePropertiesHandleError handles the PutServiceProperties error response.
func (client *xmlOperations) putServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutSimple - Put a simple XML document
func (client *xmlOperations) PutSimple(ctx context.Context, slideshow Slideshow) (*http.Response, error) {
	req, err := client.putSimpleCreateRequest(slideshow)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putSimpleHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putSimpleCreateRequest creates the PutSimple request.
func (client *xmlOperations) putSimpleCreateRequest(slideshow Slideshow) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(slideshow)
}

// putSimpleHandleResponse handles the PutSimple response.
func (client *xmlOperations) putSimpleHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putSimpleHandleError(resp)
	}
	return resp.Response, nil
}

// putSimpleHandleError handles the PutSimple error response.
func (client *xmlOperations) putSimpleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
func (client *xmlOperations) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel) (*http.Response, error) {
	req, err := client.putWrappedListsCreateRequest(wrappedLists)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.putWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// putWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *xmlOperations) putWrappedListsCreateRequest(wrappedLists AppleBarrel) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	u, err := client.u.Parse(path.Join(client.u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsXML(wrappedLists)
}

// putWrappedListsHandleResponse handles the PutWrappedLists response.
func (client *xmlOperations) putWrappedListsHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putWrappedListsHandleError(resp)
	}
	return resp.Response, nil
}

// putWrappedListsHandleError handles the PutWrappedLists error response.
func (client *xmlOperations) putWrappedListsHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}
