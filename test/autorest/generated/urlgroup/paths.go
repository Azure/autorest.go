// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package urlgroup

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"
)

// PathsOperations contains the methods for the Paths group.
type PathsOperations interface {
	// ArrayCSVInPath - Get an array of string ['ArrayPath1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
	ArrayCSVInPath(ctx context.Context, arrayPath []string) (*http.Response, error)
	// Base64URL - Get 'lorem' encoded value as 'bG9yZW0' (base64url)
	Base64URL(ctx context.Context, base64UrlPath []byte) (*http.Response, error)
	// ByteEmpty - Get '' as byte array
	ByteEmpty(ctx context.Context) (*http.Response, error)
	// ByteMultiByte - Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
	ByteMultiByte(ctx context.Context, bytePath []byte) (*http.Response, error)
	// ByteNull - Get null as byte array (should throw)
	ByteNull(ctx context.Context, bytePath []byte) (*http.Response, error)
	// DateNull - Get null as date - this should throw or be unusable on the client side, depending on date representation
	DateNull(ctx context.Context, datePath time.Time) (*http.Response, error)
	// DateTimeNull - Get null as date-time, should be disallowed or throw depending on representation of date-time
	DateTimeNull(ctx context.Context, dateTimePath time.Time) (*http.Response, error)
	// DateTimeValid - Get '2012-01-01T01:01:01Z' as date-time
	DateTimeValid(ctx context.Context) (*http.Response, error)
	// DateValid - Get '2012-01-01' as date
	DateValid(ctx context.Context) (*http.Response, error)
	// DoubleDecimalNegative - Get '-9999999.999' numeric value
	DoubleDecimalNegative(ctx context.Context) (*http.Response, error)
	// DoubleDecimalPositive - Get '9999999.999' numeric value
	DoubleDecimalPositive(ctx context.Context) (*http.Response, error)
	// EnumNull - Get null (should throw on the client before the request is sent on wire)
	EnumNull(ctx context.Context, enumPath URIColor) (*http.Response, error)
	// EnumValid - Get using uri with 'green color' in path parameter
	EnumValid(ctx context.Context, enumPath URIColor) (*http.Response, error)
	// FloatScientificNegative - Get '-1.034E-20' numeric value
	FloatScientificNegative(ctx context.Context) (*http.Response, error)
	// FloatScientificPositive - Get '1.034E+20' numeric value
	FloatScientificPositive(ctx context.Context) (*http.Response, error)
	// GetBooleanFalse - Get false Boolean value on path
	GetBooleanFalse(ctx context.Context) (*http.Response, error)
	// GetBooleanTrue - Get true Boolean value on path
	GetBooleanTrue(ctx context.Context) (*http.Response, error)
	// GetIntNegativeOneMillion - Get '-1000000' integer value
	GetIntNegativeOneMillion(ctx context.Context) (*http.Response, error)
	// GetIntOneMillion - Get '1000000' integer value
	GetIntOneMillion(ctx context.Context) (*http.Response, error)
	// GetNegativeTenBillion - Get '-10000000000' 64 bit integer value
	GetNegativeTenBillion(ctx context.Context) (*http.Response, error)
	// GetTenBillion - Get '10000000000' 64 bit integer value
	GetTenBillion(ctx context.Context) (*http.Response, error)
	// StringEmpty - Get ''
	StringEmpty(ctx context.Context) (*http.Response, error)
	// StringNull - Get null (should throw)
	StringNull(ctx context.Context, stringPath string) (*http.Response, error)
	// StringURLEncoded - Get 'begin!*'();:@ &=+$,/?#[]end
	StringURLEncoded(ctx context.Context) (*http.Response, error)
	// StringURLNonEncoded - https://tools.ietf.org/html/rfc3986#appendix-A 'path' accept any 'pchar' not encoded
	StringURLNonEncoded(ctx context.Context) (*http.Response, error)
	// StringUnicode - Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
	StringUnicode(ctx context.Context) (*http.Response, error)
	// UnixTimeURL - Get the date 2016-04-13 encoded value as '1460505600' (Unix time)
	UnixTimeURL(ctx context.Context, unixTimeUrlPath time.Time) (*http.Response, error)
}

// PathsClient implements the PathsOperations interface.
// Don't use this type directly, use NewPathsClient() instead.
type PathsClient struct {
	*Client
}

// NewPathsClient creates a new instance of PathsClient with the specified values.
func NewPathsClient(c *Client) PathsOperations {
	return &PathsClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *PathsClient) Do(ctx context.Context, req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(ctx, req)
}

// ArrayCSVInPath - Get an array of string ['ArrayPath1', 'begin!*'();:@ &=+$,/?#[]end' , null, ''] using the csv-array format
func (client *PathsClient) ArrayCSVInPath(ctx context.Context, arrayPath []string) (*http.Response, error) {
	req, err := client.ArrayCSVInPathCreateRequest(arrayPath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.ArrayCSVInPathHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ArrayCSVInPathCreateRequest creates the ArrayCSVInPath request.
func (client *PathsClient) ArrayCSVInPathCreateRequest(arrayPath []string) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/array/ArrayPath1%2cbegin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend%2c%2c/{arrayPath}"
	urlPath = strings.ReplaceAll(urlPath, "{arrayPath}", url.PathEscape(strings.Join(arrayPath, ",")))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// ArrayCSVInPathHandleResponse handles the ArrayCSVInPath response.
func (client *PathsClient) ArrayCSVInPathHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ArrayCSVInPathHandleError(resp)
	}
	return resp.Response, nil
}

// ArrayCSVInPathHandleError handles the ArrayCSVInPath error response.
func (client *PathsClient) ArrayCSVInPathHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// Base64URL - Get 'lorem' encoded value as 'bG9yZW0' (base64url)
func (client *PathsClient) Base64URL(ctx context.Context, base64UrlPath []byte) (*http.Response, error) {
	req, err := client.Base64URLCreateRequest(base64UrlPath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.Base64URLHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// Base64URLCreateRequest creates the Base64URL request.
func (client *PathsClient) Base64URLCreateRequest(base64UrlPath []byte) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/bG9yZW0/{base64UrlPath}"
	urlPath = strings.ReplaceAll(urlPath, "{base64UrlPath}", url.PathEscape(base64.RawURLEncoding.EncodeToString(base64UrlPath)))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// Base64URLHandleResponse handles the Base64URL response.
func (client *PathsClient) Base64URLHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.Base64URLHandleError(resp)
	}
	return resp.Response, nil
}

// Base64URLHandleError handles the Base64URL error response.
func (client *PathsClient) Base64URLHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ByteEmpty - Get '' as byte array
func (client *PathsClient) ByteEmpty(ctx context.Context) (*http.Response, error) {
	req, err := client.ByteEmptyCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.ByteEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ByteEmptyCreateRequest creates the ByteEmpty request.
func (client *PathsClient) ByteEmptyCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/byte/empty/{bytePath}"
	urlPath = strings.ReplaceAll(urlPath, "{bytePath}", url.PathEscape(""))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// ByteEmptyHandleResponse handles the ByteEmpty response.
func (client *PathsClient) ByteEmptyHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ByteEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// ByteEmptyHandleError handles the ByteEmpty error response.
func (client *PathsClient) ByteEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ByteMultiByte - Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
func (client *PathsClient) ByteMultiByte(ctx context.Context, bytePath []byte) (*http.Response, error) {
	req, err := client.ByteMultiByteCreateRequest(bytePath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.ByteMultiByteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ByteMultiByteCreateRequest creates the ByteMultiByte request.
func (client *PathsClient) ByteMultiByteCreateRequest(bytePath []byte) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/byte/multibyte/{bytePath}"
	urlPath = strings.ReplaceAll(urlPath, "{bytePath}", url.PathEscape(base64.StdEncoding.EncodeToString(bytePath)))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// ByteMultiByteHandleResponse handles the ByteMultiByte response.
func (client *PathsClient) ByteMultiByteHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ByteMultiByteHandleError(resp)
	}
	return resp.Response, nil
}

// ByteMultiByteHandleError handles the ByteMultiByte error response.
func (client *PathsClient) ByteMultiByteHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// ByteNull - Get null as byte array (should throw)
func (client *PathsClient) ByteNull(ctx context.Context, bytePath []byte) (*http.Response, error) {
	req, err := client.ByteNullCreateRequest(bytePath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.ByteNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ByteNullCreateRequest creates the ByteNull request.
func (client *PathsClient) ByteNullCreateRequest(bytePath []byte) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/byte/null/{bytePath}"
	urlPath = strings.ReplaceAll(urlPath, "{bytePath}", url.PathEscape(base64.StdEncoding.EncodeToString(bytePath)))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// ByteNullHandleResponse handles the ByteNull response.
func (client *PathsClient) ByteNullHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusBadRequest) {
		return nil, client.ByteNullHandleError(resp)
	}
	return resp.Response, nil
}

// ByteNullHandleError handles the ByteNull error response.
func (client *PathsClient) ByteNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateNull - Get null as date - this should throw or be unusable on the client side, depending on date representation
func (client *PathsClient) DateNull(ctx context.Context, datePath time.Time) (*http.Response, error) {
	req, err := client.DateNullCreateRequest(datePath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DateNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DateNullCreateRequest creates the DateNull request.
func (client *PathsClient) DateNullCreateRequest(datePath time.Time) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/date/null/{datePath}"
	urlPath = strings.ReplaceAll(urlPath, "{datePath}", url.PathEscape(datePath.Format("2006-01-02")))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// DateNullHandleResponse handles the DateNull response.
func (client *PathsClient) DateNullHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusBadRequest) {
		return nil, client.DateNullHandleError(resp)
	}
	return resp.Response, nil
}

// DateNullHandleError handles the DateNull error response.
func (client *PathsClient) DateNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateTimeNull - Get null as date-time, should be disallowed or throw depending on representation of date-time
func (client *PathsClient) DateTimeNull(ctx context.Context, dateTimePath time.Time) (*http.Response, error) {
	req, err := client.DateTimeNullCreateRequest(dateTimePath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DateTimeNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DateTimeNullCreateRequest creates the DateTimeNull request.
func (client *PathsClient) DateTimeNullCreateRequest(dateTimePath time.Time) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/datetime/null/{dateTimePath}"
	urlPath = strings.ReplaceAll(urlPath, "{dateTimePath}", url.PathEscape(dateTimePath.Format(time.RFC3339Nano)))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// DateTimeNullHandleResponse handles the DateTimeNull response.
func (client *PathsClient) DateTimeNullHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusBadRequest) {
		return nil, client.DateTimeNullHandleError(resp)
	}
	return resp.Response, nil
}

// DateTimeNullHandleError handles the DateTimeNull error response.
func (client *PathsClient) DateTimeNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateTimeValid - Get '2012-01-01T01:01:01Z' as date-time
func (client *PathsClient) DateTimeValid(ctx context.Context) (*http.Response, error) {
	req, err := client.DateTimeValidCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DateTimeValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DateTimeValidCreateRequest creates the DateTimeValid request.
func (client *PathsClient) DateTimeValidCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/datetime/2012-01-01T01%3A01%3A01Z/{dateTimePath}"
	urlPath = strings.ReplaceAll(urlPath, "{dateTimePath}", url.PathEscape("2012-01-01T01:01:01Z"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// DateTimeValidHandleResponse handles the DateTimeValid response.
func (client *PathsClient) DateTimeValidHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DateTimeValidHandleError(resp)
	}
	return resp.Response, nil
}

// DateTimeValidHandleError handles the DateTimeValid error response.
func (client *PathsClient) DateTimeValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DateValid - Get '2012-01-01' as date
func (client *PathsClient) DateValid(ctx context.Context) (*http.Response, error) {
	req, err := client.DateValidCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DateValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DateValidCreateRequest creates the DateValid request.
func (client *PathsClient) DateValidCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/date/2012-01-01/{datePath}"
	urlPath = strings.ReplaceAll(urlPath, "{datePath}", url.PathEscape("2012-01-01"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// DateValidHandleResponse handles the DateValid response.
func (client *PathsClient) DateValidHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DateValidHandleError(resp)
	}
	return resp.Response, nil
}

// DateValidHandleError handles the DateValid error response.
func (client *PathsClient) DateValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DoubleDecimalNegative - Get '-9999999.999' numeric value
func (client *PathsClient) DoubleDecimalNegative(ctx context.Context) (*http.Response, error) {
	req, err := client.DoubleDecimalNegativeCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DoubleDecimalNegativeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DoubleDecimalNegativeCreateRequest creates the DoubleDecimalNegative request.
func (client *PathsClient) DoubleDecimalNegativeCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/double/-9999999.999/{doublePath}"
	urlPath = strings.ReplaceAll(urlPath, "{doublePath}", url.PathEscape("-9999999.999"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// DoubleDecimalNegativeHandleResponse handles the DoubleDecimalNegative response.
func (client *PathsClient) DoubleDecimalNegativeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DoubleDecimalNegativeHandleError(resp)
	}
	return resp.Response, nil
}

// DoubleDecimalNegativeHandleError handles the DoubleDecimalNegative error response.
func (client *PathsClient) DoubleDecimalNegativeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// DoubleDecimalPositive - Get '9999999.999' numeric value
func (client *PathsClient) DoubleDecimalPositive(ctx context.Context) (*http.Response, error) {
	req, err := client.DoubleDecimalPositiveCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.DoubleDecimalPositiveHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// DoubleDecimalPositiveCreateRequest creates the DoubleDecimalPositive request.
func (client *PathsClient) DoubleDecimalPositiveCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/double/9999999.999/{doublePath}"
	urlPath = strings.ReplaceAll(urlPath, "{doublePath}", url.PathEscape("9999999.999"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// DoubleDecimalPositiveHandleResponse handles the DoubleDecimalPositive response.
func (client *PathsClient) DoubleDecimalPositiveHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.DoubleDecimalPositiveHandleError(resp)
	}
	return resp.Response, nil
}

// DoubleDecimalPositiveHandleError handles the DoubleDecimalPositive error response.
func (client *PathsClient) DoubleDecimalPositiveHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// EnumNull - Get null (should throw on the client before the request is sent on wire)
func (client *PathsClient) EnumNull(ctx context.Context, enumPath URIColor) (*http.Response, error) {
	req, err := client.EnumNullCreateRequest(enumPath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.EnumNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// EnumNullCreateRequest creates the EnumNull request.
func (client *PathsClient) EnumNullCreateRequest(enumPath URIColor) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/null/{enumPath}"
	urlPath = strings.ReplaceAll(urlPath, "{enumPath}", url.PathEscape(string(enumPath)))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// EnumNullHandleResponse handles the EnumNull response.
func (client *PathsClient) EnumNullHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusBadRequest) {
		return nil, client.EnumNullHandleError(resp)
	}
	return resp.Response, nil
}

// EnumNullHandleError handles the EnumNull error response.
func (client *PathsClient) EnumNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// EnumValid - Get using uri with 'green color' in path parameter
func (client *PathsClient) EnumValid(ctx context.Context, enumPath URIColor) (*http.Response, error) {
	req, err := client.EnumValidCreateRequest(enumPath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.EnumValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// EnumValidCreateRequest creates the EnumValid request.
func (client *PathsClient) EnumValidCreateRequest(enumPath URIColor) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/enum/green%20color/{enumPath}"
	urlPath = strings.ReplaceAll(urlPath, "{enumPath}", url.PathEscape(string(enumPath)))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// EnumValidHandleResponse handles the EnumValid response.
func (client *PathsClient) EnumValidHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.EnumValidHandleError(resp)
	}
	return resp.Response, nil
}

// EnumValidHandleError handles the EnumValid error response.
func (client *PathsClient) EnumValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// FloatScientificNegative - Get '-1.034E-20' numeric value
func (client *PathsClient) FloatScientificNegative(ctx context.Context) (*http.Response, error) {
	req, err := client.FloatScientificNegativeCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.FloatScientificNegativeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// FloatScientificNegativeCreateRequest creates the FloatScientificNegative request.
func (client *PathsClient) FloatScientificNegativeCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/float/-1.034E-20/{floatPath}"
	urlPath = strings.ReplaceAll(urlPath, "{floatPath}", url.PathEscape("-1.034e-20"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// FloatScientificNegativeHandleResponse handles the FloatScientificNegative response.
func (client *PathsClient) FloatScientificNegativeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.FloatScientificNegativeHandleError(resp)
	}
	return resp.Response, nil
}

// FloatScientificNegativeHandleError handles the FloatScientificNegative error response.
func (client *PathsClient) FloatScientificNegativeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// FloatScientificPositive - Get '1.034E+20' numeric value
func (client *PathsClient) FloatScientificPositive(ctx context.Context) (*http.Response, error) {
	req, err := client.FloatScientificPositiveCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.FloatScientificPositiveHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// FloatScientificPositiveCreateRequest creates the FloatScientificPositive request.
func (client *PathsClient) FloatScientificPositiveCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/float/1.034E+20/{floatPath}"
	urlPath = strings.ReplaceAll(urlPath, "{floatPath}", url.PathEscape("103400000000000000000"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// FloatScientificPositiveHandleResponse handles the FloatScientificPositive response.
func (client *PathsClient) FloatScientificPositiveHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.FloatScientificPositiveHandleError(resp)
	}
	return resp.Response, nil
}

// FloatScientificPositiveHandleError handles the FloatScientificPositive error response.
func (client *PathsClient) FloatScientificPositiveHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetBooleanFalse - Get false Boolean value on path
func (client *PathsClient) GetBooleanFalse(ctx context.Context) (*http.Response, error) {
	req, err := client.GetBooleanFalseCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetBooleanFalseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetBooleanFalseCreateRequest creates the GetBooleanFalse request.
func (client *PathsClient) GetBooleanFalseCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/bool/false/{boolPath}"
	urlPath = strings.ReplaceAll(urlPath, "{boolPath}", url.PathEscape("false"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// GetBooleanFalseHandleResponse handles the GetBooleanFalse response.
func (client *PathsClient) GetBooleanFalseHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanFalseHandleError(resp)
	}
	return resp.Response, nil
}

// GetBooleanFalseHandleError handles the GetBooleanFalse error response.
func (client *PathsClient) GetBooleanFalseHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetBooleanTrue - Get true Boolean value on path
func (client *PathsClient) GetBooleanTrue(ctx context.Context) (*http.Response, error) {
	req, err := client.GetBooleanTrueCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetBooleanTrueHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetBooleanTrueCreateRequest creates the GetBooleanTrue request.
func (client *PathsClient) GetBooleanTrueCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/bool/true/{boolPath}"
	urlPath = strings.ReplaceAll(urlPath, "{boolPath}", url.PathEscape("true"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// GetBooleanTrueHandleResponse handles the GetBooleanTrue response.
func (client *PathsClient) GetBooleanTrueHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanTrueHandleError(resp)
	}
	return resp.Response, nil
}

// GetBooleanTrueHandleError handles the GetBooleanTrue error response.
func (client *PathsClient) GetBooleanTrueHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetIntNegativeOneMillion - Get '-1000000' integer value
func (client *PathsClient) GetIntNegativeOneMillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetIntNegativeOneMillionCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetIntNegativeOneMillionHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetIntNegativeOneMillionCreateRequest creates the GetIntNegativeOneMillion request.
func (client *PathsClient) GetIntNegativeOneMillionCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/int/-1000000/{intPath}"
	urlPath = strings.ReplaceAll(urlPath, "{intPath}", url.PathEscape("-1000000"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// GetIntNegativeOneMillionHandleResponse handles the GetIntNegativeOneMillion response.
func (client *PathsClient) GetIntNegativeOneMillionHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntNegativeOneMillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetIntNegativeOneMillionHandleError handles the GetIntNegativeOneMillion error response.
func (client *PathsClient) GetIntNegativeOneMillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetIntOneMillion - Get '1000000' integer value
func (client *PathsClient) GetIntOneMillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetIntOneMillionCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetIntOneMillionHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetIntOneMillionCreateRequest creates the GetIntOneMillion request.
func (client *PathsClient) GetIntOneMillionCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/int/1000000/{intPath}"
	urlPath = strings.ReplaceAll(urlPath, "{intPath}", url.PathEscape("1000000"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// GetIntOneMillionHandleResponse handles the GetIntOneMillion response.
func (client *PathsClient) GetIntOneMillionHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntOneMillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetIntOneMillionHandleError handles the GetIntOneMillion error response.
func (client *PathsClient) GetIntOneMillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetNegativeTenBillion - Get '-10000000000' 64 bit integer value
func (client *PathsClient) GetNegativeTenBillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetNegativeTenBillionCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetNegativeTenBillionHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNegativeTenBillionCreateRequest creates the GetNegativeTenBillion request.
func (client *PathsClient) GetNegativeTenBillionCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/long/-10000000000/{longPath}"
	urlPath = strings.ReplaceAll(urlPath, "{longPath}", url.PathEscape("-10000000000"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// GetNegativeTenBillionHandleResponse handles the GetNegativeTenBillion response.
func (client *PathsClient) GetNegativeTenBillionHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNegativeTenBillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetNegativeTenBillionHandleError handles the GetNegativeTenBillion error response.
func (client *PathsClient) GetNegativeTenBillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetTenBillion - Get '10000000000' 64 bit integer value
func (client *PathsClient) GetTenBillion(ctx context.Context) (*http.Response, error) {
	req, err := client.GetTenBillionCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetTenBillionHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetTenBillionCreateRequest creates the GetTenBillion request.
func (client *PathsClient) GetTenBillionCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/long/10000000000/{longPath}"
	urlPath = strings.ReplaceAll(urlPath, "{longPath}", url.PathEscape("10000000000"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// GetTenBillionHandleResponse handles the GetTenBillion response.
func (client *PathsClient) GetTenBillionHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetTenBillionHandleError(resp)
	}
	return resp.Response, nil
}

// GetTenBillionHandleError handles the GetTenBillion error response.
func (client *PathsClient) GetTenBillionHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringEmpty - Get ''
func (client *PathsClient) StringEmpty(ctx context.Context) (*http.Response, error) {
	req, err := client.StringEmptyCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.StringEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// StringEmptyCreateRequest creates the StringEmpty request.
func (client *PathsClient) StringEmptyCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/empty/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape(""))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// StringEmptyHandleResponse handles the StringEmpty response.
func (client *PathsClient) StringEmptyHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// StringEmptyHandleError handles the StringEmpty error response.
func (client *PathsClient) StringEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringNull - Get null (should throw)
func (client *PathsClient) StringNull(ctx context.Context, stringPath string) (*http.Response, error) {
	req, err := client.StringNullCreateRequest(stringPath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.StringNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// StringNullCreateRequest creates the StringNull request.
func (client *PathsClient) StringNullCreateRequest(stringPath string) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/null/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape(stringPath))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// StringNullHandleResponse handles the StringNull response.
func (client *PathsClient) StringNullHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusBadRequest) {
		return nil, client.StringNullHandleError(resp)
	}
	return resp.Response, nil
}

// StringNullHandleError handles the StringNull error response.
func (client *PathsClient) StringNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringURLEncoded - Get 'begin!*'();:@ &=+$,/?#[]end
func (client *PathsClient) StringURLEncoded(ctx context.Context) (*http.Response, error) {
	req, err := client.StringURLEncodedCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.StringURLEncodedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// StringURLEncodedCreateRequest creates the StringURLEncoded request.
func (client *PathsClient) StringURLEncodedCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape("begin!*'();:@ &=+$,/?#[]end"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// StringURLEncodedHandleResponse handles the StringURLEncoded response.
func (client *PathsClient) StringURLEncodedHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringURLEncodedHandleError(resp)
	}
	return resp.Response, nil
}

// StringURLEncodedHandleError handles the StringURLEncoded error response.
func (client *PathsClient) StringURLEncodedHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringURLNonEncoded - https://tools.ietf.org/html/rfc3986#appendix-A 'path' accept any 'pchar' not encoded
func (client *PathsClient) StringURLNonEncoded(ctx context.Context) (*http.Response, error) {
	req, err := client.StringURLNonEncodedCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.StringURLNonEncodedHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// StringURLNonEncodedCreateRequest creates the StringURLNonEncoded request.
func (client *PathsClient) StringURLNonEncodedCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/begin!*'();:@&=+$,end/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", "begin!*'();:@&=+$,end")
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// StringURLNonEncodedHandleResponse handles the StringURLNonEncoded response.
func (client *PathsClient) StringURLNonEncodedHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringURLNonEncodedHandleError(resp)
	}
	return resp.Response, nil
}

// StringURLNonEncodedHandleError handles the StringURLNonEncoded error response.
func (client *PathsClient) StringURLNonEncodedHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// StringUnicode - Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
func (client *PathsClient) StringUnicode(ctx context.Context) (*http.Response, error) {
	req, err := client.StringUnicodeCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.StringUnicodeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// StringUnicodeCreateRequest creates the StringUnicode request.
func (client *PathsClient) StringUnicodeCreateRequest() (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/string/unicode/{stringPath}"
	urlPath = strings.ReplaceAll(urlPath, "{stringPath}", url.PathEscape("啊齄丂狛狜隣郎隣兀﨩"))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// StringUnicodeHandleResponse handles the StringUnicode response.
func (client *PathsClient) StringUnicodeHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.StringUnicodeHandleError(resp)
	}
	return resp.Response, nil
}

// StringUnicodeHandleError handles the StringUnicode error response.
func (client *PathsClient) StringUnicodeHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// UnixTimeURL - Get the date 2016-04-13 encoded value as '1460505600' (Unix time)
func (client *PathsClient) UnixTimeURL(ctx context.Context, unixTimeUrlPath time.Time) (*http.Response, error) {
	req, err := client.UnixTimeURLCreateRequest(unixTimeUrlPath)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.UnixTimeURLHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// UnixTimeURLCreateRequest creates the UnixTimeURL request.
func (client *PathsClient) UnixTimeURLCreateRequest(unixTimeUrlPath time.Time) (*azcore.Request, error) {
	u, err := url.Parse(client.u)
	if err != nil {
		return nil, err
	}
	urlPath := "/paths/int/1460505600/{unixTimeUrlPath}"
	urlPath = strings.ReplaceAll(urlPath, "{unixTimeUrlPath}", url.PathEscape(timeUnix(unixTimeUrlPath).String()))
	u, err = u.Parse(path.Join(u.Path, urlPath))
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// UnixTimeURLHandleResponse handles the UnixTimeURL response.
func (client *PathsClient) UnixTimeURLHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.UnixTimeURLHandleError(resp)
	}
	return resp.Response, nil
}

// UnixTimeURLHandleError handles the UnixTimeURL error response.
func (client *PathsClient) UnixTimeURLHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
