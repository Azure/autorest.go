// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// PagingOperations contains the methods for the Paging group.
type PagingOperations interface {
	// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePages(pagingGetMultiplePagesOptions *PagingGetMultiplePagesOptions) (ProductResultPager, error)
	// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
	GetMultiplePagesFailure() (ProductResultPager, error)
	// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
	GetMultiplePagesFailureURI() (ProductResultPager, error)
	// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
	GetMultiplePagesFragmentNextLink(apiVersion string, tenant string) (OdataProductResultPager, error)
	// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
	GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) (OdataProductResultPager, error)
	// BeginGetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
	BeginGetMultiplePagesLro(pagingGetMultiplePagesLroOptions *PagingGetMultiplePagesLroOptions) (ProductResultPager, error)
	// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that has 10 pages
	GetMultiplePagesRetryFirst() (ProductResultPager, error)
	// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should retry and finish all 10 pages eventually.
	GetMultiplePagesRetrySecond() (ProductResultPager, error)
	// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) (ProductResultPager, error)
	// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
	GetNoItemNamePages() (ProductResultValuePager, error)
	// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
	GetNullNextLinkNamePages(ctx context.Context) (*ProductResultResponse, error)
	// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
	GetOdataMultiplePages(pagingGetOdataMultiplePagesOptions *PagingGetOdataMultiplePagesOptions) (OdataProductResultPager, error)
	// GetSinglePages - A paging operation that finishes on the first call without a nextlink
	GetSinglePages() (ProductResultPager, error)
	// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
	GetSinglePagesFailure() (ProductResultPager, error)
}

// pagingOperations implements the PagingOperations interface.
type pagingOperations struct {
	*Client
}

// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
func (client *pagingOperations) GetMultiplePages(pagingGetMultiplePagesOptions *PagingGetMultiplePagesOptions) (ProductResultPager, error) {
	req, err := client.getMultiplePagesCreateRequest(pagingGetMultiplePagesOptions)
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *pagingOperations) getMultiplePagesCreateRequest(pagingGetMultiplePagesOptions *PagingGetMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if pagingGetMultiplePagesOptions != nil && pagingGetMultiplePagesOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesOptions != nil && pagingGetMultiplePagesOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesOptions != nil && pagingGetMultiplePagesOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesOptions.Timeout), 10))
	}
	return req, nil
}

// getMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *pagingOperations) getMultiplePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesHandleError handles the GetMultiplePages error response.
func (client *pagingOperations) getMultiplePagesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
func (client *pagingOperations) GetMultiplePagesFailure() (ProductResultPager, error) {
	req, err := client.getMultiplePagesFailureCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFailureHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *pagingOperations) getMultiplePagesFailureCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/failure"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *pagingOperations) getMultiplePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesFailureHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesFailureHandleError handles the GetMultiplePagesFailure error response.
func (client *pagingOperations) getMultiplePagesFailureHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
func (client *pagingOperations) GetMultiplePagesFailureURI() (ProductResultPager, error) {
	req, err := client.getMultiplePagesFailureUriCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFailureUriHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesFailureUriCreateRequest creates the GetMultiplePagesFailureURI request.
func (client *pagingOperations) getMultiplePagesFailureUriCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFailureUriHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *pagingOperations) getMultiplePagesFailureUriHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesFailureUriHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesFailureUriHandleError handles the GetMultiplePagesFailureURI error response.
func (client *pagingOperations) getMultiplePagesFailureUriHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
func (client *pagingOperations) GetMultiplePagesFragmentNextLink(apiVersion string, tenant string) (OdataProductResultPager, error) {
	req, err := client.getMultiplePagesFragmentNextLinkCreateRequest(apiVersion, tenant)
	if err != nil {
		return nil, err
	}
	return &odataProductResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFragmentNextLinkHandleResponse,
		advancer: func(resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.nextFragmentCreateRequest(apiVersion, tenant, *resp.OdataProductResult.OdataNextLink)
		},
	}, nil
}

// getMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *pagingOperations) getMultiplePagesFragmentNextLinkCreateRequest(apiVersion string, tenant string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", apiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *pagingOperations) getMultiplePagesFragmentNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesFragmentNextLinkHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// getMultiplePagesFragmentNextLinkHandleError handles the GetMultiplePagesFragmentNextLink error response.
func (client *pagingOperations) getMultiplePagesFragmentNextLinkHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
func (client *pagingOperations) GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) (OdataProductResultPager, error) {
	req, err := client.getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(customParameterGroup)
	if err != nil {
		return nil, err
	}
	return &odataProductResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFragmentWithGroupingNextLinkHandleResponse,
		advancer: func(resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.nextFragmentWithGroupingCreateRequest(*resp.OdataProductResult.OdataNextLink, customParameterGroup)
		},
	}, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *pagingOperations) getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *pagingOperations) getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesFragmentWithGroupingNextLinkHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleError handles the GetMultiplePagesFragmentWithGroupingNextLink error response.
func (client *pagingOperations) getMultiplePagesFragmentWithGroupingNextLinkHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
func (client *pagingOperations) BeginGetMultiplePagesLro(pagingGetMultiplePagesLroOptions *PagingGetMultiplePagesLroOptions) (ProductResultPager, error) {
	return nil, nil
}

// getMultiplePagesLroCreateRequest creates the GetMultiplePagesLro request.
func (client *pagingOperations) getMultiplePagesLroCreateRequest(pagingGetMultiplePagesLroOptions *PagingGetMultiplePagesLroOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/lro"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if pagingGetMultiplePagesLroOptions != nil && pagingGetMultiplePagesLroOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesLroOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesLroOptions != nil && pagingGetMultiplePagesLroOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesLroOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesLroOptions != nil && pagingGetMultiplePagesLroOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesLroOptions.Timeout), 10))
	}
	return req, nil
}

// getMultiplePagesLroHandleResponse handles the GetMultiplePagesLro response.
func (client *pagingOperations) getMultiplePagesLroHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesLroHandleError handles the GetMultiplePagesLro error response.
func (client *pagingOperations) getMultiplePagesLroHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that has 10 pages
func (client *pagingOperations) GetMultiplePagesRetryFirst() (ProductResultPager, error) {
	req, err := client.getMultiplePagesRetryFirstCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesRetryFirstHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *pagingOperations) getMultiplePagesRetryFirstCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *pagingOperations) getMultiplePagesRetryFirstHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesRetryFirstHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesRetryFirstHandleError handles the GetMultiplePagesRetryFirst error response.
func (client *pagingOperations) getMultiplePagesRetryFirstHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should retry and finish all 10 pages eventually.
func (client *pagingOperations) GetMultiplePagesRetrySecond() (ProductResultPager, error) {
	req, err := client.getMultiplePagesRetrySecondCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesRetrySecondHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *pagingOperations) getMultiplePagesRetrySecondCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *pagingOperations) getMultiplePagesRetrySecondHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesRetrySecondHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesRetrySecondHandleError handles the GetMultiplePagesRetrySecond error response.
func (client *pagingOperations) getMultiplePagesRetrySecondHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
func (client *pagingOperations) GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) (ProductResultPager, error) {
	req, err := client.getMultiplePagesWithOffsetCreateRequest(pagingGetMultiplePagesWithOffsetOptions)
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesWithOffsetHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *pagingOperations) getMultiplePagesWithOffsetCreateRequest(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(pagingGetMultiplePagesWithOffsetOptions.Offset), 10)))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if pagingGetMultiplePagesWithOffsetOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesWithOffsetOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesWithOffsetOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesWithOffsetOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Timeout), 10))
	}
	return req, nil
}

// getMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *pagingOperations) getMultiplePagesWithOffsetHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getMultiplePagesWithOffsetHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getMultiplePagesWithOffsetHandleError handles the GetMultiplePagesWithOffset error response.
func (client *pagingOperations) getMultiplePagesWithOffsetHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
func (client *pagingOperations) GetNoItemNamePages() (ProductResultValuePager, error) {
	req, err := client.getNoItemNamePagesCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultValuePager{
		client:    client,
		request:   req,
		responder: client.getNoItemNamePagesHandleResponse,
		advancer: func(resp *ProductResultValueResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResultValue.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResultValue.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *pagingOperations) getNoItemNamePagesCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/noitemname"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *pagingOperations) getNoItemNamePagesHandleResponse(resp *azcore.Response) (*ProductResultValueResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getNoItemNamePagesHandleError(resp)
	}
	result := ProductResultValueResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResultValue)
}

// getNoItemNamePagesHandleError handles the GetNoItemNamePages error response.
func (client *pagingOperations) getNoItemNamePagesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
func (client *pagingOperations) GetNullNextLinkNamePages(ctx context.Context) (*ProductResultResponse, error) {
	req, err := client.getNullNextLinkNamePagesCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getNullNextLinkNamePagesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *pagingOperations) getNullNextLinkNamePagesCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/nullnextlink"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *pagingOperations) getNullNextLinkNamePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getNullNextLinkNamePagesHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getNullNextLinkNamePagesHandleError handles the GetNullNextLinkNamePages error response.
func (client *pagingOperations) getNullNextLinkNamePagesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
func (client *pagingOperations) GetOdataMultiplePages(pagingGetOdataMultiplePagesOptions *PagingGetOdataMultiplePagesOptions) (OdataProductResultPager, error) {
	req, err := client.getOdataMultiplePagesCreateRequest(pagingGetOdataMultiplePagesOptions)
	if err != nil {
		return nil, err
	}
	return &odataProductResultPager{
		client:    client,
		request:   req,
		responder: client.getOdataMultiplePagesHandleResponse,
		advancer: func(resp *OdataProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.OdataProductResult.OdataNextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid OdataNextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in OdataNextLink %s", *resp.OdataProductResult.OdataNextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getOdataMultiplePagesCreateRequest creates the GetOdataMultiplePages request.
func (client *pagingOperations) getOdataMultiplePagesCreateRequest(pagingGetOdataMultiplePagesOptions *PagingGetOdataMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/odata"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if pagingGetOdataMultiplePagesOptions != nil && pagingGetOdataMultiplePagesOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetOdataMultiplePagesOptions.ClientRequestId)
	}
	if pagingGetOdataMultiplePagesOptions != nil && pagingGetOdataMultiplePagesOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetOdataMultiplePagesOptions.Maxresults), 10))
	}
	if pagingGetOdataMultiplePagesOptions != nil && pagingGetOdataMultiplePagesOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetOdataMultiplePagesOptions.Timeout), 10))
	}
	return req, nil
}

// getOdataMultiplePagesHandleResponse handles the GetOdataMultiplePages response.
func (client *pagingOperations) getOdataMultiplePagesHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getOdataMultiplePagesHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// getOdataMultiplePagesHandleError handles the GetOdataMultiplePages error response.
func (client *pagingOperations) getOdataMultiplePagesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetSinglePages - A paging operation that finishes on the first call without a nextlink
func (client *pagingOperations) GetSinglePages() (ProductResultPager, error) {
	req, err := client.getSinglePagesCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getSinglePagesHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getSinglePagesCreateRequest creates the GetSinglePages request.
func (client *pagingOperations) getSinglePagesCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/single"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getSinglePagesHandleResponse handles the GetSinglePages response.
func (client *pagingOperations) getSinglePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getSinglePagesHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getSinglePagesHandleError handles the GetSinglePages error response.
func (client *pagingOperations) getSinglePagesHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
func (client *pagingOperations) GetSinglePagesFailure() (ProductResultPager, error) {
	req, err := client.getSinglePagesFailureCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getSinglePagesFailureHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *pagingOperations) getSinglePagesFailureCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/single/failure"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *pagingOperations) getSinglePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getSinglePagesFailureHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// getSinglePagesFailureHandleError handles the GetSinglePagesFailure error response.
func (client *pagingOperations) getSinglePagesFailureHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// nextFragmentCreateRequest creates the NextFragment request.
func (client *pagingOperations) nextFragmentCreateRequest(apiVersion string, tenant string, nextLink string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", apiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// nextFragmentHandleResponse handles the NextFragment response.
func (client *pagingOperations) nextFragmentHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.nextFragmentHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// nextFragmentHandleError handles the NextFragment error response.
func (client *pagingOperations) nextFragmentHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// nextFragmentWithGroupingCreateRequest creates the NextFragmentWithGrouping request.
func (client *pagingOperations) nextFragmentWithGroupingCreateRequest(nextLink string, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// nextFragmentWithGroupingHandleResponse handles the NextFragmentWithGrouping response.
func (client *pagingOperations) nextFragmentWithGroupingHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.nextFragmentWithGroupingHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// nextFragmentWithGroupingHandleError handles the NextFragmentWithGrouping error response.
func (client *pagingOperations) nextFragmentWithGroupingHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}
