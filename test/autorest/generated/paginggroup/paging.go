// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// PagingOperations contains the methods for the Paging group.
type PagingOperations interface {
	// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePages(options *PagingGetMultiplePagesOptions) (ProductResultPager, error)
	// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
	GetMultiplePagesFailure() (ProductResultPager, error)
	// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
	GetMultiplePagesFailureURI() (ProductResultPager, error)
	// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
	GetMultiplePagesFragmentNextLink(apiVersion string, tenant string) (OdataProductResultPager, error)
	// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
	GetMultiplePagesFragmentWithGroupingNextLink(apiVersion string, tenant string) (OdataProductResultPager, error)
	// BeginGetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
	BeginGetMultiplePagesLro(options *PagingGetMultiplePagesLroOptions) (ProductResultPager, error)
	// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that has 10 pages
	GetMultiplePagesRetryFirst() (ProductResultPager, error)
	// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should retry and finish all 10 pages eventually.
	GetMultiplePagesRetrySecond() (ProductResultPager, error)
	// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePagesWithOffset(offset int32, options *PagingGetMultiplePagesWithOffsetOptions) (ProductResultPager, error)
	// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
	GetNoItemNamePages() (ProductResultValuePager, error)
	// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
	GetNullNextLinkNamePages(ctx context.Context) (*ProductResultResponse, error)
	// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
	GetOdataMultiplePages(options *PagingGetOdataMultiplePagesOptions) (OdataProductResultPager, error)
	// GetSinglePages - A paging operation that finishes on the first call without a nextlink
	GetSinglePages() (ProductResultPager, error)
	// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
	GetSinglePagesFailure() (ProductResultPager, error)
}

// pagingOperations implements the PagingOperations interface.
type pagingOperations struct {
	*Client
}

// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
func (client *pagingOperations) GetMultiplePages(options *PagingGetMultiplePagesOptions) (ProductResultPager, error) {
	req, err := client.getMultiplePagesCreateRequest(options)
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *pagingOperations) getMultiplePagesCreateRequest(options *PagingGetMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	return req, nil
}

// getMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *pagingOperations) getMultiplePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
func (client *pagingOperations) GetMultiplePagesFailure() (ProductResultPager, error) {
	req, err := client.getMultiplePagesFailureCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFailureHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *pagingOperations) getMultiplePagesFailureCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/failure"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *pagingOperations) getMultiplePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
func (client *pagingOperations) GetMultiplePagesFailureURI() (ProductResultPager, error) {
	req, err := client.getMultiplePagesFailureUriCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFailureUriHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesFailureUriCreateRequest creates the GetMultiplePagesFailureURI request.
func (client *pagingOperations) getMultiplePagesFailureUriCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFailureUriHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *pagingOperations) getMultiplePagesFailureUriHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
func (client *pagingOperations) GetMultiplePagesFragmentNextLink(apiVersion string, tenant string) (OdataProductResultPager, error) {
	req, err := client.getMultiplePagesFragmentNextLinkCreateRequest(apiVersion, tenant)
	if err != nil {
		return nil, err
	}
	return &odataProductResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFragmentNextLinkHandleResponse,
		advancer: func(resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.nextFragmentCreateRequest(apiVersion, tenant, *resp.OdataProductResult.OdataNextLink)
		},
	}, nil
}

// getMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *pagingOperations) getMultiplePagesFragmentNextLinkCreateRequest(apiVersion string, tenant string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", apiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *pagingOperations) getMultiplePagesFragmentNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
func (client *pagingOperations) GetMultiplePagesFragmentWithGroupingNextLink(apiVersion string, tenant string) (OdataProductResultPager, error) {
	req, err := client.getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(apiVersion, tenant)
	if err != nil {
		return nil, err
	}
	return &odataProductResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesFragmentWithGroupingNextLinkHandleResponse,
		advancer: func(resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.nextFragmentWithGroupingCreateRequest(apiVersion, tenant, *resp.OdataProductResult.OdataNextLink)
		},
	}, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *pagingOperations) getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(apiVersion string, tenant string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", apiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *pagingOperations) getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
func (client *pagingOperations) BeginGetMultiplePagesLro(options *PagingGetMultiplePagesLroOptions) (ProductResultPager, error) {
	return nil, nil
}

// getMultiplePagesLroCreateRequest creates the GetMultiplePagesLro request.
func (client *pagingOperations) getMultiplePagesLroCreateRequest(options *PagingGetMultiplePagesLroOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/lro"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodPost, *u)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	return req, nil
}

// getMultiplePagesLroHandleResponse handles the GetMultiplePagesLro response.
func (client *pagingOperations) getMultiplePagesLroHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that has 10 pages
func (client *pagingOperations) GetMultiplePagesRetryFirst() (ProductResultPager, error) {
	req, err := client.getMultiplePagesRetryFirstCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesRetryFirstHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *pagingOperations) getMultiplePagesRetryFirstCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *pagingOperations) getMultiplePagesRetryFirstHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should retry and finish all 10 pages eventually.
func (client *pagingOperations) GetMultiplePagesRetrySecond() (ProductResultPager, error) {
	req, err := client.getMultiplePagesRetrySecondCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesRetrySecondHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *pagingOperations) getMultiplePagesRetrySecondCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *pagingOperations) getMultiplePagesRetrySecondHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
func (client *pagingOperations) GetMultiplePagesWithOffset(offset int32, options *PagingGetMultiplePagesWithOffsetOptions) (ProductResultPager, error) {
	req, err := client.getMultiplePagesWithOffsetCreateRequest(offset, options)
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getMultiplePagesWithOffsetHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *pagingOperations) getMultiplePagesWithOffsetCreateRequest(offset int32, options *PagingGetMultiplePagesWithOffsetOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(offset), 10)))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	return req, nil
}

// getMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *pagingOperations) getMultiplePagesWithOffsetHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
func (client *pagingOperations) GetNoItemNamePages() (ProductResultValuePager, error) {
	req, err := client.getNoItemNamePagesCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultValuePager{
		client:    client,
		request:   req,
		responder: client.getNoItemNamePagesHandleResponse,
		advancer: func(resp *ProductResultValueResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResultValue.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResultValue.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *pagingOperations) getNoItemNamePagesCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/noitemname"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *pagingOperations) getNoItemNamePagesHandleResponse(resp *azcore.Response) (*ProductResultValueResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultValueResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResultValue)
}

// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
func (client *pagingOperations) GetNullNextLinkNamePages(ctx context.Context) (*ProductResultResponse, error) {
	req, err := client.getNullNextLinkNamePagesCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getNullNextLinkNamePagesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *pagingOperations) getNullNextLinkNamePagesCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/nullnextlink"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *pagingOperations) getNullNextLinkNamePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
func (client *pagingOperations) GetOdataMultiplePages(options *PagingGetOdataMultiplePagesOptions) (OdataProductResultPager, error) {
	req, err := client.getOdataMultiplePagesCreateRequest(options)
	if err != nil {
		return nil, err
	}
	return &odataProductResultPager{
		client:    client,
		request:   req,
		responder: client.getOdataMultiplePagesHandleResponse,
		advancer: func(resp *OdataProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.OdataProductResult.OdataNextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid OdataNextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in OdataNextLink %s", *resp.OdataProductResult.OdataNextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getOdataMultiplePagesCreateRequest creates the GetOdataMultiplePages request.
func (client *pagingOperations) getOdataMultiplePagesCreateRequest(options *PagingGetOdataMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/odata"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	return req, nil
}

// getOdataMultiplePagesHandleResponse handles the GetOdataMultiplePages response.
func (client *pagingOperations) getOdataMultiplePagesHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetSinglePages - A paging operation that finishes on the first call without a nextlink
func (client *pagingOperations) GetSinglePages() (ProductResultPager, error) {
	req, err := client.getSinglePagesCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getSinglePagesHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getSinglePagesCreateRequest creates the GetSinglePages request.
func (client *pagingOperations) getSinglePagesCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/single"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getSinglePagesHandleResponse handles the GetSinglePages response.
func (client *pagingOperations) getSinglePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
func (client *pagingOperations) GetSinglePagesFailure() (ProductResultPager, error) {
	req, err := client.getSinglePagesFailureCreateRequest()
	if err != nil {
		return nil, err
	}
	return &productResultPager{
		client:    client,
		request:   req,
		responder: client.getSinglePagesFailureHandleResponse,
		advancer: func(resp *ProductResultResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ProductResult.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ProductResult.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// getSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *pagingOperations) getSinglePagesFailureCreateRequest() (*azcore.Request, error) {
	urlPath := "/paging/single/failure"
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *pagingOperations) getSinglePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// nextFragmentCreateRequest creates the NextFragment request.
func (client *pagingOperations) nextFragmentCreateRequest(apiVersion string, tenant string, nextLink string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", apiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// nextFragmentHandleResponse handles the NextFragment response.
func (client *pagingOperations) nextFragmentHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// nextFragmentWithGroupingCreateRequest creates the NextFragmentWithGrouping request.
func (client *pagingOperations) nextFragmentWithGroupingCreateRequest(apiVersion string, tenant string, nextLink string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api_version", apiVersion)
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// nextFragmentWithGroupingHandleResponse handles the NextFragmentWithGrouping response.
func (client *pagingOperations) nextFragmentWithGroupingHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, errors.New(resp.Status)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}
