// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package datetimegroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// DatetimeOperations contains the methods for the Datetime group.
type DatetimeOperations interface {
	// GetInvalid - Get invalid datetime value
	GetInvalid(ctx context.Context) (*TimeResponse, error)
	// GetLocalNegativeOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999-14:00
	GetLocalNegativeOffsetLowercaseMaxDateTime(ctx context.Context) (*TimeResponse, error)
	// GetLocalNegativeOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00-14:00
	GetLocalNegativeOffsetMinDateTime(ctx context.Context) (*TimeResponse, error)
	// GetLocalNegativeOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999-14:00
	GetLocalNegativeOffsetUppercaseMaxDateTime(ctx context.Context) (*TimeResponse, error)
	// GetLocalNoOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00
	GetLocalNoOffsetMinDateTime(ctx context.Context) (*TimeResponse, error)
	// GetLocalPositiveOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999+14:00
	GetLocalPositiveOffsetLowercaseMaxDateTime(ctx context.Context) (*TimeResponse, error)
	// GetLocalPositiveOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00+14:00
	GetLocalPositiveOffsetMinDateTime(ctx context.Context) (*TimeResponse, error)
	// GetLocalPositiveOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999+14:00
	GetLocalPositiveOffsetUppercaseMaxDateTime(ctx context.Context) (*TimeResponse, error)
	// GetNull - Get null datetime value
	GetNull(ctx context.Context) (*TimeResponse, error)
	// GetOverflow - Get overflow datetime value
	GetOverflow(ctx context.Context) (*TimeResponse, error)
	// GetUTCLowercaseMaxDateTime - Get max datetime value 9999-12-31t23:59:59.999z
	GetUTCLowercaseMaxDateTime(ctx context.Context) (*TimeResponse, error)
	// GetUTCMinDateTime - Get min datetime value 0001-01-01T00:00:00Z
	GetUTCMinDateTime(ctx context.Context) (*TimeResponse, error)
	// GetUTCUppercaseMaxDateTime - Get max datetime value 9999-12-31T23:59:59.999Z
	GetUTCUppercaseMaxDateTime(ctx context.Context) (*TimeResponse, error)
	// GetUTCUppercaseMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in that scenario
	GetUTCUppercaseMaxDateTime7Digits(ctx context.Context) (*TimeResponse, error)
	// GetUnderflow - Get underflow datetime value
	GetUnderflow(ctx context.Context) (*TimeResponse, error)
	// PutLocalNegativeOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999-14:00
	PutLocalNegativeOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
	// PutLocalNegativeOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00-14:00
	PutLocalNegativeOffsetMinDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
	// PutLocalPositiveOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999+14:00
	PutLocalPositiveOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
	// PutLocalPositiveOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00+14:00
	PutLocalPositiveOffsetMinDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
	// PutUTCMaxDateTime - Put max datetime value 9999-12-31T23:59:59.999Z
	PutUTCMaxDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
	// PutUTCMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in that scenario
	PutUTCMaxDateTime7Digits(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
	// PutUTCMinDateTime - Put min datetime value 0001-01-01T00:00:00Z
	PutUTCMinDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error)
}

// DatetimeClient implements the DatetimeOperations interface.
// Don't use this type directly, use NewDatetimeClient() instead.
type DatetimeClient struct {
	*Client
}

// NewDatetimeClient creates a new instance of DatetimeClient with the specified values.
func NewDatetimeClient(c *Client) DatetimeOperations {
	return &DatetimeClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *DatetimeClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// GetInvalid - Get invalid datetime value
func (client *DatetimeClient) GetInvalid(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetInvalidCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetInvalidHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetInvalidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetInvalidCreateRequest creates the GetInvalid request.
func (client *DatetimeClient) GetInvalidCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/invalid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetInvalidHandleResponse handles the GetInvalid response.
func (client *DatetimeClient) GetInvalidHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetInvalidHandleError handles the GetInvalid error response.
func (client *DatetimeClient) GetInvalidHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalNegativeOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999-14:00
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalNegativeOffsetLowercaseMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/lowercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalNegativeOffsetLowercaseMaxDateTimeHandleError handles the GetLocalNegativeOffsetLowercaseMaxDateTime error response.
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalNegativeOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00-14:00
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalNegativeOffsetMinDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalNegativeOffsetMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalNegativeOffsetMinDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalNegativeOffsetMinDateTimeCreateRequest creates the GetLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalNegativeOffsetMinDateTimeHandleResponse handles the GetLocalNegativeOffsetMinDateTime response.
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalNegativeOffsetMinDateTimeHandleError handles the GetLocalNegativeOffsetMinDateTime error response.
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalNegativeOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999-14:00
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalNegativeOffsetUppercaseMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalNegativeOffsetUppercaseMaxDateTimeHandleError handles the GetLocalNegativeOffsetUppercaseMaxDateTime error response.
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalNoOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00
func (client *DatetimeClient) GetLocalNoOffsetMinDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalNoOffsetMinDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalNoOffsetMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalNoOffsetMinDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalNoOffsetMinDateTimeCreateRequest creates the GetLocalNoOffsetMinDateTime request.
func (client *DatetimeClient) GetLocalNoOffsetMinDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/min/localnooffset"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalNoOffsetMinDateTimeHandleResponse handles the GetLocalNoOffsetMinDateTime response.
func (client *DatetimeClient) GetLocalNoOffsetMinDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalNoOffsetMinDateTimeHandleError handles the GetLocalNoOffsetMinDateTime error response.
func (client *DatetimeClient) GetLocalNoOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalPositiveOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999+14:00
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalPositiveOffsetLowercaseMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/lowercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalPositiveOffsetLowercaseMaxDateTimeHandleError handles the GetLocalPositiveOffsetLowercaseMaxDateTime error response.
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalPositiveOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00+14:00
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalPositiveOffsetMinDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalPositiveOffsetMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalPositiveOffsetMinDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalPositiveOffsetMinDateTimeCreateRequest creates the GetLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalPositiveOffsetMinDateTimeHandleResponse handles the GetLocalPositiveOffsetMinDateTime response.
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalPositiveOffsetMinDateTimeHandleError handles the GetLocalPositiveOffsetMinDateTime error response.
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetLocalPositiveOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999+14:00
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetLocalPositiveOffsetUppercaseMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetLocalPositiveOffsetUppercaseMaxDateTimeHandleError handles the GetLocalPositiveOffsetUppercaseMaxDateTime error response.
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetNull - Get null datetime value
func (client *DatetimeClient) GetNull(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetNullCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetNullHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNullCreateRequest creates the GetNull request.
func (client *DatetimeClient) GetNullCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNullHandleResponse handles the GetNull response.
func (client *DatetimeClient) GetNullHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetNullHandleError handles the GetNull error response.
func (client *DatetimeClient) GetNullHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetOverflow - Get overflow datetime value
func (client *DatetimeClient) GetOverflow(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetOverflowCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetOverflowHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetOverflowHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetOverflowCreateRequest creates the GetOverflow request.
func (client *DatetimeClient) GetOverflowCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/overflow"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetOverflowHandleResponse handles the GetOverflow response.
func (client *DatetimeClient) GetOverflowHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetOverflowHandleError handles the GetOverflow error response.
func (client *DatetimeClient) GetOverflowHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetUTCLowercaseMaxDateTime - Get max datetime value 9999-12-31t23:59:59.999z
func (client *DatetimeClient) GetUTCLowercaseMaxDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetUTCLowercaseMaxDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetUTCLowercaseMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetUTCLowercaseMaxDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetUTCLowercaseMaxDateTimeCreateRequest creates the GetUTCLowercaseMaxDateTime request.
func (client *DatetimeClient) GetUTCLowercaseMaxDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc/lowercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetUTCLowercaseMaxDateTimeHandleResponse handles the GetUTCLowercaseMaxDateTime response.
func (client *DatetimeClient) GetUTCLowercaseMaxDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetUTCLowercaseMaxDateTimeHandleError handles the GetUTCLowercaseMaxDateTime error response.
func (client *DatetimeClient) GetUTCLowercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetUTCMinDateTime - Get min datetime value 0001-01-01T00:00:00Z
func (client *DatetimeClient) GetUTCMinDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetUTCMinDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetUTCMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetUTCMinDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetUTCMinDateTimeCreateRequest creates the GetUTCMinDateTime request.
func (client *DatetimeClient) GetUTCMinDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetUTCMinDateTimeHandleResponse handles the GetUTCMinDateTime response.
func (client *DatetimeClient) GetUTCMinDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetUTCMinDateTimeHandleError handles the GetUTCMinDateTime error response.
func (client *DatetimeClient) GetUTCMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetUTCUppercaseMaxDateTime - Get max datetime value 9999-12-31T23:59:59.999Z
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetUTCUppercaseMaxDateTimeCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetUTCUppercaseMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetUTCUppercaseMaxDateTimeHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetUTCUppercaseMaxDateTimeCreateRequest creates the GetUTCUppercaseMaxDateTime request.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTimeCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetUTCUppercaseMaxDateTimeHandleResponse handles the GetUTCUppercaseMaxDateTime response.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTimeHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetUTCUppercaseMaxDateTimeHandleError handles the GetUTCUppercaseMaxDateTime error response.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetUTCUppercaseMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in that scenario
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7Digits(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetUTCUppercaseMaxDateTime7DigitsHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetUTCUppercaseMaxDateTime7DigitsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetUTCUppercaseMaxDateTime7DigitsCreateRequest creates the GetUTCUppercaseMaxDateTime7Digits request.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc7ms/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetUTCUppercaseMaxDateTime7DigitsHandleResponse handles the GetUTCUppercaseMaxDateTime7Digits response.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7DigitsHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetUTCUppercaseMaxDateTime7DigitsHandleError handles the GetUTCUppercaseMaxDateTime7Digits error response.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7DigitsHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// GetUnderflow - Get underflow datetime value
func (client *DatetimeClient) GetUnderflow(ctx context.Context) (*TimeResponse, error) {
	req, err := client.GetUnderflowCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.GetUnderflowHandleError(resp); err != nil {
		return nil, err
	}
	result, err := client.GetUnderflowHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetUnderflowCreateRequest creates the GetUnderflow request.
func (client *DatetimeClient) GetUnderflowCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/datetime/underflow"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetUnderflowHandleResponse handles the GetUnderflow response.
func (client *DatetimeClient) GetUnderflowHandleResponse(resp *azcore.Response) (*TimeResponse, error) {
	var aux *timeRFC3339
	err := resp.UnmarshalAsJSON(&aux)
	return &TimeResponse{RawResponse: resp.Response, Value: (*time.Time)(aux)}, err
}

// GetUnderflowHandleError handles the GetUnderflow error response.
func (client *DatetimeClient) GetUnderflowHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutLocalNegativeOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999-14:00
func (client *DatetimeClient) PutLocalNegativeOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutLocalNegativeOffsetMaxDateTimeCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutLocalNegativeOffsetMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutLocalNegativeOffsetMaxDateTimeCreateRequest creates the PutLocalNegativeOffsetMaxDateTime request.
func (client *DatetimeClient) PutLocalNegativeOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutLocalNegativeOffsetMaxDateTimeHandleError handles the PutLocalNegativeOffsetMaxDateTime error response.
func (client *DatetimeClient) PutLocalNegativeOffsetMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutLocalNegativeOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00-14:00
func (client *DatetimeClient) PutLocalNegativeOffsetMinDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutLocalNegativeOffsetMinDateTimeCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutLocalNegativeOffsetMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutLocalNegativeOffsetMinDateTimeCreateRequest creates the PutLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) PutLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutLocalNegativeOffsetMinDateTimeHandleError handles the PutLocalNegativeOffsetMinDateTime error response.
func (client *DatetimeClient) PutLocalNegativeOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutLocalPositiveOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999+14:00
func (client *DatetimeClient) PutLocalPositiveOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutLocalPositiveOffsetMaxDateTimeCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutLocalPositiveOffsetMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutLocalPositiveOffsetMaxDateTimeCreateRequest creates the PutLocalPositiveOffsetMaxDateTime request.
func (client *DatetimeClient) PutLocalPositiveOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutLocalPositiveOffsetMaxDateTimeHandleError handles the PutLocalPositiveOffsetMaxDateTime error response.
func (client *DatetimeClient) PutLocalPositiveOffsetMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutLocalPositiveOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00+14:00
func (client *DatetimeClient) PutLocalPositiveOffsetMinDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutLocalPositiveOffsetMinDateTimeCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutLocalPositiveOffsetMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutLocalPositiveOffsetMinDateTimeCreateRequest creates the PutLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) PutLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutLocalPositiveOffsetMinDateTimeHandleError handles the PutLocalPositiveOffsetMinDateTime error response.
func (client *DatetimeClient) PutLocalPositiveOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutUTCMaxDateTime - Put max datetime value 9999-12-31T23:59:59.999Z
func (client *DatetimeClient) PutUTCMaxDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutUTCMaxDateTimeCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutUTCMaxDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutUTCMaxDateTimeCreateRequest creates the PutUTCMaxDateTime request.
func (client *DatetimeClient) PutUTCMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutUTCMaxDateTimeHandleError handles the PutUTCMaxDateTime error response.
func (client *DatetimeClient) PutUTCMaxDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutUTCMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in that scenario
func (client *DatetimeClient) PutUTCMaxDateTime7Digits(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutUTCMaxDateTime7DigitsCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutUTCMaxDateTime7DigitsHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutUTCMaxDateTime7DigitsCreateRequest creates the PutUTCMaxDateTime7Digits request.
func (client *DatetimeClient) PutUTCMaxDateTime7DigitsCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc7ms"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutUTCMaxDateTime7DigitsHandleError handles the PutUTCMaxDateTime7Digits error response.
func (client *DatetimeClient) PutUTCMaxDateTime7DigitsHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}

// PutUTCMinDateTime - Put min datetime value 0001-01-01T00:00:00Z
func (client *DatetimeClient) PutUTCMinDateTime(ctx context.Context, datetimeBody time.Time) (*http.Response, error) {
	req, err := client.PutUTCMinDateTimeCreateRequest(ctx, datetimeBody)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := client.PutUTCMinDateTimeHandleError(resp); err != nil {
		return nil, err
	}
	return resp.Response, nil
}

// PutUTCMinDateTimeCreateRequest creates the PutUTCMinDateTime request.
func (client *DatetimeClient) PutUTCMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time) (*azcore.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// PutUTCMinDateTimeHandleError handles the PutUTCMinDateTime error response.
func (client *DatetimeClient) PutUTCMinDateTimeHandleError(resp *azcore.Response) error {
	if resp.HasStatusCode(http.StatusOK) {
		return nil
	}
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return err
}
