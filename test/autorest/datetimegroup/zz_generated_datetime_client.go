//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package datetimegroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"time"
)

// DatetimeClient contains the methods for the Datetime group.
// Don't use this type directly, use NewDatetimeClient() instead.
type DatetimeClient struct {
	pl runtime.Pipeline
}

// NewDatetimeClient creates a new instance of DatetimeClient with the specified values.
// pl - the pipeline used for sending requests and handling responses.
func NewDatetimeClient(pl runtime.Pipeline) *DatetimeClient {
	client := &DatetimeClient{
		pl: pl,
	}
	return client
}

// GetInvalid - Get invalid datetime value
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetInvalidOptions contains the optional parameters for the DatetimeClient.GetInvalid method.
func (client *DatetimeClient) GetInvalid(ctx context.Context, options *DatetimeClientGetInvalidOptions) (DatetimeClientGetInvalidResponse, error) {
	req, err := client.getInvalidCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetInvalidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetInvalidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetInvalidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInvalidHandleResponse(resp)
}

// getInvalidCreateRequest creates the GetInvalid request.
func (client *DatetimeClient) getInvalidCreateRequest(ctx context.Context, options *DatetimeClientGetInvalidOptions) (*policy.Request, error) {
	urlPath := "/datetime/invalid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInvalidHandleResponse handles the GetInvalid response.
func (client *DatetimeClient) getInvalidHandleResponse(resp *http.Response) (DatetimeClientGetInvalidResponse, error) {
	result := DatetimeClientGetInvalidResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetInvalidResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNegativeOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999-14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNegativeOffsetLowercaseMaxDateTime
// method.
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeOptions) (DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp)
}

// getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/lowercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse, error) {
	result := DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNegativeOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00-14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalNegativeOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNegativeOffsetMinDateTime
// method.
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTime(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetMinDateTimeOptions) (DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse, error) {
	req, err := client.getLocalNegativeOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalNegativeOffsetMinDateTimeHandleResponse(resp)
}

// getLocalNegativeOffsetMinDateTimeCreateRequest creates the GetLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNegativeOffsetMinDateTimeHandleResponse handles the GetLocalNegativeOffsetMinDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse, error) {
	result := DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNegativeOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999-14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNegativeOffsetUppercaseMaxDateTime
// method.
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeOptions) (DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp)
}

// getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse, error) {
	result := DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNoOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalNoOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNoOffsetMinDateTime
// method.
func (client *DatetimeClient) GetLocalNoOffsetMinDateTime(ctx context.Context, options *DatetimeClientGetLocalNoOffsetMinDateTimeOptions) (DatetimeClientGetLocalNoOffsetMinDateTimeResponse, error) {
	req, err := client.getLocalNoOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalNoOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalNoOffsetMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalNoOffsetMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalNoOffsetMinDateTimeHandleResponse(resp)
}

// getLocalNoOffsetMinDateTimeCreateRequest creates the GetLocalNoOffsetMinDateTime request.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNoOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localnooffset"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNoOffsetMinDateTimeHandleResponse handles the GetLocalNoOffsetMinDateTime response.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalNoOffsetMinDateTimeResponse, error) {
	result := DatetimeClientGetLocalNoOffsetMinDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalNoOffsetMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalPositiveOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999+14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalPositiveOffsetLowercaseMaxDateTime
// method.
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeOptions) (DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp)
}

// getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/lowercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse, error) {
	result := DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalPositiveOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00+14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalPositiveOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalPositiveOffsetMinDateTime
// method.
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTime(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetMinDateTimeOptions) (DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse, error) {
	req, err := client.getLocalPositiveOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalPositiveOffsetMinDateTimeHandleResponse(resp)
}

// getLocalPositiveOffsetMinDateTimeCreateRequest creates the GetLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalPositiveOffsetMinDateTimeHandleResponse handles the GetLocalPositiveOffsetMinDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse, error) {
	result := DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalPositiveOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999+14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalPositiveOffsetUppercaseMaxDateTime
// method.
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeOptions) (DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp)
}

// getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse, error) {
	result := DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetNull - Get null datetime value
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetNullOptions contains the optional parameters for the DatetimeClient.GetNull method.
func (client *DatetimeClient) GetNull(ctx context.Context, options *DatetimeClientGetNullOptions) (DatetimeClientGetNullResponse, error) {
	req, err := client.getNullCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNullHandleResponse(resp)
}

// getNullCreateRequest creates the GetNull request.
func (client *DatetimeClient) getNullCreateRequest(ctx context.Context, options *DatetimeClientGetNullOptions) (*policy.Request, error) {
	urlPath := "/datetime/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNullHandleResponse handles the GetNull response.
func (client *DatetimeClient) getNullHandleResponse(resp *http.Response) (DatetimeClientGetNullResponse, error) {
	result := DatetimeClientGetNullResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetNullResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetOverflow - Get overflow datetime value
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetOverflowOptions contains the optional parameters for the DatetimeClient.GetOverflow method.
func (client *DatetimeClient) GetOverflow(ctx context.Context, options *DatetimeClientGetOverflowOptions) (DatetimeClientGetOverflowResponse, error) {
	req, err := client.getOverflowCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetOverflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetOverflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetOverflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOverflowHandleResponse(resp)
}

// getOverflowCreateRequest creates the GetOverflow request.
func (client *DatetimeClient) getOverflowCreateRequest(ctx context.Context, options *DatetimeClientGetOverflowOptions) (*policy.Request, error) {
	urlPath := "/datetime/overflow"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getOverflowHandleResponse handles the GetOverflow response.
func (client *DatetimeClient) getOverflowHandleResponse(resp *http.Response) (DatetimeClientGetOverflowResponse, error) {
	result := DatetimeClientGetOverflowResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetOverflowResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCLowercaseMaxDateTime - Get max datetime value 9999-12-31t23:59:59.999z
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetUTCLowercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetUTCLowercaseMaxDateTime
// method.
func (client *DatetimeClient) GetUTCLowercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetUTCLowercaseMaxDateTimeOptions) (DatetimeClientGetUTCLowercaseMaxDateTimeResponse, error) {
	req, err := client.getUTCLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetUTCLowercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetUTCLowercaseMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetUTCLowercaseMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUTCLowercaseMaxDateTimeHandleResponse(resp)
}

// getUTCLowercaseMaxDateTimeCreateRequest creates the GetUTCLowercaseMaxDateTime request.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetUTCLowercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc/lowercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCLowercaseMaxDateTimeHandleResponse handles the GetUTCLowercaseMaxDateTime response.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetUTCLowercaseMaxDateTimeResponse, error) {
	result := DatetimeClientGetUTCLowercaseMaxDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetUTCLowercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCMinDateTime - Get min datetime value 0001-01-01T00:00:00Z
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetUTCMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetUTCMinDateTime
// method.
func (client *DatetimeClient) GetUTCMinDateTime(ctx context.Context, options *DatetimeClientGetUTCMinDateTimeOptions) (DatetimeClientGetUTCMinDateTimeResponse, error) {
	req, err := client.getUTCMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetUTCMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetUTCMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetUTCMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUTCMinDateTimeHandleResponse(resp)
}

// getUTCMinDateTimeCreateRequest creates the GetUTCMinDateTime request.
func (client *DatetimeClient) getUTCMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetUTCMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCMinDateTimeHandleResponse handles the GetUTCMinDateTime response.
func (client *DatetimeClient) getUTCMinDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetUTCMinDateTimeResponse, error) {
	result := DatetimeClientGetUTCMinDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetUTCMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCUppercaseMaxDateTime - Get max datetime value 9999-12-31T23:59:59.999Z
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetUTCUppercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetUTCUppercaseMaxDateTime
// method.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTimeOptions) (DatetimeClientGetUTCUppercaseMaxDateTimeResponse, error) {
	req, err := client.getUTCUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetUTCUppercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetUTCUppercaseMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetUTCUppercaseMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUTCUppercaseMaxDateTimeHandleResponse(resp)
}

// getUTCUppercaseMaxDateTimeCreateRequest creates the GetUTCUppercaseMaxDateTime request.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCUppercaseMaxDateTimeHandleResponse handles the GetUTCUppercaseMaxDateTime response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeHandleResponse(resp *http.Response) (DatetimeClientGetUTCUppercaseMaxDateTimeResponse, error) {
	result := DatetimeClientGetUTCUppercaseMaxDateTimeResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetUTCUppercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCUppercaseMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens
// in that scenario
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetUTCUppercaseMaxDateTime7DigitsOptions contains the optional parameters for the DatetimeClient.GetUTCUppercaseMaxDateTime7Digits
// method.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7Digits(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTime7DigitsOptions) (DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse, error) {
	req, err := client.getUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUTCUppercaseMaxDateTime7DigitsHandleResponse(resp)
}

// getUTCUppercaseMaxDateTime7DigitsCreateRequest creates the GetUTCUppercaseMaxDateTime7Digits request.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTime7DigitsOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc7ms/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCUppercaseMaxDateTime7DigitsHandleResponse handles the GetUTCUppercaseMaxDateTime7Digits response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsHandleResponse(resp *http.Response) (DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse, error) {
	result := DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUnderflow - Get underflow datetime value
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - DatetimeClientGetUnderflowOptions contains the optional parameters for the DatetimeClient.GetUnderflow method.
func (client *DatetimeClient) GetUnderflow(ctx context.Context, options *DatetimeClientGetUnderflowOptions) (DatetimeClientGetUnderflowResponse, error) {
	req, err := client.getUnderflowCreateRequest(ctx, options)
	if err != nil {
		return DatetimeClientGetUnderflowResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientGetUnderflowResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientGetUnderflowResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUnderflowHandleResponse(resp)
}

// getUnderflowCreateRequest creates the GetUnderflow request.
func (client *DatetimeClient) getUnderflowCreateRequest(ctx context.Context, options *DatetimeClientGetUnderflowOptions) (*policy.Request, error) {
	urlPath := "/datetime/underflow"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUnderflowHandleResponse handles the GetUnderflow response.
func (client *DatetimeClient) getUnderflowHandleResponse(resp *http.Response) (DatetimeClientGetUnderflowResponse, error) {
	result := DatetimeClientGetUnderflowResponse{}
	var aux *timeRFC3339
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DatetimeClientGetUnderflowResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// PutLocalNegativeOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999-14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutLocalNegativeOffsetMaxDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalNegativeOffsetMaxDateTime
// method.
func (client *DatetimeClient) PutLocalNegativeOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMaxDateTimeOptions) (DatetimeClientPutLocalNegativeOffsetMaxDateTimeResponse, error) {
	req, err := client.putLocalNegativeOffsetMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutLocalNegativeOffsetMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutLocalNegativeOffsetMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutLocalNegativeOffsetMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutLocalNegativeOffsetMaxDateTimeResponse{}, nil
}

// putLocalNegativeOffsetMaxDateTimeCreateRequest creates the PutLocalNegativeOffsetMaxDateTime request.
func (client *DatetimeClient) putLocalNegativeOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutLocalNegativeOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00-14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutLocalNegativeOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalNegativeOffsetMinDateTime
// method.
func (client *DatetimeClient) PutLocalNegativeOffsetMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMinDateTimeOptions) (DatetimeClientPutLocalNegativeOffsetMinDateTimeResponse, error) {
	req, err := client.putLocalNegativeOffsetMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutLocalNegativeOffsetMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutLocalNegativeOffsetMinDateTimeResponse{}, nil
}

// putLocalNegativeOffsetMinDateTimeCreateRequest creates the PutLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) putLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutLocalPositiveOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999+14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutLocalPositiveOffsetMaxDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalPositiveOffsetMaxDateTime
// method.
func (client *DatetimeClient) PutLocalPositiveOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMaxDateTimeOptions) (DatetimeClientPutLocalPositiveOffsetMaxDateTimeResponse, error) {
	req, err := client.putLocalPositiveOffsetMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutLocalPositiveOffsetMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutLocalPositiveOffsetMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutLocalPositiveOffsetMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutLocalPositiveOffsetMaxDateTimeResponse{}, nil
}

// putLocalPositiveOffsetMaxDateTimeCreateRequest creates the PutLocalPositiveOffsetMaxDateTime request.
func (client *DatetimeClient) putLocalPositiveOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutLocalPositiveOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00+14:00
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutLocalPositiveOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalPositiveOffsetMinDateTime
// method.
func (client *DatetimeClient) PutLocalPositiveOffsetMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMinDateTimeOptions) (DatetimeClientPutLocalPositiveOffsetMinDateTimeResponse, error) {
	req, err := client.putLocalPositiveOffsetMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutLocalPositiveOffsetMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutLocalPositiveOffsetMinDateTimeResponse{}, nil
}

// putLocalPositiveOffsetMinDateTimeCreateRequest creates the PutLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) putLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutUTCMaxDateTime - Put max datetime value 9999-12-31T23:59:59.999Z
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutUTCMaxDateTimeOptions contains the optional parameters for the DatetimeClient.PutUTCMaxDateTime
// method.
func (client *DatetimeClient) PutUTCMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTimeOptions) (DatetimeClientPutUTCMaxDateTimeResponse, error) {
	req, err := client.putUTCMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutUTCMaxDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutUTCMaxDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutUTCMaxDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutUTCMaxDateTimeResponse{}, nil
}

// putUTCMaxDateTimeCreateRequest creates the PutUTCMaxDateTime request.
func (client *DatetimeClient) putUTCMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutUTCMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in
// that scenario
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutUTCMaxDateTime7DigitsOptions contains the optional parameters for the DatetimeClient.PutUTCMaxDateTime7Digits
// method.
func (client *DatetimeClient) PutUTCMaxDateTime7Digits(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTime7DigitsOptions) (DatetimeClientPutUTCMaxDateTime7DigitsResponse, error) {
	req, err := client.putUTCMaxDateTime7DigitsCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutUTCMaxDateTime7DigitsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutUTCMaxDateTime7DigitsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutUTCMaxDateTime7DigitsResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutUTCMaxDateTime7DigitsResponse{}, nil
}

// putUTCMaxDateTime7DigitsCreateRequest creates the PutUTCMaxDateTime7Digits request.
func (client *DatetimeClient) putUTCMaxDateTime7DigitsCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTime7DigitsOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc7ms"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutUTCMinDateTime - Put min datetime value 0001-01-01T00:00:00Z
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// datetimeBody - datetime body
// options - DatetimeClientPutUTCMinDateTimeOptions contains the optional parameters for the DatetimeClient.PutUTCMinDateTime
// method.
func (client *DatetimeClient) PutUTCMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMinDateTimeOptions) (DatetimeClientPutUTCMinDateTimeResponse, error) {
	req, err := client.putUTCMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimeClientPutUTCMinDateTimeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DatetimeClientPutUTCMinDateTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DatetimeClientPutUTCMinDateTimeResponse{}, runtime.NewResponseError(resp)
	}
	return DatetimeClientPutUTCMinDateTimeResponse{}, nil
}

// putUTCMinDateTimeCreateRequest creates the PutUTCMinDateTime request.
func (client *DatetimeClient) putUTCMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}
