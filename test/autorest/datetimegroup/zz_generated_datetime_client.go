// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package datetimegroup

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// DatetimeClient contains the methods for the Datetime group.
// Don't use this type directly, use NewDatetimeClient() instead.
type DatetimeClient struct {
	con *Connection
}

// NewDatetimeClient creates a new instance of DatetimeClient with the specified values.
func NewDatetimeClient(con *Connection) *DatetimeClient {
	return &DatetimeClient{con: con}
}

// GetInvalid - Get invalid datetime value
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetInvalid(ctx context.Context, options *DatetimeGetInvalidOptions) (DatetimeGetInvalidResponse, error) {
	req, err := client.getInvalidCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetInvalidResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetInvalidResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetInvalidResponse{}, client.getInvalidHandleError(resp)
	}
	return client.getInvalidHandleResponse(resp)
}

// getInvalidCreateRequest creates the GetInvalid request.
func (client *DatetimeClient) getInvalidCreateRequest(ctx context.Context, options *DatetimeGetInvalidOptions) (*azcore.Request, error) {
	urlPath := "/datetime/invalid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getInvalidHandleResponse handles the GetInvalid response.
func (client *DatetimeClient) getInvalidHandleResponse(resp *azcore.Response) (DatetimeGetInvalidResponse, error) {
	result := DatetimeGetInvalidResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetInvalidResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getInvalidHandleError handles the GetInvalid error response.
func (client *DatetimeClient) getInvalidHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalNegativeOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999-14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTime(ctx context.Context, options *DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeOptions) (DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, client.getLocalNegativeOffsetLowercaseMaxDateTimeHandleError(resp)
	}
	return client.getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp)
}

// getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/lowercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse, error) {
	result := DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalNegativeOffsetLowercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalNegativeOffsetLowercaseMaxDateTimeHandleError handles the GetLocalNegativeOffsetLowercaseMaxDateTime error response.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalNegativeOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00-14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTime(ctx context.Context, options *DatetimeGetLocalNegativeOffsetMinDateTimeOptions) (DatetimeGetLocalNegativeOffsetMinDateTimeResponse, error) {
	req, err := client.getLocalNegativeOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalNegativeOffsetMinDateTimeResponse{}, client.getLocalNegativeOffsetMinDateTimeHandleError(resp)
	}
	return client.getLocalNegativeOffsetMinDateTimeHandleResponse(resp)
}

// getLocalNegativeOffsetMinDateTimeCreateRequest creates the GetLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalNegativeOffsetMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalNegativeOffsetMinDateTimeHandleResponse handles the GetLocalNegativeOffsetMinDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalNegativeOffsetMinDateTimeResponse, error) {
	result := DatetimeGetLocalNegativeOffsetMinDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalNegativeOffsetMinDateTimeHandleError handles the GetLocalNegativeOffsetMinDateTime error response.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalNegativeOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999-14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTime(ctx context.Context, options *DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeOptions) (DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, client.getLocalNegativeOffsetUppercaseMaxDateTimeHandleError(resp)
	}
	return client.getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp)
}

// getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse, error) {
	result := DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalNegativeOffsetUppercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalNegativeOffsetUppercaseMaxDateTimeHandleError handles the GetLocalNegativeOffsetUppercaseMaxDateTime error response.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalNoOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalNoOffsetMinDateTime(ctx context.Context, options *DatetimeGetLocalNoOffsetMinDateTimeOptions) (DatetimeGetLocalNoOffsetMinDateTimeResponse, error) {
	req, err := client.getLocalNoOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalNoOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalNoOffsetMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalNoOffsetMinDateTimeResponse{}, client.getLocalNoOffsetMinDateTimeHandleError(resp)
	}
	return client.getLocalNoOffsetMinDateTimeHandleResponse(resp)
}

// getLocalNoOffsetMinDateTimeCreateRequest creates the GetLocalNoOffsetMinDateTime request.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalNoOffsetMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/localnooffset"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalNoOffsetMinDateTimeHandleResponse handles the GetLocalNoOffsetMinDateTime response.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalNoOffsetMinDateTimeResponse, error) {
	result := DatetimeGetLocalNoOffsetMinDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalNoOffsetMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalNoOffsetMinDateTimeHandleError handles the GetLocalNoOffsetMinDateTime error response.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalPositiveOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999+14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTime(ctx context.Context, options *DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeOptions) (DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, client.getLocalPositiveOffsetLowercaseMaxDateTimeHandleError(resp)
	}
	return client.getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp)
}

// getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/lowercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse, error) {
	result := DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalPositiveOffsetLowercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalPositiveOffsetLowercaseMaxDateTimeHandleError handles the GetLocalPositiveOffsetLowercaseMaxDateTime error response.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalPositiveOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00+14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTime(ctx context.Context, options *DatetimeGetLocalPositiveOffsetMinDateTimeOptions) (DatetimeGetLocalPositiveOffsetMinDateTimeResponse, error) {
	req, err := client.getLocalPositiveOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalPositiveOffsetMinDateTimeResponse{}, client.getLocalPositiveOffsetMinDateTimeHandleError(resp)
	}
	return client.getLocalPositiveOffsetMinDateTimeHandleResponse(resp)
}

// getLocalPositiveOffsetMinDateTimeCreateRequest creates the GetLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalPositiveOffsetMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalPositiveOffsetMinDateTimeHandleResponse handles the GetLocalPositiveOffsetMinDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalPositiveOffsetMinDateTimeResponse, error) {
	result := DatetimeGetLocalPositiveOffsetMinDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalPositiveOffsetMinDateTimeHandleError handles the GetLocalPositiveOffsetMinDateTime error response.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLocalPositiveOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999+14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTime(ctx context.Context, options *DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeOptions) (DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse, error) {
	req, err := client.getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, client.getLocalPositiveOffsetUppercaseMaxDateTimeHandleError(resp)
	}
	return client.getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp)
}

// getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse, error) {
	result := DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetLocalPositiveOffsetUppercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getLocalPositiveOffsetUppercaseMaxDateTimeHandleError handles the GetLocalPositiveOffsetUppercaseMaxDateTime error response.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetNull - Get null datetime value
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetNull(ctx context.Context, options *DatetimeGetNullOptions) (DatetimeGetNullResponse, error) {
	req, err := client.getNullCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetNullResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetNullResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetNullResponse{}, client.getNullHandleError(resp)
	}
	return client.getNullHandleResponse(resp)
}

// getNullCreateRequest creates the GetNull request.
func (client *DatetimeClient) getNullCreateRequest(ctx context.Context, options *DatetimeGetNullOptions) (*azcore.Request, error) {
	urlPath := "/datetime/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNullHandleResponse handles the GetNull response.
func (client *DatetimeClient) getNullHandleResponse(resp *azcore.Response) (DatetimeGetNullResponse, error) {
	result := DatetimeGetNullResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetNullResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getNullHandleError handles the GetNull error response.
func (client *DatetimeClient) getNullHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetOverflow - Get overflow datetime value
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetOverflow(ctx context.Context, options *DatetimeGetOverflowOptions) (DatetimeGetOverflowResponse, error) {
	req, err := client.getOverflowCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetOverflowResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetOverflowResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetOverflowResponse{}, client.getOverflowHandleError(resp)
	}
	return client.getOverflowHandleResponse(resp)
}

// getOverflowCreateRequest creates the GetOverflow request.
func (client *DatetimeClient) getOverflowCreateRequest(ctx context.Context, options *DatetimeGetOverflowOptions) (*azcore.Request, error) {
	urlPath := "/datetime/overflow"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getOverflowHandleResponse handles the GetOverflow response.
func (client *DatetimeClient) getOverflowHandleResponse(resp *azcore.Response) (DatetimeGetOverflowResponse, error) {
	result := DatetimeGetOverflowResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetOverflowResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getOverflowHandleError handles the GetOverflow error response.
func (client *DatetimeClient) getOverflowHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetUTCLowercaseMaxDateTime - Get max datetime value 9999-12-31t23:59:59.999z
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetUTCLowercaseMaxDateTime(ctx context.Context, options *DatetimeGetUTCLowercaseMaxDateTimeOptions) (DatetimeGetUTCLowercaseMaxDateTimeResponse, error) {
	req, err := client.getUTCLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetUTCLowercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetUTCLowercaseMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetUTCLowercaseMaxDateTimeResponse{}, client.getUTCLowercaseMaxDateTimeHandleError(resp)
	}
	return client.getUTCLowercaseMaxDateTimeHandleResponse(resp)
}

// getUTCLowercaseMaxDateTimeCreateRequest creates the GetUTCLowercaseMaxDateTime request.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeGetUTCLowercaseMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc/lowercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getUTCLowercaseMaxDateTimeHandleResponse handles the GetUTCLowercaseMaxDateTime response.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetUTCLowercaseMaxDateTimeResponse, error) {
	result := DatetimeGetUTCLowercaseMaxDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetUTCLowercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getUTCLowercaseMaxDateTimeHandleError handles the GetUTCLowercaseMaxDateTime error response.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetUTCMinDateTime - Get min datetime value 0001-01-01T00:00:00Z
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetUTCMinDateTime(ctx context.Context, options *DatetimeGetUTCMinDateTimeOptions) (DatetimeGetUTCMinDateTimeResponse, error) {
	req, err := client.getUTCMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetUTCMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetUTCMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetUTCMinDateTimeResponse{}, client.getUTCMinDateTimeHandleError(resp)
	}
	return client.getUTCMinDateTimeHandleResponse(resp)
}

// getUTCMinDateTimeCreateRequest creates the GetUTCMinDateTime request.
func (client *DatetimeClient) getUTCMinDateTimeCreateRequest(ctx context.Context, options *DatetimeGetUTCMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getUTCMinDateTimeHandleResponse handles the GetUTCMinDateTime response.
func (client *DatetimeClient) getUTCMinDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetUTCMinDateTimeResponse, error) {
	result := DatetimeGetUTCMinDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetUTCMinDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getUTCMinDateTimeHandleError handles the GetUTCMinDateTime error response.
func (client *DatetimeClient) getUTCMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetUTCUppercaseMaxDateTime - Get max datetime value 9999-12-31T23:59:59.999Z
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime(ctx context.Context, options *DatetimeGetUTCUppercaseMaxDateTimeOptions) (DatetimeGetUTCUppercaseMaxDateTimeResponse, error) {
	req, err := client.getUTCUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetUTCUppercaseMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetUTCUppercaseMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetUTCUppercaseMaxDateTimeResponse{}, client.getUTCUppercaseMaxDateTimeHandleError(resp)
	}
	return client.getUTCUppercaseMaxDateTimeHandleResponse(resp)
}

// getUTCUppercaseMaxDateTimeCreateRequest creates the GetUTCUppercaseMaxDateTime request.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeGetUTCUppercaseMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getUTCUppercaseMaxDateTimeHandleResponse handles the GetUTCUppercaseMaxDateTime response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeHandleResponse(resp *azcore.Response) (DatetimeGetUTCUppercaseMaxDateTimeResponse, error) {
	result := DatetimeGetUTCUppercaseMaxDateTimeResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetUTCUppercaseMaxDateTimeResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getUTCUppercaseMaxDateTimeHandleError handles the GetUTCUppercaseMaxDateTime error response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetUTCUppercaseMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in that scenario
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7Digits(ctx context.Context, options *DatetimeGetUTCUppercaseMaxDateTime7DigitsOptions) (DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse, error) {
	req, err := client.getUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse{}, client.getUTCUppercaseMaxDateTime7DigitsHandleError(resp)
	}
	return client.getUTCUppercaseMaxDateTime7DigitsHandleResponse(resp)
}

// getUTCUppercaseMaxDateTime7DigitsCreateRequest creates the GetUTCUppercaseMaxDateTime7Digits request.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx context.Context, options *DatetimeGetUTCUppercaseMaxDateTime7DigitsOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc7ms/uppercase"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getUTCUppercaseMaxDateTime7DigitsHandleResponse handles the GetUTCUppercaseMaxDateTime7Digits response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsHandleResponse(resp *azcore.Response) (DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse, error) {
	result := DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetUTCUppercaseMaxDateTime7DigitsResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getUTCUppercaseMaxDateTime7DigitsHandleError handles the GetUTCUppercaseMaxDateTime7Digits error response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetUnderflow - Get underflow datetime value
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) GetUnderflow(ctx context.Context, options *DatetimeGetUnderflowOptions) (DatetimeGetUnderflowResponse, error) {
	req, err := client.getUnderflowCreateRequest(ctx, options)
	if err != nil {
		return DatetimeGetUnderflowResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimeGetUnderflowResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimeGetUnderflowResponse{}, client.getUnderflowHandleError(resp)
	}
	return client.getUnderflowHandleResponse(resp)
}

// getUnderflowCreateRequest creates the GetUnderflow request.
func (client *DatetimeClient) getUnderflowCreateRequest(ctx context.Context, options *DatetimeGetUnderflowOptions) (*azcore.Request, error) {
	urlPath := "/datetime/underflow"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getUnderflowHandleResponse handles the GetUnderflow response.
func (client *DatetimeClient) getUnderflowHandleResponse(resp *azcore.Response) (DatetimeGetUnderflowResponse, error) {
	result := DatetimeGetUnderflowResponse{RawResponse: resp.Response}
	var aux *timeRFC3339
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return DatetimeGetUnderflowResponse{}, err
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// getUnderflowHandleError handles the GetUnderflow error response.
func (client *DatetimeClient) getUnderflowHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutLocalNegativeOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999-14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutLocalNegativeOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalNegativeOffsetMaxDateTimeOptions) (DatetimePutLocalNegativeOffsetMaxDateTimeResponse, error) {
	req, err := client.putLocalNegativeOffsetMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutLocalNegativeOffsetMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutLocalNegativeOffsetMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutLocalNegativeOffsetMaxDateTimeResponse{}, client.putLocalNegativeOffsetMaxDateTimeHandleError(resp)
	}
	return DatetimePutLocalNegativeOffsetMaxDateTimeResponse{RawResponse: resp.Response}, nil
}

// putLocalNegativeOffsetMaxDateTimeCreateRequest creates the PutLocalNegativeOffsetMaxDateTime request.
func (client *DatetimeClient) putLocalNegativeOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalNegativeOffsetMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putLocalNegativeOffsetMaxDateTimeHandleError handles the PutLocalNegativeOffsetMaxDateTime error response.
func (client *DatetimeClient) putLocalNegativeOffsetMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutLocalNegativeOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00-14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutLocalNegativeOffsetMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalNegativeOffsetMinDateTimeOptions) (DatetimePutLocalNegativeOffsetMinDateTimeResponse, error) {
	req, err := client.putLocalNegativeOffsetMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutLocalNegativeOffsetMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutLocalNegativeOffsetMinDateTimeResponse{}, client.putLocalNegativeOffsetMinDateTimeHandleError(resp)
	}
	return DatetimePutLocalNegativeOffsetMinDateTimeResponse{RawResponse: resp.Response}, nil
}

// putLocalNegativeOffsetMinDateTimeCreateRequest creates the PutLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) putLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalNegativeOffsetMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putLocalNegativeOffsetMinDateTimeHandleError handles the PutLocalNegativeOffsetMinDateTime error response.
func (client *DatetimeClient) putLocalNegativeOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutLocalPositiveOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999+14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutLocalPositiveOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalPositiveOffsetMaxDateTimeOptions) (DatetimePutLocalPositiveOffsetMaxDateTimeResponse, error) {
	req, err := client.putLocalPositiveOffsetMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutLocalPositiveOffsetMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutLocalPositiveOffsetMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutLocalPositiveOffsetMaxDateTimeResponse{}, client.putLocalPositiveOffsetMaxDateTimeHandleError(resp)
	}
	return DatetimePutLocalPositiveOffsetMaxDateTimeResponse{RawResponse: resp.Response}, nil
}

// putLocalPositiveOffsetMaxDateTimeCreateRequest creates the PutLocalPositiveOffsetMaxDateTime request.
func (client *DatetimeClient) putLocalPositiveOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalPositiveOffsetMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putLocalPositiveOffsetMaxDateTimeHandleError handles the PutLocalPositiveOffsetMaxDateTime error response.
func (client *DatetimeClient) putLocalPositiveOffsetMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutLocalPositiveOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00+14:00
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutLocalPositiveOffsetMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalPositiveOffsetMinDateTimeOptions) (DatetimePutLocalPositiveOffsetMinDateTimeResponse, error) {
	req, err := client.putLocalPositiveOffsetMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutLocalPositiveOffsetMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutLocalPositiveOffsetMinDateTimeResponse{}, client.putLocalPositiveOffsetMinDateTimeHandleError(resp)
	}
	return DatetimePutLocalPositiveOffsetMinDateTimeResponse{RawResponse: resp.Response}, nil
}

// putLocalPositiveOffsetMinDateTimeCreateRequest creates the PutLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) putLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutLocalPositiveOffsetMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putLocalPositiveOffsetMinDateTimeHandleError handles the PutLocalPositiveOffsetMinDateTime error response.
func (client *DatetimeClient) putLocalPositiveOffsetMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutUTCMaxDateTime - Put max datetime value 9999-12-31T23:59:59.999Z
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutUTCMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimePutUTCMaxDateTimeOptions) (DatetimePutUTCMaxDateTimeResponse, error) {
	req, err := client.putUTCMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutUTCMaxDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutUTCMaxDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutUTCMaxDateTimeResponse{}, client.putUTCMaxDateTimeHandleError(resp)
	}
	return DatetimePutUTCMaxDateTimeResponse{RawResponse: resp.Response}, nil
}

// putUTCMaxDateTimeCreateRequest creates the PutUTCMaxDateTime request.
func (client *DatetimeClient) putUTCMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutUTCMaxDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putUTCMaxDateTimeHandleError handles the PutUTCMaxDateTime error response.
func (client *DatetimeClient) putUTCMaxDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutUTCMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in that scenario
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutUTCMaxDateTime7Digits(ctx context.Context, datetimeBody time.Time, options *DatetimePutUTCMaxDateTime7DigitsOptions) (DatetimePutUTCMaxDateTime7DigitsResponse, error) {
	req, err := client.putUTCMaxDateTime7DigitsCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutUTCMaxDateTime7DigitsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutUTCMaxDateTime7DigitsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutUTCMaxDateTime7DigitsResponse{}, client.putUTCMaxDateTime7DigitsHandleError(resp)
	}
	return DatetimePutUTCMaxDateTime7DigitsResponse{RawResponse: resp.Response}, nil
}

// putUTCMaxDateTime7DigitsCreateRequest creates the PutUTCMaxDateTime7Digits request.
func (client *DatetimeClient) putUTCMaxDateTime7DigitsCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutUTCMaxDateTime7DigitsOptions) (*azcore.Request, error) {
	urlPath := "/datetime/max/utc7ms"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putUTCMaxDateTime7DigitsHandleError handles the PutUTCMaxDateTime7Digits error response.
func (client *DatetimeClient) putUTCMaxDateTime7DigitsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutUTCMinDateTime - Put min datetime value 0001-01-01T00:00:00Z
// If the operation fails it returns the *Error error type.
func (client *DatetimeClient) PutUTCMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimePutUTCMinDateTimeOptions) (DatetimePutUTCMinDateTimeResponse, error) {
	req, err := client.putUTCMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return DatetimePutUTCMinDateTimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DatetimePutUTCMinDateTimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DatetimePutUTCMinDateTimeResponse{}, client.putUTCMinDateTimeHandleError(resp)
	}
	return DatetimePutUTCMinDateTimeResponse{RawResponse: resp.Response}, nil
}

// putUTCMinDateTimeCreateRequest creates the PutUTCMinDateTime request.
func (client *DatetimeClient) putUTCMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimePutUTCMinDateTimeOptions) (*azcore.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(datetimeBody)
}

// putUTCMinDateTimeHandleError handles the PutUTCMinDateTime error response.
func (client *DatetimeClient) putUTCMinDateTimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
