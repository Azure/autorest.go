// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package dictionarygroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"time"
)

// DictionaryOperations contains the methods for the Dictionary group.
type DictionaryOperations interface {
	// GetArrayEmpty - Get an empty dictionary {}
	GetArrayEmpty(ctx context.Context, options *DictionaryGetArrayEmptyOptions) (*MapOfStringArrayResponse, error)
	// GetArrayItemEmpty - Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}
	GetArrayItemEmpty(ctx context.Context, options *DictionaryGetArrayItemEmptyOptions) (*MapOfStringArrayResponse, error)
	// GetArrayItemNull - Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}
	GetArrayItemNull(ctx context.Context, options *DictionaryGetArrayItemNullOptions) (*MapOfStringArrayResponse, error)
	// GetArrayNull - Get a null array
	GetArrayNull(ctx context.Context, options *DictionaryGetArrayNullOptions) (*MapOfStringArrayResponse, error)
	// GetArrayValid - Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
	GetArrayValid(ctx context.Context, options *DictionaryGetArrayValidOptions) (*MapOfStringArrayResponse, error)
	// GetBase64URL - Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}
	GetBase64URL(ctx context.Context, options *DictionaryGetBase64URLOptions) (*MapOfByteArrayResponse, error)
	// GetBooleanInvalidNull - Get boolean dictionary value {"0": true, "1": null, "2": false }
	GetBooleanInvalidNull(ctx context.Context, options *DictionaryGetBooleanInvalidNullOptions) (*MapOfBoolResponse, error)
	// GetBooleanInvalidString - Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'
	GetBooleanInvalidString(ctx context.Context, options *DictionaryGetBooleanInvalidStringOptions) (*MapOfBoolResponse, error)
	// GetBooleanTfft - Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }
	GetBooleanTfft(ctx context.Context, options *DictionaryGetBooleanTfftOptions) (*MapOfBoolResponse, error)
	// GetByteInvalidNull - Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded
	GetByteInvalidNull(ctx context.Context, options *DictionaryGetByteInvalidNullOptions) (*MapOfByteArrayResponse, error)
	// GetByteValid - Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64
	GetByteValid(ctx context.Context, options *DictionaryGetByteValidOptions) (*MapOfByteArrayResponse, error)
	// GetComplexEmpty - Get empty dictionary of complex type {}
	GetComplexEmpty(ctx context.Context, options *DictionaryGetComplexEmptyOptions) (*MapOfWidgetResponse, error)
	// GetComplexItemEmpty - Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}
	GetComplexItemEmpty(ctx context.Context, options *DictionaryGetComplexItemEmptyOptions) (*MapOfWidgetResponse, error)
	// GetComplexItemNull - Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}
	GetComplexItemNull(ctx context.Context, options *DictionaryGetComplexItemNullOptions) (*MapOfWidgetResponse, error)
	// GetComplexNull - Get dictionary of complex type null value
	GetComplexNull(ctx context.Context, options *DictionaryGetComplexNullOptions) (*MapOfWidgetResponse, error)
	// GetComplexValid - Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string":
	// "6"}}
	GetComplexValid(ctx context.Context, options *DictionaryGetComplexValidOptions) (*MapOfWidgetResponse, error)
	// GetDateInvalidChars - Get date dictionary value {"0": "2011-03-22", "1": "date"}
	GetDateInvalidChars(ctx context.Context, options *DictionaryGetDateInvalidCharsOptions) (*MapOfTimeResponse, error)
	// GetDateInvalidNull - Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}
	GetDateInvalidNull(ctx context.Context, options *DictionaryGetDateInvalidNullOptions) (*MapOfTimeResponse, error)
	// GetDateTimeInvalidChars - Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}
	GetDateTimeInvalidChars(ctx context.Context, options *DictionaryGetDateTimeInvalidCharsOptions) (*MapOfTimeResponse, error)
	// GetDateTimeInvalidNull - Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}
	GetDateTimeInvalidNull(ctx context.Context, options *DictionaryGetDateTimeInvalidNullOptions) (*MapOfTimeResponse, error)
	// GetDateTimeRFC1123Valid - Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed,
	// 12 Oct 1492 10:15:01 GMT"}
	GetDateTimeRFC1123Valid(ctx context.Context, options *DictionaryGetDateTimeRFC1123ValidOptions) (*MapOfTimeResponse, error)
	// GetDateTimeValid - Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
	GetDateTimeValid(ctx context.Context, options *DictionaryGetDateTimeValidOptions) (*MapOfTimeResponse, error)
	// GetDateValid - Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
	GetDateValid(ctx context.Context, options *DictionaryGetDateValidOptions) (*MapOfTimeResponse, error)
	// GetDictionaryEmpty - Get an dictionaries of dictionaries of type with value {}
	GetDictionaryEmpty(ctx context.Context, options *DictionaryGetDictionaryEmptyOptions) (*MapOfInterfaceResponse, error)
	// GetDictionaryItemEmpty - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven",
	// "8": "eight", "9": "nine"}}
	GetDictionaryItemEmpty(ctx context.Context, options *DictionaryGetDictionaryItemEmptyOptions) (*MapOfInterfaceResponse, error)
	// GetDictionaryItemNull - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven",
	// "8": "eight", "9": "nine"}}
	GetDictionaryItemNull(ctx context.Context, options *DictionaryGetDictionaryItemNullOptions) (*MapOfInterfaceResponse, error)
	// GetDictionaryNull - Get an dictionaries of dictionaries with value null
	GetDictionaryNull(ctx context.Context, options *DictionaryGetDictionaryNullOptions) (*MapOfInterfaceResponse, error)
	// GetDictionaryValid - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five",
	// "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
	GetDictionaryValid(ctx context.Context, options *DictionaryGetDictionaryValidOptions) (*MapOfInterfaceResponse, error)
	// GetDoubleInvalidNull - Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
	GetDoubleInvalidNull(ctx context.Context, options *DictionaryGetDoubleInvalidNullOptions) (*MapOfFloat64Response, error)
	// GetDoubleInvalidString - Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
	GetDoubleInvalidString(ctx context.Context, options *DictionaryGetDoubleInvalidStringOptions) (*MapOfFloat64Response, error)
	// GetDoubleValid - Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
	GetDoubleValid(ctx context.Context, options *DictionaryGetDoubleValidOptions) (*MapOfFloat64Response, error)
	// GetDurationValid - Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}
	GetDurationValid(ctx context.Context, options *DictionaryGetDurationValidOptions) (*MapOfStringResponse, error)
	// GetEmpty - Get empty dictionary value {}
	GetEmpty(ctx context.Context, options *DictionaryGetEmptyOptions) (*MapOfInt32Response, error)
	// GetEmptyStringKey - Get Dictionary with key as empty string
	GetEmptyStringKey(ctx context.Context, options *DictionaryGetEmptyStringKeyOptions) (*MapOfStringResponse, error)
	// GetFloatInvalidNull - Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
	GetFloatInvalidNull(ctx context.Context, options *DictionaryGetFloatInvalidNullOptions) (*MapOfFloat32Response, error)
	// GetFloatInvalidString - Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
	GetFloatInvalidString(ctx context.Context, options *DictionaryGetFloatInvalidStringOptions) (*MapOfFloat32Response, error)
	// GetFloatValid - Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
	GetFloatValid(ctx context.Context, options *DictionaryGetFloatValidOptions) (*MapOfFloat32Response, error)
	// GetIntInvalidNull - Get integer dictionary value {"0": 1, "1": null, "2": 0}
	GetIntInvalidNull(ctx context.Context, options *DictionaryGetIntInvalidNullOptions) (*MapOfInt32Response, error)
	// GetIntInvalidString - Get integer dictionary value {"0": 1, "1": "integer", "2": 0}
	GetIntInvalidString(ctx context.Context, options *DictionaryGetIntInvalidStringOptions) (*MapOfInt32Response, error)
	// GetIntegerValid - Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
	GetIntegerValid(ctx context.Context, options *DictionaryGetIntegerValidOptions) (*MapOfInt32Response, error)
	// GetInvalid - Get invalid Dictionary value
	GetInvalid(ctx context.Context, options *DictionaryGetInvalidOptions) (*MapOfStringResponse, error)
	// GetLongInvalidNull - Get long dictionary value {"0": 1, "1": null, "2": 0}
	GetLongInvalidNull(ctx context.Context, options *DictionaryGetLongInvalidNullOptions) (*MapOfInt64Response, error)
	// GetLongInvalidString - Get long dictionary value {"0": 1, "1": "integer", "2": 0}
	GetLongInvalidString(ctx context.Context, options *DictionaryGetLongInvalidStringOptions) (*MapOfInt64Response, error)
	// GetLongValid - Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
	GetLongValid(ctx context.Context, options *DictionaryGetLongValidOptions) (*MapOfInt64Response, error)
	// GetNull - Get null dictionary value
	GetNull(ctx context.Context, options *DictionaryGetNullOptions) (*MapOfInt32Response, error)
	// GetNullKey - Get Dictionary with null key
	GetNullKey(ctx context.Context, options *DictionaryGetNullKeyOptions) (*MapOfStringResponse, error)
	// GetNullValue - Get Dictionary with null value
	GetNullValue(ctx context.Context, options *DictionaryGetNullValueOptions) (*MapOfStringResponse, error)
	// GetStringValid - Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
	GetStringValid(ctx context.Context, options *DictionaryGetStringValidOptions) (*MapOfStringResponse, error)
	// GetStringWithInvalid - Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}
	GetStringWithInvalid(ctx context.Context, options *DictionaryGetStringWithInvalidOptions) (*MapOfStringResponse, error)
	// GetStringWithNull - Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}
	GetStringWithNull(ctx context.Context, options *DictionaryGetStringWithNullOptions) (*MapOfStringResponse, error)
	// PutArrayValid - Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
	PutArrayValid(ctx context.Context, arrayBody map[string][]string, options *DictionaryPutArrayValidOptions) (*http.Response, error)
	// PutBooleanTfft - Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }
	PutBooleanTfft(ctx context.Context, arrayBody map[string]bool, options *DictionaryPutBooleanTfftOptions) (*http.Response, error)
	// PutByteValid - Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64
	PutByteValid(ctx context.Context, arrayBody map[string][]byte, options *DictionaryPutByteValidOptions) (*http.Response, error)
	// PutComplexValid - Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer":
	// 5, "string": "6"}}
	PutComplexValid(ctx context.Context, arrayBody map[string]Widget, options *DictionaryPutComplexValidOptions) (*http.Response, error)
	// PutDateTimeRFC1123Valid - Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492
	// 10:15:01 GMT"}
	PutDateTimeRFC1123Valid(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateTimeRFC1123ValidOptions) (*http.Response, error)
	// PutDateTimeValid - Set dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
	PutDateTimeValid(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateTimeValidOptions) (*http.Response, error)
	// PutDateValid - Set dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
	PutDateValid(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateValidOptions) (*http.Response, error)
	// PutDictionaryValid - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five",
	// "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
	PutDictionaryValid(ctx context.Context, arrayBody map[string]interface{}, options *DictionaryPutDictionaryValidOptions) (*http.Response, error)
	// PutDoubleValid - Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
	PutDoubleValid(ctx context.Context, arrayBody map[string]float64, options *DictionaryPutDoubleValidOptions) (*http.Response, error)
	// PutDurationValid - Set dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}
	PutDurationValid(ctx context.Context, arrayBody map[string]string, options *DictionaryPutDurationValidOptions) (*http.Response, error)
	// PutEmpty - Set dictionary value empty {}
	PutEmpty(ctx context.Context, arrayBody map[string]string, options *DictionaryPutEmptyOptions) (*http.Response, error)
	// PutFloatValid - Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
	PutFloatValid(ctx context.Context, arrayBody map[string]float32, options *DictionaryPutFloatValidOptions) (*http.Response, error)
	// PutIntegerValid - Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
	PutIntegerValid(ctx context.Context, arrayBody map[string]int32, options *DictionaryPutIntegerValidOptions) (*http.Response, error)
	// PutLongValid - Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
	PutLongValid(ctx context.Context, arrayBody map[string]int64, options *DictionaryPutLongValidOptions) (*http.Response, error)
	// PutStringValid - Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
	PutStringValid(ctx context.Context, arrayBody map[string]string, options *DictionaryPutStringValidOptions) (*http.Response, error)
}

// DictionaryClient implements the DictionaryOperations interface.
// Don't use this type directly, use NewDictionaryClient() instead.
type DictionaryClient struct {
	con *Connection
}

// NewDictionaryClient creates a new instance of DictionaryClient with the specified values.
func NewDictionaryClient(con *Connection) DictionaryOperations {
	return &DictionaryClient{con: con}
}

// Pipeline returns the pipeline associated with this client.
func (client *DictionaryClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// GetArrayEmpty - Get an empty dictionary {}
func (client *DictionaryClient) GetArrayEmpty(ctx context.Context, options *DictionaryGetArrayEmptyOptions) (*MapOfStringArrayResponse, error) {
	req, err := client.GetArrayEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetArrayEmptyHandleError(resp)
	}
	result, err := client.GetArrayEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetArrayEmptyCreateRequest creates the GetArrayEmpty request.
func (client *DictionaryClient) GetArrayEmptyCreateRequest(ctx context.Context, options *DictionaryGetArrayEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/array/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetArrayEmptyHandleResponse handles the GetArrayEmpty response.
func (client *DictionaryClient) GetArrayEmptyHandleResponse(resp *azcore.Response) (*MapOfStringArrayResponse, error) {
	result := MapOfStringArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetArrayEmptyHandleError handles the GetArrayEmpty error response.
func (client *DictionaryClient) GetArrayEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetArrayItemEmpty - Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}
func (client *DictionaryClient) GetArrayItemEmpty(ctx context.Context, options *DictionaryGetArrayItemEmptyOptions) (*MapOfStringArrayResponse, error) {
	req, err := client.GetArrayItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetArrayItemEmptyHandleError(resp)
	}
	result, err := client.GetArrayItemEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetArrayItemEmptyCreateRequest creates the GetArrayItemEmpty request.
func (client *DictionaryClient) GetArrayItemEmptyCreateRequest(ctx context.Context, options *DictionaryGetArrayItemEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/array/itemempty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetArrayItemEmptyHandleResponse handles the GetArrayItemEmpty response.
func (client *DictionaryClient) GetArrayItemEmptyHandleResponse(resp *azcore.Response) (*MapOfStringArrayResponse, error) {
	result := MapOfStringArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetArrayItemEmptyHandleError handles the GetArrayItemEmpty error response.
func (client *DictionaryClient) GetArrayItemEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetArrayItemNull - Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}
func (client *DictionaryClient) GetArrayItemNull(ctx context.Context, options *DictionaryGetArrayItemNullOptions) (*MapOfStringArrayResponse, error) {
	req, err := client.GetArrayItemNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetArrayItemNullHandleError(resp)
	}
	result, err := client.GetArrayItemNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetArrayItemNullCreateRequest creates the GetArrayItemNull request.
func (client *DictionaryClient) GetArrayItemNullCreateRequest(ctx context.Context, options *DictionaryGetArrayItemNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/array/itemnull"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetArrayItemNullHandleResponse handles the GetArrayItemNull response.
func (client *DictionaryClient) GetArrayItemNullHandleResponse(resp *azcore.Response) (*MapOfStringArrayResponse, error) {
	result := MapOfStringArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetArrayItemNullHandleError handles the GetArrayItemNull error response.
func (client *DictionaryClient) GetArrayItemNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetArrayNull - Get a null array
func (client *DictionaryClient) GetArrayNull(ctx context.Context, options *DictionaryGetArrayNullOptions) (*MapOfStringArrayResponse, error) {
	req, err := client.GetArrayNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetArrayNullHandleError(resp)
	}
	result, err := client.GetArrayNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetArrayNullCreateRequest creates the GetArrayNull request.
func (client *DictionaryClient) GetArrayNullCreateRequest(ctx context.Context, options *DictionaryGetArrayNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/array/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetArrayNullHandleResponse handles the GetArrayNull response.
func (client *DictionaryClient) GetArrayNullHandleResponse(resp *azcore.Response) (*MapOfStringArrayResponse, error) {
	result := MapOfStringArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetArrayNullHandleError handles the GetArrayNull error response.
func (client *DictionaryClient) GetArrayNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetArrayValid - Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
func (client *DictionaryClient) GetArrayValid(ctx context.Context, options *DictionaryGetArrayValidOptions) (*MapOfStringArrayResponse, error) {
	req, err := client.GetArrayValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetArrayValidHandleError(resp)
	}
	result, err := client.GetArrayValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetArrayValidCreateRequest creates the GetArrayValid request.
func (client *DictionaryClient) GetArrayValidCreateRequest(ctx context.Context, options *DictionaryGetArrayValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/array/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetArrayValidHandleResponse handles the GetArrayValid response.
func (client *DictionaryClient) GetArrayValidHandleResponse(resp *azcore.Response) (*MapOfStringArrayResponse, error) {
	result := MapOfStringArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetArrayValidHandleError handles the GetArrayValid error response.
func (client *DictionaryClient) GetArrayValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetBase64URL - Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}
func (client *DictionaryClient) GetBase64URL(ctx context.Context, options *DictionaryGetBase64URLOptions) (*MapOfByteArrayResponse, error) {
	req, err := client.GetBase64URLCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBase64URLHandleError(resp)
	}
	result, err := client.GetBase64URLHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetBase64URLCreateRequest creates the GetBase64URL request.
func (client *DictionaryClient) GetBase64URLCreateRequest(ctx context.Context, options *DictionaryGetBase64URLOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/base64url/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBase64URLHandleResponse handles the GetBase64URL response.
func (client *DictionaryClient) GetBase64URLHandleResponse(resp *azcore.Response) (*MapOfByteArrayResponse, error) {
	result := MapOfByteArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetBase64URLHandleError handles the GetBase64URL error response.
func (client *DictionaryClient) GetBase64URLHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetBooleanInvalidNull - Get boolean dictionary value {"0": true, "1": null, "2": false }
func (client *DictionaryClient) GetBooleanInvalidNull(ctx context.Context, options *DictionaryGetBooleanInvalidNullOptions) (*MapOfBoolResponse, error) {
	req, err := client.GetBooleanInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanInvalidNullHandleError(resp)
	}
	result, err := client.GetBooleanInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetBooleanInvalidNullCreateRequest creates the GetBooleanInvalidNull request.
func (client *DictionaryClient) GetBooleanInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetBooleanInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/boolean/true.null.false"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBooleanInvalidNullHandleResponse handles the GetBooleanInvalidNull response.
func (client *DictionaryClient) GetBooleanInvalidNullHandleResponse(resp *azcore.Response) (*MapOfBoolResponse, error) {
	result := MapOfBoolResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetBooleanInvalidNullHandleError handles the GetBooleanInvalidNull error response.
func (client *DictionaryClient) GetBooleanInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetBooleanInvalidString - Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'
func (client *DictionaryClient) GetBooleanInvalidString(ctx context.Context, options *DictionaryGetBooleanInvalidStringOptions) (*MapOfBoolResponse, error) {
	req, err := client.GetBooleanInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanInvalidStringHandleError(resp)
	}
	result, err := client.GetBooleanInvalidStringHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetBooleanInvalidStringCreateRequest creates the GetBooleanInvalidString request.
func (client *DictionaryClient) GetBooleanInvalidStringCreateRequest(ctx context.Context, options *DictionaryGetBooleanInvalidStringOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/boolean/true.boolean.false"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBooleanInvalidStringHandleResponse handles the GetBooleanInvalidString response.
func (client *DictionaryClient) GetBooleanInvalidStringHandleResponse(resp *azcore.Response) (*MapOfBoolResponse, error) {
	result := MapOfBoolResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetBooleanInvalidStringHandleError handles the GetBooleanInvalidString error response.
func (client *DictionaryClient) GetBooleanInvalidStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetBooleanTfft - Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }
func (client *DictionaryClient) GetBooleanTfft(ctx context.Context, options *DictionaryGetBooleanTfftOptions) (*MapOfBoolResponse, error) {
	req, err := client.GetBooleanTfftCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetBooleanTfftHandleError(resp)
	}
	result, err := client.GetBooleanTfftHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetBooleanTfftCreateRequest creates the GetBooleanTfft request.
func (client *DictionaryClient) GetBooleanTfftCreateRequest(ctx context.Context, options *DictionaryGetBooleanTfftOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/boolean/tfft"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetBooleanTfftHandleResponse handles the GetBooleanTfft response.
func (client *DictionaryClient) GetBooleanTfftHandleResponse(resp *azcore.Response) (*MapOfBoolResponse, error) {
	result := MapOfBoolResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetBooleanTfftHandleError handles the GetBooleanTfft error response.
func (client *DictionaryClient) GetBooleanTfftHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetByteInvalidNull - Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded
func (client *DictionaryClient) GetByteInvalidNull(ctx context.Context, options *DictionaryGetByteInvalidNullOptions) (*MapOfByteArrayResponse, error) {
	req, err := client.GetByteInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetByteInvalidNullHandleError(resp)
	}
	result, err := client.GetByteInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetByteInvalidNullCreateRequest creates the GetByteInvalidNull request.
func (client *DictionaryClient) GetByteInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetByteInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/byte/invalidnull"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetByteInvalidNullHandleResponse handles the GetByteInvalidNull response.
func (client *DictionaryClient) GetByteInvalidNullHandleResponse(resp *azcore.Response) (*MapOfByteArrayResponse, error) {
	result := MapOfByteArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetByteInvalidNullHandleError handles the GetByteInvalidNull error response.
func (client *DictionaryClient) GetByteInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetByteValid - Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64
func (client *DictionaryClient) GetByteValid(ctx context.Context, options *DictionaryGetByteValidOptions) (*MapOfByteArrayResponse, error) {
	req, err := client.GetByteValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetByteValidHandleError(resp)
	}
	result, err := client.GetByteValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetByteValidCreateRequest creates the GetByteValid request.
func (client *DictionaryClient) GetByteValidCreateRequest(ctx context.Context, options *DictionaryGetByteValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/byte/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetByteValidHandleResponse handles the GetByteValid response.
func (client *DictionaryClient) GetByteValidHandleResponse(resp *azcore.Response) (*MapOfByteArrayResponse, error) {
	result := MapOfByteArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetByteValidHandleError handles the GetByteValid error response.
func (client *DictionaryClient) GetByteValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetComplexEmpty - Get empty dictionary of complex type {}
func (client *DictionaryClient) GetComplexEmpty(ctx context.Context, options *DictionaryGetComplexEmptyOptions) (*MapOfWidgetResponse, error) {
	req, err := client.GetComplexEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexEmptyHandleError(resp)
	}
	result, err := client.GetComplexEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexEmptyCreateRequest creates the GetComplexEmpty request.
func (client *DictionaryClient) GetComplexEmptyCreateRequest(ctx context.Context, options *DictionaryGetComplexEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/complex/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetComplexEmptyHandleResponse handles the GetComplexEmpty response.
func (client *DictionaryClient) GetComplexEmptyHandleResponse(resp *azcore.Response) (*MapOfWidgetResponse, error) {
	result := MapOfWidgetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetComplexEmptyHandleError handles the GetComplexEmpty error response.
func (client *DictionaryClient) GetComplexEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetComplexItemEmpty - Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}
func (client *DictionaryClient) GetComplexItemEmpty(ctx context.Context, options *DictionaryGetComplexItemEmptyOptions) (*MapOfWidgetResponse, error) {
	req, err := client.GetComplexItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexItemEmptyHandleError(resp)
	}
	result, err := client.GetComplexItemEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexItemEmptyCreateRequest creates the GetComplexItemEmpty request.
func (client *DictionaryClient) GetComplexItemEmptyCreateRequest(ctx context.Context, options *DictionaryGetComplexItemEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/complex/itemempty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetComplexItemEmptyHandleResponse handles the GetComplexItemEmpty response.
func (client *DictionaryClient) GetComplexItemEmptyHandleResponse(resp *azcore.Response) (*MapOfWidgetResponse, error) {
	result := MapOfWidgetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetComplexItemEmptyHandleError handles the GetComplexItemEmpty error response.
func (client *DictionaryClient) GetComplexItemEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetComplexItemNull - Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}
func (client *DictionaryClient) GetComplexItemNull(ctx context.Context, options *DictionaryGetComplexItemNullOptions) (*MapOfWidgetResponse, error) {
	req, err := client.GetComplexItemNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexItemNullHandleError(resp)
	}
	result, err := client.GetComplexItemNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexItemNullCreateRequest creates the GetComplexItemNull request.
func (client *DictionaryClient) GetComplexItemNullCreateRequest(ctx context.Context, options *DictionaryGetComplexItemNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/complex/itemnull"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetComplexItemNullHandleResponse handles the GetComplexItemNull response.
func (client *DictionaryClient) GetComplexItemNullHandleResponse(resp *azcore.Response) (*MapOfWidgetResponse, error) {
	result := MapOfWidgetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetComplexItemNullHandleError handles the GetComplexItemNull error response.
func (client *DictionaryClient) GetComplexItemNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetComplexNull - Get dictionary of complex type null value
func (client *DictionaryClient) GetComplexNull(ctx context.Context, options *DictionaryGetComplexNullOptions) (*MapOfWidgetResponse, error) {
	req, err := client.GetComplexNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexNullHandleError(resp)
	}
	result, err := client.GetComplexNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexNullCreateRequest creates the GetComplexNull request.
func (client *DictionaryClient) GetComplexNullCreateRequest(ctx context.Context, options *DictionaryGetComplexNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/complex/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetComplexNullHandleResponse handles the GetComplexNull response.
func (client *DictionaryClient) GetComplexNullHandleResponse(resp *azcore.Response) (*MapOfWidgetResponse, error) {
	result := MapOfWidgetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetComplexNullHandleError handles the GetComplexNull error response.
func (client *DictionaryClient) GetComplexNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetComplexValid - Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string":
// "6"}}
func (client *DictionaryClient) GetComplexValid(ctx context.Context, options *DictionaryGetComplexValidOptions) (*MapOfWidgetResponse, error) {
	req, err := client.GetComplexValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexValidHandleError(resp)
	}
	result, err := client.GetComplexValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexValidCreateRequest creates the GetComplexValid request.
func (client *DictionaryClient) GetComplexValidCreateRequest(ctx context.Context, options *DictionaryGetComplexValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/complex/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetComplexValidHandleResponse handles the GetComplexValid response.
func (client *DictionaryClient) GetComplexValidHandleResponse(resp *azcore.Response) (*MapOfWidgetResponse, error) {
	result := MapOfWidgetResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetComplexValidHandleError handles the GetComplexValid error response.
func (client *DictionaryClient) GetComplexValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateInvalidChars - Get date dictionary value {"0": "2011-03-22", "1": "date"}
func (client *DictionaryClient) GetDateInvalidChars(ctx context.Context, options *DictionaryGetDateInvalidCharsOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateInvalidCharsHandleError(resp)
	}
	result, err := client.GetDateInvalidCharsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateInvalidCharsCreateRequest creates the GetDateInvalidChars request.
func (client *DictionaryClient) GetDateInvalidCharsCreateRequest(ctx context.Context, options *DictionaryGetDateInvalidCharsOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date/invalidchars"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateInvalidCharsHandleResponse handles the GetDateInvalidChars response.
func (client *DictionaryClient) GetDateInvalidCharsHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]dateType{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateInvalidCharsHandleError handles the GetDateInvalidChars error response.
func (client *DictionaryClient) GetDateInvalidCharsHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateInvalidNull - Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}
func (client *DictionaryClient) GetDateInvalidNull(ctx context.Context, options *DictionaryGetDateInvalidNullOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateInvalidNullHandleError(resp)
	}
	result, err := client.GetDateInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateInvalidNullCreateRequest creates the GetDateInvalidNull request.
func (client *DictionaryClient) GetDateInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetDateInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date/invalidnull"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateInvalidNullHandleResponse handles the GetDateInvalidNull response.
func (client *DictionaryClient) GetDateInvalidNullHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]dateType{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateInvalidNullHandleError handles the GetDateInvalidNull error response.
func (client *DictionaryClient) GetDateInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateTimeInvalidChars - Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}
func (client *DictionaryClient) GetDateTimeInvalidChars(ctx context.Context, options *DictionaryGetDateTimeInvalidCharsOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateTimeInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateTimeInvalidCharsHandleError(resp)
	}
	result, err := client.GetDateTimeInvalidCharsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateTimeInvalidCharsCreateRequest creates the GetDateTimeInvalidChars request.
func (client *DictionaryClient) GetDateTimeInvalidCharsCreateRequest(ctx context.Context, options *DictionaryGetDateTimeInvalidCharsOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date-time/invalidchars"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateTimeInvalidCharsHandleResponse handles the GetDateTimeInvalidChars response.
func (client *DictionaryClient) GetDateTimeInvalidCharsHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]timeRFC3339{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateTimeInvalidCharsHandleError handles the GetDateTimeInvalidChars error response.
func (client *DictionaryClient) GetDateTimeInvalidCharsHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateTimeInvalidNull - Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}
func (client *DictionaryClient) GetDateTimeInvalidNull(ctx context.Context, options *DictionaryGetDateTimeInvalidNullOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateTimeInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateTimeInvalidNullHandleError(resp)
	}
	result, err := client.GetDateTimeInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateTimeInvalidNullCreateRequest creates the GetDateTimeInvalidNull request.
func (client *DictionaryClient) GetDateTimeInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetDateTimeInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date-time/invalidnull"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateTimeInvalidNullHandleResponse handles the GetDateTimeInvalidNull response.
func (client *DictionaryClient) GetDateTimeInvalidNullHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]timeRFC3339{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateTimeInvalidNullHandleError handles the GetDateTimeInvalidNull error response.
func (client *DictionaryClient) GetDateTimeInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateTimeRFC1123Valid - Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed,
// 12 Oct 1492 10:15:01 GMT"}
func (client *DictionaryClient) GetDateTimeRFC1123Valid(ctx context.Context, options *DictionaryGetDateTimeRFC1123ValidOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateTimeRFC1123ValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateTimeRFC1123ValidHandleError(resp)
	}
	result, err := client.GetDateTimeRFC1123ValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateTimeRFC1123ValidCreateRequest creates the GetDateTimeRFC1123Valid request.
func (client *DictionaryClient) GetDateTimeRFC1123ValidCreateRequest(ctx context.Context, options *DictionaryGetDateTimeRFC1123ValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date-time-rfc1123/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateTimeRFC1123ValidHandleResponse handles the GetDateTimeRFC1123Valid response.
func (client *DictionaryClient) GetDateTimeRFC1123ValidHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]timeRFC1123{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateTimeRFC1123ValidHandleError handles the GetDateTimeRFC1123Valid error response.
func (client *DictionaryClient) GetDateTimeRFC1123ValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateTimeValid - Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
func (client *DictionaryClient) GetDateTimeValid(ctx context.Context, options *DictionaryGetDateTimeValidOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateTimeValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateTimeValidHandleError(resp)
	}
	result, err := client.GetDateTimeValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateTimeValidCreateRequest creates the GetDateTimeValid request.
func (client *DictionaryClient) GetDateTimeValidCreateRequest(ctx context.Context, options *DictionaryGetDateTimeValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date-time/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateTimeValidHandleResponse handles the GetDateTimeValid response.
func (client *DictionaryClient) GetDateTimeValidHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]timeRFC3339{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateTimeValidHandleError handles the GetDateTimeValid error response.
func (client *DictionaryClient) GetDateTimeValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDateValid - Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
func (client *DictionaryClient) GetDateValid(ctx context.Context, options *DictionaryGetDateValidOptions) (*MapOfTimeResponse, error) {
	req, err := client.GetDateValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDateValidHandleError(resp)
	}
	result, err := client.GetDateValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDateValidCreateRequest creates the GetDateValid request.
func (client *DictionaryClient) GetDateValidCreateRequest(ctx context.Context, options *DictionaryGetDateValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDateValidHandleResponse handles the GetDateValid response.
func (client *DictionaryClient) GetDateValidHandleResponse(resp *azcore.Response) (*MapOfTimeResponse, error) {
	aux := map[string]dateType{}
	if err := resp.UnmarshalAsJSON(&aux); err != nil {
		return nil, err
	}
	cp := map[string]time.Time{}
	for k, v := range aux {
		cp[k] = time.Time(v)
	}
	return &MapOfTimeResponse{RawResponse: resp.Response, Value: &cp}, nil
}

// GetDateValidHandleError handles the GetDateValid error response.
func (client *DictionaryClient) GetDateValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDictionaryEmpty - Get an dictionaries of dictionaries of type with value {}
func (client *DictionaryClient) GetDictionaryEmpty(ctx context.Context, options *DictionaryGetDictionaryEmptyOptions) (*MapOfInterfaceResponse, error) {
	req, err := client.GetDictionaryEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDictionaryEmptyHandleError(resp)
	}
	result, err := client.GetDictionaryEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDictionaryEmptyCreateRequest creates the GetDictionaryEmpty request.
func (client *DictionaryClient) GetDictionaryEmptyCreateRequest(ctx context.Context, options *DictionaryGetDictionaryEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/dictionary/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDictionaryEmptyHandleResponse handles the GetDictionaryEmpty response.
func (client *DictionaryClient) GetDictionaryEmptyHandleResponse(resp *azcore.Response) (*MapOfInterfaceResponse, error) {
	result := MapOfInterfaceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDictionaryEmptyHandleError handles the GetDictionaryEmpty error response.
func (client *DictionaryClient) GetDictionaryEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDictionaryItemEmpty - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven",
// "8": "eight", "9": "nine"}}
func (client *DictionaryClient) GetDictionaryItemEmpty(ctx context.Context, options *DictionaryGetDictionaryItemEmptyOptions) (*MapOfInterfaceResponse, error) {
	req, err := client.GetDictionaryItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDictionaryItemEmptyHandleError(resp)
	}
	result, err := client.GetDictionaryItemEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDictionaryItemEmptyCreateRequest creates the GetDictionaryItemEmpty request.
func (client *DictionaryClient) GetDictionaryItemEmptyCreateRequest(ctx context.Context, options *DictionaryGetDictionaryItemEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/dictionary/itemempty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDictionaryItemEmptyHandleResponse handles the GetDictionaryItemEmpty response.
func (client *DictionaryClient) GetDictionaryItemEmptyHandleResponse(resp *azcore.Response) (*MapOfInterfaceResponse, error) {
	result := MapOfInterfaceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDictionaryItemEmptyHandleError handles the GetDictionaryItemEmpty error response.
func (client *DictionaryClient) GetDictionaryItemEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDictionaryItemNull - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven",
// "8": "eight", "9": "nine"}}
func (client *DictionaryClient) GetDictionaryItemNull(ctx context.Context, options *DictionaryGetDictionaryItemNullOptions) (*MapOfInterfaceResponse, error) {
	req, err := client.GetDictionaryItemNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDictionaryItemNullHandleError(resp)
	}
	result, err := client.GetDictionaryItemNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDictionaryItemNullCreateRequest creates the GetDictionaryItemNull request.
func (client *DictionaryClient) GetDictionaryItemNullCreateRequest(ctx context.Context, options *DictionaryGetDictionaryItemNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/dictionary/itemnull"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDictionaryItemNullHandleResponse handles the GetDictionaryItemNull response.
func (client *DictionaryClient) GetDictionaryItemNullHandleResponse(resp *azcore.Response) (*MapOfInterfaceResponse, error) {
	result := MapOfInterfaceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDictionaryItemNullHandleError handles the GetDictionaryItemNull error response.
func (client *DictionaryClient) GetDictionaryItemNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDictionaryNull - Get an dictionaries of dictionaries with value null
func (client *DictionaryClient) GetDictionaryNull(ctx context.Context, options *DictionaryGetDictionaryNullOptions) (*MapOfInterfaceResponse, error) {
	req, err := client.GetDictionaryNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDictionaryNullHandleError(resp)
	}
	result, err := client.GetDictionaryNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDictionaryNullCreateRequest creates the GetDictionaryNull request.
func (client *DictionaryClient) GetDictionaryNullCreateRequest(ctx context.Context, options *DictionaryGetDictionaryNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/dictionary/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDictionaryNullHandleResponse handles the GetDictionaryNull response.
func (client *DictionaryClient) GetDictionaryNullHandleResponse(resp *azcore.Response) (*MapOfInterfaceResponse, error) {
	result := MapOfInterfaceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDictionaryNullHandleError handles the GetDictionaryNull error response.
func (client *DictionaryClient) GetDictionaryNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDictionaryValid - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five",
// "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
func (client *DictionaryClient) GetDictionaryValid(ctx context.Context, options *DictionaryGetDictionaryValidOptions) (*MapOfInterfaceResponse, error) {
	req, err := client.GetDictionaryValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDictionaryValidHandleError(resp)
	}
	result, err := client.GetDictionaryValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDictionaryValidCreateRequest creates the GetDictionaryValid request.
func (client *DictionaryClient) GetDictionaryValidCreateRequest(ctx context.Context, options *DictionaryGetDictionaryValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/dictionary/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDictionaryValidHandleResponse handles the GetDictionaryValid response.
func (client *DictionaryClient) GetDictionaryValidHandleResponse(resp *azcore.Response) (*MapOfInterfaceResponse, error) {
	result := MapOfInterfaceResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDictionaryValidHandleError handles the GetDictionaryValid error response.
func (client *DictionaryClient) GetDictionaryValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDoubleInvalidNull - Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
func (client *DictionaryClient) GetDoubleInvalidNull(ctx context.Context, options *DictionaryGetDoubleInvalidNullOptions) (*MapOfFloat64Response, error) {
	req, err := client.GetDoubleInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDoubleInvalidNullHandleError(resp)
	}
	result, err := client.GetDoubleInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDoubleInvalidNullCreateRequest creates the GetDoubleInvalidNull request.
func (client *DictionaryClient) GetDoubleInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetDoubleInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/double/0.0-null-1.2e20"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDoubleInvalidNullHandleResponse handles the GetDoubleInvalidNull response.
func (client *DictionaryClient) GetDoubleInvalidNullHandleResponse(resp *azcore.Response) (*MapOfFloat64Response, error) {
	result := MapOfFloat64Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDoubleInvalidNullHandleError handles the GetDoubleInvalidNull error response.
func (client *DictionaryClient) GetDoubleInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDoubleInvalidString - Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
func (client *DictionaryClient) GetDoubleInvalidString(ctx context.Context, options *DictionaryGetDoubleInvalidStringOptions) (*MapOfFloat64Response, error) {
	req, err := client.GetDoubleInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDoubleInvalidStringHandleError(resp)
	}
	result, err := client.GetDoubleInvalidStringHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDoubleInvalidStringCreateRequest creates the GetDoubleInvalidString request.
func (client *DictionaryClient) GetDoubleInvalidStringCreateRequest(ctx context.Context, options *DictionaryGetDoubleInvalidStringOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/double/1.number.0"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDoubleInvalidStringHandleResponse handles the GetDoubleInvalidString response.
func (client *DictionaryClient) GetDoubleInvalidStringHandleResponse(resp *azcore.Response) (*MapOfFloat64Response, error) {
	result := MapOfFloat64Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDoubleInvalidStringHandleError handles the GetDoubleInvalidString error response.
func (client *DictionaryClient) GetDoubleInvalidStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDoubleValid - Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
func (client *DictionaryClient) GetDoubleValid(ctx context.Context, options *DictionaryGetDoubleValidOptions) (*MapOfFloat64Response, error) {
	req, err := client.GetDoubleValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDoubleValidHandleError(resp)
	}
	result, err := client.GetDoubleValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDoubleValidCreateRequest creates the GetDoubleValid request.
func (client *DictionaryClient) GetDoubleValidCreateRequest(ctx context.Context, options *DictionaryGetDoubleValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/double/0--0.01-1.2e20"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDoubleValidHandleResponse handles the GetDoubleValid response.
func (client *DictionaryClient) GetDoubleValidHandleResponse(resp *azcore.Response) (*MapOfFloat64Response, error) {
	result := MapOfFloat64Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDoubleValidHandleError handles the GetDoubleValid error response.
func (client *DictionaryClient) GetDoubleValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetDurationValid - Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}
func (client *DictionaryClient) GetDurationValid(ctx context.Context, options *DictionaryGetDurationValidOptions) (*MapOfStringResponse, error) {
	req, err := client.GetDurationValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetDurationValidHandleError(resp)
	}
	result, err := client.GetDurationValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetDurationValidCreateRequest creates the GetDurationValid request.
func (client *DictionaryClient) GetDurationValidCreateRequest(ctx context.Context, options *DictionaryGetDurationValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/duration/valid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetDurationValidHandleResponse handles the GetDurationValid response.
func (client *DictionaryClient) GetDurationValidHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetDurationValidHandleError handles the GetDurationValid error response.
func (client *DictionaryClient) GetDurationValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetEmpty - Get empty dictionary value {}
func (client *DictionaryClient) GetEmpty(ctx context.Context, options *DictionaryGetEmptyOptions) (*MapOfInt32Response, error) {
	req, err := client.GetEmptyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetEmptyHandleError(resp)
	}
	result, err := client.GetEmptyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetEmptyCreateRequest creates the GetEmpty request.
func (client *DictionaryClient) GetEmptyCreateRequest(ctx context.Context, options *DictionaryGetEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/empty"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetEmptyHandleResponse handles the GetEmpty response.
func (client *DictionaryClient) GetEmptyHandleResponse(resp *azcore.Response) (*MapOfInt32Response, error) {
	result := MapOfInt32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetEmptyHandleError handles the GetEmpty error response.
func (client *DictionaryClient) GetEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetEmptyStringKey - Get Dictionary with key as empty string
func (client *DictionaryClient) GetEmptyStringKey(ctx context.Context, options *DictionaryGetEmptyStringKeyOptions) (*MapOfStringResponse, error) {
	req, err := client.GetEmptyStringKeyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetEmptyStringKeyHandleError(resp)
	}
	result, err := client.GetEmptyStringKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetEmptyStringKeyCreateRequest creates the GetEmptyStringKey request.
func (client *DictionaryClient) GetEmptyStringKeyCreateRequest(ctx context.Context, options *DictionaryGetEmptyStringKeyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/keyemptystring"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetEmptyStringKeyHandleResponse handles the GetEmptyStringKey response.
func (client *DictionaryClient) GetEmptyStringKeyHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetEmptyStringKeyHandleError handles the GetEmptyStringKey error response.
func (client *DictionaryClient) GetEmptyStringKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetFloatInvalidNull - Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
func (client *DictionaryClient) GetFloatInvalidNull(ctx context.Context, options *DictionaryGetFloatInvalidNullOptions) (*MapOfFloat32Response, error) {
	req, err := client.GetFloatInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetFloatInvalidNullHandleError(resp)
	}
	result, err := client.GetFloatInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetFloatInvalidNullCreateRequest creates the GetFloatInvalidNull request.
func (client *DictionaryClient) GetFloatInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetFloatInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/float/0.0-null-1.2e20"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetFloatInvalidNullHandleResponse handles the GetFloatInvalidNull response.
func (client *DictionaryClient) GetFloatInvalidNullHandleResponse(resp *azcore.Response) (*MapOfFloat32Response, error) {
	result := MapOfFloat32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetFloatInvalidNullHandleError handles the GetFloatInvalidNull error response.
func (client *DictionaryClient) GetFloatInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetFloatInvalidString - Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
func (client *DictionaryClient) GetFloatInvalidString(ctx context.Context, options *DictionaryGetFloatInvalidStringOptions) (*MapOfFloat32Response, error) {
	req, err := client.GetFloatInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetFloatInvalidStringHandleError(resp)
	}
	result, err := client.GetFloatInvalidStringHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetFloatInvalidStringCreateRequest creates the GetFloatInvalidString request.
func (client *DictionaryClient) GetFloatInvalidStringCreateRequest(ctx context.Context, options *DictionaryGetFloatInvalidStringOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/float/1.number.0"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetFloatInvalidStringHandleResponse handles the GetFloatInvalidString response.
func (client *DictionaryClient) GetFloatInvalidStringHandleResponse(resp *azcore.Response) (*MapOfFloat32Response, error) {
	result := MapOfFloat32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetFloatInvalidStringHandleError handles the GetFloatInvalidString error response.
func (client *DictionaryClient) GetFloatInvalidStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetFloatValid - Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
func (client *DictionaryClient) GetFloatValid(ctx context.Context, options *DictionaryGetFloatValidOptions) (*MapOfFloat32Response, error) {
	req, err := client.GetFloatValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetFloatValidHandleError(resp)
	}
	result, err := client.GetFloatValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetFloatValidCreateRequest creates the GetFloatValid request.
func (client *DictionaryClient) GetFloatValidCreateRequest(ctx context.Context, options *DictionaryGetFloatValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/float/0--0.01-1.2e20"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetFloatValidHandleResponse handles the GetFloatValid response.
func (client *DictionaryClient) GetFloatValidHandleResponse(resp *azcore.Response) (*MapOfFloat32Response, error) {
	result := MapOfFloat32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetFloatValidHandleError handles the GetFloatValid error response.
func (client *DictionaryClient) GetFloatValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetIntInvalidNull - Get integer dictionary value {"0": 1, "1": null, "2": 0}
func (client *DictionaryClient) GetIntInvalidNull(ctx context.Context, options *DictionaryGetIntInvalidNullOptions) (*MapOfInt32Response, error) {
	req, err := client.GetIntInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntInvalidNullHandleError(resp)
	}
	result, err := client.GetIntInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetIntInvalidNullCreateRequest creates the GetIntInvalidNull request.
func (client *DictionaryClient) GetIntInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetIntInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/integer/1.null.zero"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetIntInvalidNullHandleResponse handles the GetIntInvalidNull response.
func (client *DictionaryClient) GetIntInvalidNullHandleResponse(resp *azcore.Response) (*MapOfInt32Response, error) {
	result := MapOfInt32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetIntInvalidNullHandleError handles the GetIntInvalidNull error response.
func (client *DictionaryClient) GetIntInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetIntInvalidString - Get integer dictionary value {"0": 1, "1": "integer", "2": 0}
func (client *DictionaryClient) GetIntInvalidString(ctx context.Context, options *DictionaryGetIntInvalidStringOptions) (*MapOfInt32Response, error) {
	req, err := client.GetIntInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntInvalidStringHandleError(resp)
	}
	result, err := client.GetIntInvalidStringHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetIntInvalidStringCreateRequest creates the GetIntInvalidString request.
func (client *DictionaryClient) GetIntInvalidStringCreateRequest(ctx context.Context, options *DictionaryGetIntInvalidStringOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/integer/1.integer.0"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetIntInvalidStringHandleResponse handles the GetIntInvalidString response.
func (client *DictionaryClient) GetIntInvalidStringHandleResponse(resp *azcore.Response) (*MapOfInt32Response, error) {
	result := MapOfInt32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetIntInvalidStringHandleError handles the GetIntInvalidString error response.
func (client *DictionaryClient) GetIntInvalidStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetIntegerValid - Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
func (client *DictionaryClient) GetIntegerValid(ctx context.Context, options *DictionaryGetIntegerValidOptions) (*MapOfInt32Response, error) {
	req, err := client.GetIntegerValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetIntegerValidHandleError(resp)
	}
	result, err := client.GetIntegerValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetIntegerValidCreateRequest creates the GetIntegerValid request.
func (client *DictionaryClient) GetIntegerValidCreateRequest(ctx context.Context, options *DictionaryGetIntegerValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/integer/1.-1.3.300"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetIntegerValidHandleResponse handles the GetIntegerValid response.
func (client *DictionaryClient) GetIntegerValidHandleResponse(resp *azcore.Response) (*MapOfInt32Response, error) {
	result := MapOfInt32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetIntegerValidHandleError handles the GetIntegerValid error response.
func (client *DictionaryClient) GetIntegerValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetInvalid - Get invalid Dictionary value
func (client *DictionaryClient) GetInvalid(ctx context.Context, options *DictionaryGetInvalidOptions) (*MapOfStringResponse, error) {
	req, err := client.GetInvalidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetInvalidHandleError(resp)
	}
	result, err := client.GetInvalidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetInvalidCreateRequest creates the GetInvalid request.
func (client *DictionaryClient) GetInvalidCreateRequest(ctx context.Context, options *DictionaryGetInvalidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/invalid"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetInvalidHandleResponse handles the GetInvalid response.
func (client *DictionaryClient) GetInvalidHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetInvalidHandleError handles the GetInvalid error response.
func (client *DictionaryClient) GetInvalidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetLongInvalidNull - Get long dictionary value {"0": 1, "1": null, "2": 0}
func (client *DictionaryClient) GetLongInvalidNull(ctx context.Context, options *DictionaryGetLongInvalidNullOptions) (*MapOfInt64Response, error) {
	req, err := client.GetLongInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetLongInvalidNullHandleError(resp)
	}
	result, err := client.GetLongInvalidNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLongInvalidNullCreateRequest creates the GetLongInvalidNull request.
func (client *DictionaryClient) GetLongInvalidNullCreateRequest(ctx context.Context, options *DictionaryGetLongInvalidNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/long/1.null.zero"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLongInvalidNullHandleResponse handles the GetLongInvalidNull response.
func (client *DictionaryClient) GetLongInvalidNullHandleResponse(resp *azcore.Response) (*MapOfInt64Response, error) {
	result := MapOfInt64Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetLongInvalidNullHandleError handles the GetLongInvalidNull error response.
func (client *DictionaryClient) GetLongInvalidNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetLongInvalidString - Get long dictionary value {"0": 1, "1": "integer", "2": 0}
func (client *DictionaryClient) GetLongInvalidString(ctx context.Context, options *DictionaryGetLongInvalidStringOptions) (*MapOfInt64Response, error) {
	req, err := client.GetLongInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetLongInvalidStringHandleError(resp)
	}
	result, err := client.GetLongInvalidStringHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLongInvalidStringCreateRequest creates the GetLongInvalidString request.
func (client *DictionaryClient) GetLongInvalidStringCreateRequest(ctx context.Context, options *DictionaryGetLongInvalidStringOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/long/1.integer.0"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLongInvalidStringHandleResponse handles the GetLongInvalidString response.
func (client *DictionaryClient) GetLongInvalidStringHandleResponse(resp *azcore.Response) (*MapOfInt64Response, error) {
	result := MapOfInt64Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetLongInvalidStringHandleError handles the GetLongInvalidString error response.
func (client *DictionaryClient) GetLongInvalidStringHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetLongValid - Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
func (client *DictionaryClient) GetLongValid(ctx context.Context, options *DictionaryGetLongValidOptions) (*MapOfInt64Response, error) {
	req, err := client.GetLongValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetLongValidHandleError(resp)
	}
	result, err := client.GetLongValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetLongValidCreateRequest creates the GetLongValid request.
func (client *DictionaryClient) GetLongValidCreateRequest(ctx context.Context, options *DictionaryGetLongValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/long/1.-1.3.300"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetLongValidHandleResponse handles the GetLongValid response.
func (client *DictionaryClient) GetLongValidHandleResponse(resp *azcore.Response) (*MapOfInt64Response, error) {
	result := MapOfInt64Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetLongValidHandleError handles the GetLongValid error response.
func (client *DictionaryClient) GetLongValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetNull - Get null dictionary value
func (client *DictionaryClient) GetNull(ctx context.Context, options *DictionaryGetNullOptions) (*MapOfInt32Response, error) {
	req, err := client.GetNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNullHandleError(resp)
	}
	result, err := client.GetNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNullCreateRequest creates the GetNull request.
func (client *DictionaryClient) GetNullCreateRequest(ctx context.Context, options *DictionaryGetNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/null"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNullHandleResponse handles the GetNull response.
func (client *DictionaryClient) GetNullHandleResponse(resp *azcore.Response) (*MapOfInt32Response, error) {
	result := MapOfInt32Response{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetNullHandleError handles the GetNull error response.
func (client *DictionaryClient) GetNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetNullKey - Get Dictionary with null key
func (client *DictionaryClient) GetNullKey(ctx context.Context, options *DictionaryGetNullKeyOptions) (*MapOfStringResponse, error) {
	req, err := client.GetNullKeyCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNullKeyHandleError(resp)
	}
	result, err := client.GetNullKeyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNullKeyCreateRequest creates the GetNullKey request.
func (client *DictionaryClient) GetNullKeyCreateRequest(ctx context.Context, options *DictionaryGetNullKeyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/nullkey"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNullKeyHandleResponse handles the GetNullKey response.
func (client *DictionaryClient) GetNullKeyHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetNullKeyHandleError handles the GetNullKey error response.
func (client *DictionaryClient) GetNullKeyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetNullValue - Get Dictionary with null value
func (client *DictionaryClient) GetNullValue(ctx context.Context, options *DictionaryGetNullValueOptions) (*MapOfStringResponse, error) {
	req, err := client.GetNullValueCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNullValueHandleError(resp)
	}
	result, err := client.GetNullValueHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNullValueCreateRequest creates the GetNullValue request.
func (client *DictionaryClient) GetNullValueCreateRequest(ctx context.Context, options *DictionaryGetNullValueOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/nullvalue"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNullValueHandleResponse handles the GetNullValue response.
func (client *DictionaryClient) GetNullValueHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetNullValueHandleError handles the GetNullValue error response.
func (client *DictionaryClient) GetNullValueHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetStringValid - Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
func (client *DictionaryClient) GetStringValid(ctx context.Context, options *DictionaryGetStringValidOptions) (*MapOfStringResponse, error) {
	req, err := client.GetStringValidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetStringValidHandleError(resp)
	}
	result, err := client.GetStringValidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetStringValidCreateRequest creates the GetStringValid request.
func (client *DictionaryClient) GetStringValidCreateRequest(ctx context.Context, options *DictionaryGetStringValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/string/foo1.foo2.foo3"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetStringValidHandleResponse handles the GetStringValid response.
func (client *DictionaryClient) GetStringValidHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetStringValidHandleError handles the GetStringValid error response.
func (client *DictionaryClient) GetStringValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetStringWithInvalid - Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}
func (client *DictionaryClient) GetStringWithInvalid(ctx context.Context, options *DictionaryGetStringWithInvalidOptions) (*MapOfStringResponse, error) {
	req, err := client.GetStringWithInvalidCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetStringWithInvalidHandleError(resp)
	}
	result, err := client.GetStringWithInvalidHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetStringWithInvalidCreateRequest creates the GetStringWithInvalid request.
func (client *DictionaryClient) GetStringWithInvalidCreateRequest(ctx context.Context, options *DictionaryGetStringWithInvalidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/string/foo.123.foo2"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetStringWithInvalidHandleResponse handles the GetStringWithInvalid response.
func (client *DictionaryClient) GetStringWithInvalidHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetStringWithInvalidHandleError handles the GetStringWithInvalid error response.
func (client *DictionaryClient) GetStringWithInvalidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetStringWithNull - Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}
func (client *DictionaryClient) GetStringWithNull(ctx context.Context, options *DictionaryGetStringWithNullOptions) (*MapOfStringResponse, error) {
	req, err := client.GetStringWithNullCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetStringWithNullHandleError(resp)
	}
	result, err := client.GetStringWithNullHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetStringWithNullCreateRequest creates the GetStringWithNull request.
func (client *DictionaryClient) GetStringWithNullCreateRequest(ctx context.Context, options *DictionaryGetStringWithNullOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/string/foo.null.foo2"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetStringWithNullHandleResponse handles the GetStringWithNull response.
func (client *DictionaryClient) GetStringWithNullHandleResponse(resp *azcore.Response) (*MapOfStringResponse, error) {
	result := MapOfStringResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.Value)
}

// GetStringWithNullHandleError handles the GetStringWithNull error response.
func (client *DictionaryClient) GetStringWithNullHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutArrayValid - Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
func (client *DictionaryClient) PutArrayValid(ctx context.Context, arrayBody map[string][]string, options *DictionaryPutArrayValidOptions) (*http.Response, error) {
	req, err := client.PutArrayValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutArrayValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutArrayValidCreateRequest creates the PutArrayValid request.
func (client *DictionaryClient) PutArrayValidCreateRequest(ctx context.Context, arrayBody map[string][]string, options *DictionaryPutArrayValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/array/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutArrayValidHandleError handles the PutArrayValid error response.
func (client *DictionaryClient) PutArrayValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutBooleanTfft - Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }
func (client *DictionaryClient) PutBooleanTfft(ctx context.Context, arrayBody map[string]bool, options *DictionaryPutBooleanTfftOptions) (*http.Response, error) {
	req, err := client.PutBooleanTfftCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutBooleanTfftHandleError(resp)
	}
	return resp.Response, nil
}

// PutBooleanTfftCreateRequest creates the PutBooleanTfft request.
func (client *DictionaryClient) PutBooleanTfftCreateRequest(ctx context.Context, arrayBody map[string]bool, options *DictionaryPutBooleanTfftOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/boolean/tfft"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutBooleanTfftHandleError handles the PutBooleanTfft error response.
func (client *DictionaryClient) PutBooleanTfftHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutByteValid - Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64
func (client *DictionaryClient) PutByteValid(ctx context.Context, arrayBody map[string][]byte, options *DictionaryPutByteValidOptions) (*http.Response, error) {
	req, err := client.PutByteValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutByteValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutByteValidCreateRequest creates the PutByteValid request.
func (client *DictionaryClient) PutByteValidCreateRequest(ctx context.Context, arrayBody map[string][]byte, options *DictionaryPutByteValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/byte/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutByteValidHandleError handles the PutByteValid error response.
func (client *DictionaryClient) PutByteValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutComplexValid - Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer":
// 5, "string": "6"}}
func (client *DictionaryClient) PutComplexValid(ctx context.Context, arrayBody map[string]Widget, options *DictionaryPutComplexValidOptions) (*http.Response, error) {
	req, err := client.PutComplexValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutComplexValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutComplexValidCreateRequest creates the PutComplexValid request.
func (client *DictionaryClient) PutComplexValidCreateRequest(ctx context.Context, arrayBody map[string]Widget, options *DictionaryPutComplexValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/complex/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutComplexValidHandleError handles the PutComplexValid error response.
func (client *DictionaryClient) PutComplexValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutDateTimeRFC1123Valid - Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492
// 10:15:01 GMT"}
func (client *DictionaryClient) PutDateTimeRFC1123Valid(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateTimeRFC1123ValidOptions) (*http.Response, error) {
	req, err := client.PutDateTimeRFC1123ValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutDateTimeRFC1123ValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutDateTimeRFC1123ValidCreateRequest creates the PutDateTimeRFC1123Valid request.
func (client *DictionaryClient) PutDateTimeRFC1123ValidCreateRequest(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateTimeRFC1123ValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date-time-rfc1123/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	aux := map[string]timeRFC1123{}
	for k, v := range arrayBody {
		aux[k] = timeRFC1123(v)
	}
	return req, req.MarshalAsJSON(aux)
}

// PutDateTimeRFC1123ValidHandleError handles the PutDateTimeRFC1123Valid error response.
func (client *DictionaryClient) PutDateTimeRFC1123ValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutDateTimeValid - Set dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
func (client *DictionaryClient) PutDateTimeValid(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateTimeValidOptions) (*http.Response, error) {
	req, err := client.PutDateTimeValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutDateTimeValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutDateTimeValidCreateRequest creates the PutDateTimeValid request.
func (client *DictionaryClient) PutDateTimeValidCreateRequest(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateTimeValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date-time/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	aux := map[string]timeRFC3339{}
	for k, v := range arrayBody {
		aux[k] = timeRFC3339(v)
	}
	return req, req.MarshalAsJSON(aux)
}

// PutDateTimeValidHandleError handles the PutDateTimeValid error response.
func (client *DictionaryClient) PutDateTimeValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutDateValid - Set dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
func (client *DictionaryClient) PutDateValid(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateValidOptions) (*http.Response, error) {
	req, err := client.PutDateValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutDateValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutDateValidCreateRequest creates the PutDateValid request.
func (client *DictionaryClient) PutDateValidCreateRequest(ctx context.Context, arrayBody map[string]time.Time, options *DictionaryPutDateValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/date/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	aux := map[string]dateType{}
	for k, v := range arrayBody {
		aux[k] = dateType(v)
	}
	return req, req.MarshalAsJSON(aux)
}

// PutDateValidHandleError handles the PutDateValid error response.
func (client *DictionaryClient) PutDateValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutDictionaryValid - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five",
// "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
func (client *DictionaryClient) PutDictionaryValid(ctx context.Context, arrayBody map[string]interface{}, options *DictionaryPutDictionaryValidOptions) (*http.Response, error) {
	req, err := client.PutDictionaryValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutDictionaryValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutDictionaryValidCreateRequest creates the PutDictionaryValid request.
func (client *DictionaryClient) PutDictionaryValidCreateRequest(ctx context.Context, arrayBody map[string]interface{}, options *DictionaryPutDictionaryValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/dictionary/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutDictionaryValidHandleError handles the PutDictionaryValid error response.
func (client *DictionaryClient) PutDictionaryValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutDoubleValid - Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
func (client *DictionaryClient) PutDoubleValid(ctx context.Context, arrayBody map[string]float64, options *DictionaryPutDoubleValidOptions) (*http.Response, error) {
	req, err := client.PutDoubleValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutDoubleValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutDoubleValidCreateRequest creates the PutDoubleValid request.
func (client *DictionaryClient) PutDoubleValidCreateRequest(ctx context.Context, arrayBody map[string]float64, options *DictionaryPutDoubleValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/double/0--0.01-1.2e20"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutDoubleValidHandleError handles the PutDoubleValid error response.
func (client *DictionaryClient) PutDoubleValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutDurationValid - Set dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}
func (client *DictionaryClient) PutDurationValid(ctx context.Context, arrayBody map[string]string, options *DictionaryPutDurationValidOptions) (*http.Response, error) {
	req, err := client.PutDurationValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutDurationValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutDurationValidCreateRequest creates the PutDurationValid request.
func (client *DictionaryClient) PutDurationValidCreateRequest(ctx context.Context, arrayBody map[string]string, options *DictionaryPutDurationValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/duration/valid"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutDurationValidHandleError handles the PutDurationValid error response.
func (client *DictionaryClient) PutDurationValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutEmpty - Set dictionary value empty {}
func (client *DictionaryClient) PutEmpty(ctx context.Context, arrayBody map[string]string, options *DictionaryPutEmptyOptions) (*http.Response, error) {
	req, err := client.PutEmptyCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutEmptyHandleError(resp)
	}
	return resp.Response, nil
}

// PutEmptyCreateRequest creates the PutEmpty request.
func (client *DictionaryClient) PutEmptyCreateRequest(ctx context.Context, arrayBody map[string]string, options *DictionaryPutEmptyOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/empty"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutEmptyHandleError handles the PutEmpty error response.
func (client *DictionaryClient) PutEmptyHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutFloatValid - Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
func (client *DictionaryClient) PutFloatValid(ctx context.Context, arrayBody map[string]float32, options *DictionaryPutFloatValidOptions) (*http.Response, error) {
	req, err := client.PutFloatValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutFloatValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutFloatValidCreateRequest creates the PutFloatValid request.
func (client *DictionaryClient) PutFloatValidCreateRequest(ctx context.Context, arrayBody map[string]float32, options *DictionaryPutFloatValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/float/0--0.01-1.2e20"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutFloatValidHandleError handles the PutFloatValid error response.
func (client *DictionaryClient) PutFloatValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutIntegerValid - Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
func (client *DictionaryClient) PutIntegerValid(ctx context.Context, arrayBody map[string]int32, options *DictionaryPutIntegerValidOptions) (*http.Response, error) {
	req, err := client.PutIntegerValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutIntegerValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutIntegerValidCreateRequest creates the PutIntegerValid request.
func (client *DictionaryClient) PutIntegerValidCreateRequest(ctx context.Context, arrayBody map[string]int32, options *DictionaryPutIntegerValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/integer/1.-1.3.300"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutIntegerValidHandleError handles the PutIntegerValid error response.
func (client *DictionaryClient) PutIntegerValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutLongValid - Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
func (client *DictionaryClient) PutLongValid(ctx context.Context, arrayBody map[string]int64, options *DictionaryPutLongValidOptions) (*http.Response, error) {
	req, err := client.PutLongValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutLongValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutLongValidCreateRequest creates the PutLongValid request.
func (client *DictionaryClient) PutLongValidCreateRequest(ctx context.Context, arrayBody map[string]int64, options *DictionaryPutLongValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/long/1.-1.3.300"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutLongValidHandleError handles the PutLongValid error response.
func (client *DictionaryClient) PutLongValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutStringValid - Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
func (client *DictionaryClient) PutStringValid(ctx context.Context, arrayBody map[string]string, options *DictionaryPutStringValidOptions) (*http.Response, error) {
	req, err := client.PutStringValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.PutStringValidHandleError(resp)
	}
	return resp.Response, nil
}

// PutStringValidCreateRequest creates the PutStringValid request.
func (client *DictionaryClient) PutStringValidCreateRequest(ctx context.Context, arrayBody map[string]string, options *DictionaryPutStringValidOptions) (*azcore.Request, error) {
	urlPath := "/dictionary/prim/string/foo1.foo2.foo3"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(arrayBody)
}

// PutStringValidHandleError handles the PutStringValid error response.
func (client *DictionaryClient) PutStringValidHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsJSON(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
