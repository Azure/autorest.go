//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package dictionarygroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"time"
)

// DictionaryClient contains the methods for the Dictionary group.
// Don't use this type directly, use NewDictionaryClient() instead.
type DictionaryClient struct {
	pl runtime.Pipeline
}

// NewDictionaryClient creates a new instance of DictionaryClient with the specified values.
// options - pass nil to accept the default values.
func NewDictionaryClient(options *azcore.ClientOptions) *DictionaryClient {
	if options == nil {
		options = &azcore.ClientOptions{}
	}
	client := &DictionaryClient{
		pl: runtime.NewPipeline(moduleName, moduleVersion, runtime.PipelineOptions{}, options),
	}
	return client
}

// GetArrayEmpty - Get an empty dictionary {}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetArrayEmptyOptions contains the optional parameters for the DictionaryClient.GetArrayEmpty
// method.
func (client *DictionaryClient) GetArrayEmpty(ctx context.Context, options *DictionaryClientGetArrayEmptyOptions) (DictionaryClientGetArrayEmptyResponse, error) {
	req, err := client.getArrayEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetArrayEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetArrayEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetArrayEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getArrayEmptyHandleResponse(resp)
}

// getArrayEmptyCreateRequest creates the GetArrayEmpty request.
func (client *DictionaryClient) getArrayEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetArrayEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/array/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getArrayEmptyHandleResponse handles the GetArrayEmpty response.
func (client *DictionaryClient) getArrayEmptyHandleResponse(resp *http.Response) (DictionaryClientGetArrayEmptyResponse, error) {
	result := DictionaryClientGetArrayEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetArrayEmptyResponse{}, err
	}
	return result, nil
}

// GetArrayItemEmpty - Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetArrayItemEmptyOptions contains the optional parameters for the DictionaryClient.GetArrayItemEmpty
// method.
func (client *DictionaryClient) GetArrayItemEmpty(ctx context.Context, options *DictionaryClientGetArrayItemEmptyOptions) (DictionaryClientGetArrayItemEmptyResponse, error) {
	req, err := client.getArrayItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetArrayItemEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetArrayItemEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetArrayItemEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getArrayItemEmptyHandleResponse(resp)
}

// getArrayItemEmptyCreateRequest creates the GetArrayItemEmpty request.
func (client *DictionaryClient) getArrayItemEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetArrayItemEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/array/itemempty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getArrayItemEmptyHandleResponse handles the GetArrayItemEmpty response.
func (client *DictionaryClient) getArrayItemEmptyHandleResponse(resp *http.Response) (DictionaryClientGetArrayItemEmptyResponse, error) {
	result := DictionaryClientGetArrayItemEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetArrayItemEmptyResponse{}, err
	}
	return result, nil
}

// GetArrayItemNull - Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetArrayItemNullOptions contains the optional parameters for the DictionaryClient.GetArrayItemNull
// method.
func (client *DictionaryClient) GetArrayItemNull(ctx context.Context, options *DictionaryClientGetArrayItemNullOptions) (DictionaryClientGetArrayItemNullResponse, error) {
	req, err := client.getArrayItemNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetArrayItemNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetArrayItemNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetArrayItemNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getArrayItemNullHandleResponse(resp)
}

// getArrayItemNullCreateRequest creates the GetArrayItemNull request.
func (client *DictionaryClient) getArrayItemNullCreateRequest(ctx context.Context, options *DictionaryClientGetArrayItemNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/array/itemnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getArrayItemNullHandleResponse handles the GetArrayItemNull response.
func (client *DictionaryClient) getArrayItemNullHandleResponse(resp *http.Response) (DictionaryClientGetArrayItemNullResponse, error) {
	result := DictionaryClientGetArrayItemNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetArrayItemNullResponse{}, err
	}
	return result, nil
}

// GetArrayNull - Get a null array
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetArrayNullOptions contains the optional parameters for the DictionaryClient.GetArrayNull method.
func (client *DictionaryClient) GetArrayNull(ctx context.Context, options *DictionaryClientGetArrayNullOptions) (DictionaryClientGetArrayNullResponse, error) {
	req, err := client.getArrayNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetArrayNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetArrayNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetArrayNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getArrayNullHandleResponse(resp)
}

// getArrayNullCreateRequest creates the GetArrayNull request.
func (client *DictionaryClient) getArrayNullCreateRequest(ctx context.Context, options *DictionaryClientGetArrayNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/array/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getArrayNullHandleResponse handles the GetArrayNull response.
func (client *DictionaryClient) getArrayNullHandleResponse(resp *http.Response) (DictionaryClientGetArrayNullResponse, error) {
	result := DictionaryClientGetArrayNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetArrayNullResponse{}, err
	}
	return result, nil
}

// GetArrayValid - Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetArrayValidOptions contains the optional parameters for the DictionaryClient.GetArrayValid
// method.
func (client *DictionaryClient) GetArrayValid(ctx context.Context, options *DictionaryClientGetArrayValidOptions) (DictionaryClientGetArrayValidResponse, error) {
	req, err := client.getArrayValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetArrayValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetArrayValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetArrayValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getArrayValidHandleResponse(resp)
}

// getArrayValidCreateRequest creates the GetArrayValid request.
func (client *DictionaryClient) getArrayValidCreateRequest(ctx context.Context, options *DictionaryClientGetArrayValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/array/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getArrayValidHandleResponse handles the GetArrayValid response.
func (client *DictionaryClient) getArrayValidHandleResponse(resp *http.Response) (DictionaryClientGetArrayValidResponse, error) {
	result := DictionaryClientGetArrayValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetArrayValidResponse{}, err
	}
	return result, nil
}

// GetBase64URL - Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2":
// "Lorem ipsum"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetBase64URLOptions contains the optional parameters for the DictionaryClient.GetBase64URL method.
func (client *DictionaryClient) GetBase64URL(ctx context.Context, options *DictionaryClientGetBase64URLOptions) (DictionaryClientGetBase64URLResponse, error) {
	req, err := client.getBase64URLCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetBase64URLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetBase64URLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetBase64URLResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBase64URLHandleResponse(resp)
}

// getBase64URLCreateRequest creates the GetBase64URL request.
func (client *DictionaryClient) getBase64URLCreateRequest(ctx context.Context, options *DictionaryClientGetBase64URLOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/base64url/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBase64URLHandleResponse handles the GetBase64URL response.
func (client *DictionaryClient) getBase64URLHandleResponse(resp *http.Response) (DictionaryClientGetBase64URLResponse, error) {
	result := DictionaryClientGetBase64URLResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetBase64URLResponse{}, err
	}
	return result, nil
}

// GetBooleanInvalidNull - Get boolean dictionary value {"0": true, "1": null, "2": false }
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetBooleanInvalidNullOptions contains the optional parameters for the DictionaryClient.GetBooleanInvalidNull
// method.
func (client *DictionaryClient) GetBooleanInvalidNull(ctx context.Context, options *DictionaryClientGetBooleanInvalidNullOptions) (DictionaryClientGetBooleanInvalidNullResponse, error) {
	req, err := client.getBooleanInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetBooleanInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetBooleanInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetBooleanInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBooleanInvalidNullHandleResponse(resp)
}

// getBooleanInvalidNullCreateRequest creates the GetBooleanInvalidNull request.
func (client *DictionaryClient) getBooleanInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetBooleanInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/boolean/true.null.false"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanInvalidNullHandleResponse handles the GetBooleanInvalidNull response.
func (client *DictionaryClient) getBooleanInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetBooleanInvalidNullResponse, error) {
	result := DictionaryClientGetBooleanInvalidNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetBooleanInvalidNullResponse{}, err
	}
	return result, nil
}

// GetBooleanInvalidString - Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetBooleanInvalidStringOptions contains the optional parameters for the DictionaryClient.GetBooleanInvalidString
// method.
func (client *DictionaryClient) GetBooleanInvalidString(ctx context.Context, options *DictionaryClientGetBooleanInvalidStringOptions) (DictionaryClientGetBooleanInvalidStringResponse, error) {
	req, err := client.getBooleanInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetBooleanInvalidStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetBooleanInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetBooleanInvalidStringResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBooleanInvalidStringHandleResponse(resp)
}

// getBooleanInvalidStringCreateRequest creates the GetBooleanInvalidString request.
func (client *DictionaryClient) getBooleanInvalidStringCreateRequest(ctx context.Context, options *DictionaryClientGetBooleanInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/boolean/true.boolean.false"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanInvalidStringHandleResponse handles the GetBooleanInvalidString response.
func (client *DictionaryClient) getBooleanInvalidStringHandleResponse(resp *http.Response) (DictionaryClientGetBooleanInvalidStringResponse, error) {
	result := DictionaryClientGetBooleanInvalidStringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetBooleanInvalidStringResponse{}, err
	}
	return result, nil
}

// GetBooleanTfft - Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetBooleanTfftOptions contains the optional parameters for the DictionaryClient.GetBooleanTfft
// method.
func (client *DictionaryClient) GetBooleanTfft(ctx context.Context, options *DictionaryClientGetBooleanTfftOptions) (DictionaryClientGetBooleanTfftResponse, error) {
	req, err := client.getBooleanTfftCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetBooleanTfftResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetBooleanTfftResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetBooleanTfftResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBooleanTfftHandleResponse(resp)
}

// getBooleanTfftCreateRequest creates the GetBooleanTfft request.
func (client *DictionaryClient) getBooleanTfftCreateRequest(ctx context.Context, options *DictionaryClientGetBooleanTfftOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/boolean/tfft"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBooleanTfftHandleResponse handles the GetBooleanTfft response.
func (client *DictionaryClient) getBooleanTfftHandleResponse(resp *http.Response) (DictionaryClientGetBooleanTfftResponse, error) {
	result := DictionaryClientGetBooleanTfftResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetBooleanTfftResponse{}, err
	}
	return result, nil
}

// GetByteInvalidNull - Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetByteInvalidNullOptions contains the optional parameters for the DictionaryClient.GetByteInvalidNull
// method.
func (client *DictionaryClient) GetByteInvalidNull(ctx context.Context, options *DictionaryClientGetByteInvalidNullOptions) (DictionaryClientGetByteInvalidNullResponse, error) {
	req, err := client.getByteInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetByteInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetByteInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetByteInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getByteInvalidNullHandleResponse(resp)
}

// getByteInvalidNullCreateRequest creates the GetByteInvalidNull request.
func (client *DictionaryClient) getByteInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetByteInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/byte/invalidnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByteInvalidNullHandleResponse handles the GetByteInvalidNull response.
func (client *DictionaryClient) getByteInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetByteInvalidNullResponse, error) {
	result := DictionaryClientGetByteInvalidNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetByteInvalidNullResponse{}, err
	}
	return result, nil
}

// GetByteValid - Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item
// encoded in base64
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetByteValidOptions contains the optional parameters for the DictionaryClient.GetByteValid method.
func (client *DictionaryClient) GetByteValid(ctx context.Context, options *DictionaryClientGetByteValidOptions) (DictionaryClientGetByteValidResponse, error) {
	req, err := client.getByteValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetByteValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetByteValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetByteValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getByteValidHandleResponse(resp)
}

// getByteValidCreateRequest creates the GetByteValid request.
func (client *DictionaryClient) getByteValidCreateRequest(ctx context.Context, options *DictionaryClientGetByteValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/byte/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getByteValidHandleResponse handles the GetByteValid response.
func (client *DictionaryClient) getByteValidHandleResponse(resp *http.Response) (DictionaryClientGetByteValidResponse, error) {
	result := DictionaryClientGetByteValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetByteValidResponse{}, err
	}
	return result, nil
}

// GetComplexEmpty - Get empty dictionary of complex type {}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetComplexEmptyOptions contains the optional parameters for the DictionaryClient.GetComplexEmpty
// method.
func (client *DictionaryClient) GetComplexEmpty(ctx context.Context, options *DictionaryClientGetComplexEmptyOptions) (DictionaryClientGetComplexEmptyResponse, error) {
	req, err := client.getComplexEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetComplexEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetComplexEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetComplexEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexEmptyHandleResponse(resp)
}

// getComplexEmptyCreateRequest creates the GetComplexEmpty request.
func (client *DictionaryClient) getComplexEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetComplexEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/complex/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComplexEmptyHandleResponse handles the GetComplexEmpty response.
func (client *DictionaryClient) getComplexEmptyHandleResponse(resp *http.Response) (DictionaryClientGetComplexEmptyResponse, error) {
	result := DictionaryClientGetComplexEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetComplexEmptyResponse{}, err
	}
	return result, nil
}

// GetComplexItemEmpty - Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2":
// {"integer": 5, "string": "6"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetComplexItemEmptyOptions contains the optional parameters for the DictionaryClient.GetComplexItemEmpty
// method.
func (client *DictionaryClient) GetComplexItemEmpty(ctx context.Context, options *DictionaryClientGetComplexItemEmptyOptions) (DictionaryClientGetComplexItemEmptyResponse, error) {
	req, err := client.getComplexItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetComplexItemEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetComplexItemEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetComplexItemEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexItemEmptyHandleResponse(resp)
}

// getComplexItemEmptyCreateRequest creates the GetComplexItemEmpty request.
func (client *DictionaryClient) getComplexItemEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetComplexItemEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/complex/itemempty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComplexItemEmptyHandleResponse handles the GetComplexItemEmpty response.
func (client *DictionaryClient) getComplexItemEmptyHandleResponse(resp *http.Response) (DictionaryClientGetComplexItemEmptyResponse, error) {
	result := DictionaryClientGetComplexItemEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetComplexItemEmptyResponse{}, err
	}
	return result, nil
}

// GetComplexItemNull - Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2":
// {"integer": 5, "string": "6"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetComplexItemNullOptions contains the optional parameters for the DictionaryClient.GetComplexItemNull
// method.
func (client *DictionaryClient) GetComplexItemNull(ctx context.Context, options *DictionaryClientGetComplexItemNullOptions) (DictionaryClientGetComplexItemNullResponse, error) {
	req, err := client.getComplexItemNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetComplexItemNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetComplexItemNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetComplexItemNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexItemNullHandleResponse(resp)
}

// getComplexItemNullCreateRequest creates the GetComplexItemNull request.
func (client *DictionaryClient) getComplexItemNullCreateRequest(ctx context.Context, options *DictionaryClientGetComplexItemNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/complex/itemnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComplexItemNullHandleResponse handles the GetComplexItemNull response.
func (client *DictionaryClient) getComplexItemNullHandleResponse(resp *http.Response) (DictionaryClientGetComplexItemNullResponse, error) {
	result := DictionaryClientGetComplexItemNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetComplexItemNullResponse{}, err
	}
	return result, nil
}

// GetComplexNull - Get dictionary of complex type null value
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetComplexNullOptions contains the optional parameters for the DictionaryClient.GetComplexNull
// method.
func (client *DictionaryClient) GetComplexNull(ctx context.Context, options *DictionaryClientGetComplexNullOptions) (DictionaryClientGetComplexNullResponse, error) {
	req, err := client.getComplexNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetComplexNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetComplexNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetComplexNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexNullHandleResponse(resp)
}

// getComplexNullCreateRequest creates the GetComplexNull request.
func (client *DictionaryClient) getComplexNullCreateRequest(ctx context.Context, options *DictionaryClientGetComplexNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/complex/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComplexNullHandleResponse handles the GetComplexNull response.
func (client *DictionaryClient) getComplexNullHandleResponse(resp *http.Response) (DictionaryClientGetComplexNullResponse, error) {
	result := DictionaryClientGetComplexNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetComplexNullResponse{}, err
	}
	return result, nil
}

// GetComplexValid - Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string":
// "4"}, "2": {"integer": 5, "string": "6"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetComplexValidOptions contains the optional parameters for the DictionaryClient.GetComplexValid
// method.
func (client *DictionaryClient) GetComplexValid(ctx context.Context, options *DictionaryClientGetComplexValidOptions) (DictionaryClientGetComplexValidResponse, error) {
	req, err := client.getComplexValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetComplexValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetComplexValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetComplexValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexValidHandleResponse(resp)
}

// getComplexValidCreateRequest creates the GetComplexValid request.
func (client *DictionaryClient) getComplexValidCreateRequest(ctx context.Context, options *DictionaryClientGetComplexValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/complex/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComplexValidHandleResponse handles the GetComplexValid response.
func (client *DictionaryClient) getComplexValidHandleResponse(resp *http.Response) (DictionaryClientGetComplexValidResponse, error) {
	result := DictionaryClientGetComplexValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetComplexValidResponse{}, err
	}
	return result, nil
}

// GetDateInvalidChars - Get date dictionary value {"0": "2011-03-22", "1": "date"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateInvalidCharsOptions contains the optional parameters for the DictionaryClient.GetDateInvalidChars
// method.
func (client *DictionaryClient) GetDateInvalidChars(ctx context.Context, options *DictionaryClientGetDateInvalidCharsOptions) (DictionaryClientGetDateInvalidCharsResponse, error) {
	req, err := client.getDateInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateInvalidCharsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateInvalidCharsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateInvalidCharsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateInvalidCharsHandleResponse(resp)
}

// getDateInvalidCharsCreateRequest creates the GetDateInvalidChars request.
func (client *DictionaryClient) getDateInvalidCharsCreateRequest(ctx context.Context, options *DictionaryClientGetDateInvalidCharsOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date/invalidchars"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateInvalidCharsHandleResponse handles the GetDateInvalidChars response.
func (client *DictionaryClient) getDateInvalidCharsHandleResponse(resp *http.Response) (DictionaryClientGetDateInvalidCharsResponse, error) {
	result := DictionaryClientGetDateInvalidCharsResponse{RawResponse: resp}
	aux := map[string]*dateType{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateInvalidCharsResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDateInvalidNull - Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateInvalidNullOptions contains the optional parameters for the DictionaryClient.GetDateInvalidNull
// method.
func (client *DictionaryClient) GetDateInvalidNull(ctx context.Context, options *DictionaryClientGetDateInvalidNullOptions) (DictionaryClientGetDateInvalidNullResponse, error) {
	req, err := client.getDateInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateInvalidNullHandleResponse(resp)
}

// getDateInvalidNullCreateRequest creates the GetDateInvalidNull request.
func (client *DictionaryClient) getDateInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetDateInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date/invalidnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateInvalidNullHandleResponse handles the GetDateInvalidNull response.
func (client *DictionaryClient) getDateInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetDateInvalidNullResponse, error) {
	result := DictionaryClientGetDateInvalidNullResponse{RawResponse: resp}
	aux := map[string]*dateType{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateInvalidNullResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDateTimeInvalidChars - Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateTimeInvalidCharsOptions contains the optional parameters for the DictionaryClient.GetDateTimeInvalidChars
// method.
func (client *DictionaryClient) GetDateTimeInvalidChars(ctx context.Context, options *DictionaryClientGetDateTimeInvalidCharsOptions) (DictionaryClientGetDateTimeInvalidCharsResponse, error) {
	req, err := client.getDateTimeInvalidCharsCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateTimeInvalidCharsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateTimeInvalidCharsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateTimeInvalidCharsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateTimeInvalidCharsHandleResponse(resp)
}

// getDateTimeInvalidCharsCreateRequest creates the GetDateTimeInvalidChars request.
func (client *DictionaryClient) getDateTimeInvalidCharsCreateRequest(ctx context.Context, options *DictionaryClientGetDateTimeInvalidCharsOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date-time/invalidchars"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateTimeInvalidCharsHandleResponse handles the GetDateTimeInvalidChars response.
func (client *DictionaryClient) getDateTimeInvalidCharsHandleResponse(resp *http.Response) (DictionaryClientGetDateTimeInvalidCharsResponse, error) {
	result := DictionaryClientGetDateTimeInvalidCharsResponse{RawResponse: resp}
	aux := map[string]*timeRFC3339{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateTimeInvalidCharsResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDateTimeInvalidNull - Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateTimeInvalidNullOptions contains the optional parameters for the DictionaryClient.GetDateTimeInvalidNull
// method.
func (client *DictionaryClient) GetDateTimeInvalidNull(ctx context.Context, options *DictionaryClientGetDateTimeInvalidNullOptions) (DictionaryClientGetDateTimeInvalidNullResponse, error) {
	req, err := client.getDateTimeInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateTimeInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateTimeInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateTimeInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateTimeInvalidNullHandleResponse(resp)
}

// getDateTimeInvalidNullCreateRequest creates the GetDateTimeInvalidNull request.
func (client *DictionaryClient) getDateTimeInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetDateTimeInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date-time/invalidnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateTimeInvalidNullHandleResponse handles the GetDateTimeInvalidNull response.
func (client *DictionaryClient) getDateTimeInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetDateTimeInvalidNullResponse, error) {
	result := DictionaryClientGetDateTimeInvalidNullResponse{RawResponse: resp}
	aux := map[string]*timeRFC3339{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateTimeInvalidNullResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDateTimeRFC1123Valid - Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan
// 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateTimeRFC1123ValidOptions contains the optional parameters for the DictionaryClient.GetDateTimeRFC1123Valid
// method.
func (client *DictionaryClient) GetDateTimeRFC1123Valid(ctx context.Context, options *DictionaryClientGetDateTimeRFC1123ValidOptions) (DictionaryClientGetDateTimeRFC1123ValidResponse, error) {
	req, err := client.getDateTimeRFC1123ValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateTimeRFC1123ValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateTimeRFC1123ValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateTimeRFC1123ValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateTimeRFC1123ValidHandleResponse(resp)
}

// getDateTimeRFC1123ValidCreateRequest creates the GetDateTimeRFC1123Valid request.
func (client *DictionaryClient) getDateTimeRFC1123ValidCreateRequest(ctx context.Context, options *DictionaryClientGetDateTimeRFC1123ValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date-time-rfc1123/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateTimeRFC1123ValidHandleResponse handles the GetDateTimeRFC1123Valid response.
func (client *DictionaryClient) getDateTimeRFC1123ValidHandleResponse(resp *http.Response) (DictionaryClientGetDateTimeRFC1123ValidResponse, error) {
	result := DictionaryClientGetDateTimeRFC1123ValidResponse{RawResponse: resp}
	aux := map[string]*timeRFC1123{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateTimeRFC1123ValidResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDateTimeValid - Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2":
// "1492-10-12T10:15:01-08:00"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateTimeValidOptions contains the optional parameters for the DictionaryClient.GetDateTimeValid
// method.
func (client *DictionaryClient) GetDateTimeValid(ctx context.Context, options *DictionaryClientGetDateTimeValidOptions) (DictionaryClientGetDateTimeValidResponse, error) {
	req, err := client.getDateTimeValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateTimeValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateTimeValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateTimeValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateTimeValidHandleResponse(resp)
}

// getDateTimeValidCreateRequest creates the GetDateTimeValid request.
func (client *DictionaryClient) getDateTimeValidCreateRequest(ctx context.Context, options *DictionaryClientGetDateTimeValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date-time/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateTimeValidHandleResponse handles the GetDateTimeValid response.
func (client *DictionaryClient) getDateTimeValidHandleResponse(resp *http.Response) (DictionaryClientGetDateTimeValidResponse, error) {
	result := DictionaryClientGetDateTimeValidResponse{RawResponse: resp}
	aux := map[string]*timeRFC3339{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateTimeValidResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDateValid - Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDateValidOptions contains the optional parameters for the DictionaryClient.GetDateValid method.
func (client *DictionaryClient) GetDateValid(ctx context.Context, options *DictionaryClientGetDateValidOptions) (DictionaryClientGetDateValidResponse, error) {
	req, err := client.getDateValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDateValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDateValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDateValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDateValidHandleResponse(resp)
}

// getDateValidCreateRequest creates the GetDateValid request.
func (client *DictionaryClient) getDateValidCreateRequest(ctx context.Context, options *DictionaryClientGetDateValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDateValidHandleResponse handles the GetDateValid response.
func (client *DictionaryClient) getDateValidHandleResponse(resp *http.Response) (DictionaryClientGetDateValidResponse, error) {
	result := DictionaryClientGetDateValidResponse{RawResponse: resp}
	aux := map[string]*dateType{}
	if err := runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return DictionaryClientGetDateValidResponse{}, err
	}
	cp := map[string]*time.Time{}
	for k, v := range aux {
		cp[k] = (*time.Time)(v)
	}
	result.Value = cp
	return result, nil
}

// GetDictionaryEmpty - Get an dictionaries of dictionaries of type with value {}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDictionaryEmptyOptions contains the optional parameters for the DictionaryClient.GetDictionaryEmpty
// method.
func (client *DictionaryClient) GetDictionaryEmpty(ctx context.Context, options *DictionaryClientGetDictionaryEmptyOptions) (DictionaryClientGetDictionaryEmptyResponse, error) {
	req, err := client.getDictionaryEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDictionaryEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDictionaryEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDictionaryEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDictionaryEmptyHandleResponse(resp)
}

// getDictionaryEmptyCreateRequest creates the GetDictionaryEmpty request.
func (client *DictionaryClient) getDictionaryEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetDictionaryEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/dictionary/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDictionaryEmptyHandleResponse handles the GetDictionaryEmpty response.
func (client *DictionaryClient) getDictionaryEmptyHandleResponse(resp *http.Response) (DictionaryClientGetDictionaryEmptyResponse, error) {
	result := DictionaryClientGetDictionaryEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDictionaryEmptyResponse{}, err
	}
	return result, nil
}

// GetDictionaryItemEmpty - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"},
// "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDictionaryItemEmptyOptions contains the optional parameters for the DictionaryClient.GetDictionaryItemEmpty
// method.
func (client *DictionaryClient) GetDictionaryItemEmpty(ctx context.Context, options *DictionaryClientGetDictionaryItemEmptyOptions) (DictionaryClientGetDictionaryItemEmptyResponse, error) {
	req, err := client.getDictionaryItemEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDictionaryItemEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDictionaryItemEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDictionaryItemEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDictionaryItemEmptyHandleResponse(resp)
}

// getDictionaryItemEmptyCreateRequest creates the GetDictionaryItemEmpty request.
func (client *DictionaryClient) getDictionaryItemEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetDictionaryItemEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/dictionary/itemempty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDictionaryItemEmptyHandleResponse handles the GetDictionaryItemEmpty response.
func (client *DictionaryClient) getDictionaryItemEmptyHandleResponse(resp *http.Response) (DictionaryClientGetDictionaryItemEmptyResponse, error) {
	result := DictionaryClientGetDictionaryItemEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDictionaryItemEmptyResponse{}, err
	}
	return result, nil
}

// GetDictionaryItemNull - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"},
// "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDictionaryItemNullOptions contains the optional parameters for the DictionaryClient.GetDictionaryItemNull
// method.
func (client *DictionaryClient) GetDictionaryItemNull(ctx context.Context, options *DictionaryClientGetDictionaryItemNullOptions) (DictionaryClientGetDictionaryItemNullResponse, error) {
	req, err := client.getDictionaryItemNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDictionaryItemNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDictionaryItemNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDictionaryItemNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDictionaryItemNullHandleResponse(resp)
}

// getDictionaryItemNullCreateRequest creates the GetDictionaryItemNull request.
func (client *DictionaryClient) getDictionaryItemNullCreateRequest(ctx context.Context, options *DictionaryClientGetDictionaryItemNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/dictionary/itemnull"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDictionaryItemNullHandleResponse handles the GetDictionaryItemNull response.
func (client *DictionaryClient) getDictionaryItemNullHandleResponse(resp *http.Response) (DictionaryClientGetDictionaryItemNullResponse, error) {
	result := DictionaryClientGetDictionaryItemNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDictionaryItemNullResponse{}, err
	}
	return result, nil
}

// GetDictionaryNull - Get an dictionaries of dictionaries with value null
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDictionaryNullOptions contains the optional parameters for the DictionaryClient.GetDictionaryNull
// method.
func (client *DictionaryClient) GetDictionaryNull(ctx context.Context, options *DictionaryClientGetDictionaryNullOptions) (DictionaryClientGetDictionaryNullResponse, error) {
	req, err := client.getDictionaryNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDictionaryNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDictionaryNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDictionaryNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDictionaryNullHandleResponse(resp)
}

// getDictionaryNullCreateRequest creates the GetDictionaryNull request.
func (client *DictionaryClient) getDictionaryNullCreateRequest(ctx context.Context, options *DictionaryClientGetDictionaryNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/dictionary/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDictionaryNullHandleResponse handles the GetDictionaryNull response.
func (client *DictionaryClient) getDictionaryNullHandleResponse(resp *http.Response) (DictionaryClientGetDictionaryNullResponse, error) {
	result := DictionaryClientGetDictionaryNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDictionaryNullResponse{}, err
	}
	return result, nil
}

// GetDictionaryValid - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"},
// "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDictionaryValidOptions contains the optional parameters for the DictionaryClient.GetDictionaryValid
// method.
func (client *DictionaryClient) GetDictionaryValid(ctx context.Context, options *DictionaryClientGetDictionaryValidOptions) (DictionaryClientGetDictionaryValidResponse, error) {
	req, err := client.getDictionaryValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDictionaryValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDictionaryValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDictionaryValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDictionaryValidHandleResponse(resp)
}

// getDictionaryValidCreateRequest creates the GetDictionaryValid request.
func (client *DictionaryClient) getDictionaryValidCreateRequest(ctx context.Context, options *DictionaryClientGetDictionaryValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/dictionary/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDictionaryValidHandleResponse handles the GetDictionaryValid response.
func (client *DictionaryClient) getDictionaryValidHandleResponse(resp *http.Response) (DictionaryClientGetDictionaryValidResponse, error) {
	result := DictionaryClientGetDictionaryValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDictionaryValidResponse{}, err
	}
	return result, nil
}

// GetDoubleInvalidNull - Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDoubleInvalidNullOptions contains the optional parameters for the DictionaryClient.GetDoubleInvalidNull
// method.
func (client *DictionaryClient) GetDoubleInvalidNull(ctx context.Context, options *DictionaryClientGetDoubleInvalidNullOptions) (DictionaryClientGetDoubleInvalidNullResponse, error) {
	req, err := client.getDoubleInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDoubleInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDoubleInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDoubleInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDoubleInvalidNullHandleResponse(resp)
}

// getDoubleInvalidNullCreateRequest creates the GetDoubleInvalidNull request.
func (client *DictionaryClient) getDoubleInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetDoubleInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/double/0.0-null-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDoubleInvalidNullHandleResponse handles the GetDoubleInvalidNull response.
func (client *DictionaryClient) getDoubleInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetDoubleInvalidNullResponse, error) {
	result := DictionaryClientGetDoubleInvalidNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDoubleInvalidNullResponse{}, err
	}
	return result, nil
}

// GetDoubleInvalidString - Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDoubleInvalidStringOptions contains the optional parameters for the DictionaryClient.GetDoubleInvalidString
// method.
func (client *DictionaryClient) GetDoubleInvalidString(ctx context.Context, options *DictionaryClientGetDoubleInvalidStringOptions) (DictionaryClientGetDoubleInvalidStringResponse, error) {
	req, err := client.getDoubleInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDoubleInvalidStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDoubleInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDoubleInvalidStringResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDoubleInvalidStringHandleResponse(resp)
}

// getDoubleInvalidStringCreateRequest creates the GetDoubleInvalidString request.
func (client *DictionaryClient) getDoubleInvalidStringCreateRequest(ctx context.Context, options *DictionaryClientGetDoubleInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/double/1.number.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDoubleInvalidStringHandleResponse handles the GetDoubleInvalidString response.
func (client *DictionaryClient) getDoubleInvalidStringHandleResponse(resp *http.Response) (DictionaryClientGetDoubleInvalidStringResponse, error) {
	result := DictionaryClientGetDoubleInvalidStringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDoubleInvalidStringResponse{}, err
	}
	return result, nil
}

// GetDoubleValid - Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDoubleValidOptions contains the optional parameters for the DictionaryClient.GetDoubleValid
// method.
func (client *DictionaryClient) GetDoubleValid(ctx context.Context, options *DictionaryClientGetDoubleValidOptions) (DictionaryClientGetDoubleValidResponse, error) {
	req, err := client.getDoubleValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDoubleValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDoubleValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDoubleValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDoubleValidHandleResponse(resp)
}

// getDoubleValidCreateRequest creates the GetDoubleValid request.
func (client *DictionaryClient) getDoubleValidCreateRequest(ctx context.Context, options *DictionaryClientGetDoubleValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/double/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDoubleValidHandleResponse handles the GetDoubleValid response.
func (client *DictionaryClient) getDoubleValidHandleResponse(resp *http.Response) (DictionaryClientGetDoubleValidResponse, error) {
	result := DictionaryClientGetDoubleValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDoubleValidResponse{}, err
	}
	return result, nil
}

// GetDurationValid - Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetDurationValidOptions contains the optional parameters for the DictionaryClient.GetDurationValid
// method.
func (client *DictionaryClient) GetDurationValid(ctx context.Context, options *DictionaryClientGetDurationValidOptions) (DictionaryClientGetDurationValidResponse, error) {
	req, err := client.getDurationValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetDurationValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetDurationValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetDurationValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDurationValidHandleResponse(resp)
}

// getDurationValidCreateRequest creates the GetDurationValid request.
func (client *DictionaryClient) getDurationValidCreateRequest(ctx context.Context, options *DictionaryClientGetDurationValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/duration/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDurationValidHandleResponse handles the GetDurationValid response.
func (client *DictionaryClient) getDurationValidHandleResponse(resp *http.Response) (DictionaryClientGetDurationValidResponse, error) {
	result := DictionaryClientGetDurationValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetDurationValidResponse{}, err
	}
	return result, nil
}

// GetEmpty - Get empty dictionary value {}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetEmptyOptions contains the optional parameters for the DictionaryClient.GetEmpty method.
func (client *DictionaryClient) GetEmpty(ctx context.Context, options *DictionaryClientGetEmptyOptions) (DictionaryClientGetEmptyResponse, error) {
	req, err := client.getEmptyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEmptyHandleResponse(resp)
}

// getEmptyCreateRequest creates the GetEmpty request.
func (client *DictionaryClient) getEmptyCreateRequest(ctx context.Context, options *DictionaryClientGetEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/empty"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getEmptyHandleResponse handles the GetEmpty response.
func (client *DictionaryClient) getEmptyHandleResponse(resp *http.Response) (DictionaryClientGetEmptyResponse, error) {
	result := DictionaryClientGetEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetEmptyResponse{}, err
	}
	return result, nil
}

// GetEmptyStringKey - Get Dictionary with key as empty string
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetEmptyStringKeyOptions contains the optional parameters for the DictionaryClient.GetEmptyStringKey
// method.
func (client *DictionaryClient) GetEmptyStringKey(ctx context.Context, options *DictionaryClientGetEmptyStringKeyOptions) (DictionaryClientGetEmptyStringKeyResponse, error) {
	req, err := client.getEmptyStringKeyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetEmptyStringKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetEmptyStringKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetEmptyStringKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEmptyStringKeyHandleResponse(resp)
}

// getEmptyStringKeyCreateRequest creates the GetEmptyStringKey request.
func (client *DictionaryClient) getEmptyStringKeyCreateRequest(ctx context.Context, options *DictionaryClientGetEmptyStringKeyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/keyemptystring"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getEmptyStringKeyHandleResponse handles the GetEmptyStringKey response.
func (client *DictionaryClient) getEmptyStringKeyHandleResponse(resp *http.Response) (DictionaryClientGetEmptyStringKeyResponse, error) {
	result := DictionaryClientGetEmptyStringKeyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetEmptyStringKeyResponse{}, err
	}
	return result, nil
}

// GetFloatInvalidNull - Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetFloatInvalidNullOptions contains the optional parameters for the DictionaryClient.GetFloatInvalidNull
// method.
func (client *DictionaryClient) GetFloatInvalidNull(ctx context.Context, options *DictionaryClientGetFloatInvalidNullOptions) (DictionaryClientGetFloatInvalidNullResponse, error) {
	req, err := client.getFloatInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetFloatInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetFloatInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetFloatInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFloatInvalidNullHandleResponse(resp)
}

// getFloatInvalidNullCreateRequest creates the GetFloatInvalidNull request.
func (client *DictionaryClient) getFloatInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetFloatInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/float/0.0-null-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFloatInvalidNullHandleResponse handles the GetFloatInvalidNull response.
func (client *DictionaryClient) getFloatInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetFloatInvalidNullResponse, error) {
	result := DictionaryClientGetFloatInvalidNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetFloatInvalidNullResponse{}, err
	}
	return result, nil
}

// GetFloatInvalidString - Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetFloatInvalidStringOptions contains the optional parameters for the DictionaryClient.GetFloatInvalidString
// method.
func (client *DictionaryClient) GetFloatInvalidString(ctx context.Context, options *DictionaryClientGetFloatInvalidStringOptions) (DictionaryClientGetFloatInvalidStringResponse, error) {
	req, err := client.getFloatInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetFloatInvalidStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetFloatInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetFloatInvalidStringResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFloatInvalidStringHandleResponse(resp)
}

// getFloatInvalidStringCreateRequest creates the GetFloatInvalidString request.
func (client *DictionaryClient) getFloatInvalidStringCreateRequest(ctx context.Context, options *DictionaryClientGetFloatInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/float/1.number.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFloatInvalidStringHandleResponse handles the GetFloatInvalidString response.
func (client *DictionaryClient) getFloatInvalidStringHandleResponse(resp *http.Response) (DictionaryClientGetFloatInvalidStringResponse, error) {
	result := DictionaryClientGetFloatInvalidStringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetFloatInvalidStringResponse{}, err
	}
	return result, nil
}

// GetFloatValid - Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetFloatValidOptions contains the optional parameters for the DictionaryClient.GetFloatValid
// method.
func (client *DictionaryClient) GetFloatValid(ctx context.Context, options *DictionaryClientGetFloatValidOptions) (DictionaryClientGetFloatValidResponse, error) {
	req, err := client.getFloatValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetFloatValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetFloatValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetFloatValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getFloatValidHandleResponse(resp)
}

// getFloatValidCreateRequest creates the GetFloatValid request.
func (client *DictionaryClient) getFloatValidCreateRequest(ctx context.Context, options *DictionaryClientGetFloatValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/float/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFloatValidHandleResponse handles the GetFloatValid response.
func (client *DictionaryClient) getFloatValidHandleResponse(resp *http.Response) (DictionaryClientGetFloatValidResponse, error) {
	result := DictionaryClientGetFloatValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetFloatValidResponse{}, err
	}
	return result, nil
}

// GetIntInvalidNull - Get integer dictionary value {"0": 1, "1": null, "2": 0}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetIntInvalidNullOptions contains the optional parameters for the DictionaryClient.GetIntInvalidNull
// method.
func (client *DictionaryClient) GetIntInvalidNull(ctx context.Context, options *DictionaryClientGetIntInvalidNullOptions) (DictionaryClientGetIntInvalidNullResponse, error) {
	req, err := client.getIntInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetIntInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetIntInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetIntInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getIntInvalidNullHandleResponse(resp)
}

// getIntInvalidNullCreateRequest creates the GetIntInvalidNull request.
func (client *DictionaryClient) getIntInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetIntInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/integer/1.null.zero"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntInvalidNullHandleResponse handles the GetIntInvalidNull response.
func (client *DictionaryClient) getIntInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetIntInvalidNullResponse, error) {
	result := DictionaryClientGetIntInvalidNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetIntInvalidNullResponse{}, err
	}
	return result, nil
}

// GetIntInvalidString - Get integer dictionary value {"0": 1, "1": "integer", "2": 0}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetIntInvalidStringOptions contains the optional parameters for the DictionaryClient.GetIntInvalidString
// method.
func (client *DictionaryClient) GetIntInvalidString(ctx context.Context, options *DictionaryClientGetIntInvalidStringOptions) (DictionaryClientGetIntInvalidStringResponse, error) {
	req, err := client.getIntInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetIntInvalidStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetIntInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetIntInvalidStringResponse{}, runtime.NewResponseError(resp)
	}
	return client.getIntInvalidStringHandleResponse(resp)
}

// getIntInvalidStringCreateRequest creates the GetIntInvalidString request.
func (client *DictionaryClient) getIntInvalidStringCreateRequest(ctx context.Context, options *DictionaryClientGetIntInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/integer/1.integer.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntInvalidStringHandleResponse handles the GetIntInvalidString response.
func (client *DictionaryClient) getIntInvalidStringHandleResponse(resp *http.Response) (DictionaryClientGetIntInvalidStringResponse, error) {
	result := DictionaryClientGetIntInvalidStringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetIntInvalidStringResponse{}, err
	}
	return result, nil
}

// GetIntegerValid - Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetIntegerValidOptions contains the optional parameters for the DictionaryClient.GetIntegerValid
// method.
func (client *DictionaryClient) GetIntegerValid(ctx context.Context, options *DictionaryClientGetIntegerValidOptions) (DictionaryClientGetIntegerValidResponse, error) {
	req, err := client.getIntegerValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetIntegerValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetIntegerValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetIntegerValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getIntegerValidHandleResponse(resp)
}

// getIntegerValidCreateRequest creates the GetIntegerValid request.
func (client *DictionaryClient) getIntegerValidCreateRequest(ctx context.Context, options *DictionaryClientGetIntegerValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/integer/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getIntegerValidHandleResponse handles the GetIntegerValid response.
func (client *DictionaryClient) getIntegerValidHandleResponse(resp *http.Response) (DictionaryClientGetIntegerValidResponse, error) {
	result := DictionaryClientGetIntegerValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetIntegerValidResponse{}, err
	}
	return result, nil
}

// GetInvalid - Get invalid Dictionary value
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetInvalidOptions contains the optional parameters for the DictionaryClient.GetInvalid method.
func (client *DictionaryClient) GetInvalid(ctx context.Context, options *DictionaryClientGetInvalidOptions) (DictionaryClientGetInvalidResponse, error) {
	req, err := client.getInvalidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetInvalidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetInvalidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetInvalidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInvalidHandleResponse(resp)
}

// getInvalidCreateRequest creates the GetInvalid request.
func (client *DictionaryClient) getInvalidCreateRequest(ctx context.Context, options *DictionaryClientGetInvalidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/invalid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInvalidHandleResponse handles the GetInvalid response.
func (client *DictionaryClient) getInvalidHandleResponse(resp *http.Response) (DictionaryClientGetInvalidResponse, error) {
	result := DictionaryClientGetInvalidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetInvalidResponse{}, err
	}
	return result, nil
}

// GetLongInvalidNull - Get long dictionary value {"0": 1, "1": null, "2": 0}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetLongInvalidNullOptions contains the optional parameters for the DictionaryClient.GetLongInvalidNull
// method.
func (client *DictionaryClient) GetLongInvalidNull(ctx context.Context, options *DictionaryClientGetLongInvalidNullOptions) (DictionaryClientGetLongInvalidNullResponse, error) {
	req, err := client.getLongInvalidNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetLongInvalidNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetLongInvalidNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetLongInvalidNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLongInvalidNullHandleResponse(resp)
}

// getLongInvalidNullCreateRequest creates the GetLongInvalidNull request.
func (client *DictionaryClient) getLongInvalidNullCreateRequest(ctx context.Context, options *DictionaryClientGetLongInvalidNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/long/1.null.zero"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getLongInvalidNullHandleResponse handles the GetLongInvalidNull response.
func (client *DictionaryClient) getLongInvalidNullHandleResponse(resp *http.Response) (DictionaryClientGetLongInvalidNullResponse, error) {
	result := DictionaryClientGetLongInvalidNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetLongInvalidNullResponse{}, err
	}
	return result, nil
}

// GetLongInvalidString - Get long dictionary value {"0": 1, "1": "integer", "2": 0}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetLongInvalidStringOptions contains the optional parameters for the DictionaryClient.GetLongInvalidString
// method.
func (client *DictionaryClient) GetLongInvalidString(ctx context.Context, options *DictionaryClientGetLongInvalidStringOptions) (DictionaryClientGetLongInvalidStringResponse, error) {
	req, err := client.getLongInvalidStringCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetLongInvalidStringResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetLongInvalidStringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetLongInvalidStringResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLongInvalidStringHandleResponse(resp)
}

// getLongInvalidStringCreateRequest creates the GetLongInvalidString request.
func (client *DictionaryClient) getLongInvalidStringCreateRequest(ctx context.Context, options *DictionaryClientGetLongInvalidStringOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/long/1.integer.0"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getLongInvalidStringHandleResponse handles the GetLongInvalidString response.
func (client *DictionaryClient) getLongInvalidStringHandleResponse(resp *http.Response) (DictionaryClientGetLongInvalidStringResponse, error) {
	result := DictionaryClientGetLongInvalidStringResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetLongInvalidStringResponse{}, err
	}
	return result, nil
}

// GetLongValid - Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetLongValidOptions contains the optional parameters for the DictionaryClient.GetLongValid method.
func (client *DictionaryClient) GetLongValid(ctx context.Context, options *DictionaryClientGetLongValidOptions) (DictionaryClientGetLongValidResponse, error) {
	req, err := client.getLongValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetLongValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetLongValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetLongValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getLongValidHandleResponse(resp)
}

// getLongValidCreateRequest creates the GetLongValid request.
func (client *DictionaryClient) getLongValidCreateRequest(ctx context.Context, options *DictionaryClientGetLongValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/long/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getLongValidHandleResponse handles the GetLongValid response.
func (client *DictionaryClient) getLongValidHandleResponse(resp *http.Response) (DictionaryClientGetLongValidResponse, error) {
	result := DictionaryClientGetLongValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetLongValidResponse{}, err
	}
	return result, nil
}

// GetNull - Get null dictionary value
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetNullOptions contains the optional parameters for the DictionaryClient.GetNull method.
func (client *DictionaryClient) GetNull(ctx context.Context, options *DictionaryClientGetNullOptions) (DictionaryClientGetNullResponse, error) {
	req, err := client.getNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNullHandleResponse(resp)
}

// getNullCreateRequest creates the GetNull request.
func (client *DictionaryClient) getNullCreateRequest(ctx context.Context, options *DictionaryClientGetNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNullHandleResponse handles the GetNull response.
func (client *DictionaryClient) getNullHandleResponse(resp *http.Response) (DictionaryClientGetNullResponse, error) {
	result := DictionaryClientGetNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetNullResponse{}, err
	}
	return result, nil
}

// GetNullKey - Get Dictionary with null key
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetNullKeyOptions contains the optional parameters for the DictionaryClient.GetNullKey method.
func (client *DictionaryClient) GetNullKey(ctx context.Context, options *DictionaryClientGetNullKeyOptions) (DictionaryClientGetNullKeyResponse, error) {
	req, err := client.getNullKeyCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetNullKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetNullKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetNullKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNullKeyHandleResponse(resp)
}

// getNullKeyCreateRequest creates the GetNullKey request.
func (client *DictionaryClient) getNullKeyCreateRequest(ctx context.Context, options *DictionaryClientGetNullKeyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/nullkey"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNullKeyHandleResponse handles the GetNullKey response.
func (client *DictionaryClient) getNullKeyHandleResponse(resp *http.Response) (DictionaryClientGetNullKeyResponse, error) {
	result := DictionaryClientGetNullKeyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetNullKeyResponse{}, err
	}
	return result, nil
}

// GetNullValue - Get Dictionary with null value
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetNullValueOptions contains the optional parameters for the DictionaryClient.GetNullValue method.
func (client *DictionaryClient) GetNullValue(ctx context.Context, options *DictionaryClientGetNullValueOptions) (DictionaryClientGetNullValueResponse, error) {
	req, err := client.getNullValueCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetNullValueResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetNullValueResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetNullValueResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNullValueHandleResponse(resp)
}

// getNullValueCreateRequest creates the GetNullValue request.
func (client *DictionaryClient) getNullValueCreateRequest(ctx context.Context, options *DictionaryClientGetNullValueOptions) (*policy.Request, error) {
	urlPath := "/dictionary/nullvalue"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNullValueHandleResponse handles the GetNullValue response.
func (client *DictionaryClient) getNullValueHandleResponse(resp *http.Response) (DictionaryClientGetNullValueResponse, error) {
	result := DictionaryClientGetNullValueResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetNullValueResponse{}, err
	}
	return result, nil
}

// GetStringValid - Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetStringValidOptions contains the optional parameters for the DictionaryClient.GetStringValid
// method.
func (client *DictionaryClient) GetStringValid(ctx context.Context, options *DictionaryClientGetStringValidOptions) (DictionaryClientGetStringValidResponse, error) {
	req, err := client.getStringValidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetStringValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetStringValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetStringValidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getStringValidHandleResponse(resp)
}

// getStringValidCreateRequest creates the GetStringValid request.
func (client *DictionaryClient) getStringValidCreateRequest(ctx context.Context, options *DictionaryClientGetStringValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/string/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStringValidHandleResponse handles the GetStringValid response.
func (client *DictionaryClient) getStringValidHandleResponse(resp *http.Response) (DictionaryClientGetStringValidResponse, error) {
	result := DictionaryClientGetStringValidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetStringValidResponse{}, err
	}
	return result, nil
}

// GetStringWithInvalid - Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetStringWithInvalidOptions contains the optional parameters for the DictionaryClient.GetStringWithInvalid
// method.
func (client *DictionaryClient) GetStringWithInvalid(ctx context.Context, options *DictionaryClientGetStringWithInvalidOptions) (DictionaryClientGetStringWithInvalidResponse, error) {
	req, err := client.getStringWithInvalidCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetStringWithInvalidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetStringWithInvalidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetStringWithInvalidResponse{}, runtime.NewResponseError(resp)
	}
	return client.getStringWithInvalidHandleResponse(resp)
}

// getStringWithInvalidCreateRequest creates the GetStringWithInvalid request.
func (client *DictionaryClient) getStringWithInvalidCreateRequest(ctx context.Context, options *DictionaryClientGetStringWithInvalidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/string/foo.123.foo2"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStringWithInvalidHandleResponse handles the GetStringWithInvalid response.
func (client *DictionaryClient) getStringWithInvalidHandleResponse(resp *http.Response) (DictionaryClientGetStringWithInvalidResponse, error) {
	result := DictionaryClientGetStringWithInvalidResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetStringWithInvalidResponse{}, err
	}
	return result, nil
}

// GetStringWithNull - Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientGetStringWithNullOptions contains the optional parameters for the DictionaryClient.GetStringWithNull
// method.
func (client *DictionaryClient) GetStringWithNull(ctx context.Context, options *DictionaryClientGetStringWithNullOptions) (DictionaryClientGetStringWithNullResponse, error) {
	req, err := client.getStringWithNullCreateRequest(ctx, options)
	if err != nil {
		return DictionaryClientGetStringWithNullResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientGetStringWithNullResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientGetStringWithNullResponse{}, runtime.NewResponseError(resp)
	}
	return client.getStringWithNullHandleResponse(resp)
}

// getStringWithNullCreateRequest creates the GetStringWithNull request.
func (client *DictionaryClient) getStringWithNullCreateRequest(ctx context.Context, options *DictionaryClientGetStringWithNullOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/string/foo.null.foo2"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStringWithNullHandleResponse handles the GetStringWithNull response.
func (client *DictionaryClient) getStringWithNullHandleResponse(resp *http.Response) (DictionaryClientGetStringWithNullResponse, error) {
	result := DictionaryClientGetStringWithNullResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return DictionaryClientGetStringWithNullResponse{}, err
	}
	return result, nil
}

// PutArrayValid - Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutArrayValidOptions contains the optional parameters for the DictionaryClient.PutArrayValid
// method.
func (client *DictionaryClient) PutArrayValid(ctx context.Context, arrayBody map[string][]*string, options *DictionaryClientPutArrayValidOptions) (DictionaryClientPutArrayValidResponse, error) {
	req, err := client.putArrayValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutArrayValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutArrayValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutArrayValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutArrayValidResponse{RawResponse: resp}, nil
}

// putArrayValidCreateRequest creates the PutArrayValid request.
func (client *DictionaryClient) putArrayValidCreateRequest(ctx context.Context, arrayBody map[string][]*string, options *DictionaryClientPutArrayValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/array/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutBooleanTfft - Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutBooleanTfftOptions contains the optional parameters for the DictionaryClient.PutBooleanTfft
// method.
func (client *DictionaryClient) PutBooleanTfft(ctx context.Context, arrayBody map[string]*bool, options *DictionaryClientPutBooleanTfftOptions) (DictionaryClientPutBooleanTfftResponse, error) {
	req, err := client.putBooleanTfftCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutBooleanTfftResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutBooleanTfftResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutBooleanTfftResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutBooleanTfftResponse{RawResponse: resp}, nil
}

// putBooleanTfftCreateRequest creates the PutBooleanTfft request.
func (client *DictionaryClient) putBooleanTfftCreateRequest(ctx context.Context, arrayBody map[string]*bool, options *DictionaryClientPutBooleanTfftOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/boolean/tfft"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutByteValid - Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded
// in base 64
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutByteValidOptions contains the optional parameters for the DictionaryClient.PutByteValid method.
func (client *DictionaryClient) PutByteValid(ctx context.Context, arrayBody map[string][]byte, options *DictionaryClientPutByteValidOptions) (DictionaryClientPutByteValidResponse, error) {
	req, err := client.putByteValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutByteValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutByteValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutByteValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutByteValidResponse{RawResponse: resp}, nil
}

// putByteValidCreateRequest creates the PutByteValid request.
func (client *DictionaryClient) putByteValidCreateRequest(ctx context.Context, arrayBody map[string][]byte, options *DictionaryClientPutByteValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/byte/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutComplexValid - Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3,
// "string": "4"}, "2": {"integer": 5, "string": "6"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutComplexValidOptions contains the optional parameters for the DictionaryClient.PutComplexValid
// method.
func (client *DictionaryClient) PutComplexValid(ctx context.Context, arrayBody map[string]*Widget, options *DictionaryClientPutComplexValidOptions) (DictionaryClientPutComplexValidResponse, error) {
	req, err := client.putComplexValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutComplexValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutComplexValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutComplexValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutComplexValidResponse{RawResponse: resp}, nil
}

// putComplexValidCreateRequest creates the PutComplexValid request.
func (client *DictionaryClient) putComplexValidCreateRequest(ctx context.Context, arrayBody map[string]*Widget, options *DictionaryClientPutComplexValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/complex/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutDateTimeRFC1123Valid - Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35
// GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutDateTimeRFC1123ValidOptions contains the optional parameters for the DictionaryClient.PutDateTimeRFC1123Valid
// method.
func (client *DictionaryClient) PutDateTimeRFC1123Valid(ctx context.Context, arrayBody map[string]*time.Time, options *DictionaryClientPutDateTimeRFC1123ValidOptions) (DictionaryClientPutDateTimeRFC1123ValidResponse, error) {
	req, err := client.putDateTimeRFC1123ValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutDateTimeRFC1123ValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutDateTimeRFC1123ValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutDateTimeRFC1123ValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutDateTimeRFC1123ValidResponse{RawResponse: resp}, nil
}

// putDateTimeRFC1123ValidCreateRequest creates the PutDateTimeRFC1123Valid request.
func (client *DictionaryClient) putDateTimeRFC1123ValidCreateRequest(ctx context.Context, arrayBody map[string]*time.Time, options *DictionaryClientPutDateTimeRFC1123ValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date-time-rfc1123/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	aux := map[string]*timeRFC1123{}
	for k, v := range arrayBody {
		aux[k] = (*timeRFC1123)(v)
	}
	return req, runtime.MarshalAsJSON(req, aux)
}

// PutDateTimeValid - Set dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutDateTimeValidOptions contains the optional parameters for the DictionaryClient.PutDateTimeValid
// method.
func (client *DictionaryClient) PutDateTimeValid(ctx context.Context, arrayBody map[string]*time.Time, options *DictionaryClientPutDateTimeValidOptions) (DictionaryClientPutDateTimeValidResponse, error) {
	req, err := client.putDateTimeValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutDateTimeValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutDateTimeValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutDateTimeValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutDateTimeValidResponse{RawResponse: resp}, nil
}

// putDateTimeValidCreateRequest creates the PutDateTimeValid request.
func (client *DictionaryClient) putDateTimeValidCreateRequest(ctx context.Context, arrayBody map[string]*time.Time, options *DictionaryClientPutDateTimeValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date-time/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	aux := map[string]*timeRFC3339{}
	for k, v := range arrayBody {
		aux[k] = (*timeRFC3339)(v)
	}
	return req, runtime.MarshalAsJSON(req, aux)
}

// PutDateValid - Set dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutDateValidOptions contains the optional parameters for the DictionaryClient.PutDateValid method.
func (client *DictionaryClient) PutDateValid(ctx context.Context, arrayBody map[string]*time.Time, options *DictionaryClientPutDateValidOptions) (DictionaryClientPutDateValidResponse, error) {
	req, err := client.putDateValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutDateValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutDateValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutDateValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutDateValidResponse{RawResponse: resp}, nil
}

// putDateValidCreateRequest creates the PutDateValid request.
func (client *DictionaryClient) putDateValidCreateRequest(ctx context.Context, arrayBody map[string]*time.Time, options *DictionaryClientPutDateValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/date/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	aux := map[string]*dateType{}
	for k, v := range arrayBody {
		aux[k] = (*dateType)(v)
	}
	return req, runtime.MarshalAsJSON(req, aux)
}

// PutDictionaryValid - Get an dictionaries of dictionaries of type with value {"0": {"1": "one", "2": "two", "3": "three"},
// "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutDictionaryValidOptions contains the optional parameters for the DictionaryClient.PutDictionaryValid
// method.
func (client *DictionaryClient) PutDictionaryValid(ctx context.Context, arrayBody map[string]map[string]*string, options *DictionaryClientPutDictionaryValidOptions) (DictionaryClientPutDictionaryValidResponse, error) {
	req, err := client.putDictionaryValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutDictionaryValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutDictionaryValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutDictionaryValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutDictionaryValidResponse{RawResponse: resp}, nil
}

// putDictionaryValidCreateRequest creates the PutDictionaryValid request.
func (client *DictionaryClient) putDictionaryValidCreateRequest(ctx context.Context, arrayBody map[string]map[string]*string, options *DictionaryClientPutDictionaryValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/dictionary/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutDoubleValid - Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutDoubleValidOptions contains the optional parameters for the DictionaryClient.PutDoubleValid
// method.
func (client *DictionaryClient) PutDoubleValid(ctx context.Context, arrayBody map[string]*float64, options *DictionaryClientPutDoubleValidOptions) (DictionaryClientPutDoubleValidResponse, error) {
	req, err := client.putDoubleValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutDoubleValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutDoubleValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutDoubleValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutDoubleValidResponse{RawResponse: resp}, nil
}

// putDoubleValidCreateRequest creates the PutDoubleValid request.
func (client *DictionaryClient) putDoubleValidCreateRequest(ctx context.Context, arrayBody map[string]*float64, options *DictionaryClientPutDoubleValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/double/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutDurationValid - Set dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutDurationValidOptions contains the optional parameters for the DictionaryClient.PutDurationValid
// method.
func (client *DictionaryClient) PutDurationValid(ctx context.Context, arrayBody map[string]*string, options *DictionaryClientPutDurationValidOptions) (DictionaryClientPutDurationValidResponse, error) {
	req, err := client.putDurationValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutDurationValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutDurationValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutDurationValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutDurationValidResponse{RawResponse: resp}, nil
}

// putDurationValidCreateRequest creates the PutDurationValid request.
func (client *DictionaryClient) putDurationValidCreateRequest(ctx context.Context, arrayBody map[string]*string, options *DictionaryClientPutDurationValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/duration/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutEmpty - Set dictionary value empty {}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutEmptyOptions contains the optional parameters for the DictionaryClient.PutEmpty method.
func (client *DictionaryClient) PutEmpty(ctx context.Context, arrayBody map[string]*string, options *DictionaryClientPutEmptyOptions) (DictionaryClientPutEmptyResponse, error) {
	req, err := client.putEmptyCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutEmptyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutEmptyResponse{RawResponse: resp}, nil
}

// putEmptyCreateRequest creates the PutEmpty request.
func (client *DictionaryClient) putEmptyCreateRequest(ctx context.Context, arrayBody map[string]*string, options *DictionaryClientPutEmptyOptions) (*policy.Request, error) {
	urlPath := "/dictionary/empty"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutFloatValid - Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutFloatValidOptions contains the optional parameters for the DictionaryClient.PutFloatValid
// method.
func (client *DictionaryClient) PutFloatValid(ctx context.Context, arrayBody map[string]*float32, options *DictionaryClientPutFloatValidOptions) (DictionaryClientPutFloatValidResponse, error) {
	req, err := client.putFloatValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutFloatValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutFloatValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutFloatValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutFloatValidResponse{RawResponse: resp}, nil
}

// putFloatValidCreateRequest creates the PutFloatValid request.
func (client *DictionaryClient) putFloatValidCreateRequest(ctx context.Context, arrayBody map[string]*float32, options *DictionaryClientPutFloatValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/float/0--0.01-1.2e20"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutIntegerValid - Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutIntegerValidOptions contains the optional parameters for the DictionaryClient.PutIntegerValid
// method.
func (client *DictionaryClient) PutIntegerValid(ctx context.Context, arrayBody map[string]*int32, options *DictionaryClientPutIntegerValidOptions) (DictionaryClientPutIntegerValidResponse, error) {
	req, err := client.putIntegerValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutIntegerValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutIntegerValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutIntegerValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutIntegerValidResponse{RawResponse: resp}, nil
}

// putIntegerValidCreateRequest creates the PutIntegerValid request.
func (client *DictionaryClient) putIntegerValidCreateRequest(ctx context.Context, arrayBody map[string]*int32, options *DictionaryClientPutIntegerValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/integer/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutLongValid - Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutLongValidOptions contains the optional parameters for the DictionaryClient.PutLongValid method.
func (client *DictionaryClient) PutLongValid(ctx context.Context, arrayBody map[string]*int64, options *DictionaryClientPutLongValidOptions) (DictionaryClientPutLongValidResponse, error) {
	req, err := client.putLongValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutLongValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutLongValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutLongValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutLongValidResponse{RawResponse: resp}, nil
}

// putLongValidCreateRequest creates the PutLongValid request.
func (client *DictionaryClient) putLongValidCreateRequest(ctx context.Context, arrayBody map[string]*int64, options *DictionaryClientPutLongValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/long/1.-1.3.300"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}

// PutStringValid - Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
// If the operation fails it returns an *azcore.ResponseError type.
// options - DictionaryClientPutStringValidOptions contains the optional parameters for the DictionaryClient.PutStringValid
// method.
func (client *DictionaryClient) PutStringValid(ctx context.Context, arrayBody map[string]*string, options *DictionaryClientPutStringValidOptions) (DictionaryClientPutStringValidResponse, error) {
	req, err := client.putStringValidCreateRequest(ctx, arrayBody, options)
	if err != nil {
		return DictionaryClientPutStringValidResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DictionaryClientPutStringValidResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DictionaryClientPutStringValidResponse{}, runtime.NewResponseError(resp)
	}
	return DictionaryClientPutStringValidResponse{RawResponse: resp}, nil
}

// putStringValidCreateRequest creates the PutStringValid request.
func (client *DictionaryClient) putStringValidCreateRequest(ctx context.Context, arrayBody map[string]*string, options *DictionaryClientPutStringValidOptions) (*policy.Request, error) {
	urlPath := "/dictionary/prim/string/foo1.foo2.foo3"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, arrayBody)
}
