// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PagingOperations contains the methods for the Paging group.
type PagingOperations interface {
	// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePages(pagingGetMultiplePagesOptions *PagingGetMultiplePagesOptions) ProductResultPager
	// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
	GetMultiplePagesFailure() ProductResultPager
	// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
	GetMultiplePagesFailureURI() ProductResultPager
	// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
	GetMultiplePagesFragmentNextLink(apiVersion string, tenant string) OdataProductResultPager
	// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
	GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) OdataProductResultPager
	// BeginGetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
	BeginGetMultiplePagesLro(ctx context.Context, pagingGetMultiplePagesLroOptions *PagingGetMultiplePagesLroOptions) (*ProductResultPagerPollerResponse, error)
	// ResumeGetMultiplePagesLro - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeGetMultiplePagesLro(token string) (ProductResultPagerPoller, error)
	// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that has 10 pages
	GetMultiplePagesRetryFirst() ProductResultPager
	// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should retry and finish all 10 pages eventually.
	GetMultiplePagesRetrySecond() ProductResultPager
	// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) ProductResultPager
	// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
	GetNoItemNamePages() ProductResultValuePager
	// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
	GetNullNextLinkNamePages(ctx context.Context) (*ProductResultResponse, error)
	// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
	GetOdataMultiplePages(pagingGetOdataMultiplePagesOptions *PagingGetOdataMultiplePagesOptions) OdataProductResultPager
	// GetPagingModelWithItemNameWithXmsClientName - A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name 'indexes'.
	GetPagingModelWithItemNameWithXmsClientName() ProductResultValueWithXmsClientNamePager
	// GetSinglePages - A paging operation that finishes on the first call without a nextlink
	GetSinglePages() ProductResultPager
	// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
	GetSinglePagesFailure() ProductResultPager
	// GetWithQueryParams - A paging operation that includes a next operation. It has a different query parameter from it's next operation nextOperationWithQueryParams. Returns a ProductResult
	GetWithQueryParams(requiredQueryParameter int32) ProductResultPager
}

// PagingClient implements the PagingOperations interface.
// Don't use this type directly, use NewPagingClient() instead.
type PagingClient struct {
	*Client
}

// NewPagingClient creates a new instance of PagingClient with the specified values.
func NewPagingClient(c *Client) PagingOperations {
	return &PagingClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *PagingClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePages(pagingGetMultiplePagesOptions *PagingGetMultiplePagesOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesCreateRequest(ctx, pagingGetMultiplePagesOptions)
		},
		responder: client.GetMultiplePagesHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *PagingClient) GetMultiplePagesCreateRequest(ctx context.Context, pagingGetMultiplePagesOptions *PagingGetMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	if pagingGetMultiplePagesOptions != nil && pagingGetMultiplePagesOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesOptions != nil && pagingGetMultiplePagesOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesOptions != nil && pagingGetMultiplePagesOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesOptions.Timeout), 10))
	}
	return req, nil
}

// GetMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *PagingClient) GetMultiplePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesHandleError handles the GetMultiplePages error response.
func (client *PagingClient) GetMultiplePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
func (client *PagingClient) GetMultiplePagesFailure() ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFailureCreateRequest(ctx)
		},
		responder: client.GetMultiplePagesFailureHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *PagingClient) GetMultiplePagesFailureCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/failure"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *PagingClient) GetMultiplePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesFailureHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFailureHandleError handles the GetMultiplePagesFailure error response.
func (client *PagingClient) GetMultiplePagesFailureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
func (client *PagingClient) GetMultiplePagesFailureURI() ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFailureURICreateRequest(ctx)
		},
		responder: client.GetMultiplePagesFailureURIHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetMultiplePagesFailureURICreateRequest creates the GetMultiplePagesFailureURI request.
func (client *PagingClient) GetMultiplePagesFailureURICreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetMultiplePagesFailureURIHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *PagingClient) GetMultiplePagesFailureURIHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesFailureURIHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFailureURIHandleError handles the GetMultiplePagesFailureURI error response.
func (client *PagingClient) GetMultiplePagesFailureURIHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
func (client *PagingClient) GetMultiplePagesFragmentNextLink(apiVersion string, tenant string) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFragmentNextLinkCreateRequest(ctx, apiVersion, tenant)
		},
		responder: client.GetMultiplePagesFragmentNextLinkHandleResponse,
		advancer: func(ctx context.Context, resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.NextFragmentCreateRequest(ctx, apiVersion, tenant, *resp.OdataProductResult.OdataNextLink)
		},
	}
}

// GetMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *PagingClient) GetMultiplePagesFragmentNextLinkCreateRequest(ctx context.Context, apiVersion string, tenant string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api_version", apiVersion)
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// GetMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *PagingClient) GetMultiplePagesFragmentNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesFragmentNextLinkHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetMultiplePagesFragmentNextLinkHandleError handles the GetMultiplePagesFragmentNextLink error response.
func (client *PagingClient) GetMultiplePagesFragmentNextLinkHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx, customParameterGroup)
		},
		responder: client.GetMultiplePagesFragmentWithGroupingNextLinkHandleResponse,
		advancer: func(ctx context.Context, resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.NextFragmentWithGroupingCreateRequest(ctx, *resp.OdataProductResult.OdataNextLink, customParameterGroup)
		},
	}
}

// GetMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx context.Context, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// GetMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesFragmentWithGroupingNextLinkHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetMultiplePagesFragmentWithGroupingNextLinkHandleError handles the GetMultiplePagesFragmentWithGroupingNextLink error response.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) BeginGetMultiplePagesLro(ctx context.Context, pagingGetMultiplePagesLroOptions *PagingGetMultiplePagesLroOptions) (*ProductResultPagerPollerResponse, error) {
	req, err := client.GetMultiplePagesLroCreateRequest(ctx, pagingGetMultiplePagesLroOptions)
	if err != nil {
		return nil, err
	}
	// send the first request to initialize the poller
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetMultiplePagesLroHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	pt, err := armcore.NewPoller("PagingClient.GetMultiplePagesLro", "", resp, client.GetMultiplePagesLroHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productResultPagerPoller{
		pt:          pt,
		respHandler: client.productResultPagerHandleResponse,
		pipeline:    client.p,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResultPager, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *PagingClient) ResumeGetMultiplePagesLro(token string) (ProductResultPagerPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("PagingClient.GetMultiplePagesLro", token, client.GetMultiplePagesLroHandleError)
	if err != nil {
		return nil, err
	}
	return &productResultPagerPoller{
		pipeline: client.p,
		pt:       pt,
	}, nil
}

// GetMultiplePagesLroCreateRequest creates the GetMultiplePagesLro request.
func (client *PagingClient) GetMultiplePagesLroCreateRequest(ctx context.Context, pagingGetMultiplePagesLroOptions *PagingGetMultiplePagesLroOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/lro"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	if pagingGetMultiplePagesLroOptions != nil && pagingGetMultiplePagesLroOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesLroOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesLroOptions != nil && pagingGetMultiplePagesLroOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesLroOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesLroOptions != nil && pagingGetMultiplePagesLroOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesLroOptions.Timeout), 10))
	}
	return req, nil
}

// GetMultiplePagesLroHandleResponse handles the GetMultiplePagesLro response.
func (client *PagingClient) GetMultiplePagesLroHandleResponse(resp *azcore.Response) (*ProductResultPagerPollerResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.GetMultiplePagesLroHandleError(resp)
	}
	return &ProductResultPagerPollerResponse{RawResponse: resp.Response}, nil
}

// GetMultiplePagesLroHandleResponse handles the GetMultiplePagesLro response.
func (client *PagingClient) productResultPagerHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusOK) {
		return nil, client.GetMultiplePagesLroHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesLroHandleError handles the GetMultiplePagesLro error response.
func (client *PagingClient) GetMultiplePagesLroHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePagesRetryFirst() ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesRetryFirstCreateRequest(ctx)
		},
		responder: client.GetMultiplePagesRetryFirstHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *PagingClient) GetMultiplePagesRetryFirstCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *PagingClient) GetMultiplePagesRetryFirstHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesRetryFirstHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesRetryFirstHandleError handles the GetMultiplePagesRetryFirst error response.
func (client *PagingClient) GetMultiplePagesRetryFirstHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should retry and finish all 10 pages eventually.
func (client *PagingClient) GetMultiplePagesRetrySecond() ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesRetrySecondCreateRequest(ctx)
		},
		responder: client.GetMultiplePagesRetrySecondHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *PagingClient) GetMultiplePagesRetrySecondCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *PagingClient) GetMultiplePagesRetrySecondHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesRetrySecondHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesRetrySecondHandleError handles the GetMultiplePagesRetrySecond error response.
func (client *PagingClient) GetMultiplePagesRetrySecondHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesWithOffsetCreateRequest(ctx, pagingGetMultiplePagesWithOffsetOptions)
		},
		responder: client.GetMultiplePagesWithOffsetHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *PagingClient) GetMultiplePagesWithOffsetCreateRequest(ctx context.Context, pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(pagingGetMultiplePagesWithOffsetOptions.Offset), 10)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	if pagingGetMultiplePagesWithOffsetOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesWithOffsetOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesWithOffsetOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesWithOffsetOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Timeout), 10))
	}
	return req, nil
}

// GetMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *PagingClient) GetMultiplePagesWithOffsetHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetMultiplePagesWithOffsetHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesWithOffsetHandleError handles the GetMultiplePagesWithOffset error response.
func (client *PagingClient) GetMultiplePagesWithOffsetHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
func (client *PagingClient) GetNoItemNamePages() ProductResultValuePager {
	return &productResultValuePager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetNoItemNamePagesCreateRequest(ctx)
		},
		responder: client.GetNoItemNamePagesHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultValueResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResultValue.NextLink)
		},
	}
}

// GetNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *PagingClient) GetNoItemNamePagesCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/noitemname"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *PagingClient) GetNoItemNamePagesHandleResponse(resp *azcore.Response) (*ProductResultValueResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNoItemNamePagesHandleError(resp)
	}
	result := ProductResultValueResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResultValue)
}

// GetNoItemNamePagesHandleError handles the GetNoItemNamePages error response.
func (client *PagingClient) GetNoItemNamePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
func (client *PagingClient) GetNullNextLinkNamePages(ctx context.Context) (*ProductResultResponse, error) {
	req, err := client.GetNullNextLinkNamePagesCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetNullNextLinkNamePagesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *PagingClient) GetNullNextLinkNamePagesCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/nullnextlink"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *PagingClient) GetNullNextLinkNamePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNullNextLinkNamePagesHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetNullNextLinkNamePagesHandleError handles the GetNullNextLinkNamePages error response.
func (client *PagingClient) GetNullNextLinkNamePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
func (client *PagingClient) GetOdataMultiplePages(pagingGetOdataMultiplePagesOptions *PagingGetOdataMultiplePagesOptions) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetOdataMultiplePagesCreateRequest(ctx, pagingGetOdataMultiplePagesOptions)
		},
		responder: client.GetOdataMultiplePagesHandleResponse,
		advancer: func(ctx context.Context, resp *OdataProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.OdataProductResult.OdataNextLink)
		},
	}
}

// GetOdataMultiplePagesCreateRequest creates the GetOdataMultiplePages request.
func (client *PagingClient) GetOdataMultiplePagesCreateRequest(ctx context.Context, pagingGetOdataMultiplePagesOptions *PagingGetOdataMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/odata"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	if pagingGetOdataMultiplePagesOptions != nil && pagingGetOdataMultiplePagesOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetOdataMultiplePagesOptions.ClientRequestId)
	}
	if pagingGetOdataMultiplePagesOptions != nil && pagingGetOdataMultiplePagesOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetOdataMultiplePagesOptions.Maxresults), 10))
	}
	if pagingGetOdataMultiplePagesOptions != nil && pagingGetOdataMultiplePagesOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetOdataMultiplePagesOptions.Timeout), 10))
	}
	return req, nil
}

// GetOdataMultiplePagesHandleResponse handles the GetOdataMultiplePages response.
func (client *PagingClient) GetOdataMultiplePagesHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetOdataMultiplePagesHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetOdataMultiplePagesHandleError handles the GetOdataMultiplePages error response.
func (client *PagingClient) GetOdataMultiplePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetPagingModelWithItemNameWithXmsClientName - A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name 'indexes'.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientName() ProductResultValueWithXmsClientNamePager {
	return &productResultValueWithXmsClientNamePager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetPagingModelWithItemNameWithXmsClientNameCreateRequest(ctx)
		},
		responder: client.GetPagingModelWithItemNameWithXmsClientNameHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultValueWithXmsClientNameResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResultValueWithXmsClientName.NextLink)
		},
	}
}

// GetPagingModelWithItemNameWithXmsClientNameCreateRequest creates the GetPagingModelWithItemNameWithXmsClientName request.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientNameCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/itemNameWithXMSClientName"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetPagingModelWithItemNameWithXmsClientNameHandleResponse handles the GetPagingModelWithItemNameWithXmsClientName response.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientNameHandleResponse(resp *azcore.Response) (*ProductResultValueWithXmsClientNameResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetPagingModelWithItemNameWithXmsClientNameHandleError(resp)
	}
	result := ProductResultValueWithXmsClientNameResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResultValueWithXmsClientName)
}

// GetPagingModelWithItemNameWithXmsClientNameHandleError handles the GetPagingModelWithItemNameWithXmsClientName error response.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientNameHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetSinglePages - A paging operation that finishes on the first call without a nextlink
func (client *PagingClient) GetSinglePages() ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetSinglePagesCreateRequest(ctx)
		},
		responder: client.GetSinglePagesHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetSinglePagesCreateRequest creates the GetSinglePages request.
func (client *PagingClient) GetSinglePagesCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/single"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetSinglePagesHandleResponse handles the GetSinglePages response.
func (client *PagingClient) GetSinglePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetSinglePagesHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetSinglePagesHandleError handles the GetSinglePages error response.
func (client *PagingClient) GetSinglePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
func (client *PagingClient) GetSinglePagesFailure() ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetSinglePagesFailureCreateRequest(ctx)
		},
		responder: client.GetSinglePagesFailureHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// GetSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *PagingClient) GetSinglePagesFailureCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/single/failure"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *PagingClient) GetSinglePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetSinglePagesFailureHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetSinglePagesFailureHandleError handles the GetSinglePagesFailure error response.
func (client *PagingClient) GetSinglePagesFailureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetWithQueryParams - A paging operation that includes a next operation. It has a different query parameter from it's next operation nextOperationWithQueryParams. Returns a ProductResult
func (client *PagingClient) GetWithQueryParams(requiredQueryParameter int32) ProductResultPager {
	return &productResultPager{
		pipeline: client.p,
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetWithQueryParamsCreateRequest(ctx, requiredQueryParameter)
		},
		responder: client.GetWithQueryParamsHandleResponse,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return client.NextOperationWithQueryParamsCreateRequest(ctx)
		},
	}
}

// GetWithQueryParamsCreateRequest creates the GetWithQueryParams request.
func (client *PagingClient) GetWithQueryParamsCreateRequest(ctx context.Context, requiredQueryParameter int32) (*azcore.Request, error) {
	urlPath := "/paging/multiple/getWithQueryParams"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("requiredQueryParameter", strconv.FormatInt(int64(requiredQueryParameter), 10))
	query.Set("queryConstant", "true")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// GetWithQueryParamsHandleResponse handles the GetWithQueryParams response.
func (client *PagingClient) GetWithQueryParamsHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetWithQueryParamsHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetWithQueryParamsHandleError handles the GetWithQueryParams error response.
func (client *PagingClient) GetWithQueryParamsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// NextFragmentCreateRequest creates the NextFragment request.
func (client *PagingClient) NextFragmentCreateRequest(ctx context.Context, apiVersion string, tenant string, nextLink string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api_version", apiVersion)
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// NextFragmentHandleResponse handles the NextFragment response.
func (client *PagingClient) NextFragmentHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.NextFragmentHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// NextFragmentHandleError handles the NextFragment error response.
func (client *PagingClient) NextFragmentHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// NextFragmentWithGroupingCreateRequest creates the NextFragmentWithGrouping request.
func (client *PagingClient) NextFragmentWithGroupingCreateRequest(ctx context.Context, nextLink string, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// NextFragmentWithGroupingHandleResponse handles the NextFragmentWithGrouping response.
func (client *PagingClient) NextFragmentWithGroupingHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.NextFragmentWithGroupingHandleError(resp)
	}
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// NextFragmentWithGroupingHandleError handles the NextFragmentWithGrouping error response.
func (client *PagingClient) NextFragmentWithGroupingHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// NextOperationWithQueryParamsCreateRequest creates the NextOperationWithQueryParams request.
func (client *PagingClient) NextOperationWithQueryParamsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/nextOperationWithQueryParams"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("queryConstant", "true")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// NextOperationWithQueryParamsHandleResponse handles the NextOperationWithQueryParams response.
func (client *PagingClient) NextOperationWithQueryParamsHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.NextOperationWithQueryParamsHandleError(resp)
	}
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// NextOperationWithQueryParamsHandleError handles the NextOperationWithQueryParams error response.
func (client *PagingClient) NextOperationWithQueryParamsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}
