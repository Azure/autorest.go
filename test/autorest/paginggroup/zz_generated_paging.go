// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PagingOperations contains the methods for the Paging group.
type PagingOperations interface {
	// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePages(options *PagingGetMultiplePagesOptions) ProductResultPager
	// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
	GetMultiplePagesFailure(options *PagingGetMultiplePagesFailureOptions) ProductResultPager
	// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
	GetMultiplePagesFailureURI(options *PagingGetMultiplePagesFailureURIOptions) ProductResultPager
	// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
	GetMultiplePagesFragmentNextLink(apiVersion string, tenant string, options *PagingGetMultiplePagesFragmentNextLinkOptions) OdataProductResultPager
	// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
	GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) OdataProductResultPager
	// BeginGetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
	BeginGetMultiplePagesLro(ctx context.Context, options *PagingGetMultiplePagesLroOptions) (*ProductResultPagerPollerResponse, error)
	// ResumeGetMultiplePagesLro - Used to create a new instance of this poller from the resume token of a previous instance of this poller type.
	ResumeGetMultiplePagesLro(token string) (ProductResultPagerPoller, error)
	// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that
	// has 10 pages
	GetMultiplePagesRetryFirst(options *PagingGetMultiplePagesRetryFirstOptions) ProductResultPager
	// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should
	// retry and finish all 10 pages eventually.
	GetMultiplePagesRetrySecond(options *PagingGetMultiplePagesRetrySecondOptions) ProductResultPager
	// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
	GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) ProductResultPager
	// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
	GetNoItemNamePages(options *PagingGetNoItemNamePagesOptions) ProductResultValuePager
	// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
	GetNullNextLinkNamePages(ctx context.Context, options *PagingGetNullNextLinkNamePagesOptions) (*ProductResultResponse, error)
	// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
	GetOdataMultiplePages(options *PagingGetOdataMultiplePagesOptions) OdataProductResultPager
	// GetPagingModelWithItemNameWithXmsClientName - A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name 'indexes'.
	GetPagingModelWithItemNameWithXmsClientName(options *PagingGetPagingModelWithItemNameWithXmsClientNameOptions) ProductResultValueWithXmsClientNamePager
	// GetSinglePages - A paging operation that finishes on the first call without a nextlink
	GetSinglePages(options *PagingGetSinglePagesOptions) ProductResultPager
	// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
	GetSinglePagesFailure(options *PagingGetSinglePagesFailureOptions) ProductResultPager
	// GetWithQueryParams - A paging operation that includes a next operation. It has a different query parameter from it's next operation nextOperationWithQueryParams.
	// Returns a ProductResult
	GetWithQueryParams(requiredQueryParameter int32, options *PagingGetWithQueryParamsOptions) ProductResultPager
}

// PagingClient implements the PagingOperations interface.
// Don't use this type directly, use NewPagingClient() instead.
type PagingClient struct {
	con *Connection
}

// NewPagingClient creates a new instance of PagingClient with the specified values.
func NewPagingClient(con *Connection) PagingOperations {
	return &PagingClient{con: con}
}

// Pipeline returns the pipeline associated with this client.
func (client *PagingClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePages(options *PagingGetMultiplePagesOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesCreateRequest(ctx, options)
		},
		responder: client.GetMultiplePagesHandleResponse,
		errorer:   client.GetMultiplePagesHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *PagingClient) GetMultiplePagesCreateRequest(ctx context.Context, options *PagingGetMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *PagingClient) GetMultiplePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesHandleError handles the GetMultiplePages error response.
func (client *PagingClient) GetMultiplePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
func (client *PagingClient) GetMultiplePagesFailure(options *PagingGetMultiplePagesFailureOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFailureCreateRequest(ctx, options)
		},
		responder: client.GetMultiplePagesFailureHandleResponse,
		errorer:   client.GetMultiplePagesFailureHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *PagingClient) GetMultiplePagesFailureCreateRequest(ctx context.Context, options *PagingGetMultiplePagesFailureOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/failure"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *PagingClient) GetMultiplePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFailureHandleError handles the GetMultiplePagesFailure error response.
func (client *PagingClient) GetMultiplePagesFailureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
func (client *PagingClient) GetMultiplePagesFailureURI(options *PagingGetMultiplePagesFailureURIOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFailureURICreateRequest(ctx, options)
		},
		responder: client.GetMultiplePagesFailureURIHandleResponse,
		errorer:   client.GetMultiplePagesFailureURIHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesFailureURICreateRequest creates the GetMultiplePagesFailureURI request.
func (client *PagingClient) GetMultiplePagesFailureURICreateRequest(ctx context.Context, options *PagingGetMultiplePagesFailureURIOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesFailureURIHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *PagingClient) GetMultiplePagesFailureURIHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesFailureURIHandleError handles the GetMultiplePagesFailureURI error response.
func (client *PagingClient) GetMultiplePagesFailureURIHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
func (client *PagingClient) GetMultiplePagesFragmentNextLink(apiVersion string, tenant string, options *PagingGetMultiplePagesFragmentNextLinkOptions) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFragmentNextLinkCreateRequest(ctx, apiVersion, tenant, options)
		},
		responder: client.GetMultiplePagesFragmentNextLinkHandleResponse,
		errorer:   client.GetMultiplePagesFragmentNextLinkHandleError,
		advancer: func(ctx context.Context, resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.NextFragmentCreateRequest(ctx, apiVersion, tenant, *resp.OdataProductResult.OdataNextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *PagingClient) GetMultiplePagesFragmentNextLinkCreateRequest(ctx context.Context, apiVersion string, tenant string, options *PagingGetMultiplePagesFragmentNextLinkOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", apiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *PagingClient) GetMultiplePagesFragmentNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetMultiplePagesFragmentNextLinkHandleError handles the GetMultiplePagesFragmentNextLink error response.
func (client *PagingClient) GetMultiplePagesFragmentNextLinkHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx, customParameterGroup)
		},
		responder: client.GetMultiplePagesFragmentWithGroupingNextLinkHandleResponse,
		errorer:   client.GetMultiplePagesFragmentWithGroupingNextLinkHandleError,
		advancer: func(ctx context.Context, resp *OdataProductResultResponse) (*azcore.Request, error) {
			return client.NextFragmentWithGroupingCreateRequest(ctx, *resp.OdataProductResult.OdataNextLink, customParameterGroup)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx context.Context, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetMultiplePagesFragmentWithGroupingNextLinkHandleError handles the GetMultiplePagesFragmentWithGroupingNextLink error response.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLinkHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

func (client *PagingClient) BeginGetMultiplePagesLro(ctx context.Context, options *PagingGetMultiplePagesLroOptions) (*ProductResultPagerPollerResponse, error) {
	resp, err := client.GetMultiplePagesLro(ctx, options)
	if err != nil {
		return nil, err
	}
	result := &ProductResultPagerPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("PagingClient.GetMultiplePagesLro", "", resp, client.GetMultiplePagesLroHandleError)
	if err != nil {
		return nil, err
	}
	poller := &productResultPagerPoller{
		pt: pt,
		errHandler: func(resp *azcore.Response) error {
			if resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
				return nil
			}
			return client.GetMultiplePagesLroHandleError(resp)
		},
		respHandler: func(resp *azcore.Response) (*ProductResultResponse, error) {
			result := ProductResultResponse{RawResponse: resp.Response}
			return &result, resp.UnmarshalAsJSON(&result.ProductResult)
		},
		statusCodes: []int{http.StatusOK, http.StatusAccepted, http.StatusNoContent},
		pipeline:    client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResultPager, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

func (client *PagingClient) ResumeGetMultiplePagesLro(token string) (ProductResultPagerPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("PagingClient.GetMultiplePagesLro", token, client.GetMultiplePagesLroHandleError)
	if err != nil {
		return nil, err
	}
	return &productResultPagerPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// GetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePagesLro(ctx context.Context, options *PagingGetMultiplePagesLroOptions) (*azcore.Response, error) {
	req, err := client.GetMultiplePagesLroCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.GetMultiplePagesLroHandleError(resp)
	}
	return resp, nil
}

// GetMultiplePagesLroCreateRequest creates the GetMultiplePagesLro request.
func (client *PagingClient) GetMultiplePagesLroCreateRequest(ctx context.Context, options *PagingGetMultiplePagesLroOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/lro"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesLroHandleResponse handles the GetMultiplePagesLro response.
func (client *PagingClient) GetMultiplePagesLroHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesLroHandleError handles the GetMultiplePagesLro error response.
func (client *PagingClient) GetMultiplePagesLroHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that
// has 10 pages
func (client *PagingClient) GetMultiplePagesRetryFirst(options *PagingGetMultiplePagesRetryFirstOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesRetryFirstCreateRequest(ctx, options)
		},
		responder: client.GetMultiplePagesRetryFirstHandleResponse,
		errorer:   client.GetMultiplePagesRetryFirstHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *PagingClient) GetMultiplePagesRetryFirstCreateRequest(ctx context.Context, options *PagingGetMultiplePagesRetryFirstOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *PagingClient) GetMultiplePagesRetryFirstHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesRetryFirstHandleError handles the GetMultiplePagesRetryFirst error response.
func (client *PagingClient) GetMultiplePagesRetryFirstHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should
// retry and finish all 10 pages eventually.
func (client *PagingClient) GetMultiplePagesRetrySecond(options *PagingGetMultiplePagesRetrySecondOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesRetrySecondCreateRequest(ctx, options)
		},
		responder: client.GetMultiplePagesRetrySecondHandleResponse,
		errorer:   client.GetMultiplePagesRetrySecondHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *PagingClient) GetMultiplePagesRetrySecondCreateRequest(ctx context.Context, options *PagingGetMultiplePagesRetrySecondOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *PagingClient) GetMultiplePagesRetrySecondHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesRetrySecondHandleError handles the GetMultiplePagesRetrySecond error response.
func (client *PagingClient) GetMultiplePagesRetrySecondHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetMultiplePagesWithOffsetCreateRequest(ctx, pagingGetMultiplePagesWithOffsetOptions)
		},
		responder: client.GetMultiplePagesWithOffsetHandleResponse,
		errorer:   client.GetMultiplePagesWithOffsetHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *PagingClient) GetMultiplePagesWithOffsetCreateRequest(ctx context.Context, pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(pagingGetMultiplePagesWithOffsetOptions.Offset), 10)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if pagingGetMultiplePagesWithOffsetOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesWithOffsetOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesWithOffsetOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesWithOffsetOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *PagingClient) GetMultiplePagesWithOffsetHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetMultiplePagesWithOffsetHandleError handles the GetMultiplePagesWithOffset error response.
func (client *PagingClient) GetMultiplePagesWithOffsetHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
func (client *PagingClient) GetNoItemNamePages(options *PagingGetNoItemNamePagesOptions) ProductResultValuePager {
	return &productResultValuePager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetNoItemNamePagesCreateRequest(ctx, options)
		},
		responder: client.GetNoItemNamePagesHandleResponse,
		errorer:   client.GetNoItemNamePagesHandleError,
		advancer: func(ctx context.Context, resp *ProductResultValueResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResultValue.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *PagingClient) GetNoItemNamePagesCreateRequest(ctx context.Context, options *PagingGetNoItemNamePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/noitemname"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *PagingClient) GetNoItemNamePagesHandleResponse(resp *azcore.Response) (*ProductResultValueResponse, error) {
	result := ProductResultValueResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResultValue)
}

// GetNoItemNamePagesHandleError handles the GetNoItemNamePages error response.
func (client *PagingClient) GetNoItemNamePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
func (client *PagingClient) GetNullNextLinkNamePages(ctx context.Context, options *PagingGetNullNextLinkNamePagesOptions) (*ProductResultResponse, error) {
	req, err := client.GetNullNextLinkNamePagesCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetNullNextLinkNamePagesHandleError(resp)
	}
	result, err := client.GetNullNextLinkNamePagesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *PagingClient) GetNullNextLinkNamePagesCreateRequest(ctx context.Context, options *PagingGetNullNextLinkNamePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/nullnextlink"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *PagingClient) GetNullNextLinkNamePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetNullNextLinkNamePagesHandleError handles the GetNullNextLinkNamePages error response.
func (client *PagingClient) GetNullNextLinkNamePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
func (client *PagingClient) GetOdataMultiplePages(options *PagingGetOdataMultiplePagesOptions) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetOdataMultiplePagesCreateRequest(ctx, options)
		},
		responder: client.GetOdataMultiplePagesHandleResponse,
		errorer:   client.GetOdataMultiplePagesHandleError,
		advancer: func(ctx context.Context, resp *OdataProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.OdataProductResult.OdataNextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetOdataMultiplePagesCreateRequest creates the GetOdataMultiplePages request.
func (client *PagingClient) GetOdataMultiplePagesCreateRequest(ctx context.Context, options *PagingGetOdataMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/odata"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetOdataMultiplePagesHandleResponse handles the GetOdataMultiplePages response.
func (client *PagingClient) GetOdataMultiplePagesHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// GetOdataMultiplePagesHandleError handles the GetOdataMultiplePages error response.
func (client *PagingClient) GetOdataMultiplePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetPagingModelWithItemNameWithXmsClientName - A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name 'indexes'.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientName(options *PagingGetPagingModelWithItemNameWithXmsClientNameOptions) ProductResultValueWithXmsClientNamePager {
	return &productResultValueWithXmsClientNamePager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetPagingModelWithItemNameWithXmsClientNameCreateRequest(ctx, options)
		},
		responder: client.GetPagingModelWithItemNameWithXmsClientNameHandleResponse,
		errorer:   client.GetPagingModelWithItemNameWithXmsClientNameHandleError,
		advancer: func(ctx context.Context, resp *ProductResultValueWithXmsClientNameResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResultValueWithXmsClientName.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetPagingModelWithItemNameWithXmsClientNameCreateRequest creates the GetPagingModelWithItemNameWithXmsClientName request.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientNameCreateRequest(ctx context.Context, options *PagingGetPagingModelWithItemNameWithXmsClientNameOptions) (*azcore.Request, error) {
	urlPath := "/paging/itemNameWithXMSClientName"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetPagingModelWithItemNameWithXmsClientNameHandleResponse handles the GetPagingModelWithItemNameWithXmsClientName response.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientNameHandleResponse(resp *azcore.Response) (*ProductResultValueWithXmsClientNameResponse, error) {
	result := ProductResultValueWithXmsClientNameResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResultValueWithXmsClientName)
}

// GetPagingModelWithItemNameWithXmsClientNameHandleError handles the GetPagingModelWithItemNameWithXmsClientName error response.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientNameHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetSinglePages - A paging operation that finishes on the first call without a nextlink
func (client *PagingClient) GetSinglePages(options *PagingGetSinglePagesOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetSinglePagesCreateRequest(ctx, options)
		},
		responder: client.GetSinglePagesHandleResponse,
		errorer:   client.GetSinglePagesHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetSinglePagesCreateRequest creates the GetSinglePages request.
func (client *PagingClient) GetSinglePagesCreateRequest(ctx context.Context, options *PagingGetSinglePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/single"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetSinglePagesHandleResponse handles the GetSinglePages response.
func (client *PagingClient) GetSinglePagesHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetSinglePagesHandleError handles the GetSinglePages error response.
func (client *PagingClient) GetSinglePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
func (client *PagingClient) GetSinglePagesFailure(options *PagingGetSinglePagesFailureOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetSinglePagesFailureCreateRequest(ctx, options)
		},
		responder: client.GetSinglePagesFailureHandleResponse,
		errorer:   client.GetSinglePagesFailureHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *PagingClient) GetSinglePagesFailureCreateRequest(ctx context.Context, options *PagingGetSinglePagesFailureOptions) (*azcore.Request, error) {
	urlPath := "/paging/single/failure"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *PagingClient) GetSinglePagesFailureHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetSinglePagesFailureHandleError handles the GetSinglePagesFailure error response.
func (client *PagingClient) GetSinglePagesFailureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetWithQueryParams - A paging operation that includes a next operation. It has a different query parameter from it's next operation nextOperationWithQueryParams.
// Returns a ProductResult
func (client *PagingClient) GetWithQueryParams(requiredQueryParameter int32, options *PagingGetWithQueryParamsOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.GetWithQueryParamsCreateRequest(ctx, requiredQueryParameter, options)
		},
		responder: client.GetWithQueryParamsHandleResponse,
		errorer:   client.GetWithQueryParamsHandleError,
		advancer: func(ctx context.Context, resp *ProductResultResponse) (*azcore.Request, error) {
			return client.NextOperationWithQueryParamsCreateRequest(ctx)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// GetWithQueryParamsCreateRequest creates the GetWithQueryParams request.
func (client *PagingClient) GetWithQueryParamsCreateRequest(ctx context.Context, requiredQueryParameter int32, options *PagingGetWithQueryParamsOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/getWithQueryParams"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("requiredQueryParameter", strconv.FormatInt(int64(requiredQueryParameter), 10))
	query.Set("queryConstant", "true")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// GetWithQueryParamsHandleResponse handles the GetWithQueryParams response.
func (client *PagingClient) GetWithQueryParamsHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// GetWithQueryParamsHandleError handles the GetWithQueryParams error response.
func (client *PagingClient) GetWithQueryParamsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// NextFragmentCreateRequest creates the NextFragment request.
func (client *PagingClient) NextFragmentCreateRequest(ctx context.Context, apiVersion string, tenant string, nextLink string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", apiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// NextFragmentHandleResponse handles the NextFragment response.
func (client *PagingClient) NextFragmentHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// NextFragmentHandleError handles the NextFragment error response.
func (client *PagingClient) NextFragmentHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// NextFragmentWithGroupingCreateRequest creates the NextFragmentWithGrouping request.
func (client *PagingClient) NextFragmentWithGroupingCreateRequest(ctx context.Context, nextLink string, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// NextFragmentWithGroupingHandleResponse handles the NextFragmentWithGrouping response.
func (client *PagingClient) NextFragmentWithGroupingHandleResponse(resp *azcore.Response) (*OdataProductResultResponse, error) {
	result := OdataProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.OdataProductResult)
}

// NextFragmentWithGroupingHandleError handles the NextFragmentWithGrouping error response.
func (client *PagingClient) NextFragmentWithGroupingHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// NextOperationWithQueryParamsCreateRequest creates the NextOperationWithQueryParams request.
func (client *PagingClient) NextOperationWithQueryParamsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/nextOperationWithQueryParams"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("queryConstant", "true")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// NextOperationWithQueryParamsHandleResponse handles the NextOperationWithQueryParams response.
func (client *PagingClient) NextOperationWithQueryParamsHandleResponse(resp *azcore.Response) (*ProductResultResponse, error) {
	result := ProductResultResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ProductResult)
}

// NextOperationWithQueryParamsHandleError handles the NextOperationWithQueryParams error response.
func (client *PagingClient) NextOperationWithQueryParamsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}
