// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PagingClient contains the methods for the Paging group.
// Don't use this type directly, use NewPagingClient() instead.
type PagingClient struct {
	con *Connection
}

// NewPagingClient creates a new instance of PagingClient with the specified values.
func NewPagingClient(con *Connection) *PagingClient {
	return &PagingClient{con: con}
}

// Pipeline returns the pipeline associated with this client.
func (client *PagingClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePages(options *PagingGetMultiplePagesOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesCreateRequest(ctx, options)
		},
		responder: client.getMultiplePagesHandleResponse,
		errorer:   client.getMultiplePagesHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *PagingClient) getMultiplePagesCreateRequest(ctx context.Context, options *PagingGetMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *PagingClient) getMultiplePagesHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesHandleError handles the GetMultiplePages error response.
func (client *PagingClient) getMultiplePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
func (client *PagingClient) GetMultiplePagesFailure(options *PagingGetMultiplePagesFailureOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesFailureCreateRequest(ctx, options)
		},
		responder: client.getMultiplePagesFailureHandleResponse,
		errorer:   client.getMultiplePagesFailureHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *PagingClient) getMultiplePagesFailureCreateRequest(ctx context.Context, options *PagingGetMultiplePagesFailureOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/failure"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *PagingClient) getMultiplePagesFailureHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesFailureHandleError handles the GetMultiplePagesFailure error response.
func (client *PagingClient) getMultiplePagesFailureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
func (client *PagingClient) GetMultiplePagesFailureURI(options *PagingGetMultiplePagesFailureURIOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesFailureUriCreateRequest(ctx, options)
		},
		responder: client.getMultiplePagesFailureUriHandleResponse,
		errorer:   client.getMultiplePagesFailureUriHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesFailureUriCreateRequest creates the GetMultiplePagesFailureURI request.
func (client *PagingClient) getMultiplePagesFailureUriCreateRequest(ctx context.Context, options *PagingGetMultiplePagesFailureURIOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFailureUriHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *PagingClient) getMultiplePagesFailureUriHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesFailureUriHandleError handles the GetMultiplePagesFailureURI error response.
func (client *PagingClient) getMultiplePagesFailureUriHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
func (client *PagingClient) GetMultiplePagesFragmentNextLink(apiVersion string, tenant string, options *PagingGetMultiplePagesFragmentNextLinkOptions) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesFragmentNextLinkCreateRequest(ctx, apiVersion, tenant, options)
		},
		responder: client.getMultiplePagesFragmentNextLinkHandleResponse,
		errorer:   client.getMultiplePagesFragmentNextLinkHandleError,
		advancer: func(ctx context.Context, resp OdataProductResultResponse) (*azcore.Request, error) {
			return client.nextFragmentCreateRequest(ctx, apiVersion, tenant, *resp.OdataProductResult.OdataNextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *PagingClient) getMultiplePagesFragmentNextLinkCreateRequest(ctx context.Context, apiVersion string, tenant string, options *PagingGetMultiplePagesFragmentNextLinkOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", apiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *PagingClient) getMultiplePagesFragmentNextLinkHandleResponse(resp *azcore.Response) (OdataProductResultResponse, error) {
	var val *OdataProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return OdataProductResultResponse{}, err
	}
	return OdataProductResultResponse{RawResponse: resp.Response, OdataProductResult: val}, nil
}

// getMultiplePagesFragmentNextLinkHandleError handles the GetMultiplePagesFragmentNextLink error response.
func (client *PagingClient) getMultiplePagesFragmentNextLinkHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with parameters grouped
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx, customParameterGroup)
		},
		responder: client.getMultiplePagesFragmentWithGroupingNextLinkHandleResponse,
		errorer:   client.getMultiplePagesFragmentWithGroupingNextLinkHandleError,
		advancer: func(ctx context.Context, resp OdataProductResultResponse) (*azcore.Request, error) {
			return client.nextFragmentWithGroupingCreateRequest(ctx, *resp.OdataProductResult.OdataNextLink, customParameterGroup)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx context.Context, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *azcore.Response) (OdataProductResultResponse, error) {
	var val *OdataProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return OdataProductResultResponse{}, err
	}
	return OdataProductResultResponse{RawResponse: resp.Response, OdataProductResult: val}, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleError handles the GetMultiplePagesFragmentWithGroupingNextLink error response.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// BeginGetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) BeginGetMultiplePagesLro(ctx context.Context, options *PagingBeginGetMultiplePagesLroOptions) (ProductResultPagerPollerResponse, error) {
	resp, err := client.getMultiplePagesLro(ctx, options)
	if err != nil {
		return ProductResultPagerPollerResponse{}, err
	}
	result := ProductResultPagerPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("PagingClient.GetMultiplePagesLro", "", resp, client.getMultiplePagesLroHandleError)
	if err != nil {
		return ProductResultPagerPollerResponse{}, err
	}
	poller := &productResultPagerPoller{
		pt: pt,
		errHandler: func(resp *azcore.Response) error {
			if resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
				return nil
			}
			return client.getMultiplePagesLroHandleError(resp)
		},
		respHandler: func(resp *azcore.Response) (ProductResultResponse, error) {
			var val *ProductResult
			if err := resp.UnmarshalAsJSON(&val); err != nil {
				return ProductResultResponse{}, err
			}
			return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
		},
		statusCodes: []int{http.StatusOK, http.StatusAccepted, http.StatusNoContent},
		pipeline:    client.con.Pipeline(),
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (ProductResultPager, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeGetMultiplePagesLro creates a new ProductResultPagerPoller from the specified resume token.
// token - The value must come from a previous call to ProductResultPagerPoller.ResumeToken().
func (client *PagingClient) ResumeGetMultiplePagesLro(token string) (ProductResultPagerPoller, error) {
	pt, err := armcore.NewPollerFromResumeToken("PagingClient.GetMultiplePagesLro", token, client.getMultiplePagesLroHandleError)
	if err != nil {
		return nil, err
	}
	return &productResultPagerPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}, nil
}

// GetMultiplePagesLro - A long-running paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) getMultiplePagesLro(ctx context.Context, options *PagingBeginGetMultiplePagesLroOptions) (*azcore.Response, error) {
	req, err := client.getMultiplePagesLroCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, client.getMultiplePagesLroHandleError(resp)
	}
	return resp, nil
}

// getMultiplePagesLroCreateRequest creates the GetMultiplePagesLro request.
func (client *PagingClient) getMultiplePagesLroCreateRequest(ctx context.Context, options *PagingBeginGetMultiplePagesLroOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/lro"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesLroHandleResponse handles the GetMultiplePagesLro response.
func (client *PagingClient) getMultiplePagesLroHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesLroHandleError handles the GetMultiplePagesLro error response.
func (client *PagingClient) getMultiplePagesLroHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response including a nextLink that
// has 10 pages
func (client *PagingClient) GetMultiplePagesRetryFirst(options *PagingGetMultiplePagesRetryFirstOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesRetryFirstCreateRequest(ctx, options)
		},
		responder: client.getMultiplePagesRetryFirstHandleResponse,
		errorer:   client.getMultiplePagesRetryFirstHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *PagingClient) getMultiplePagesRetryFirstCreateRequest(ctx context.Context, options *PagingGetMultiplePagesRetryFirstOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *PagingClient) getMultiplePagesRetryFirstHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesRetryFirstHandleError handles the GetMultiplePagesRetryFirst error response.
func (client *PagingClient) getMultiplePagesRetryFirstHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails first with 500. The client should
// retry and finish all 10 pages eventually.
func (client *PagingClient) GetMultiplePagesRetrySecond(options *PagingGetMultiplePagesRetrySecondOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesRetrySecondCreateRequest(ctx, options)
		},
		responder: client.getMultiplePagesRetrySecondHandleResponse,
		errorer:   client.getMultiplePagesRetrySecondHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *PagingClient) getMultiplePagesRetrySecondCreateRequest(ctx context.Context, options *PagingGetMultiplePagesRetrySecondOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *PagingClient) getMultiplePagesRetrySecondHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesRetrySecondHandleError handles the GetMultiplePagesRetrySecond error response.
func (client *PagingClient) getMultiplePagesRetrySecondHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
func (client *PagingClient) GetMultiplePagesWithOffset(pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getMultiplePagesWithOffsetCreateRequest(ctx, pagingGetMultiplePagesWithOffsetOptions)
		},
		responder: client.getMultiplePagesWithOffsetHandleResponse,
		errorer:   client.getMultiplePagesWithOffsetHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *PagingClient) getMultiplePagesWithOffsetCreateRequest(ctx context.Context, pagingGetMultiplePagesWithOffsetOptions PagingGetMultiplePagesWithOffsetOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(pagingGetMultiplePagesWithOffsetOptions.Offset), 10)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if pagingGetMultiplePagesWithOffsetOptions.ClientRequestId != nil {
		req.Header.Set("client-request-id", *pagingGetMultiplePagesWithOffsetOptions.ClientRequestId)
	}
	if pagingGetMultiplePagesWithOffsetOptions.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Maxresults), 10))
	}
	if pagingGetMultiplePagesWithOffsetOptions.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*pagingGetMultiplePagesWithOffsetOptions.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *PagingClient) getMultiplePagesWithOffsetHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getMultiplePagesWithOffsetHandleError handles the GetMultiplePagesWithOffset error response.
func (client *PagingClient) getMultiplePagesWithOffsetHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
func (client *PagingClient) GetNoItemNamePages(options *PagingGetNoItemNamePagesOptions) ProductResultValuePager {
	return &productResultValuePager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getNoItemNamePagesCreateRequest(ctx, options)
		},
		responder: client.getNoItemNamePagesHandleResponse,
		errorer:   client.getNoItemNamePagesHandleError,
		advancer: func(ctx context.Context, resp ProductResultValueResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResultValue.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *PagingClient) getNoItemNamePagesCreateRequest(ctx context.Context, options *PagingGetNoItemNamePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/noitemname"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *PagingClient) getNoItemNamePagesHandleResponse(resp *azcore.Response) (ProductResultValueResponse, error) {
	var val *ProductResultValue
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultValueResponse{}, err
	}
	return ProductResultValueResponse{RawResponse: resp.Response, ProductResultValue: val}, nil
}

// getNoItemNamePagesHandleError handles the GetNoItemNamePages error response.
func (client *PagingClient) getNoItemNamePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
func (client *PagingClient) GetNullNextLinkNamePages(ctx context.Context, options *PagingGetNullNextLinkNamePagesOptions) (ProductResultResponse, error) {
	req, err := client.getNullNextLinkNamePagesCreateRequest(ctx, options)
	if err != nil {
		return ProductResultResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return ProductResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ProductResultResponse{}, client.getNullNextLinkNamePagesHandleError(resp)
	}
	return client.getNullNextLinkNamePagesHandleResponse(resp)
}

// getNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *PagingClient) getNullNextLinkNamePagesCreateRequest(ctx context.Context, options *PagingGetNullNextLinkNamePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/nullnextlink"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *PagingClient) getNullNextLinkNamePagesHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getNullNextLinkNamePagesHandleError handles the GetNullNextLinkNamePages error response.
func (client *PagingClient) getNullNextLinkNamePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetOdataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
func (client *PagingClient) GetOdataMultiplePages(options *PagingGetOdataMultiplePagesOptions) OdataProductResultPager {
	return &odataProductResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getOdataMultiplePagesCreateRequest(ctx, options)
		},
		responder: client.getOdataMultiplePagesHandleResponse,
		errorer:   client.getOdataMultiplePagesHandleError,
		advancer: func(ctx context.Context, resp OdataProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.OdataProductResult.OdataNextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getOdataMultiplePagesCreateRequest creates the GetOdataMultiplePages request.
func (client *PagingClient) getOdataMultiplePagesCreateRequest(ctx context.Context, options *PagingGetOdataMultiplePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/odata"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	if options != nil && options.ClientRequestId != nil {
		req.Header.Set("client-request-id", *options.ClientRequestId)
	}
	if options != nil && options.Maxresults != nil {
		req.Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getOdataMultiplePagesHandleResponse handles the GetOdataMultiplePages response.
func (client *PagingClient) getOdataMultiplePagesHandleResponse(resp *azcore.Response) (OdataProductResultResponse, error) {
	var val *OdataProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return OdataProductResultResponse{}, err
	}
	return OdataProductResultResponse{RawResponse: resp.Response, OdataProductResult: val}, nil
}

// getOdataMultiplePagesHandleError handles the GetOdataMultiplePages error response.
func (client *PagingClient) getOdataMultiplePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetPagingModelWithItemNameWithXmsClientName - A paging operation that returns a paging model whose item name is is overriden by x-ms-client-name 'indexes'.
func (client *PagingClient) GetPagingModelWithItemNameWithXmsClientName(options *PagingGetPagingModelWithItemNameWithXmsClientNameOptions) ProductResultValueWithXmsClientNamePager {
	return &productResultValueWithXmsClientNamePager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getPagingModelWithItemNameWithXmsClientNameCreateRequest(ctx, options)
		},
		responder: client.getPagingModelWithItemNameWithXmsClientNameHandleResponse,
		errorer:   client.getPagingModelWithItemNameWithXmsClientNameHandleError,
		advancer: func(ctx context.Context, resp ProductResultValueWithXmsClientNameResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResultValueWithXmsClientName.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getPagingModelWithItemNameWithXmsClientNameCreateRequest creates the GetPagingModelWithItemNameWithXmsClientName request.
func (client *PagingClient) getPagingModelWithItemNameWithXmsClientNameCreateRequest(ctx context.Context, options *PagingGetPagingModelWithItemNameWithXmsClientNameOptions) (*azcore.Request, error) {
	urlPath := "/paging/itemNameWithXMSClientName"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPagingModelWithItemNameWithXmsClientNameHandleResponse handles the GetPagingModelWithItemNameWithXmsClientName response.
func (client *PagingClient) getPagingModelWithItemNameWithXmsClientNameHandleResponse(resp *azcore.Response) (ProductResultValueWithXmsClientNameResponse, error) {
	var val *ProductResultValueWithXmsClientName
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultValueWithXmsClientNameResponse{}, err
	}
	return ProductResultValueWithXmsClientNameResponse{RawResponse: resp.Response, ProductResultValueWithXmsClientName: val}, nil
}

// getPagingModelWithItemNameWithXmsClientNameHandleError handles the GetPagingModelWithItemNameWithXmsClientName error response.
func (client *PagingClient) getPagingModelWithItemNameWithXmsClientNameHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetSinglePages - A paging operation that finishes on the first call without a nextlink
func (client *PagingClient) GetSinglePages(options *PagingGetSinglePagesOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSinglePagesCreateRequest(ctx, options)
		},
		responder: client.getSinglePagesHandleResponse,
		errorer:   client.getSinglePagesHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSinglePagesCreateRequest creates the GetSinglePages request.
func (client *PagingClient) getSinglePagesCreateRequest(ctx context.Context, options *PagingGetSinglePagesOptions) (*azcore.Request, error) {
	urlPath := "/paging/single"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSinglePagesHandleResponse handles the GetSinglePages response.
func (client *PagingClient) getSinglePagesHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getSinglePagesHandleError handles the GetSinglePages error response.
func (client *PagingClient) getSinglePagesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
func (client *PagingClient) GetSinglePagesFailure(options *PagingGetSinglePagesFailureOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getSinglePagesFailureCreateRequest(ctx, options)
		},
		responder: client.getSinglePagesFailureHandleResponse,
		errorer:   client.getSinglePagesFailureHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *PagingClient) getSinglePagesFailureCreateRequest(ctx context.Context, options *PagingGetSinglePagesFailureOptions) (*azcore.Request, error) {
	urlPath := "/paging/single/failure"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *PagingClient) getSinglePagesFailureHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getSinglePagesFailureHandleError handles the GetSinglePagesFailure error response.
func (client *PagingClient) getSinglePagesFailureHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetWithQueryParams - A paging operation that includes a next operation. It has a different query parameter from it's next operation nextOperationWithQueryParams.
// Returns a ProductResult
func (client *PagingClient) GetWithQueryParams(requiredQueryParameter int32, options *PagingGetWithQueryParamsOptions) ProductResultPager {
	return &productResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.getWithQueryParamsCreateRequest(ctx, requiredQueryParameter, options)
		},
		responder: client.getWithQueryParamsHandleResponse,
		errorer:   client.getWithQueryParamsHandleError,
		advancer: func(ctx context.Context, resp ProductResultResponse) (*azcore.Request, error) {
			return client.nextOperationWithQueryParamsCreateRequest(ctx)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// getWithQueryParamsCreateRequest creates the GetWithQueryParams request.
func (client *PagingClient) getWithQueryParamsCreateRequest(ctx context.Context, requiredQueryParameter int32, options *PagingGetWithQueryParamsOptions) (*azcore.Request, error) {
	urlPath := "/paging/multiple/getWithQueryParams"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("requiredQueryParameter", strconv.FormatInt(int64(requiredQueryParameter), 10))
	query.Set("queryConstant", "true")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getWithQueryParamsHandleResponse handles the GetWithQueryParams response.
func (client *PagingClient) getWithQueryParamsHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// getWithQueryParamsHandleError handles the GetWithQueryParams error response.
func (client *PagingClient) getWithQueryParamsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// nextFragmentCreateRequest creates the NextFragment request.
func (client *PagingClient) nextFragmentCreateRequest(ctx context.Context, apiVersion string, tenant string, nextLink string) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", apiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// nextFragmentHandleResponse handles the NextFragment response.
func (client *PagingClient) nextFragmentHandleResponse(resp *azcore.Response) (OdataProductResultResponse, error) {
	var val *OdataProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return OdataProductResultResponse{}, err
	}
	return OdataProductResultResponse{RawResponse: resp.Response, OdataProductResult: val}, nil
}

// nextFragmentHandleError handles the NextFragment error response.
func (client *PagingClient) nextFragmentHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// nextFragmentWithGroupingCreateRequest creates the NextFragmentWithGrouping request.
func (client *PagingClient) nextFragmentWithGroupingCreateRequest(ctx context.Context, nextLink string, customParameterGroup CustomParameterGroup) (*azcore.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("api_version", customParameterGroup.ApiVersion)
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// nextFragmentWithGroupingHandleResponse handles the NextFragmentWithGrouping response.
func (client *PagingClient) nextFragmentWithGroupingHandleResponse(resp *azcore.Response) (OdataProductResultResponse, error) {
	var val *OdataProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return OdataProductResultResponse{}, err
	}
	return OdataProductResultResponse{RawResponse: resp.Response, OdataProductResult: val}, nil
}

// nextFragmentWithGroupingHandleError handles the NextFragmentWithGrouping error response.
func (client *PagingClient) nextFragmentWithGroupingHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// nextOperationWithQueryParamsCreateRequest creates the NextOperationWithQueryParams request.
func (client *PagingClient) nextOperationWithQueryParamsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/paging/multiple/nextOperationWithQueryParams"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("queryConstant", "true")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// nextOperationWithQueryParamsHandleResponse handles the NextOperationWithQueryParams response.
func (client *PagingClient) nextOperationWithQueryParamsHandleResponse(resp *azcore.Response) (ProductResultResponse, error) {
	var val *ProductResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ProductResultResponse{}, err
	}
	return ProductResultResponse{RawResponse: resp.Response, ProductResult: val}, nil
}

// nextOperationWithQueryParamsHandleError handles the NextOperationWithQueryParams error response.
func (client *PagingClient) nextOperationWithQueryParamsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}
