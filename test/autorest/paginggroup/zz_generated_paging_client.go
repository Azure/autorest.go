//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// PagingClient contains the methods for the Paging group.
// Don't use this type directly, use NewPagingClient() instead.
type PagingClient struct {
	pl runtime.Pipeline
}

// NewPagingClient creates a new instance of PagingClient with the specified values.
// options - pass nil to accept the default values.
func NewPagingClient(options *azcore.ClientOptions) *PagingClient {
	cp := azcore.ClientOptions{}
	if options != nil {
		cp = *options
	}
	client := &PagingClient{
		pl: runtime.NewPipeline(module, version, runtime.PipelineOptions{}, &cp),
	}
	return client
}

// FirstResponseEmpty - A paging operation whose first response's items list is empty, but still returns a next link. Second
// (and final) call, will give you an items list of 1.
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientFirstResponseEmptyOptions contains the optional parameters for the PagingClient.FirstResponseEmpty
// method.
func (client *PagingClient) FirstResponseEmpty(options *PagingClientFirstResponseEmptyOptions) *PagingClientFirstResponseEmptyPager {
	return &PagingClientFirstResponseEmptyPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.firstResponseEmptyCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientFirstResponseEmptyResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResultValue.NextLink)
		},
	}
}

// firstResponseEmptyCreateRequest creates the FirstResponseEmpty request.
func (client *PagingClient) firstResponseEmptyCreateRequest(ctx context.Context, options *PagingClientFirstResponseEmptyOptions) (*policy.Request, error) {
	urlPath := "/paging/firstResponseEmpty/1"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// firstResponseEmptyHandleResponse handles the FirstResponseEmpty response.
func (client *PagingClient) firstResponseEmptyHandleResponse(resp *http.Response) (PagingClientFirstResponseEmptyResponse, error) {
	result := PagingClientFirstResponseEmptyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResultValue); err != nil {
		return PagingClientFirstResponseEmptyResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePages - A paging operation that includes a nextLink that has 10 pages
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetMultiplePagesOptions contains the optional parameters for the PagingClient.GetMultiplePages method.
func (client *PagingClient) GetMultiplePages(options *PagingClientGetMultiplePagesOptions) *PagingClientGetMultiplePagesPager {
	return &PagingClientGetMultiplePagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getMultiplePagesCreateRequest creates the GetMultiplePages request.
func (client *PagingClient) getMultiplePagesCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header.Set("client-request-id", *options.ClientRequestID)
	}
	if options != nil && options.Maxresults != nil {
		req.Raw().Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Raw().Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesHandleResponse handles the GetMultiplePages response.
func (client *PagingClient) getMultiplePagesHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesResponse, error) {
	result := PagingClientGetMultiplePagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesFailure - A paging operation that receives a 400 on the second call
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetMultiplePagesFailureOptions contains the optional parameters for the PagingClient.GetMultiplePagesFailure
// method.
func (client *PagingClient) GetMultiplePagesFailure(options *PagingClientGetMultiplePagesFailureOptions) *PagingClientGetMultiplePagesFailurePager {
	return &PagingClientGetMultiplePagesFailurePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesFailureCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesFailureResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getMultiplePagesFailureCreateRequest creates the GetMultiplePagesFailure request.
func (client *PagingClient) getMultiplePagesFailureCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesFailureOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/failure"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFailureHandleResponse handles the GetMultiplePagesFailure response.
func (client *PagingClient) getMultiplePagesFailureHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFailureResponse, error) {
	result := PagingClientGetMultiplePagesFailureResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesFailureResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesFailureURI - A paging operation that receives an invalid nextLink
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetMultiplePagesFailureURIOptions contains the optional parameters for the PagingClient.GetMultiplePagesFailureURI
// method.
func (client *PagingClient) GetMultiplePagesFailureURI(options *PagingClientGetMultiplePagesFailureURIOptions) *PagingClientGetMultiplePagesFailureURIPager {
	return &PagingClientGetMultiplePagesFailureURIPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesFailureURICreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesFailureURIResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getMultiplePagesFailureURICreateRequest creates the GetMultiplePagesFailureURI request.
func (client *PagingClient) getMultiplePagesFailureURICreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesFailureURIOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/failureuri"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFailureURIHandleResponse handles the GetMultiplePagesFailureURI response.
func (client *PagingClient) getMultiplePagesFailureURIHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFailureURIResponse, error) {
	result := PagingClientGetMultiplePagesFailureURIResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesFailureURIResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesFragmentNextLink - A paging operation that doesn't return a full URL, just a fragment
// If the operation fails it returns an *azcore.ResponseError type.
// apiVersion - Sets the api version to use.
// tenant - Sets the tenant to use.
// options - PagingClientGetMultiplePagesFragmentNextLinkOptions contains the optional parameters for the PagingClient.GetMultiplePagesFragmentNextLink
// method.
func (client *PagingClient) GetMultiplePagesFragmentNextLink(apiVersion string, tenant string, options *PagingClientGetMultiplePagesFragmentNextLinkOptions) *PagingClientGetMultiplePagesFragmentNextLinkPager {
	return &PagingClientGetMultiplePagesFragmentNextLinkPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesFragmentNextLinkCreateRequest(ctx, apiVersion, tenant, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesFragmentNextLinkResponse) (*policy.Request, error) {
			return client.nextFragmentCreateRequest(ctx, apiVersion, tenant, *resp.ODataProductResult.ODataNextLink)
		},
	}
}

// getMultiplePagesFragmentNextLinkCreateRequest creates the GetMultiplePagesFragmentNextLink request.
func (client *PagingClient) getMultiplePagesFragmentNextLinkCreateRequest(ctx context.Context, apiVersion string, tenant string, options *PagingClientGetMultiplePagesFragmentNextLinkOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}"
	if tenant == "" {
		return nil, errors.New("parameter tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", apiVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFragmentNextLinkHandleResponse handles the GetMultiplePagesFragmentNextLink response.
func (client *PagingClient) getMultiplePagesFragmentNextLinkHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFragmentNextLinkResponse, error) {
	result := PagingClientGetMultiplePagesFragmentNextLinkResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesFragmentWithGroupingNextLink - A paging operation that doesn't return a full URL, just a fragment with
// parameters grouped
// If the operation fails it returns an *azcore.ResponseError type.
// CustomParameterGroup - CustomParameterGroup contains a group of parameters for the PagingClient.GetMultiplePagesFragmentWithGroupingNextLink
// method.
func (client *PagingClient) GetMultiplePagesFragmentWithGroupingNextLink(customParameterGroup CustomParameterGroup) *PagingClientGetMultiplePagesFragmentWithGroupingNextLinkPager {
	return &PagingClientGetMultiplePagesFragmentWithGroupingNextLinkPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx, customParameterGroup)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse) (*policy.Request, error) {
			return client.nextFragmentWithGroupingCreateRequest(ctx, *resp.ODataProductResult.ODataNextLink, customParameterGroup)
		},
	}
}

// getMultiplePagesFragmentWithGroupingNextLinkCreateRequest creates the GetMultiplePagesFragmentWithGroupingNextLink request.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkCreateRequest(ctx context.Context, customParameterGroup CustomParameterGroup) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}"
	if customParameterGroup.Tenant == "" {
		return nil, errors.New("parameter customParameterGroup.Tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", customParameterGroup.APIVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesFragmentWithGroupingNextLinkHandleResponse handles the GetMultiplePagesFragmentWithGroupingNextLink response.
func (client *PagingClient) getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse, error) {
	result := PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// BeginGetMultiplePagesLRO - A long-running paging operation that includes a nextLink that has 10 pages
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientBeginGetMultiplePagesLROOptions contains the optional parameters for the PagingClient.BeginGetMultiplePagesLRO
// method.
func (client *PagingClient) BeginGetMultiplePagesLRO(ctx context.Context, options *PagingClientBeginGetMultiplePagesLROOptions) (PagingClientGetMultiplePagesLROPollerResponse, error) {
	resp, err := client.getMultiplePagesLRO(ctx, options)
	if err != nil {
		return PagingClientGetMultiplePagesLROPollerResponse{}, err
	}
	result := PagingClientGetMultiplePagesLROPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("PagingClient.GetMultiplePagesLRO", "", resp, client.pl)
	if err != nil {
		return PagingClientGetMultiplePagesLROPollerResponse{}, err
	}
	result.Poller = &PagingClientGetMultiplePagesLROPoller{
		pt:     pt,
		client: client,
	}
	return result, nil
}

// GetMultiplePagesLRO - A long-running paging operation that includes a nextLink that has 10 pages
// If the operation fails it returns an *azcore.ResponseError type.
func (client *PagingClient) getMultiplePagesLRO(ctx context.Context, options *PagingClientBeginGetMultiplePagesLROOptions) (*http.Response, error) {
	req, err := client.getMultiplePagesLROCreateRequest(ctx, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// getMultiplePagesLROCreateRequest creates the GetMultiplePagesLRO request.
func (client *PagingClient) getMultiplePagesLROCreateRequest(ctx context.Context, options *PagingClientBeginGetMultiplePagesLROOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/lro"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header.Set("client-request-id", *options.ClientRequestID)
	}
	if options != nil && options.Maxresults != nil {
		req.Raw().Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Raw().Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesLROHandleResponse handles the GetMultiplePagesLRO response.
func (client *PagingClient) getMultiplePagesLROHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesLROResponse, error) {
	result := PagingClientGetMultiplePagesLROResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesLROResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesRetryFirst - A paging operation that fails on the first call with 500 and then retries and then get a response
// including a nextLink that has 10 pages
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetMultiplePagesRetryFirstOptions contains the optional parameters for the PagingClient.GetMultiplePagesRetryFirst
// method.
func (client *PagingClient) GetMultiplePagesRetryFirst(options *PagingClientGetMultiplePagesRetryFirstOptions) *PagingClientGetMultiplePagesRetryFirstPager {
	return &PagingClientGetMultiplePagesRetryFirstPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesRetryFirstCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesRetryFirstResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getMultiplePagesRetryFirstCreateRequest creates the GetMultiplePagesRetryFirst request.
func (client *PagingClient) getMultiplePagesRetryFirstCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesRetryFirstOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/retryfirst"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesRetryFirstHandleResponse handles the GetMultiplePagesRetryFirst response.
func (client *PagingClient) getMultiplePagesRetryFirstHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesRetryFirstResponse, error) {
	result := PagingClientGetMultiplePagesRetryFirstResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesRetryFirstResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesRetrySecond - A paging operation that includes a nextLink that has 10 pages, of which the 2nd call fails
// first with 500. The client should retry and finish all 10 pages eventually.
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetMultiplePagesRetrySecondOptions contains the optional parameters for the PagingClient.GetMultiplePagesRetrySecond
// method.
func (client *PagingClient) GetMultiplePagesRetrySecond(options *PagingClientGetMultiplePagesRetrySecondOptions) *PagingClientGetMultiplePagesRetrySecondPager {
	return &PagingClientGetMultiplePagesRetrySecondPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesRetrySecondCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesRetrySecondResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getMultiplePagesRetrySecondCreateRequest creates the GetMultiplePagesRetrySecond request.
func (client *PagingClient) getMultiplePagesRetrySecondCreateRequest(ctx context.Context, options *PagingClientGetMultiplePagesRetrySecondOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/retrysecond"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesRetrySecondHandleResponse handles the GetMultiplePagesRetrySecond response.
func (client *PagingClient) getMultiplePagesRetrySecondHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesRetrySecondResponse, error) {
	result := PagingClientGetMultiplePagesRetrySecondResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesRetrySecondResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetMultiplePagesWithOffset - A paging operation that includes a nextLink that has 10 pages
// If the operation fails it returns an *azcore.ResponseError type.
// PagingClientGetMultiplePagesWithOffsetOptions - PagingClientGetMultiplePagesWithOffsetOptions contains the optional parameters
// for the PagingClient.GetMultiplePagesWithOffset method.
func (client *PagingClient) GetMultiplePagesWithOffset(pagingClientGetMultiplePagesWithOffsetOptions PagingClientGetMultiplePagesWithOffsetOptions) *PagingClientGetMultiplePagesWithOffsetPager {
	return &PagingClientGetMultiplePagesWithOffsetPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getMultiplePagesWithOffsetCreateRequest(ctx, pagingClientGetMultiplePagesWithOffsetOptions)
		},
		advancer: func(ctx context.Context, resp PagingClientGetMultiplePagesWithOffsetResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getMultiplePagesWithOffsetCreateRequest creates the GetMultiplePagesWithOffset request.
func (client *PagingClient) getMultiplePagesWithOffsetCreateRequest(ctx context.Context, pagingClientGetMultiplePagesWithOffsetOptions PagingClientGetMultiplePagesWithOffsetOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/withpath/{offset}"
	urlPath = strings.ReplaceAll(urlPath, "{offset}", url.PathEscape(strconv.FormatInt(int64(pagingClientGetMultiplePagesWithOffsetOptions.Offset), 10)))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if pagingClientGetMultiplePagesWithOffsetOptions.ClientRequestID != nil {
		req.Raw().Header.Set("client-request-id", *pagingClientGetMultiplePagesWithOffsetOptions.ClientRequestID)
	}
	if pagingClientGetMultiplePagesWithOffsetOptions.Maxresults != nil {
		req.Raw().Header.Set("maxresults", strconv.FormatInt(int64(*pagingClientGetMultiplePagesWithOffsetOptions.Maxresults), 10))
	}
	if pagingClientGetMultiplePagesWithOffsetOptions.Timeout != nil {
		req.Raw().Header.Set("timeout", strconv.FormatInt(int64(*pagingClientGetMultiplePagesWithOffsetOptions.Timeout), 10))
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMultiplePagesWithOffsetHandleResponse handles the GetMultiplePagesWithOffset response.
func (client *PagingClient) getMultiplePagesWithOffsetHandleResponse(resp *http.Response) (PagingClientGetMultiplePagesWithOffsetResponse, error) {
	result := PagingClientGetMultiplePagesWithOffsetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetMultiplePagesWithOffsetResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetNoItemNamePages - A paging operation that must return result of the default 'value' node.
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetNoItemNamePagesOptions contains the optional parameters for the PagingClient.GetNoItemNamePages
// method.
func (client *PagingClient) GetNoItemNamePages(options *PagingClientGetNoItemNamePagesOptions) *PagingClientGetNoItemNamePagesPager {
	return &PagingClientGetNoItemNamePagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getNoItemNamePagesCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetNoItemNamePagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResultValue.NextLink)
		},
	}
}

// getNoItemNamePagesCreateRequest creates the GetNoItemNamePages request.
func (client *PagingClient) getNoItemNamePagesCreateRequest(ctx context.Context, options *PagingClientGetNoItemNamePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/noitemname"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNoItemNamePagesHandleResponse handles the GetNoItemNamePages response.
func (client *PagingClient) getNoItemNamePagesHandleResponse(resp *http.Response) (PagingClientGetNoItemNamePagesResponse, error) {
	result := PagingClientGetNoItemNamePagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResultValue); err != nil {
		return PagingClientGetNoItemNamePagesResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetNullNextLinkNamePages - A paging operation that must ignore any kind of nextLink, and stop after page 1.
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetNullNextLinkNamePagesOptions contains the optional parameters for the PagingClient.GetNullNextLinkNamePages
// method.
func (client *PagingClient) GetNullNextLinkNamePages(ctx context.Context, options *PagingClientGetNullNextLinkNamePagesOptions) (PagingClientGetNullNextLinkNamePagesResponse, error) {
	req, err := client.getNullNextLinkNamePagesCreateRequest(ctx, options)
	if err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PagingClientGetNullNextLinkNamePagesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getNullNextLinkNamePagesHandleResponse(resp)
}

// getNullNextLinkNamePagesCreateRequest creates the GetNullNextLinkNamePages request.
func (client *PagingClient) getNullNextLinkNamePagesCreateRequest(ctx context.Context, options *PagingClientGetNullNextLinkNamePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/nullnextlink"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNullNextLinkNamePagesHandleResponse handles the GetNullNextLinkNamePages response.
func (client *PagingClient) getNullNextLinkNamePagesHandleResponse(resp *http.Response) (PagingClientGetNullNextLinkNamePagesResponse, error) {
	result := PagingClientGetNullNextLinkNamePagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetODataMultiplePages - A paging operation that includes a nextLink in odata format that has 10 pages
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetODataMultiplePagesOptions contains the optional parameters for the PagingClient.GetODataMultiplePages
// method.
func (client *PagingClient) GetODataMultiplePages(options *PagingClientGetODataMultiplePagesOptions) *PagingClientGetODataMultiplePagesPager {
	return &PagingClientGetODataMultiplePagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getODataMultiplePagesCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetODataMultiplePagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ODataProductResult.ODataNextLink)
		},
	}
}

// getODataMultiplePagesCreateRequest creates the GetODataMultiplePages request.
func (client *PagingClient) getODataMultiplePagesCreateRequest(ctx context.Context, options *PagingClientGetODataMultiplePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/odata"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header.Set("client-request-id", *options.ClientRequestID)
	}
	if options != nil && options.Maxresults != nil {
		req.Raw().Header.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		req.Raw().Header.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getODataMultiplePagesHandleResponse handles the GetODataMultiplePages response.
func (client *PagingClient) getODataMultiplePagesHandleResponse(resp *http.Response) (PagingClientGetODataMultiplePagesResponse, error) {
	result := PagingClientGetODataMultiplePagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientGetODataMultiplePagesResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetPagingModelWithItemNameWithXMSClientName - A paging operation that returns a paging model whose item name is is overriden
// by x-ms-client-name 'indexes'.
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetPagingModelWithItemNameWithXMSClientNameOptions contains the optional parameters for the PagingClient.GetPagingModelWithItemNameWithXMSClientName
// method.
func (client *PagingClient) GetPagingModelWithItemNameWithXMSClientName(options *PagingClientGetPagingModelWithItemNameWithXMSClientNameOptions) *PagingClientGetPagingModelWithItemNameWithXMSClientNamePager {
	return &PagingClientGetPagingModelWithItemNameWithXMSClientNamePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getPagingModelWithItemNameWithXMSClientNameCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResultValueWithXMSClientName.NextLink)
		},
	}
}

// getPagingModelWithItemNameWithXMSClientNameCreateRequest creates the GetPagingModelWithItemNameWithXMSClientName request.
func (client *PagingClient) getPagingModelWithItemNameWithXMSClientNameCreateRequest(ctx context.Context, options *PagingClientGetPagingModelWithItemNameWithXMSClientNameOptions) (*policy.Request, error) {
	urlPath := "/paging/itemNameWithXMSClientName"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPagingModelWithItemNameWithXMSClientNameHandleResponse handles the GetPagingModelWithItemNameWithXMSClientName response.
func (client *PagingClient) getPagingModelWithItemNameWithXMSClientNameHandleResponse(resp *http.Response) (PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse, error) {
	result := PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResultValueWithXMSClientName); err != nil {
		return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetSinglePages - A paging operation that finishes on the first call without a nextlink
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetSinglePagesOptions contains the optional parameters for the PagingClient.GetSinglePages method.
func (client *PagingClient) GetSinglePages(options *PagingClientGetSinglePagesOptions) *PagingClientGetSinglePagesPager {
	return &PagingClientGetSinglePagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getSinglePagesCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetSinglePagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getSinglePagesCreateRequest creates the GetSinglePages request.
func (client *PagingClient) getSinglePagesCreateRequest(ctx context.Context, options *PagingClientGetSinglePagesOptions) (*policy.Request, error) {
	urlPath := "/paging/single"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSinglePagesHandleResponse handles the GetSinglePages response.
func (client *PagingClient) getSinglePagesHandleResponse(resp *http.Response) (PagingClientGetSinglePagesResponse, error) {
	result := PagingClientGetSinglePagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetSinglePagesResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetSinglePagesFailure - A paging operation that receives a 400 on the first call
// If the operation fails it returns an *azcore.ResponseError type.
// options - PagingClientGetSinglePagesFailureOptions contains the optional parameters for the PagingClient.GetSinglePagesFailure
// method.
func (client *PagingClient) GetSinglePagesFailure(options *PagingClientGetSinglePagesFailureOptions) *PagingClientGetSinglePagesFailurePager {
	return &PagingClientGetSinglePagesFailurePager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getSinglePagesFailureCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetSinglePagesFailureResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProductResult.NextLink)
		},
	}
}

// getSinglePagesFailureCreateRequest creates the GetSinglePagesFailure request.
func (client *PagingClient) getSinglePagesFailureCreateRequest(ctx context.Context, options *PagingClientGetSinglePagesFailureOptions) (*policy.Request, error) {
	urlPath := "/paging/single/failure"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSinglePagesFailureHandleResponse handles the GetSinglePagesFailure response.
func (client *PagingClient) getSinglePagesFailureHandleResponse(resp *http.Response) (PagingClientGetSinglePagesFailureResponse, error) {
	result := PagingClientGetSinglePagesFailureResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetSinglePagesFailureResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// GetWithQueryParams - A paging operation that includes a next operation. It has a different query parameter from it's next
// operation nextOperationWithQueryParams. Returns a ProductResult
// If the operation fails it returns an *azcore.ResponseError type.
// requiredQueryParameter - A required integer query parameter. Put in value '100' to pass test.
// options - PagingClientGetWithQueryParamsOptions contains the optional parameters for the PagingClient.GetWithQueryParams
// method.
func (client *PagingClient) GetWithQueryParams(requiredQueryParameter int32, options *PagingClientGetWithQueryParamsOptions) *PagingClientGetWithQueryParamsPager {
	return &PagingClientGetWithQueryParamsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getWithQueryParamsCreateRequest(ctx, requiredQueryParameter, options)
		},
		advancer: func(ctx context.Context, resp PagingClientGetWithQueryParamsResponse) (*policy.Request, error) {
			return client.nextOperationWithQueryParamsCreateRequest(ctx)
		},
	}
}

// getWithQueryParamsCreateRequest creates the GetWithQueryParams request.
func (client *PagingClient) getWithQueryParamsCreateRequest(ctx context.Context, requiredQueryParameter int32, options *PagingClientGetWithQueryParamsOptions) (*policy.Request, error) {
	urlPath := "/paging/multiple/getWithQueryParams"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("requiredQueryParameter", strconv.FormatInt(int64(requiredQueryParameter), 10))
	reqQP.Set("queryConstant", "true")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWithQueryParamsHandleResponse handles the GetWithQueryParams response.
func (client *PagingClient) getWithQueryParamsHandleResponse(resp *http.Response) (PagingClientGetWithQueryParamsResponse, error) {
	result := PagingClientGetWithQueryParamsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientGetWithQueryParamsResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// nextFragmentCreateRequest creates the NextFragment request.
func (client *PagingClient) nextFragmentCreateRequest(ctx context.Context, apiVersion string, tenant string, nextLink string) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragment/{tenant}/{nextLink}"
	if tenant == "" {
		return nil, errors.New("parameter tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", apiVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// nextFragmentHandleResponse handles the NextFragment response.
func (client *PagingClient) nextFragmentHandleResponse(resp *http.Response) (PagingClientNextFragmentResponse, error) {
	result := PagingClientNextFragmentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientNextFragmentResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// nextFragmentWithGroupingCreateRequest creates the NextFragmentWithGrouping request.
func (client *PagingClient) nextFragmentWithGroupingCreateRequest(ctx context.Context, nextLink string, customParameterGroup CustomParameterGroup) (*policy.Request, error) {
	urlPath := "/paging/multiple/fragmentwithgrouping/{tenant}/{nextLink}"
	if customParameterGroup.Tenant == "" {
		return nil, errors.New("parameter customParameterGroup.Tenant cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tenant}", url.PathEscape(customParameterGroup.Tenant))
	urlPath = strings.ReplaceAll(urlPath, "{nextLink}", nextLink)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api_version", customParameterGroup.APIVersion)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// nextFragmentWithGroupingHandleResponse handles the NextFragmentWithGrouping response.
func (client *PagingClient) nextFragmentWithGroupingHandleResponse(resp *http.Response) (PagingClientNextFragmentWithGroupingResponse, error) {
	result := PagingClientNextFragmentWithGroupingResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ODataProductResult); err != nil {
		return PagingClientNextFragmentWithGroupingResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}

// nextOperationWithQueryParamsCreateRequest creates the NextOperationWithQueryParams request.
func (client *PagingClient) nextOperationWithQueryParamsCreateRequest(ctx context.Context) (*policy.Request, error) {
	urlPath := "/paging/multiple/nextOperationWithQueryParams"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("queryConstant", "true")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// nextOperationWithQueryParamsHandleResponse handles the NextOperationWithQueryParams response.
func (client *PagingClient) nextOperationWithQueryParamsHandleResponse(resp *http.Response) (PagingClientNextOperationWithQueryParamsResponse, error) {
	result := PagingClientNextOperationWithQueryParamsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProductResult); err != nil {
		return PagingClientNextOperationWithQueryParamsResponse{}, runtime.NewResponseError(resp)
	}
	return result, nil
}
