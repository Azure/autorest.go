//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package paginggroup

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// PagingClientFirstResponseEmptyPager provides operations for iterating over paged responses.
type PagingClientFirstResponseEmptyPager struct {
	client    *PagingClient
	current   PagingClientFirstResponseEmptyResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientFirstResponseEmptyResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientFirstResponseEmptyPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResultValue.NextLink == nil || len(*p.current.ProductResultValue.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientFirstResponseEmptyPager) NextPage(ctx context.Context) (PagingClientFirstResponseEmptyResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientFirstResponseEmptyResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientFirstResponseEmptyResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientFirstResponseEmptyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientFirstResponseEmptyResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.firstResponseEmptyHandleResponse(resp)
	if err != nil {
		return PagingClientFirstResponseEmptyResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesFailurePager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesFailurePager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesFailureResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesFailureResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesFailurePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesFailurePager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesFailureResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesFailureResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesFailureResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesFailureResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesFailureResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesFailureHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesFailureResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesFailureURIPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesFailureURIPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesFailureURIResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesFailureURIResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesFailureURIPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesFailureURIPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesFailureURIResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesFailureURIResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesFailureURIResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesFailureURIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesFailureURIResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesFailureURIHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesFailureURIResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesFragmentNextLinkPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesFragmentNextLinkPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesFragmentNextLinkResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesFragmentNextLinkResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesFragmentNextLinkPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ODataProductResult.ODataNextLink == nil || len(*p.current.ODataProductResult.ODataNextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesFragmentNextLinkPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesFragmentNextLinkResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesFragmentNextLinkHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesFragmentNextLinkResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesFragmentWithGroupingNextLinkPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesFragmentWithGroupingNextLinkPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesFragmentWithGroupingNextLinkPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ODataProductResult.ODataNextLink == nil || len(*p.current.ODataProductResult.ODataNextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesFragmentWithGroupingNextLinkPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesFragmentWithGroupingNextLinkHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesFragmentWithGroupingNextLinkResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesLROPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesLROPager struct {
	client  *PagingClient
	current PagingClientGetMultiplePagesLROResponse
	second  bool
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesLROPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesLROPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesLROResponse, error) {
	if !p.second {
		p.second = true
		return p.current, nil
	} else if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesLROResponse{}, errors.New("no more pages")
		}
	}
	req, err := runtime.NewRequest(ctx, http.MethodGet, *p.current.ProductResult.NextLink)
	if err != nil {
		return PagingClientGetMultiplePagesLROResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesLROResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {

		return PagingClientGetMultiplePagesLROResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesLROHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesLROResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesRetryFirstPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesRetryFirstPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesRetryFirstResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesRetryFirstResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesRetryFirstPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesRetryFirstPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesRetryFirstResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesRetryFirstResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesRetryFirstResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesRetryFirstResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesRetryFirstResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesRetryFirstHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesRetryFirstResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesRetrySecondPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesRetrySecondPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesRetrySecondResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesRetrySecondResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesRetrySecondPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesRetrySecondPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesRetrySecondResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesRetrySecondResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesRetrySecondResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesRetrySecondResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesRetrySecondResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesRetrySecondHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesRetrySecondResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetMultiplePagesWithOffsetPager provides operations for iterating over paged responses.
type PagingClientGetMultiplePagesWithOffsetPager struct {
	client    *PagingClient
	current   PagingClientGetMultiplePagesWithOffsetResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetMultiplePagesWithOffsetResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetMultiplePagesWithOffsetPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetMultiplePagesWithOffsetPager) NextPage(ctx context.Context) (PagingClientGetMultiplePagesWithOffsetResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetMultiplePagesWithOffsetResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetMultiplePagesWithOffsetResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetMultiplePagesWithOffsetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetMultiplePagesWithOffsetResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getMultiplePagesWithOffsetHandleResponse(resp)
	if err != nil {
		return PagingClientGetMultiplePagesWithOffsetResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetNoItemNamePagesPager provides operations for iterating over paged responses.
type PagingClientGetNoItemNamePagesPager struct {
	client    *PagingClient
	current   PagingClientGetNoItemNamePagesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetNoItemNamePagesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetNoItemNamePagesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResultValue.NextLink == nil || len(*p.current.ProductResultValue.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetNoItemNamePagesPager) NextPage(ctx context.Context) (PagingClientGetNoItemNamePagesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetNoItemNamePagesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetNoItemNamePagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetNoItemNamePagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetNoItemNamePagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getNoItemNamePagesHandleResponse(resp)
	if err != nil {
		return PagingClientGetNoItemNamePagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetNullNextLinkNamePagesPager provides operations for iterating over paged responses.
type PagingClientGetNullNextLinkNamePagesPager struct {
	client    *PagingClient
	current   PagingClientGetNullNextLinkNamePagesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetNullNextLinkNamePagesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetNullNextLinkNamePagesPager) NextPage(ctx context.Context) (PagingClientGetNullNextLinkNamePagesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PagingClientGetNullNextLinkNamePagesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetNullNextLinkNamePagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getNullNextLinkNamePagesHandleResponse(resp)
	if err != nil {
		return PagingClientGetNullNextLinkNamePagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetODataMultiplePagesPager provides operations for iterating over paged responses.
type PagingClientGetODataMultiplePagesPager struct {
	client    *PagingClient
	current   PagingClientGetODataMultiplePagesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetODataMultiplePagesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetODataMultiplePagesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ODataProductResult.ODataNextLink == nil || len(*p.current.ODataProductResult.ODataNextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetODataMultiplePagesPager) NextPage(ctx context.Context) (PagingClientGetODataMultiplePagesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetODataMultiplePagesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetODataMultiplePagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetODataMultiplePagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetODataMultiplePagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getODataMultiplePagesHandleResponse(resp)
	if err != nil {
		return PagingClientGetODataMultiplePagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetPagingModelWithItemNameWithXMSClientNamePager provides operations for iterating over paged responses.
type PagingClientGetPagingModelWithItemNameWithXMSClientNamePager struct {
	client    *PagingClient
	current   PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetPagingModelWithItemNameWithXMSClientNamePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResultValueWithXMSClientName.NextLink == nil || len(*p.current.ProductResultValueWithXMSClientName.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetPagingModelWithItemNameWithXMSClientNamePager) NextPage(ctx context.Context) (PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getPagingModelWithItemNameWithXMSClientNameHandleResponse(resp)
	if err != nil {
		return PagingClientGetPagingModelWithItemNameWithXMSClientNameResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetSinglePagesFailurePager provides operations for iterating over paged responses.
type PagingClientGetSinglePagesFailurePager struct {
	client    *PagingClient
	current   PagingClientGetSinglePagesFailureResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetSinglePagesFailureResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetSinglePagesFailurePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetSinglePagesFailurePager) NextPage(ctx context.Context) (PagingClientGetSinglePagesFailureResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetSinglePagesFailureResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetSinglePagesFailureResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetSinglePagesFailureResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetSinglePagesFailureResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getSinglePagesFailureHandleResponse(resp)
	if err != nil {
		return PagingClientGetSinglePagesFailureResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetSinglePagesPager provides operations for iterating over paged responses.
type PagingClientGetSinglePagesPager struct {
	client    *PagingClient
	current   PagingClientGetSinglePagesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetSinglePagesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetSinglePagesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetSinglePagesPager) NextPage(ctx context.Context) (PagingClientGetSinglePagesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetSinglePagesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetSinglePagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetSinglePagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetSinglePagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getSinglePagesHandleResponse(resp)
	if err != nil {
		return PagingClientGetSinglePagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientGetWithQueryParamsPager provides operations for iterating over paged responses.
type PagingClientGetWithQueryParamsPager struct {
	client    *PagingClient
	current   PagingClientGetWithQueryParamsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientGetWithQueryParamsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientGetWithQueryParamsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductResult.NextLink == nil || len(*p.current.ProductResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientGetWithQueryParamsPager) NextPage(ctx context.Context) (PagingClientGetWithQueryParamsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientGetWithQueryParamsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientGetWithQueryParamsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientGetWithQueryParamsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientGetWithQueryParamsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getWithQueryParamsHandleResponse(resp)
	if err != nil {
		return PagingClientGetWithQueryParamsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientNextFragmentPager provides operations for iterating over paged responses.
type PagingClientNextFragmentPager struct {
	client    *PagingClient
	current   PagingClientNextFragmentResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientNextFragmentResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientNextFragmentPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ODataProductResult.ODataNextLink == nil || len(*p.current.ODataProductResult.ODataNextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientNextFragmentPager) NextPage(ctx context.Context) (PagingClientNextFragmentResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientNextFragmentResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientNextFragmentResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientNextFragmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientNextFragmentResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.nextFragmentHandleResponse(resp)
	if err != nil {
		return PagingClientNextFragmentResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientNextFragmentWithGroupingPager provides operations for iterating over paged responses.
type PagingClientNextFragmentWithGroupingPager struct {
	client    *PagingClient
	current   PagingClientNextFragmentWithGroupingResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PagingClientNextFragmentWithGroupingResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientNextFragmentWithGroupingPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ODataProductResult.ODataNextLink == nil || len(*p.current.ODataProductResult.ODataNextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PagingClientNextFragmentWithGroupingPager) NextPage(ctx context.Context) (PagingClientNextFragmentWithGroupingResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PagingClientNextFragmentWithGroupingResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientNextFragmentWithGroupingResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientNextFragmentWithGroupingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientNextFragmentWithGroupingResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.nextFragmentWithGroupingHandleResponse(resp)
	if err != nil {
		return PagingClientNextFragmentWithGroupingResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PagingClientNextOperationWithQueryParamsPager provides operations for iterating over paged responses.
type PagingClientNextOperationWithQueryParamsPager struct {
	client    *PagingClient
	current   PagingClientNextOperationWithQueryParamsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PagingClientNextOperationWithQueryParamsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PagingClientNextOperationWithQueryParamsPager) NextPage(ctx context.Context) (PagingClientNextOperationWithQueryParamsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PagingClientNextOperationWithQueryParamsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PagingClientNextOperationWithQueryParamsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PagingClientNextOperationWithQueryParamsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PagingClientNextOperationWithQueryParamsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.nextOperationWithQueryParamsHandleResponse(resp)
	if err != nil {
		return PagingClientNextOperationWithQueryParamsResponse{}, err
	}
	p.current = result
	return p.current, nil
}
