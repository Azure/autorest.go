// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
)

// XMLOperations contains the methods for the XML group.
type XMLOperations interface {
	// GetACLs - Gets storage ACLs for a container.
	GetACLs(ctx context.Context) (*SignedIDentifierArrayResponse, error)
	// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
	GetComplexTypeRefNoMeta(ctx context.Context) (*RootWithRefAndNoMetaResponse, error)
	// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
	GetComplexTypeRefWithMeta(ctx context.Context) (*RootWithRefAndMetaResponse, error)
	// GetEmptyChildElement - Gets an XML document with an empty child element.
	GetEmptyChildElement(ctx context.Context) (*BananaResponse, error)
	// GetEmptyList - Get an empty list.
	GetEmptyList(ctx context.Context) (*SlideshowResponse, error)
	// GetEmptyRootList - Gets an empty list as the root element.
	GetEmptyRootList(ctx context.Context) (*BananaArrayResponse, error)
	// GetEmptyWrappedLists - Gets some empty wrapped lists.
	GetEmptyWrappedLists(ctx context.Context) (*AppleBarrelResponse, error)
	// GetHeaders - Get strongly-typed response headers.
	GetHeaders(ctx context.Context) (*XMLGetHeadersResponse, error)
	// GetRootList - Gets a list as the root element.
	GetRootList(ctx context.Context) (*BananaArrayResponse, error)
	// GetRootListSingleItem - Gets a list with a single item.
	GetRootListSingleItem(ctx context.Context) (*BananaArrayResponse, error)
	// GetServiceProperties - Gets storage service properties.
	GetServiceProperties(ctx context.Context) (*StorageServicePropertiesResponse, error)
	// GetSimple - Get a simple XML document
	GetSimple(ctx context.Context) (*SlideshowResponse, error)
	// GetWrappedLists - Get an XML document with multiple wrapped lists
	GetWrappedLists(ctx context.Context) (*AppleBarrelResponse, error)
	// GetXMSText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language' property being 'english' and its 'content' property being 'I am text'
	GetXMSText(ctx context.Context) (*ObjectWithXMSTextPropertyResponse, error)
	// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
	JSONInput(ctx context.Context, properties JSONInput) (*http.Response, error)
	// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
	JSONOutput(ctx context.Context) (*JSONOutputResponse, error)
	// ListBlobs - Lists blobs in a storage container.
	ListBlobs(ctx context.Context) (*ListBlobsResponseResponse, error)
	// ListContainers - Lists containers in a storage account.
	ListContainers(ctx context.Context) (*ListContainersResponseResponse, error)
	// PutACLs - Puts storage ACLs for a container.
	PutACLs(ctx context.Context, properties []SignedIDentifier) (*http.Response, error)
	// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
	PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta) (*http.Response, error)
	// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
	PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta) (*http.Response, error)
	// PutEmptyChildElement - Puts a value with an empty child element.
	PutEmptyChildElement(ctx context.Context, banana Banana) (*http.Response, error)
	// PutEmptyList - Puts an empty list.
	PutEmptyList(ctx context.Context, slideshow Slideshow) (*http.Response, error)
	// PutEmptyRootList - Puts an empty list as the root element.
	PutEmptyRootList(ctx context.Context, bananas []Banana) (*http.Response, error)
	// PutEmptyWrappedLists - Puts some empty wrapped lists.
	PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel) (*http.Response, error)
	// PutRootList - Puts a list as the root element.
	PutRootList(ctx context.Context, bananas []Banana) (*http.Response, error)
	// PutRootListSingleItem - Puts a list with a single item.
	PutRootListSingleItem(ctx context.Context, bananas []Banana) (*http.Response, error)
	// PutServiceProperties - Puts storage service properties.
	PutServiceProperties(ctx context.Context, properties StorageServiceProperties) (*http.Response, error)
	// PutSimple - Put a simple XML document
	PutSimple(ctx context.Context, slideshow Slideshow) (*http.Response, error)
	// PutWrappedLists - Put an XML document with multiple wrapped lists
	PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel) (*http.Response, error)
}

// XMLClient implements the XMLOperations interface.
// Don't use this type directly, use NewXMLClient() instead.
type XMLClient struct {
	*Client
}

// NewXMLClient creates a new instance of XMLClient with the specified values.
func NewXMLClient(c *Client) XMLOperations {
	return &XMLClient{Client: c}
}

// Do invokes the Do() method on the pipeline associated with this client.
func (client *XMLClient) Do(req *azcore.Request) (*azcore.Response, error) {
	return client.p.Do(req)
}

// GetACLs - Gets storage ACLs for a container.
func (client *XMLClient) GetACLs(ctx context.Context) (*SignedIDentifierArrayResponse, error) {
	req, err := client.GetACLsCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetACLsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetACLsCreateRequest creates the GetACLs request.
func (client *XMLClient) GetACLsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("comp", "acl")
	query.Set("restype", "container")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// GetACLsHandleResponse handles the GetACLs response.
func (client *XMLClient) GetACLsHandleResponse(resp *azcore.Response) (*SignedIDentifierArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetACLsHandleError(resp)
	}
	result := SignedIDentifierArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// GetACLsHandleError handles the GetACLs error response.
func (client *XMLClient) GetACLsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
func (client *XMLClient) GetComplexTypeRefNoMeta(ctx context.Context) (*RootWithRefAndNoMetaResponse, error) {
	req, err := client.GetComplexTypeRefNoMetaCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetComplexTypeRefNoMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *XMLClient) GetComplexTypeRefNoMetaCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *XMLClient) GetComplexTypeRefNoMetaHandleResponse(resp *azcore.Response) (*RootWithRefAndNoMetaResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexTypeRefNoMetaHandleError(resp)
	}
	result := RootWithRefAndNoMetaResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.RootWithRefAndNoMeta)
}

// GetComplexTypeRefNoMetaHandleError handles the GetComplexTypeRefNoMeta error response.
func (client *XMLClient) GetComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
func (client *XMLClient) GetComplexTypeRefWithMeta(ctx context.Context) (*RootWithRefAndMetaResponse, error) {
	req, err := client.GetComplexTypeRefWithMetaCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetComplexTypeRefWithMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *XMLClient) GetComplexTypeRefWithMetaCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *XMLClient) GetComplexTypeRefWithMetaHandleResponse(resp *azcore.Response) (*RootWithRefAndMetaResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetComplexTypeRefWithMetaHandleError(resp)
	}
	result := RootWithRefAndMetaResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.RootWithRefAndMeta)
}

// GetComplexTypeRefWithMetaHandleError handles the GetComplexTypeRefWithMeta error response.
func (client *XMLClient) GetComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
func (client *XMLClient) GetEmptyChildElement(ctx context.Context) (*BananaResponse, error) {
	req, err := client.GetEmptyChildElementCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetEmptyChildElementHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *XMLClient) GetEmptyChildElementCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *XMLClient) GetEmptyChildElementHandleResponse(resp *azcore.Response) (*BananaResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetEmptyChildElementHandleError(resp)
	}
	result := BananaResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Banana)
}

// GetEmptyChildElementHandleError handles the GetEmptyChildElement error response.
func (client *XMLClient) GetEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyList - Get an empty list.
func (client *XMLClient) GetEmptyList(ctx context.Context) (*SlideshowResponse, error) {
	req, err := client.GetEmptyListCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetEmptyListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetEmptyListCreateRequest creates the GetEmptyList request.
func (client *XMLClient) GetEmptyListCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetEmptyListHandleResponse handles the GetEmptyList response.
func (client *XMLClient) GetEmptyListHandleResponse(resp *azcore.Response) (*SlideshowResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetEmptyListHandleError(resp)
	}
	result := SlideshowResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Slideshow)
}

// GetEmptyListHandleError handles the GetEmptyList error response.
func (client *XMLClient) GetEmptyListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyRootList - Gets an empty list as the root element.
func (client *XMLClient) GetEmptyRootList(ctx context.Context) (*BananaArrayResponse, error) {
	req, err := client.GetEmptyRootListCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetEmptyRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *XMLClient) GetEmptyRootListCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *XMLClient) GetEmptyRootListHandleResponse(resp *azcore.Response) (*BananaArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetEmptyRootListHandleError(resp)
	}
	result := BananaArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// GetEmptyRootListHandleError handles the GetEmptyRootList error response.
func (client *XMLClient) GetEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
func (client *XMLClient) GetEmptyWrappedLists(ctx context.Context) (*AppleBarrelResponse, error) {
	req, err := client.GetEmptyWrappedListsCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetEmptyWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *XMLClient) GetEmptyWrappedListsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *XMLClient) GetEmptyWrappedListsHandleResponse(resp *azcore.Response) (*AppleBarrelResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetEmptyWrappedListsHandleError(resp)
	}
	result := AppleBarrelResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.AppleBarrel)
}

// GetEmptyWrappedListsHandleError handles the GetEmptyWrappedLists error response.
func (client *XMLClient) GetEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetHeaders - Get strongly-typed response headers.
func (client *XMLClient) GetHeaders(ctx context.Context) (*XMLGetHeadersResponse, error) {
	req, err := client.GetHeadersCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetHeadersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetHeadersCreateRequest creates the GetHeaders request.
func (client *XMLClient) GetHeadersCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/headers"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetHeadersHandleResponse handles the GetHeaders response.
func (client *XMLClient) GetHeadersHandleResponse(resp *azcore.Response) (*XMLGetHeadersResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetHeadersHandleError(resp)
	}
	result := XMLGetHeadersResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return &result, nil
}

// GetHeadersHandleError handles the GetHeaders error response.
func (client *XMLClient) GetHeadersHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetRootList - Gets a list as the root element.
func (client *XMLClient) GetRootList(ctx context.Context) (*BananaArrayResponse, error) {
	req, err := client.GetRootListCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetRootListCreateRequest creates the GetRootList request.
func (client *XMLClient) GetRootListCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetRootListHandleResponse handles the GetRootList response.
func (client *XMLClient) GetRootListHandleResponse(resp *azcore.Response) (*BananaArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetRootListHandleError(resp)
	}
	result := BananaArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// GetRootListHandleError handles the GetRootList error response.
func (client *XMLClient) GetRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetRootListSingleItem - Gets a list with a single item.
func (client *XMLClient) GetRootListSingleItem(ctx context.Context) (*BananaArrayResponse, error) {
	req, err := client.GetRootListSingleItemCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetRootListSingleItemHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *XMLClient) GetRootListSingleItemCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *XMLClient) GetRootListSingleItemHandleResponse(resp *azcore.Response) (*BananaArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetRootListSingleItemHandleError(resp)
	}
	result := BananaArrayResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result)
}

// GetRootListSingleItemHandleError handles the GetRootListSingleItem error response.
func (client *XMLClient) GetRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetServiceProperties - Gets storage service properties.
func (client *XMLClient) GetServiceProperties(ctx context.Context) (*StorageServicePropertiesResponse, error) {
	req, err := client.GetServicePropertiesCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetServicePropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *XMLClient) GetServicePropertiesCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("comp", "properties")
	query.Set("restype", "service")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// GetServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *XMLClient) GetServicePropertiesHandleResponse(resp *azcore.Response) (*StorageServicePropertiesResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetServicePropertiesHandleError(resp)
	}
	result := StorageServicePropertiesResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.StorageServiceProperties)
}

// GetServicePropertiesHandleError handles the GetServiceProperties error response.
func (client *XMLClient) GetServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetSimple - Get a simple XML document
func (client *XMLClient) GetSimple(ctx context.Context) (*SlideshowResponse, error) {
	req, err := client.GetSimpleCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetSimpleHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetSimpleCreateRequest creates the GetSimple request.
func (client *XMLClient) GetSimpleCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetSimpleHandleResponse handles the GetSimple response.
func (client *XMLClient) GetSimpleHandleResponse(resp *azcore.Response) (*SlideshowResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetSimpleHandleError(resp)
	}
	result := SlideshowResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Slideshow)
}

// GetSimpleHandleError handles the GetSimple error response.
func (client *XMLClient) GetSimpleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
func (client *XMLClient) GetWrappedLists(ctx context.Context) (*AppleBarrelResponse, error) {
	req, err := client.GetWrappedListsCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *XMLClient) GetWrappedListsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *XMLClient) GetWrappedListsHandleResponse(resp *azcore.Response) (*AppleBarrelResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetWrappedListsHandleError(resp)
	}
	result := AppleBarrelResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.AppleBarrel)
}

// GetWrappedListsHandleError handles the GetWrappedLists error response.
func (client *XMLClient) GetWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// GetXMSText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language' property being 'english' and its 'content' property being 'I am text'
func (client *XMLClient) GetXMSText(ctx context.Context) (*ObjectWithXMSTextPropertyResponse, error) {
	req, err := client.GetXMSTextCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.GetXMSTextHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// GetXMSTextCreateRequest creates the GetXMSText request.
func (client *XMLClient) GetXMSTextCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/x-ms-text"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// GetXMSTextHandleResponse handles the GetXMSText response.
func (client *XMLClient) GetXMSTextHandleResponse(resp *azcore.Response) (*ObjectWithXMSTextPropertyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.GetXMSTextHandleError(resp)
	}
	result := ObjectWithXMSTextPropertyResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.Data)
}

// GetXMSTextHandleError handles the GetXMSText error response.
func (client *XMLClient) GetXMSTextHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
func (client *XMLClient) JSONInput(ctx context.Context, properties JSONInput) (*http.Response, error) {
	req, err := client.JSONInputCreateRequest(ctx, properties)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.JSONInputHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// JSONInputCreateRequest creates the JSONInput request.
func (client *XMLClient) JSONInputCreateRequest(ctx context.Context, properties JSONInput) (*azcore.Request, error) {
	urlPath := "/xml/jsoninput"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsJSON(properties)
}

// JSONInputHandleResponse handles the JSONInput response.
func (client *XMLClient) JSONInputHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.JSONInputHandleError(resp)
	}
	return resp.Response, nil
}

// JSONInputHandleError handles the JSONInput error response.
func (client *XMLClient) JSONInputHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
func (client *XMLClient) JSONOutput(ctx context.Context) (*JSONOutputResponse, error) {
	req, err := client.JSONOutputCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.JSONOutputHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// JSONOutputCreateRequest creates the JSONOutput request.
func (client *XMLClient) JSONOutputCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/jsonoutput"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// JSONOutputHandleResponse handles the JSONOutput response.
func (client *XMLClient) JSONOutputHandleResponse(resp *azcore.Response) (*JSONOutputResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.JSONOutputHandleError(resp)
	}
	result := JSONOutputResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.JSONOutput)
}

// JSONOutputHandleError handles the JSONOutput error response.
func (client *XMLClient) JSONOutputHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListBlobs - Lists blobs in a storage container.
func (client *XMLClient) ListBlobs(ctx context.Context) (*ListBlobsResponseResponse, error) {
	req, err := client.ListBlobsCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.ListBlobsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListBlobsCreateRequest creates the ListBlobs request.
func (client *XMLClient) ListBlobsCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("comp", "list")
	query.Set("restype", "container")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// ListBlobsHandleResponse handles the ListBlobs response.
func (client *XMLClient) ListBlobsHandleResponse(resp *azcore.Response) (*ListBlobsResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListBlobsHandleError(resp)
	}
	result := ListBlobsResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// ListBlobsHandleError handles the ListBlobs error response.
func (client *XMLClient) ListBlobsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// ListContainers - Lists containers in a storage account.
func (client *XMLClient) ListContainers(ctx context.Context) (*ListContainersResponseResponse, error) {
	req, err := client.ListContainersCreateRequest(ctx)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.ListContainersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ListContainersCreateRequest creates the ListContainers request.
func (client *XMLClient) ListContainersCreateRequest(ctx context.Context) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("comp", "list")
	req.URL.RawQuery = query.Encode()
	return req, nil
}

// ListContainersHandleResponse handles the ListContainers response.
func (client *XMLClient) ListContainersHandleResponse(resp *azcore.Response) (*ListContainersResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.ListContainersHandleError(resp)
	}
	result := ListContainersResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// ListContainersHandleError handles the ListContainers error response.
func (client *XMLClient) ListContainersHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutACLs - Puts storage ACLs for a container.
func (client *XMLClient) PutACLs(ctx context.Context, properties []SignedIDentifier) (*http.Response, error) {
	req, err := client.PutACLsCreateRequest(ctx, properties)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutACLsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutACLsCreateRequest creates the PutACLs request.
func (client *XMLClient) PutACLsCreateRequest(ctx context.Context, properties []SignedIDentifier) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("comp", "acl")
	query.Set("restype", "container")
	req.URL.RawQuery = query.Encode()
	type wrapper struct {
		XMLName    xml.Name            `xml:"SignedIdentifiers"`
		Properties *[]SignedIDentifier `xml:"SignedIdentifier"`
	}
	return req, req.MarshalAsXML(wrapper{Properties: &properties})
}

// PutACLsHandleResponse handles the PutACLs response.
func (client *XMLClient) PutACLsHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutACLsHandleError(resp)
	}
	return resp.Response, nil
}

// PutACLsHandleError handles the PutACLs error response.
func (client *XMLClient) PutACLsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
func (client *XMLClient) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta) (*http.Response, error) {
	req, err := client.PutComplexTypeRefNoMetaCreateRequest(ctx, model)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutComplexTypeRefNoMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *XMLClient) PutComplexTypeRefNoMetaCreateRequest(ctx context.Context, model RootWithRefAndNoMeta) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(model)
}

// PutComplexTypeRefNoMetaHandleResponse handles the PutComplexTypeRefNoMeta response.
func (client *XMLClient) PutComplexTypeRefNoMetaHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutComplexTypeRefNoMetaHandleError(resp)
	}
	return resp.Response, nil
}

// PutComplexTypeRefNoMetaHandleError handles the PutComplexTypeRefNoMeta error response.
func (client *XMLClient) PutComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
func (client *XMLClient) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta) (*http.Response, error) {
	req, err := client.PutComplexTypeRefWithMetaCreateRequest(ctx, model)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutComplexTypeRefWithMetaHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *XMLClient) PutComplexTypeRefWithMetaCreateRequest(ctx context.Context, model RootWithRefAndMeta) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(model)
}

// PutComplexTypeRefWithMetaHandleResponse handles the PutComplexTypeRefWithMeta response.
func (client *XMLClient) PutComplexTypeRefWithMetaHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutComplexTypeRefWithMetaHandleError(resp)
	}
	return resp.Response, nil
}

// PutComplexTypeRefWithMetaHandleError handles the PutComplexTypeRefWithMeta error response.
func (client *XMLClient) PutComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyChildElement - Puts a value with an empty child element.
func (client *XMLClient) PutEmptyChildElement(ctx context.Context, banana Banana) (*http.Response, error) {
	req, err := client.PutEmptyChildElementCreateRequest(ctx, banana)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutEmptyChildElementHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *XMLClient) PutEmptyChildElementCreateRequest(ctx context.Context, banana Banana) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(banana)
}

// PutEmptyChildElementHandleResponse handles the PutEmptyChildElement response.
func (client *XMLClient) PutEmptyChildElementHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutEmptyChildElementHandleError(resp)
	}
	return resp.Response, nil
}

// PutEmptyChildElementHandleError handles the PutEmptyChildElement error response.
func (client *XMLClient) PutEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyList - Puts an empty list.
func (client *XMLClient) PutEmptyList(ctx context.Context, slideshow Slideshow) (*http.Response, error) {
	req, err := client.PutEmptyListCreateRequest(ctx, slideshow)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutEmptyListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutEmptyListCreateRequest creates the PutEmptyList request.
func (client *XMLClient) PutEmptyListCreateRequest(ctx context.Context, slideshow Slideshow) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(slideshow)
}

// PutEmptyListHandleResponse handles the PutEmptyList response.
func (client *XMLClient) PutEmptyListHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutEmptyListHandleError(resp)
	}
	return resp.Response, nil
}

// PutEmptyListHandleError handles the PutEmptyList error response.
func (client *XMLClient) PutEmptyListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyRootList - Puts an empty list as the root element.
func (client *XMLClient) PutEmptyRootList(ctx context.Context, bananas []Banana) (*http.Response, error) {
	req, err := client.PutEmptyRootListCreateRequest(ctx, bananas)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutEmptyRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *XMLClient) PutEmptyRootListCreateRequest(ctx context.Context, bananas []Banana) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name  `xml:"bananas"`
		Bananas *[]Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// PutEmptyRootListHandleResponse handles the PutEmptyRootList response.
func (client *XMLClient) PutEmptyRootListHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutEmptyRootListHandleError(resp)
	}
	return resp.Response, nil
}

// PutEmptyRootListHandleError handles the PutEmptyRootList error response.
func (client *XMLClient) PutEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
func (client *XMLClient) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel) (*http.Response, error) {
	req, err := client.PutEmptyWrappedListsCreateRequest(ctx, appleBarrel)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutEmptyWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *XMLClient) PutEmptyWrappedListsCreateRequest(ctx context.Context, appleBarrel AppleBarrel) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(appleBarrel)
}

// PutEmptyWrappedListsHandleResponse handles the PutEmptyWrappedLists response.
func (client *XMLClient) PutEmptyWrappedListsHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutEmptyWrappedListsHandleError(resp)
	}
	return resp.Response, nil
}

// PutEmptyWrappedListsHandleError handles the PutEmptyWrappedLists error response.
func (client *XMLClient) PutEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutRootList - Puts a list as the root element.
func (client *XMLClient) PutRootList(ctx context.Context, bananas []Banana) (*http.Response, error) {
	req, err := client.PutRootListCreateRequest(ctx, bananas)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutRootListHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutRootListCreateRequest creates the PutRootList request.
func (client *XMLClient) PutRootListCreateRequest(ctx context.Context, bananas []Banana) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name  `xml:"bananas"`
		Bananas *[]Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// PutRootListHandleResponse handles the PutRootList response.
func (client *XMLClient) PutRootListHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutRootListHandleError(resp)
	}
	return resp.Response, nil
}

// PutRootListHandleError handles the PutRootList error response.
func (client *XMLClient) PutRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutRootListSingleItem - Puts a list with a single item.
func (client *XMLClient) PutRootListSingleItem(ctx context.Context, bananas []Banana) (*http.Response, error) {
	req, err := client.PutRootListSingleItemCreateRequest(ctx, bananas)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutRootListSingleItemHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *XMLClient) PutRootListSingleItemCreateRequest(ctx context.Context, bananas []Banana) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name  `xml:"bananas"`
		Bananas *[]Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// PutRootListSingleItemHandleResponse handles the PutRootListSingleItem response.
func (client *XMLClient) PutRootListSingleItemHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutRootListSingleItemHandleError(resp)
	}
	return resp.Response, nil
}

// PutRootListSingleItemHandleError handles the PutRootListSingleItem error response.
func (client *XMLClient) PutRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutServiceProperties - Puts storage service properties.
func (client *XMLClient) PutServiceProperties(ctx context.Context, properties StorageServiceProperties) (*http.Response, error) {
	req, err := client.PutServicePropertiesCreateRequest(ctx, properties)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutServicePropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *XMLClient) PutServicePropertiesCreateRequest(ctx context.Context, properties StorageServiceProperties) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	query := req.URL.Query()
	query.Set("comp", "properties")
	query.Set("restype", "service")
	req.URL.RawQuery = query.Encode()
	return req, req.MarshalAsXML(properties)
}

// PutServicePropertiesHandleResponse handles the PutServiceProperties response.
func (client *XMLClient) PutServicePropertiesHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutServicePropertiesHandleError(resp)
	}
	return resp.Response, nil
}

// PutServicePropertiesHandleError handles the PutServiceProperties error response.
func (client *XMLClient) PutServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return errors.New(resp.Status)
	}
	return errors.New(string(body))
}

// PutSimple - Put a simple XML document
func (client *XMLClient) PutSimple(ctx context.Context, slideshow Slideshow) (*http.Response, error) {
	req, err := client.PutSimpleCreateRequest(ctx, slideshow)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutSimpleHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutSimpleCreateRequest creates the PutSimple request.
func (client *XMLClient) PutSimpleCreateRequest(ctx context.Context, slideshow Slideshow) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(slideshow)
}

// PutSimpleHandleResponse handles the PutSimple response.
func (client *XMLClient) PutSimpleHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutSimpleHandleError(resp)
	}
	return resp.Response, nil
}

// PutSimpleHandleError handles the PutSimple error response.
func (client *XMLClient) PutSimpleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
func (client *XMLClient) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel) (*http.Response, error) {
	req, err := client.PutWrappedListsCreateRequest(ctx, wrappedLists)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	result, err := client.PutWrappedListsHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// PutWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *XMLClient) PutWrappedListsCreateRequest(ctx context.Context, wrappedLists AppleBarrel) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.u, urlPath))
	if err != nil {
		return nil, err
	}
	return req, req.MarshalAsXML(wrappedLists)
}

// PutWrappedListsHandleResponse handles the PutWrappedLists response.
func (client *XMLClient) PutWrappedListsHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.PutWrappedListsHandleError(resp)
	}
	return resp.Response, nil
}

// PutWrappedListsHandleError handles the PutWrappedLists error response.
func (client *XMLClient) PutWrappedListsHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}
