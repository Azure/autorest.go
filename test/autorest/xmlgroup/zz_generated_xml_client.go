// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"io/ioutil"
	"net/http"
)

// XMLClient contains the methods for the XML group.
// Don't use this type directly, use NewXMLClient() instead.
type XMLClient struct {
	con *Connection
}

// NewXMLClient creates a new instance of XMLClient with the specified values.
func NewXMLClient(con *Connection) *XMLClient {
	return &XMLClient{con: con}
}

// GetACLs - Gets storage ACLs for a container.
func (client *XMLClient) GetACLs(ctx context.Context, options *XMLGetACLsOptions) (SignedIdentifierArrayResponse, error) {
	req, err := client.getACLsCreateRequest(ctx, options)
	if err != nil {
		return SignedIdentifierArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SignedIdentifierArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SignedIdentifierArrayResponse{}, client.getACLsHandleError(resp)
	}
	return client.getACLsHandleResponse(resp)
}

// getACLsCreateRequest creates the GetACLs request.
func (client *XMLClient) getACLsCreateRequest(ctx context.Context, options *XMLGetACLsOptions) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getACLsHandleResponse handles the GetACLs response.
func (client *XMLClient) getACLsHandleResponse(resp *azcore.Response) (SignedIdentifierArrayResponse, error) {
	result := SignedIdentifierArrayResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return SignedIdentifierArrayResponse{}, err
	}
	return result, nil
}

// getACLsHandleError handles the GetACLs error response.
func (client *XMLClient) getACLsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
func (client *XMLClient) GetComplexTypeRefNoMeta(ctx context.Context, options *XMLGetComplexTypeRefNoMetaOptions) (RootWithRefAndNoMetaResponse, error) {
	req, err := client.getComplexTypeRefNoMetaCreateRequest(ctx, options)
	if err != nil {
		return RootWithRefAndNoMetaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RootWithRefAndNoMetaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RootWithRefAndNoMetaResponse{}, client.getComplexTypeRefNoMetaHandleError(resp)
	}
	return client.getComplexTypeRefNoMetaHandleResponse(resp)
}

// getComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *XMLClient) getComplexTypeRefNoMetaCreateRequest(ctx context.Context, options *XMLGetComplexTypeRefNoMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleResponse(resp *azcore.Response) (RootWithRefAndNoMetaResponse, error) {
	var val *RootWithRefAndNoMeta
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return RootWithRefAndNoMetaResponse{}, err
	}
	return RootWithRefAndNoMetaResponse{RawResponse: resp.Response, RootWithRefAndNoMeta: val}, nil
}

// getComplexTypeRefNoMetaHandleError handles the GetComplexTypeRefNoMeta error response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
func (client *XMLClient) GetComplexTypeRefWithMeta(ctx context.Context, options *XMLGetComplexTypeRefWithMetaOptions) (RootWithRefAndMetaResponse, error) {
	req, err := client.getComplexTypeRefWithMetaCreateRequest(ctx, options)
	if err != nil {
		return RootWithRefAndMetaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RootWithRefAndMetaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RootWithRefAndMetaResponse{}, client.getComplexTypeRefWithMetaHandleError(resp)
	}
	return client.getComplexTypeRefWithMetaHandleResponse(resp)
}

// getComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *XMLClient) getComplexTypeRefWithMetaCreateRequest(ctx context.Context, options *XMLGetComplexTypeRefWithMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleResponse(resp *azcore.Response) (RootWithRefAndMetaResponse, error) {
	var val *RootWithRefAndMeta
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return RootWithRefAndMetaResponse{}, err
	}
	return RootWithRefAndMetaResponse{RawResponse: resp.Response, RootWithRefAndMeta: val}, nil
}

// getComplexTypeRefWithMetaHandleError handles the GetComplexTypeRefWithMeta error response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
func (client *XMLClient) GetEmptyChildElement(ctx context.Context, options *XMLGetEmptyChildElementOptions) (BananaResponse, error) {
	req, err := client.getEmptyChildElementCreateRequest(ctx, options)
	if err != nil {
		return BananaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BananaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BananaResponse{}, client.getEmptyChildElementHandleError(resp)
	}
	return client.getEmptyChildElementHandleResponse(resp)
}

// getEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *XMLClient) getEmptyChildElementCreateRequest(ctx context.Context, options *XMLGetEmptyChildElementOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *XMLClient) getEmptyChildElementHandleResponse(resp *azcore.Response) (BananaResponse, error) {
	var val *Banana
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return BananaResponse{}, err
	}
	return BananaResponse{RawResponse: resp.Response, Banana: val}, nil
}

// getEmptyChildElementHandleError handles the GetEmptyChildElement error response.
func (client *XMLClient) getEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyList - Get an empty list.
func (client *XMLClient) GetEmptyList(ctx context.Context, options *XMLGetEmptyListOptions) (SlideshowResponse, error) {
	req, err := client.getEmptyListCreateRequest(ctx, options)
	if err != nil {
		return SlideshowResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SlideshowResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SlideshowResponse{}, client.getEmptyListHandleError(resp)
	}
	return client.getEmptyListHandleResponse(resp)
}

// getEmptyListCreateRequest creates the GetEmptyList request.
func (client *XMLClient) getEmptyListCreateRequest(ctx context.Context, options *XMLGetEmptyListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyListHandleResponse handles the GetEmptyList response.
func (client *XMLClient) getEmptyListHandleResponse(resp *azcore.Response) (SlideshowResponse, error) {
	var val *Slideshow
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return SlideshowResponse{}, err
	}
	return SlideshowResponse{RawResponse: resp.Response, Slideshow: val}, nil
}

// getEmptyListHandleError handles the GetEmptyList error response.
func (client *XMLClient) getEmptyListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyRootList - Gets an empty list as the root element.
func (client *XMLClient) GetEmptyRootList(ctx context.Context, options *XMLGetEmptyRootListOptions) (BananaArrayResponse, error) {
	req, err := client.getEmptyRootListCreateRequest(ctx, options)
	if err != nil {
		return BananaArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BananaArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BananaArrayResponse{}, client.getEmptyRootListHandleError(resp)
	}
	return client.getEmptyRootListHandleResponse(resp)
}

// getEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *XMLClient) getEmptyRootListCreateRequest(ctx context.Context, options *XMLGetEmptyRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *XMLClient) getEmptyRootListHandleResponse(resp *azcore.Response) (BananaArrayResponse, error) {
	result := BananaArrayResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return BananaArrayResponse{}, err
	}
	return result, nil
}

// getEmptyRootListHandleError handles the GetEmptyRootList error response.
func (client *XMLClient) getEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
func (client *XMLClient) GetEmptyWrappedLists(ctx context.Context, options *XMLGetEmptyWrappedListsOptions) (AppleBarrelResponse, error) {
	req, err := client.getEmptyWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return AppleBarrelResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AppleBarrelResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AppleBarrelResponse{}, client.getEmptyWrappedListsHandleError(resp)
	}
	return client.getEmptyWrappedListsHandleResponse(resp)
}

// getEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *XMLClient) getEmptyWrappedListsCreateRequest(ctx context.Context, options *XMLGetEmptyWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *XMLClient) getEmptyWrappedListsHandleResponse(resp *azcore.Response) (AppleBarrelResponse, error) {
	var val *AppleBarrel
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return AppleBarrelResponse{}, err
	}
	return AppleBarrelResponse{RawResponse: resp.Response, AppleBarrel: val}, nil
}

// getEmptyWrappedListsHandleError handles the GetEmptyWrappedLists error response.
func (client *XMLClient) getEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetHeaders - Get strongly-typed response headers.
func (client *XMLClient) GetHeaders(ctx context.Context, options *XMLGetHeadersOptions) (XMLGetHeadersResponse, error) {
	req, err := client.getHeadersCreateRequest(ctx, options)
	if err != nil {
		return XMLGetHeadersResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetHeadersResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetHeadersResponse{}, client.getHeadersHandleError(resp)
	}
	return client.getHeadersHandleResponse(resp)
}

// getHeadersCreateRequest creates the GetHeaders request.
func (client *XMLClient) getHeadersCreateRequest(ctx context.Context, options *XMLGetHeadersOptions) (*azcore.Request, error) {
	urlPath := "/xml/headers"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, nil
}

// getHeadersHandleResponse handles the GetHeaders response.
func (client *XMLClient) getHeadersHandleResponse(resp *azcore.Response) (XMLGetHeadersResponse, error) {
	result := XMLGetHeadersResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return result, nil
}

// getHeadersHandleError handles the GetHeaders error response.
func (client *XMLClient) getHeadersHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetRootList - Gets a list as the root element.
func (client *XMLClient) GetRootList(ctx context.Context, options *XMLGetRootListOptions) (BananaArrayResponse, error) {
	req, err := client.getRootListCreateRequest(ctx, options)
	if err != nil {
		return BananaArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BananaArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BananaArrayResponse{}, client.getRootListHandleError(resp)
	}
	return client.getRootListHandleResponse(resp)
}

// getRootListCreateRequest creates the GetRootList request.
func (client *XMLClient) getRootListCreateRequest(ctx context.Context, options *XMLGetRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getRootListHandleResponse handles the GetRootList response.
func (client *XMLClient) getRootListHandleResponse(resp *azcore.Response) (BananaArrayResponse, error) {
	result := BananaArrayResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return BananaArrayResponse{}, err
	}
	return result, nil
}

// getRootListHandleError handles the GetRootList error response.
func (client *XMLClient) getRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetRootListSingleItem - Gets a list with a single item.
func (client *XMLClient) GetRootListSingleItem(ctx context.Context, options *XMLGetRootListSingleItemOptions) (BananaArrayResponse, error) {
	req, err := client.getRootListSingleItemCreateRequest(ctx, options)
	if err != nil {
		return BananaArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BananaArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BananaArrayResponse{}, client.getRootListSingleItemHandleError(resp)
	}
	return client.getRootListSingleItemHandleResponse(resp)
}

// getRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *XMLClient) getRootListSingleItemCreateRequest(ctx context.Context, options *XMLGetRootListSingleItemOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *XMLClient) getRootListSingleItemHandleResponse(resp *azcore.Response) (BananaArrayResponse, error) {
	result := BananaArrayResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return BananaArrayResponse{}, err
	}
	return result, nil
}

// getRootListSingleItemHandleError handles the GetRootListSingleItem error response.
func (client *XMLClient) getRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetServiceProperties - Gets storage service properties.
func (client *XMLClient) GetServiceProperties(ctx context.Context, options *XMLGetServicePropertiesOptions) (StorageServicePropertiesResponse, error) {
	req, err := client.getServicePropertiesCreateRequest(ctx, options)
	if err != nil {
		return StorageServicePropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StorageServicePropertiesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StorageServicePropertiesResponse{}, client.getServicePropertiesHandleError(resp)
	}
	return client.getServicePropertiesHandleResponse(resp)
}

// getServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *XMLClient) getServicePropertiesCreateRequest(ctx context.Context, options *XMLGetServicePropertiesOptions) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *XMLClient) getServicePropertiesHandleResponse(resp *azcore.Response) (StorageServicePropertiesResponse, error) {
	var val *StorageServiceProperties
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return StorageServicePropertiesResponse{}, err
	}
	return StorageServicePropertiesResponse{RawResponse: resp.Response, StorageServiceProperties: val}, nil
}

// getServicePropertiesHandleError handles the GetServiceProperties error response.
func (client *XMLClient) getServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetSimple - Get a simple XML document
func (client *XMLClient) GetSimple(ctx context.Context, options *XMLGetSimpleOptions) (SlideshowResponse, error) {
	req, err := client.getSimpleCreateRequest(ctx, options)
	if err != nil {
		return SlideshowResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SlideshowResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SlideshowResponse{}, client.getSimpleHandleError(resp)
	}
	return client.getSimpleHandleResponse(resp)
}

// getSimpleCreateRequest creates the GetSimple request.
func (client *XMLClient) getSimpleCreateRequest(ctx context.Context, options *XMLGetSimpleOptions) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getSimpleHandleResponse handles the GetSimple response.
func (client *XMLClient) getSimpleHandleResponse(resp *azcore.Response) (SlideshowResponse, error) {
	var val *Slideshow
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return SlideshowResponse{}, err
	}
	return SlideshowResponse{RawResponse: resp.Response, Slideshow: val}, nil
}

// getSimpleHandleError handles the GetSimple error response.
func (client *XMLClient) getSimpleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
func (client *XMLClient) GetWrappedLists(ctx context.Context, options *XMLGetWrappedListsOptions) (AppleBarrelResponse, error) {
	req, err := client.getWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return AppleBarrelResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return AppleBarrelResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return AppleBarrelResponse{}, client.getWrappedListsHandleError(resp)
	}
	return client.getWrappedListsHandleResponse(resp)
}

// getWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *XMLClient) getWrappedListsCreateRequest(ctx context.Context, options *XMLGetWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *XMLClient) getWrappedListsHandleResponse(resp *azcore.Response) (AppleBarrelResponse, error) {
	var val *AppleBarrel
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return AppleBarrelResponse{}, err
	}
	return AppleBarrelResponse{RawResponse: resp.Response, AppleBarrel: val}, nil
}

// getWrappedListsHandleError handles the GetWrappedLists error response.
func (client *XMLClient) getWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetXMsText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language' property being 'english' and
// its 'content' property being 'I am text'
func (client *XMLClient) GetXMsText(ctx context.Context, options *XMLGetXMsTextOptions) (ObjectWithXMsTextPropertyResponse, error) {
	req, err := client.getXMsTextCreateRequest(ctx, options)
	if err != nil {
		return ObjectWithXMsTextPropertyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ObjectWithXMsTextPropertyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ObjectWithXMsTextPropertyResponse{}, client.getXMsTextHandleError(resp)
	}
	return client.getXMsTextHandleResponse(resp)
}

// getXMsTextCreateRequest creates the GetXMsText request.
func (client *XMLClient) getXMsTextCreateRequest(ctx context.Context, options *XMLGetXMsTextOptions) (*azcore.Request, error) {
	urlPath := "/xml/x-ms-text"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getXMsTextHandleResponse handles the GetXMsText response.
func (client *XMLClient) getXMsTextHandleResponse(resp *azcore.Response) (ObjectWithXMsTextPropertyResponse, error) {
	var val *ObjectWithXMsTextProperty
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return ObjectWithXMsTextPropertyResponse{}, err
	}
	return ObjectWithXMsTextPropertyResponse{RawResponse: resp.Response, Data: val}, nil
}

// getXMsTextHandleError handles the GetXMsText error response.
func (client *XMLClient) getXMsTextHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
func (client *XMLClient) JSONInput(ctx context.Context, properties JSONInput, options *XMLJSONInputOptions) (*http.Response, error) {
	req, err := client.jsonInputCreateRequest(ctx, properties, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.jsonInputHandleError(resp)
	}
	return resp.Response, nil
}

// jsonInputCreateRequest creates the JSONInput request.
func (client *XMLClient) jsonInputCreateRequest(ctx context.Context, properties JSONInput, options *XMLJSONInputOptions) (*azcore.Request, error) {
	urlPath := "/xml/jsoninput"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsJSON(properties)
}

// jsonInputHandleError handles the JSONInput error response.
func (client *XMLClient) jsonInputHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
func (client *XMLClient) JSONOutput(ctx context.Context, options *XMLJSONOutputOptions) (JSONOutputResponse, error) {
	req, err := client.jsonOutputCreateRequest(ctx, options)
	if err != nil {
		return JSONOutputResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return JSONOutputResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return JSONOutputResponse{}, client.jsonOutputHandleError(resp)
	}
	return client.jsonOutputHandleResponse(resp)
}

// jsonOutputCreateRequest creates the JSONOutput request.
func (client *XMLClient) jsonOutputCreateRequest(ctx context.Context, options *XMLJSONOutputOptions) (*azcore.Request, error) {
	urlPath := "/xml/jsonoutput"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// jsonOutputHandleResponse handles the JSONOutput response.
func (client *XMLClient) jsonOutputHandleResponse(resp *azcore.Response) (JSONOutputResponse, error) {
	var val *JSONOutput
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return JSONOutputResponse{}, err
	}
	return JSONOutputResponse{RawResponse: resp.Response, JSONOutput: val}, nil
}

// jsonOutputHandleError handles the JSONOutput error response.
func (client *XMLClient) jsonOutputHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListBlobs - Lists blobs in a storage container.
func (client *XMLClient) ListBlobs(ctx context.Context, options *XMLListBlobsOptions) (ListBlobsResponseResponse, error) {
	req, err := client.listBlobsCreateRequest(ctx, options)
	if err != nil {
		return ListBlobsResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ListBlobsResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ListBlobsResponseResponse{}, client.listBlobsHandleError(resp)
	}
	return client.listBlobsHandleResponse(resp)
}

// listBlobsCreateRequest creates the ListBlobs request.
func (client *XMLClient) listBlobsCreateRequest(ctx context.Context, options *XMLListBlobsOptions) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "list")
	reqQP.Set("restype", "container")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// listBlobsHandleResponse handles the ListBlobs response.
func (client *XMLClient) listBlobsHandleResponse(resp *azcore.Response) (ListBlobsResponseResponse, error) {
	var val *ListBlobsResponse
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return ListBlobsResponseResponse{}, err
	}
	return ListBlobsResponseResponse{RawResponse: resp.Response, EnumerationResults: val}, nil
}

// listBlobsHandleError handles the ListBlobs error response.
func (client *XMLClient) listBlobsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListContainers - Lists containers in a storage account.
func (client *XMLClient) ListContainers(ctx context.Context, options *XMLListContainersOptions) (ListContainersResponseResponse, error) {
	req, err := client.listContainersCreateRequest(ctx, options)
	if err != nil {
		return ListContainersResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ListContainersResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ListContainersResponseResponse{}, client.listContainersHandleError(resp)
	}
	return client.listContainersHandleResponse(resp)
}

// listContainersCreateRequest creates the ListContainers request.
func (client *XMLClient) listContainersCreateRequest(ctx context.Context, options *XMLListContainersOptions) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "list")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// listContainersHandleResponse handles the ListContainers response.
func (client *XMLClient) listContainersHandleResponse(resp *azcore.Response) (ListContainersResponseResponse, error) {
	var val *ListContainersResponse
	if err := resp.UnmarshalAsXML(&val); err != nil {
		return ListContainersResponseResponse{}, err
	}
	return ListContainersResponseResponse{RawResponse: resp.Response, EnumerationResults: val}, nil
}

// listContainersHandleError handles the ListContainers error response.
func (client *XMLClient) listContainersHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutACLs - Puts storage ACLs for a container.
func (client *XMLClient) PutACLs(ctx context.Context, properties []*SignedIdentifier, options *XMLPutACLsOptions) (*http.Response, error) {
	req, err := client.putACLsCreateRequest(ctx, properties, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putACLsHandleError(resp)
	}
	return resp.Response, nil
}

// putACLsCreateRequest creates the PutACLs request.
func (client *XMLClient) putACLsCreateRequest(ctx context.Context, properties []*SignedIdentifier, options *XMLPutACLsOptions) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.URL.RawQuery = reqQP.Encode()
	type wrapper struct {
		XMLName    xml.Name             `xml:"SignedIdentifiers"`
		Properties *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	return req, req.MarshalAsXML(wrapper{Properties: &properties})
}

// putACLsHandleError handles the PutACLs error response.
func (client *XMLClient) putACLsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
func (client *XMLClient) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta, options *XMLPutComplexTypeRefNoMetaOptions) (*http.Response, error) {
	req, err := client.putComplexTypeRefNoMetaCreateRequest(ctx, model, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putComplexTypeRefNoMetaHandleError(resp)
	}
	return resp.Response, nil
}

// putComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *XMLClient) putComplexTypeRefNoMetaCreateRequest(ctx context.Context, model RootWithRefAndNoMeta, options *XMLPutComplexTypeRefNoMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(model)
}

// putComplexTypeRefNoMetaHandleError handles the PutComplexTypeRefNoMeta error response.
func (client *XMLClient) putComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
func (client *XMLClient) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta, options *XMLPutComplexTypeRefWithMetaOptions) (*http.Response, error) {
	req, err := client.putComplexTypeRefWithMetaCreateRequest(ctx, model, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putComplexTypeRefWithMetaHandleError(resp)
	}
	return resp.Response, nil
}

// putComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *XMLClient) putComplexTypeRefWithMetaCreateRequest(ctx context.Context, model RootWithRefAndMeta, options *XMLPutComplexTypeRefWithMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(model)
}

// putComplexTypeRefWithMetaHandleError handles the PutComplexTypeRefWithMeta error response.
func (client *XMLClient) putComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyChildElement - Puts a value with an empty child element.
func (client *XMLClient) PutEmptyChildElement(ctx context.Context, banana Banana, options *XMLPutEmptyChildElementOptions) (*http.Response, error) {
	req, err := client.putEmptyChildElementCreateRequest(ctx, banana, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyChildElementHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *XMLClient) putEmptyChildElementCreateRequest(ctx context.Context, banana Banana, options *XMLPutEmptyChildElementOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(banana)
}

// putEmptyChildElementHandleError handles the PutEmptyChildElement error response.
func (client *XMLClient) putEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyList - Puts an empty list.
func (client *XMLClient) PutEmptyList(ctx context.Context, slideshow Slideshow, options *XMLPutEmptyListOptions) (*http.Response, error) {
	req, err := client.putEmptyListCreateRequest(ctx, slideshow, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyListHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyListCreateRequest creates the PutEmptyList request.
func (client *XMLClient) putEmptyListCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLPutEmptyListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(slideshow)
}

// putEmptyListHandleError handles the PutEmptyList error response.
func (client *XMLClient) putEmptyListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyRootList - Puts an empty list as the root element.
func (client *XMLClient) PutEmptyRootList(ctx context.Context, bananas []*Banana, options *XMLPutEmptyRootListOptions) (*http.Response, error) {
	req, err := client.putEmptyRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyRootListHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *XMLClient) putEmptyRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLPutEmptyRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putEmptyRootListHandleError handles the PutEmptyRootList error response.
func (client *XMLClient) putEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
func (client *XMLClient) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel, options *XMLPutEmptyWrappedListsOptions) (*http.Response, error) {
	req, err := client.putEmptyWrappedListsCreateRequest(ctx, appleBarrel, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putEmptyWrappedListsHandleError(resp)
	}
	return resp.Response, nil
}

// putEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *XMLClient) putEmptyWrappedListsCreateRequest(ctx context.Context, appleBarrel AppleBarrel, options *XMLPutEmptyWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(appleBarrel)
}

// putEmptyWrappedListsHandleError handles the PutEmptyWrappedLists error response.
func (client *XMLClient) putEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutRootList - Puts a list as the root element.
func (client *XMLClient) PutRootList(ctx context.Context, bananas []*Banana, options *XMLPutRootListOptions) (*http.Response, error) {
	req, err := client.putRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putRootListHandleError(resp)
	}
	return resp.Response, nil
}

// putRootListCreateRequest creates the PutRootList request.
func (client *XMLClient) putRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLPutRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putRootListHandleError handles the PutRootList error response.
func (client *XMLClient) putRootListHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutRootListSingleItem - Puts a list with a single item.
func (client *XMLClient) PutRootListSingleItem(ctx context.Context, bananas []*Banana, options *XMLPutRootListSingleItemOptions) (*http.Response, error) {
	req, err := client.putRootListSingleItemCreateRequest(ctx, bananas, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putRootListSingleItemHandleError(resp)
	}
	return resp.Response, nil
}

// putRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *XMLClient) putRootListSingleItemCreateRequest(ctx context.Context, bananas []*Banana, options *XMLPutRootListSingleItemOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putRootListSingleItemHandleError handles the PutRootListSingleItem error response.
func (client *XMLClient) putRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutServiceProperties - Puts storage service properties.
func (client *XMLClient) PutServiceProperties(ctx context.Context, properties StorageServiceProperties, options *XMLPutServicePropertiesOptions) (*http.Response, error) {
	req, err := client.putServicePropertiesCreateRequest(ctx, properties, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putServicePropertiesHandleError(resp)
	}
	return resp.Response, nil
}

// putServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *XMLClient) putServicePropertiesCreateRequest(ctx context.Context, properties StorageServiceProperties, options *XMLPutServicePropertiesOptions) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.URL.RawQuery = reqQP.Encode()
	return req, req.MarshalAsXML(properties)
}

// putServicePropertiesHandleError handles the PutServiceProperties error response.
func (client *XMLClient) putServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("%s; failed to read response body: %w", resp.Status, err)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutSimple - Put a simple XML document
func (client *XMLClient) PutSimple(ctx context.Context, slideshow Slideshow, options *XMLPutSimpleOptions) (*http.Response, error) {
	req, err := client.putSimpleCreateRequest(ctx, slideshow, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putSimpleHandleError(resp)
	}
	return resp.Response, nil
}

// putSimpleCreateRequest creates the PutSimple request.
func (client *XMLClient) putSimpleCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLPutSimpleOptions) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(slideshow)
}

// putSimpleHandleError handles the PutSimple error response.
func (client *XMLClient) putSimpleHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
func (client *XMLClient) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel, options *XMLPutWrappedListsOptions) (*http.Response, error) {
	req, err := client.putWrappedListsCreateRequest(ctx, wrappedLists, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, client.putWrappedListsHandleError(resp)
	}
	return resp.Response, nil
}

// putWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *XMLClient) putWrappedListsCreateRequest(ctx context.Context, wrappedLists AppleBarrel, options *XMLPutWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(wrappedLists)
}

// putWrappedListsHandleError handles the PutWrappedLists error response.
func (client *XMLClient) putWrappedListsHandleError(resp *azcore.Response) error {
	var err Error
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
