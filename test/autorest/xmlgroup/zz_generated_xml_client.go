//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// XMLClient contains the methods for the XML group.
// Don't use this type directly, use NewXMLClient() instead.
type XMLClient struct {
	con *Connection
}

// NewXMLClient creates a new instance of XMLClient with the specified values.
func NewXMLClient(con *Connection) *XMLClient {
	return &XMLClient{con: con}
}

// GetACLs - Gets storage ACLs for a container.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetACLs(ctx context.Context, options *XMLGetACLsOptions) (XMLGetACLsResponse, error) {
	req, err := client.getACLsCreateRequest(ctx, options)
	if err != nil {
		return XMLGetACLsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetACLsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetACLsResponse{}, client.getACLsHandleError(resp)
	}
	return client.getACLsHandleResponse(resp)
}

// getACLsCreateRequest creates the GetACLs request.
func (client *XMLClient) getACLsCreateRequest(ctx context.Context, options *XMLGetACLsOptions) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getACLsHandleResponse handles the GetACLs response.
func (client *XMLClient) getACLsHandleResponse(resp *azcore.Response) (XMLGetACLsResponse, error) {
	result := XMLGetACLsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return XMLGetACLsResponse{}, err
	}
	return result, nil
}

// getACLsHandleError handles the GetACLs error response.
func (client *XMLClient) getACLsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetBytes - Get an XML document with binary property
// If the operation fails it returns the *Error error type.
func (client *XMLClient) GetBytes(ctx context.Context, options *XMLGetBytesOptions) (XMLGetBytesResponse, error) {
	req, err := client.getBytesCreateRequest(ctx, options)
	if err != nil {
		return XMLGetBytesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetBytesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetBytesResponse{}, client.getBytesHandleError(resp)
	}
	return client.getBytesHandleResponse(resp)
}

// getBytesCreateRequest creates the GetBytes request.
func (client *XMLClient) getBytesCreateRequest(ctx context.Context, options *XMLGetBytesOptions) (*azcore.Request, error) {
	urlPath := "/xml/bytes"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getBytesHandleResponse handles the GetBytes response.
func (client *XMLClient) getBytesHandleResponse(resp *azcore.Response) (XMLGetBytesResponse, error) {
	result := XMLGetBytesResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.ModelWithByteProperty); err != nil {
		return XMLGetBytesResponse{}, err
	}
	return result, nil
}

// getBytesHandleError handles the GetBytes error response.
func (client *XMLClient) getBytesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns a generic error.
func (client *XMLClient) GetComplexTypeRefNoMeta(ctx context.Context, options *XMLGetComplexTypeRefNoMetaOptions) (XMLGetComplexTypeRefNoMetaResponse, error) {
	req, err := client.getComplexTypeRefNoMetaCreateRequest(ctx, options)
	if err != nil {
		return XMLGetComplexTypeRefNoMetaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetComplexTypeRefNoMetaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetComplexTypeRefNoMetaResponse{}, client.getComplexTypeRefNoMetaHandleError(resp)
	}
	return client.getComplexTypeRefNoMetaHandleResponse(resp)
}

// getComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *XMLClient) getComplexTypeRefNoMetaCreateRequest(ctx context.Context, options *XMLGetComplexTypeRefNoMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleResponse(resp *azcore.Response) (XMLGetComplexTypeRefNoMetaResponse, error) {
	result := XMLGetComplexTypeRefNoMetaResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.RootWithRefAndNoMeta); err != nil {
		return XMLGetComplexTypeRefNoMetaResponse{}, err
	}
	return result, nil
}

// getComplexTypeRefNoMetaHandleError handles the GetComplexTypeRefNoMeta error response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
// If the operation fails it returns a generic error.
func (client *XMLClient) GetComplexTypeRefWithMeta(ctx context.Context, options *XMLGetComplexTypeRefWithMetaOptions) (XMLGetComplexTypeRefWithMetaResponse, error) {
	req, err := client.getComplexTypeRefWithMetaCreateRequest(ctx, options)
	if err != nil {
		return XMLGetComplexTypeRefWithMetaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetComplexTypeRefWithMetaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetComplexTypeRefWithMetaResponse{}, client.getComplexTypeRefWithMetaHandleError(resp)
	}
	return client.getComplexTypeRefWithMetaHandleResponse(resp)
}

// getComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *XMLClient) getComplexTypeRefWithMetaCreateRequest(ctx context.Context, options *XMLGetComplexTypeRefWithMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleResponse(resp *azcore.Response) (XMLGetComplexTypeRefWithMetaResponse, error) {
	result := XMLGetComplexTypeRefWithMetaResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.RootWithRefAndMeta); err != nil {
		return XMLGetComplexTypeRefWithMetaResponse{}, err
	}
	return result, nil
}

// getComplexTypeRefWithMetaHandleError handles the GetComplexTypeRefWithMeta error response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetEmptyChildElement(ctx context.Context, options *XMLGetEmptyChildElementOptions) (XMLGetEmptyChildElementResponse, error) {
	req, err := client.getEmptyChildElementCreateRequest(ctx, options)
	if err != nil {
		return XMLGetEmptyChildElementResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetEmptyChildElementResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetEmptyChildElementResponse{}, client.getEmptyChildElementHandleError(resp)
	}
	return client.getEmptyChildElementHandleResponse(resp)
}

// getEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *XMLClient) getEmptyChildElementCreateRequest(ctx context.Context, options *XMLGetEmptyChildElementOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *XMLClient) getEmptyChildElementHandleResponse(resp *azcore.Response) (XMLGetEmptyChildElementResponse, error) {
	result := XMLGetEmptyChildElementResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.Banana); err != nil {
		return XMLGetEmptyChildElementResponse{}, err
	}
	return result, nil
}

// getEmptyChildElementHandleError handles the GetEmptyChildElement error response.
func (client *XMLClient) getEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyList - Get an empty list.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetEmptyList(ctx context.Context, options *XMLGetEmptyListOptions) (XMLGetEmptyListResponse, error) {
	req, err := client.getEmptyListCreateRequest(ctx, options)
	if err != nil {
		return XMLGetEmptyListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetEmptyListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetEmptyListResponse{}, client.getEmptyListHandleError(resp)
	}
	return client.getEmptyListHandleResponse(resp)
}

// getEmptyListCreateRequest creates the GetEmptyList request.
func (client *XMLClient) getEmptyListCreateRequest(ctx context.Context, options *XMLGetEmptyListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyListHandleResponse handles the GetEmptyList response.
func (client *XMLClient) getEmptyListHandleResponse(resp *azcore.Response) (XMLGetEmptyListResponse, error) {
	result := XMLGetEmptyListResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.Slideshow); err != nil {
		return XMLGetEmptyListResponse{}, err
	}
	return result, nil
}

// getEmptyListHandleError handles the GetEmptyList error response.
func (client *XMLClient) getEmptyListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyRootList - Gets an empty list as the root element.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetEmptyRootList(ctx context.Context, options *XMLGetEmptyRootListOptions) (XMLGetEmptyRootListResponse, error) {
	req, err := client.getEmptyRootListCreateRequest(ctx, options)
	if err != nil {
		return XMLGetEmptyRootListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetEmptyRootListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetEmptyRootListResponse{}, client.getEmptyRootListHandleError(resp)
	}
	return client.getEmptyRootListHandleResponse(resp)
}

// getEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *XMLClient) getEmptyRootListCreateRequest(ctx context.Context, options *XMLGetEmptyRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *XMLClient) getEmptyRootListHandleResponse(resp *azcore.Response) (XMLGetEmptyRootListResponse, error) {
	result := XMLGetEmptyRootListResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return XMLGetEmptyRootListResponse{}, err
	}
	return result, nil
}

// getEmptyRootListHandleError handles the GetEmptyRootList error response.
func (client *XMLClient) getEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetEmptyWrappedLists(ctx context.Context, options *XMLGetEmptyWrappedListsOptions) (XMLGetEmptyWrappedListsResponse, error) {
	req, err := client.getEmptyWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return XMLGetEmptyWrappedListsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetEmptyWrappedListsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetEmptyWrappedListsResponse{}, client.getEmptyWrappedListsHandleError(resp)
	}
	return client.getEmptyWrappedListsHandleResponse(resp)
}

// getEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *XMLClient) getEmptyWrappedListsCreateRequest(ctx context.Context, options *XMLGetEmptyWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *XMLClient) getEmptyWrappedListsHandleResponse(resp *azcore.Response) (XMLGetEmptyWrappedListsResponse, error) {
	result := XMLGetEmptyWrappedListsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.AppleBarrel); err != nil {
		return XMLGetEmptyWrappedListsResponse{}, err
	}
	return result, nil
}

// getEmptyWrappedListsHandleError handles the GetEmptyWrappedLists error response.
func (client *XMLClient) getEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetHeaders - Get strongly-typed response headers.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetHeaders(ctx context.Context, options *XMLGetHeadersOptions) (XMLGetHeadersResponse, error) {
	req, err := client.getHeadersCreateRequest(ctx, options)
	if err != nil {
		return XMLGetHeadersResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetHeadersResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetHeadersResponse{}, client.getHeadersHandleError(resp)
	}
	return client.getHeadersHandleResponse(resp)
}

// getHeadersCreateRequest creates the GetHeaders request.
func (client *XMLClient) getHeadersCreateRequest(ctx context.Context, options *XMLGetHeadersOptions) (*azcore.Request, error) {
	urlPath := "/xml/headers"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, nil
}

// getHeadersHandleResponse handles the GetHeaders response.
func (client *XMLClient) getHeadersHandleResponse(resp *azcore.Response) (XMLGetHeadersResponse, error) {
	result := XMLGetHeadersResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return result, nil
}

// getHeadersHandleError handles the GetHeaders error response.
func (client *XMLClient) getHeadersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetRootList - Gets a list as the root element.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetRootList(ctx context.Context, options *XMLGetRootListOptions) (XMLGetRootListResponse, error) {
	req, err := client.getRootListCreateRequest(ctx, options)
	if err != nil {
		return XMLGetRootListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetRootListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetRootListResponse{}, client.getRootListHandleError(resp)
	}
	return client.getRootListHandleResponse(resp)
}

// getRootListCreateRequest creates the GetRootList request.
func (client *XMLClient) getRootListCreateRequest(ctx context.Context, options *XMLGetRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getRootListHandleResponse handles the GetRootList response.
func (client *XMLClient) getRootListHandleResponse(resp *azcore.Response) (XMLGetRootListResponse, error) {
	result := XMLGetRootListResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return XMLGetRootListResponse{}, err
	}
	return result, nil
}

// getRootListHandleError handles the GetRootList error response.
func (client *XMLClient) getRootListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetRootListSingleItem - Gets a list with a single item.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetRootListSingleItem(ctx context.Context, options *XMLGetRootListSingleItemOptions) (XMLGetRootListSingleItemResponse, error) {
	req, err := client.getRootListSingleItemCreateRequest(ctx, options)
	if err != nil {
		return XMLGetRootListSingleItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetRootListSingleItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetRootListSingleItemResponse{}, client.getRootListSingleItemHandleError(resp)
	}
	return client.getRootListSingleItemHandleResponse(resp)
}

// getRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *XMLClient) getRootListSingleItemCreateRequest(ctx context.Context, options *XMLGetRootListSingleItemOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *XMLClient) getRootListSingleItemHandleResponse(resp *azcore.Response) (XMLGetRootListSingleItemResponse, error) {
	result := XMLGetRootListSingleItemResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return XMLGetRootListSingleItemResponse{}, err
	}
	return result, nil
}

// getRootListSingleItemHandleError handles the GetRootListSingleItem error response.
func (client *XMLClient) getRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetServiceProperties - Gets storage service properties.
// If the operation fails it returns a generic error.
func (client *XMLClient) GetServiceProperties(ctx context.Context, options *XMLGetServicePropertiesOptions) (XMLGetServicePropertiesResponse, error) {
	req, err := client.getServicePropertiesCreateRequest(ctx, options)
	if err != nil {
		return XMLGetServicePropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetServicePropertiesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetServicePropertiesResponse{}, client.getServicePropertiesHandleError(resp)
	}
	return client.getServicePropertiesHandleResponse(resp)
}

// getServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *XMLClient) getServicePropertiesCreateRequest(ctx context.Context, options *XMLGetServicePropertiesOptions) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *XMLClient) getServicePropertiesHandleResponse(resp *azcore.Response) (XMLGetServicePropertiesResponse, error) {
	result := XMLGetServicePropertiesResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.StorageServiceProperties); err != nil {
		return XMLGetServicePropertiesResponse{}, err
	}
	return result, nil
}

// getServicePropertiesHandleError handles the GetServiceProperties error response.
func (client *XMLClient) getServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetSimple - Get a simple XML document
// If the operation fails it returns the *Error error type.
func (client *XMLClient) GetSimple(ctx context.Context, options *XMLGetSimpleOptions) (XMLGetSimpleResponse, error) {
	req, err := client.getSimpleCreateRequest(ctx, options)
	if err != nil {
		return XMLGetSimpleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetSimpleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetSimpleResponse{}, client.getSimpleHandleError(resp)
	}
	return client.getSimpleHandleResponse(resp)
}

// getSimpleCreateRequest creates the GetSimple request.
func (client *XMLClient) getSimpleCreateRequest(ctx context.Context, options *XMLGetSimpleOptions) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getSimpleHandleResponse handles the GetSimple response.
func (client *XMLClient) getSimpleHandleResponse(resp *azcore.Response) (XMLGetSimpleResponse, error) {
	result := XMLGetSimpleResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.Slideshow); err != nil {
		return XMLGetSimpleResponse{}, err
	}
	return result, nil
}

// getSimpleHandleError handles the GetSimple error response.
func (client *XMLClient) getSimpleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetURI - Get an XML document with uri property
// If the operation fails it returns the *Error error type.
func (client *XMLClient) GetURI(ctx context.Context, options *XMLGetURIOptions) (XMLGetURIResponse, error) {
	req, err := client.getURICreateRequest(ctx, options)
	if err != nil {
		return XMLGetURIResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetURIResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetURIResponse{}, client.getURIHandleError(resp)
	}
	return client.getURIHandleResponse(resp)
}

// getURICreateRequest creates the GetURI request.
func (client *XMLClient) getURICreateRequest(ctx context.Context, options *XMLGetURIOptions) (*azcore.Request, error) {
	urlPath := "/xml/url"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getURIHandleResponse handles the GetURI response.
func (client *XMLClient) getURIHandleResponse(resp *azcore.Response) (XMLGetURIResponse, error) {
	result := XMLGetURIResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.ModelWithURLProperty); err != nil {
		return XMLGetURIResponse{}, err
	}
	return result, nil
}

// getURIHandleError handles the GetURI error response.
func (client *XMLClient) getURIHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
// If the operation fails it returns a generic error.
func (client *XMLClient) GetWrappedLists(ctx context.Context, options *XMLGetWrappedListsOptions) (XMLGetWrappedListsResponse, error) {
	req, err := client.getWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return XMLGetWrappedListsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetWrappedListsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetWrappedListsResponse{}, client.getWrappedListsHandleError(resp)
	}
	return client.getWrappedListsHandleResponse(resp)
}

// getWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *XMLClient) getWrappedListsCreateRequest(ctx context.Context, options *XMLGetWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *XMLClient) getWrappedListsHandleResponse(resp *azcore.Response) (XMLGetWrappedListsResponse, error) {
	result := XMLGetWrappedListsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.AppleBarrel); err != nil {
		return XMLGetWrappedListsResponse{}, err
	}
	return result, nil
}

// getWrappedListsHandleError handles the GetWrappedLists error response.
func (client *XMLClient) getWrappedListsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// GetXMsText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language' property being 'english' and
// its 'content' property being 'I am text'
// If the operation fails it returns a generic error.
func (client *XMLClient) GetXMsText(ctx context.Context, options *XMLGetXMsTextOptions) (XMLGetXMsTextResponse, error) {
	req, err := client.getXMsTextCreateRequest(ctx, options)
	if err != nil {
		return XMLGetXMsTextResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLGetXMsTextResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLGetXMsTextResponse{}, client.getXMsTextHandleError(resp)
	}
	return client.getXMsTextHandleResponse(resp)
}

// getXMsTextCreateRequest creates the GetXMsText request.
func (client *XMLClient) getXMsTextCreateRequest(ctx context.Context, options *XMLGetXMsTextOptions) (*azcore.Request, error) {
	urlPath := "/xml/x-ms-text"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getXMsTextHandleResponse handles the GetXMsText response.
func (client *XMLClient) getXMsTextHandleResponse(resp *azcore.Response) (XMLGetXMsTextResponse, error) {
	result := XMLGetXMsTextResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.ObjectWithXMsTextProperty); err != nil {
		return XMLGetXMsTextResponse{}, err
	}
	return result, nil
}

// getXMsTextHandleError handles the GetXMsText error response.
func (client *XMLClient) getXMsTextHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
// If the operation fails it returns a generic error.
func (client *XMLClient) JSONInput(ctx context.Context, properties JSONInput, options *XMLJSONInputOptions) (XMLJSONInputResponse, error) {
	req, err := client.jsonInputCreateRequest(ctx, properties, options)
	if err != nil {
		return XMLJSONInputResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLJSONInputResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLJSONInputResponse{}, client.jsonInputHandleError(resp)
	}
	return XMLJSONInputResponse{RawResponse: resp.Response}, nil
}

// jsonInputCreateRequest creates the JSONInput request.
func (client *XMLClient) jsonInputCreateRequest(ctx context.Context, properties JSONInput, options *XMLJSONInputOptions) (*azcore.Request, error) {
	urlPath := "/xml/jsoninput"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsJSON(properties)
}

// jsonInputHandleError handles the JSONInput error response.
func (client *XMLClient) jsonInputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
// If the operation fails it returns a generic error.
func (client *XMLClient) JSONOutput(ctx context.Context, options *XMLJSONOutputOptions) (XMLJSONOutputResponse, error) {
	req, err := client.jsonOutputCreateRequest(ctx, options)
	if err != nil {
		return XMLJSONOutputResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLJSONOutputResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLJSONOutputResponse{}, client.jsonOutputHandleError(resp)
	}
	return client.jsonOutputHandleResponse(resp)
}

// jsonOutputCreateRequest creates the JSONOutput request.
func (client *XMLClient) jsonOutputCreateRequest(ctx context.Context, options *XMLJSONOutputOptions) (*azcore.Request, error) {
	urlPath := "/xml/jsonoutput"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// jsonOutputHandleResponse handles the JSONOutput response.
func (client *XMLClient) jsonOutputHandleResponse(resp *azcore.Response) (XMLJSONOutputResponse, error) {
	result := XMLJSONOutputResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsJSON(&result.JSONOutput); err != nil {
		return XMLJSONOutputResponse{}, err
	}
	return result, nil
}

// jsonOutputHandleError handles the JSONOutput error response.
func (client *XMLClient) jsonOutputHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListBlobs - Lists blobs in a storage container.
// If the operation fails it returns a generic error.
func (client *XMLClient) ListBlobs(ctx context.Context, options *XMLListBlobsOptions) (XMLListBlobsResponse, error) {
	req, err := client.listBlobsCreateRequest(ctx, options)
	if err != nil {
		return XMLListBlobsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLListBlobsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLListBlobsResponse{}, client.listBlobsHandleError(resp)
	}
	return client.listBlobsHandleResponse(resp)
}

// listBlobsCreateRequest creates the ListBlobs request.
func (client *XMLClient) listBlobsCreateRequest(ctx context.Context, options *XMLListBlobsOptions) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "list")
	reqQP.Set("restype", "container")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// listBlobsHandleResponse handles the ListBlobs response.
func (client *XMLClient) listBlobsHandleResponse(resp *azcore.Response) (XMLListBlobsResponse, error) {
	result := XMLListBlobsResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.ListBlobsResponse); err != nil {
		return XMLListBlobsResponse{}, err
	}
	return result, nil
}

// listBlobsHandleError handles the ListBlobs error response.
func (client *XMLClient) listBlobsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// ListContainers - Lists containers in a storage account.
// If the operation fails it returns a generic error.
func (client *XMLClient) ListContainers(ctx context.Context, options *XMLListContainersOptions) (XMLListContainersResponse, error) {
	req, err := client.listContainersCreateRequest(ctx, options)
	if err != nil {
		return XMLListContainersResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLListContainersResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return XMLListContainersResponse{}, client.listContainersHandleError(resp)
	}
	return client.listContainersHandleResponse(resp)
}

// listContainersCreateRequest creates the ListContainers request.
func (client *XMLClient) listContainersCreateRequest(ctx context.Context, options *XMLListContainersOptions) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "list")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// listContainersHandleResponse handles the ListContainers response.
func (client *XMLClient) listContainersHandleResponse(resp *azcore.Response) (XMLListContainersResponse, error) {
	result := XMLListContainersResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result.ListContainersResponse); err != nil {
		return XMLListContainersResponse{}, err
	}
	return result, nil
}

// listContainersHandleError handles the ListContainers error response.
func (client *XMLClient) listContainersHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutACLs - Puts storage ACLs for a container.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutACLs(ctx context.Context, properties []*SignedIdentifier, options *XMLPutACLsOptions) (XMLPutACLsResponse, error) {
	req, err := client.putACLsCreateRequest(ctx, properties, options)
	if err != nil {
		return XMLPutACLsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutACLsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutACLsResponse{}, client.putACLsHandleError(resp)
	}
	return XMLPutACLsResponse{RawResponse: resp.Response}, nil
}

// putACLsCreateRequest creates the PutACLs request.
func (client *XMLClient) putACLsCreateRequest(ctx context.Context, properties []*SignedIdentifier, options *XMLPutACLsOptions) (*azcore.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.URL.RawQuery = reqQP.Encode()
	type wrapper struct {
		XMLName    xml.Name             `xml:"SignedIdentifiers"`
		Properties *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	return req, req.MarshalAsXML(wrapper{Properties: &properties})
}

// putACLsHandleError handles the PutACLs error response.
func (client *XMLClient) putACLsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutBinary - Put an XML document with binary property
// If the operation fails it returns the *Error error type.
func (client *XMLClient) PutBinary(ctx context.Context, slideshow ModelWithByteProperty, options *XMLPutBinaryOptions) (XMLPutBinaryResponse, error) {
	req, err := client.putBinaryCreateRequest(ctx, slideshow, options)
	if err != nil {
		return XMLPutBinaryResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutBinaryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutBinaryResponse{}, client.putBinaryHandleError(resp)
	}
	return XMLPutBinaryResponse{RawResponse: resp.Response}, nil
}

// putBinaryCreateRequest creates the PutBinary request.
func (client *XMLClient) putBinaryCreateRequest(ctx context.Context, slideshow ModelWithByteProperty, options *XMLPutBinaryOptions) (*azcore.Request, error) {
	urlPath := "/xml/bytes"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(slideshow)
}

// putBinaryHandleError handles the PutBinary error response.
func (client *XMLClient) putBinaryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns a generic error.
func (client *XMLClient) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta, options *XMLPutComplexTypeRefNoMetaOptions) (XMLPutComplexTypeRefNoMetaResponse, error) {
	req, err := client.putComplexTypeRefNoMetaCreateRequest(ctx, model, options)
	if err != nil {
		return XMLPutComplexTypeRefNoMetaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutComplexTypeRefNoMetaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutComplexTypeRefNoMetaResponse{}, client.putComplexTypeRefNoMetaHandleError(resp)
	}
	return XMLPutComplexTypeRefNoMetaResponse{RawResponse: resp.Response}, nil
}

// putComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *XMLClient) putComplexTypeRefNoMetaCreateRequest(ctx context.Context, model RootWithRefAndNoMeta, options *XMLPutComplexTypeRefNoMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(model)
}

// putComplexTypeRefNoMetaHandleError handles the PutComplexTypeRefNoMeta error response.
func (client *XMLClient) putComplexTypeRefNoMetaHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
// If the operation fails it returns a generic error.
func (client *XMLClient) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta, options *XMLPutComplexTypeRefWithMetaOptions) (XMLPutComplexTypeRefWithMetaResponse, error) {
	req, err := client.putComplexTypeRefWithMetaCreateRequest(ctx, model, options)
	if err != nil {
		return XMLPutComplexTypeRefWithMetaResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutComplexTypeRefWithMetaResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutComplexTypeRefWithMetaResponse{}, client.putComplexTypeRefWithMetaHandleError(resp)
	}
	return XMLPutComplexTypeRefWithMetaResponse{RawResponse: resp.Response}, nil
}

// putComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *XMLClient) putComplexTypeRefWithMetaCreateRequest(ctx context.Context, model RootWithRefAndMeta, options *XMLPutComplexTypeRefWithMetaOptions) (*azcore.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(model)
}

// putComplexTypeRefWithMetaHandleError handles the PutComplexTypeRefWithMeta error response.
func (client *XMLClient) putComplexTypeRefWithMetaHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyChildElement - Puts a value with an empty child element.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutEmptyChildElement(ctx context.Context, banana Banana, options *XMLPutEmptyChildElementOptions) (XMLPutEmptyChildElementResponse, error) {
	req, err := client.putEmptyChildElementCreateRequest(ctx, banana, options)
	if err != nil {
		return XMLPutEmptyChildElementResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutEmptyChildElementResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutEmptyChildElementResponse{}, client.putEmptyChildElementHandleError(resp)
	}
	return XMLPutEmptyChildElementResponse{RawResponse: resp.Response}, nil
}

// putEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *XMLClient) putEmptyChildElementCreateRequest(ctx context.Context, banana Banana, options *XMLPutEmptyChildElementOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(banana)
}

// putEmptyChildElementHandleError handles the PutEmptyChildElement error response.
func (client *XMLClient) putEmptyChildElementHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyList - Puts an empty list.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutEmptyList(ctx context.Context, slideshow Slideshow, options *XMLPutEmptyListOptions) (XMLPutEmptyListResponse, error) {
	req, err := client.putEmptyListCreateRequest(ctx, slideshow, options)
	if err != nil {
		return XMLPutEmptyListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutEmptyListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutEmptyListResponse{}, client.putEmptyListHandleError(resp)
	}
	return XMLPutEmptyListResponse{RawResponse: resp.Response}, nil
}

// putEmptyListCreateRequest creates the PutEmptyList request.
func (client *XMLClient) putEmptyListCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLPutEmptyListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(slideshow)
}

// putEmptyListHandleError handles the PutEmptyList error response.
func (client *XMLClient) putEmptyListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyRootList - Puts an empty list as the root element.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutEmptyRootList(ctx context.Context, bananas []*Banana, options *XMLPutEmptyRootListOptions) (XMLPutEmptyRootListResponse, error) {
	req, err := client.putEmptyRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return XMLPutEmptyRootListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutEmptyRootListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutEmptyRootListResponse{}, client.putEmptyRootListHandleError(resp)
	}
	return XMLPutEmptyRootListResponse{RawResponse: resp.Response}, nil
}

// putEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *XMLClient) putEmptyRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLPutEmptyRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putEmptyRootListHandleError handles the PutEmptyRootList error response.
func (client *XMLClient) putEmptyRootListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel, options *XMLPutEmptyWrappedListsOptions) (XMLPutEmptyWrappedListsResponse, error) {
	req, err := client.putEmptyWrappedListsCreateRequest(ctx, appleBarrel, options)
	if err != nil {
		return XMLPutEmptyWrappedListsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutEmptyWrappedListsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutEmptyWrappedListsResponse{}, client.putEmptyWrappedListsHandleError(resp)
	}
	return XMLPutEmptyWrappedListsResponse{RawResponse: resp.Response}, nil
}

// putEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *XMLClient) putEmptyWrappedListsCreateRequest(ctx context.Context, appleBarrel AppleBarrel, options *XMLPutEmptyWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	return req, req.MarshalAsXML(appleBarrel)
}

// putEmptyWrappedListsHandleError handles the PutEmptyWrappedLists error response.
func (client *XMLClient) putEmptyWrappedListsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutRootList - Puts a list as the root element.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutRootList(ctx context.Context, bananas []*Banana, options *XMLPutRootListOptions) (XMLPutRootListResponse, error) {
	req, err := client.putRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return XMLPutRootListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutRootListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutRootListResponse{}, client.putRootListHandleError(resp)
	}
	return XMLPutRootListResponse{RawResponse: resp.Response}, nil
}

// putRootListCreateRequest creates the PutRootList request.
func (client *XMLClient) putRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLPutRootListOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putRootListHandleError handles the PutRootList error response.
func (client *XMLClient) putRootListHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutRootListSingleItem - Puts a list with a single item.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutRootListSingleItem(ctx context.Context, bananas []*Banana, options *XMLPutRootListSingleItemOptions) (XMLPutRootListSingleItemResponse, error) {
	req, err := client.putRootListSingleItemCreateRequest(ctx, bananas, options)
	if err != nil {
		return XMLPutRootListSingleItemResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutRootListSingleItemResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutRootListSingleItemResponse{}, client.putRootListSingleItemHandleError(resp)
	}
	return XMLPutRootListSingleItemResponse{RawResponse: resp.Response}, nil
}

// putRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *XMLClient) putRootListSingleItemCreateRequest(ctx context.Context, bananas []*Banana, options *XMLPutRootListSingleItemOptions) (*azcore.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, req.MarshalAsXML(wrapper{Bananas: &bananas})
}

// putRootListSingleItemHandleError handles the PutRootListSingleItem error response.
func (client *XMLClient) putRootListSingleItemHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutServiceProperties - Puts storage service properties.
// If the operation fails it returns a generic error.
func (client *XMLClient) PutServiceProperties(ctx context.Context, properties StorageServiceProperties, options *XMLPutServicePropertiesOptions) (XMLPutServicePropertiesResponse, error) {
	req, err := client.putServicePropertiesCreateRequest(ctx, properties, options)
	if err != nil {
		return XMLPutServicePropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutServicePropertiesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutServicePropertiesResponse{}, client.putServicePropertiesHandleError(resp)
	}
	return XMLPutServicePropertiesResponse{RawResponse: resp.Response}, nil
}

// putServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *XMLClient) putServicePropertiesCreateRequest(ctx context.Context, properties StorageServiceProperties, options *XMLPutServicePropertiesOptions) (*azcore.Request, error) {
	urlPath := "/xml/"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.URL.RawQuery = reqQP.Encode()
	return req, req.MarshalAsXML(properties)
}

// putServicePropertiesHandleError handles the PutServiceProperties error response.
func (client *XMLClient) putServicePropertiesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// PutSimple - Put a simple XML document
// If the operation fails it returns the *Error error type.
func (client *XMLClient) PutSimple(ctx context.Context, slideshow Slideshow, options *XMLPutSimpleOptions) (XMLPutSimpleResponse, error) {
	req, err := client.putSimpleCreateRequest(ctx, slideshow, options)
	if err != nil {
		return XMLPutSimpleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutSimpleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutSimpleResponse{}, client.putSimpleHandleError(resp)
	}
	return XMLPutSimpleResponse{RawResponse: resp.Response}, nil
}

// putSimpleCreateRequest creates the PutSimple request.
func (client *XMLClient) putSimpleCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLPutSimpleOptions) (*azcore.Request, error) {
	urlPath := "/xml/simple"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(slideshow)
}

// putSimpleHandleError handles the PutSimple error response.
func (client *XMLClient) putSimpleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutURI - Put an XML document with uri property
// If the operation fails it returns the *Error error type.
func (client *XMLClient) PutURI(ctx context.Context, model ModelWithURLProperty, options *XMLPutURIOptions) (XMLPutURIResponse, error) {
	req, err := client.putURICreateRequest(ctx, model, options)
	if err != nil {
		return XMLPutURIResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutURIResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutURIResponse{}, client.putURIHandleError(resp)
	}
	return XMLPutURIResponse{RawResponse: resp.Response}, nil
}

// putURICreateRequest creates the PutURI request.
func (client *XMLClient) putURICreateRequest(ctx context.Context, model ModelWithURLProperty, options *XMLPutURIOptions) (*azcore.Request, error) {
	urlPath := "/xml/url"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(model)
}

// putURIHandleError handles the PutURI error response.
func (client *XMLClient) putURIHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
// If the operation fails it returns the *Error error type.
func (client *XMLClient) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel, options *XMLPutWrappedListsOptions) (XMLPutWrappedListsResponse, error) {
	req, err := client.putWrappedListsCreateRequest(ctx, wrappedLists, options)
	if err != nil {
		return XMLPutWrappedListsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return XMLPutWrappedListsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return XMLPutWrappedListsResponse{}, client.putWrappedListsHandleError(resp)
	}
	return XMLPutWrappedListsResponse{RawResponse: resp.Response}, nil
}

// putWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *XMLClient) putWrappedListsCreateRequest(ctx context.Context, wrappedLists AppleBarrel, options *XMLPutWrappedListsOptions) (*azcore.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(wrappedLists)
}

// putWrappedListsHandleError handles the PutWrappedLists error response.
func (client *XMLClient) putWrappedListsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsXML(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
