//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
)

// XMLClient contains the methods for the XML group.
// Don't use this type directly, use NewXMLClient() instead.
type XMLClient struct {
	pl runtime.Pipeline
}

// NewXMLClient creates a new instance of XMLClient with the specified values.
// pl - the pipeline used for sending requests and handling responses.
func NewXMLClient(pl runtime.Pipeline) *XMLClient {
	client := &XMLClient{
		pl: pl,
	}
	return client
}

// GetACLs - Gets storage ACLs for a container.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetACLsOptions contains the optional parameters for the XMLClient.GetACLs method.
func (client *XMLClient) GetACLs(ctx context.Context, options *XMLClientGetACLsOptions) (XMLClientGetACLsResponse, error) {
	req, err := client.getACLsCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetACLsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetACLsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetACLsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getACLsHandleResponse(resp)
}

// getACLsCreateRequest creates the GetACLs request.
func (client *XMLClient) getACLsCreateRequest(ctx context.Context, options *XMLClientGetACLsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getACLsHandleResponse handles the GetACLs response.
func (client *XMLClient) getACLsHandleResponse(resp *http.Response) (XMLClientGetACLsResponse, error) {
	result := XMLClientGetACLsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetACLsResponse{}, err
	}
	return result, nil
}

// GetBytes - Get an XML document with binary property
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetBytesOptions contains the optional parameters for the XMLClient.GetBytes method.
func (client *XMLClient) GetBytes(ctx context.Context, options *XMLClientGetBytesOptions) (XMLClientGetBytesResponse, error) {
	req, err := client.getBytesCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetBytesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetBytesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetBytesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getBytesHandleResponse(resp)
}

// getBytesCreateRequest creates the GetBytes request.
func (client *XMLClient) getBytesCreateRequest(ctx context.Context, options *XMLClientGetBytesOptions) (*policy.Request, error) {
	urlPath := "/xml/bytes"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getBytesHandleResponse handles the GetBytes response.
func (client *XMLClient) getBytesHandleResponse(resp *http.Response) (XMLClientGetBytesResponse, error) {
	result := XMLClientGetBytesResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ModelWithByteProperty); err != nil {
		return XMLClientGetBytesResponse{}, err
	}
	return result, nil
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetComplexTypeRefNoMetaOptions contains the optional parameters for the XMLClient.GetComplexTypeRefNoMeta
// method.
func (client *XMLClient) GetComplexTypeRefNoMeta(ctx context.Context, options *XMLClientGetComplexTypeRefNoMetaOptions) (XMLClientGetComplexTypeRefNoMetaResponse, error) {
	req, err := client.getComplexTypeRefNoMetaCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetComplexTypeRefNoMetaResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetComplexTypeRefNoMetaResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetComplexTypeRefNoMetaResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexTypeRefNoMetaHandleResponse(resp)
}

// getComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *XMLClient) getComplexTypeRefNoMetaCreateRequest(ctx context.Context, options *XMLClientGetComplexTypeRefNoMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleResponse(resp *http.Response) (XMLClientGetComplexTypeRefNoMetaResponse, error) {
	result := XMLClientGetComplexTypeRefNoMetaResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.RootWithRefAndNoMeta); err != nil {
		return XMLClientGetComplexTypeRefNoMetaResponse{}, err
	}
	return result, nil
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetComplexTypeRefWithMetaOptions contains the optional parameters for the XMLClient.GetComplexTypeRefWithMeta
// method.
func (client *XMLClient) GetComplexTypeRefWithMeta(ctx context.Context, options *XMLClientGetComplexTypeRefWithMetaOptions) (XMLClientGetComplexTypeRefWithMetaResponse, error) {
	req, err := client.getComplexTypeRefWithMetaCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetComplexTypeRefWithMetaResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetComplexTypeRefWithMetaResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetComplexTypeRefWithMetaResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComplexTypeRefWithMetaHandleResponse(resp)
}

// getComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *XMLClient) getComplexTypeRefWithMetaCreateRequest(ctx context.Context, options *XMLClientGetComplexTypeRefWithMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleResponse(resp *http.Response) (XMLClientGetComplexTypeRefWithMetaResponse, error) {
	result := XMLClientGetComplexTypeRefWithMetaResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.RootWithRefAndMeta); err != nil {
		return XMLClientGetComplexTypeRefWithMetaResponse{}, err
	}
	return result, nil
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetEmptyChildElementOptions contains the optional parameters for the XMLClient.GetEmptyChildElement
// method.
func (client *XMLClient) GetEmptyChildElement(ctx context.Context, options *XMLClientGetEmptyChildElementOptions) (XMLClientGetEmptyChildElementResponse, error) {
	req, err := client.getEmptyChildElementCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetEmptyChildElementResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetEmptyChildElementResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetEmptyChildElementResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEmptyChildElementHandleResponse(resp)
}

// getEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *XMLClient) getEmptyChildElementCreateRequest(ctx context.Context, options *XMLClientGetEmptyChildElementOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *XMLClient) getEmptyChildElementHandleResponse(resp *http.Response) (XMLClientGetEmptyChildElementResponse, error) {
	result := XMLClientGetEmptyChildElementResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.Banana); err != nil {
		return XMLClientGetEmptyChildElementResponse{}, err
	}
	return result, nil
}

// GetEmptyList - Get an empty list.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetEmptyListOptions contains the optional parameters for the XMLClient.GetEmptyList method.
func (client *XMLClient) GetEmptyList(ctx context.Context, options *XMLClientGetEmptyListOptions) (XMLClientGetEmptyListResponse, error) {
	req, err := client.getEmptyListCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetEmptyListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetEmptyListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetEmptyListResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEmptyListHandleResponse(resp)
}

// getEmptyListCreateRequest creates the GetEmptyList request.
func (client *XMLClient) getEmptyListCreateRequest(ctx context.Context, options *XMLClientGetEmptyListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyListHandleResponse handles the GetEmptyList response.
func (client *XMLClient) getEmptyListHandleResponse(resp *http.Response) (XMLClientGetEmptyListResponse, error) {
	result := XMLClientGetEmptyListResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.Slideshow); err != nil {
		return XMLClientGetEmptyListResponse{}, err
	}
	return result, nil
}

// GetEmptyRootList - Gets an empty list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetEmptyRootListOptions contains the optional parameters for the XMLClient.GetEmptyRootList method.
func (client *XMLClient) GetEmptyRootList(ctx context.Context, options *XMLClientGetEmptyRootListOptions) (XMLClientGetEmptyRootListResponse, error) {
	req, err := client.getEmptyRootListCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetEmptyRootListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetEmptyRootListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetEmptyRootListResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEmptyRootListHandleResponse(resp)
}

// getEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *XMLClient) getEmptyRootListCreateRequest(ctx context.Context, options *XMLClientGetEmptyRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *XMLClient) getEmptyRootListHandleResponse(resp *http.Response) (XMLClientGetEmptyRootListResponse, error) {
	result := XMLClientGetEmptyRootListResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetEmptyRootListResponse{}, err
	}
	return result, nil
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetEmptyWrappedListsOptions contains the optional parameters for the XMLClient.GetEmptyWrappedLists
// method.
func (client *XMLClient) GetEmptyWrappedLists(ctx context.Context, options *XMLClientGetEmptyWrappedListsOptions) (XMLClientGetEmptyWrappedListsResponse, error) {
	req, err := client.getEmptyWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetEmptyWrappedListsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetEmptyWrappedListsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetEmptyWrappedListsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getEmptyWrappedListsHandleResponse(resp)
}

// getEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *XMLClient) getEmptyWrappedListsCreateRequest(ctx context.Context, options *XMLClientGetEmptyWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *XMLClient) getEmptyWrappedListsHandleResponse(resp *http.Response) (XMLClientGetEmptyWrappedListsResponse, error) {
	result := XMLClientGetEmptyWrappedListsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.AppleBarrel); err != nil {
		return XMLClientGetEmptyWrappedListsResponse{}, err
	}
	return result, nil
}

// GetHeaders - Get strongly-typed response headers.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetHeadersOptions contains the optional parameters for the XMLClient.GetHeaders method.
func (client *XMLClient) GetHeaders(ctx context.Context, options *XMLClientGetHeadersOptions) (XMLClientGetHeadersResponse, error) {
	req, err := client.getHeadersCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetHeadersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetHeadersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetHeadersResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHeadersHandleResponse(resp)
}

// getHeadersCreateRequest creates the GetHeaders request.
func (client *XMLClient) getHeadersCreateRequest(ctx context.Context, options *XMLClientGetHeadersOptions) (*policy.Request, error) {
	urlPath := "/xml/headers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// getHeadersHandleResponse handles the GetHeaders response.
func (client *XMLClient) getHeadersHandleResponse(resp *http.Response) (XMLClientGetHeadersResponse, error) {
	result := XMLClientGetHeadersResponse{}
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return result, nil
}

// GetRootList - Gets a list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetRootListOptions contains the optional parameters for the XMLClient.GetRootList method.
func (client *XMLClient) GetRootList(ctx context.Context, options *XMLClientGetRootListOptions) (XMLClientGetRootListResponse, error) {
	req, err := client.getRootListCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetRootListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetRootListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetRootListResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRootListHandleResponse(resp)
}

// getRootListCreateRequest creates the GetRootList request.
func (client *XMLClient) getRootListCreateRequest(ctx context.Context, options *XMLClientGetRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRootListHandleResponse handles the GetRootList response.
func (client *XMLClient) getRootListHandleResponse(resp *http.Response) (XMLClientGetRootListResponse, error) {
	result := XMLClientGetRootListResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetRootListResponse{}, err
	}
	return result, nil
}

// GetRootListSingleItem - Gets a list with a single item.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetRootListSingleItemOptions contains the optional parameters for the XMLClient.GetRootListSingleItem
// method.
func (client *XMLClient) GetRootListSingleItem(ctx context.Context, options *XMLClientGetRootListSingleItemOptions) (XMLClientGetRootListSingleItemResponse, error) {
	req, err := client.getRootListSingleItemCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetRootListSingleItemResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetRootListSingleItemResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetRootListSingleItemResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRootListSingleItemHandleResponse(resp)
}

// getRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *XMLClient) getRootListSingleItemCreateRequest(ctx context.Context, options *XMLClientGetRootListSingleItemOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *XMLClient) getRootListSingleItemHandleResponse(resp *http.Response) (XMLClientGetRootListSingleItemResponse, error) {
	result := XMLClientGetRootListSingleItemResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return XMLClientGetRootListSingleItemResponse{}, err
	}
	return result, nil
}

// GetServiceProperties - Gets storage service properties.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetServicePropertiesOptions contains the optional parameters for the XMLClient.GetServiceProperties
// method.
func (client *XMLClient) GetServiceProperties(ctx context.Context, options *XMLClientGetServicePropertiesOptions) (XMLClientGetServicePropertiesResponse, error) {
	req, err := client.getServicePropertiesCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetServicePropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetServicePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetServicePropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getServicePropertiesHandleResponse(resp)
}

// getServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *XMLClient) getServicePropertiesCreateRequest(ctx context.Context, options *XMLClientGetServicePropertiesOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *XMLClient) getServicePropertiesHandleResponse(resp *http.Response) (XMLClientGetServicePropertiesResponse, error) {
	result := XMLClientGetServicePropertiesResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.StorageServiceProperties); err != nil {
		return XMLClientGetServicePropertiesResponse{}, err
	}
	return result, nil
}

// GetSimple - Get a simple XML document
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetSimpleOptions contains the optional parameters for the XMLClient.GetSimple method.
func (client *XMLClient) GetSimple(ctx context.Context, options *XMLClientGetSimpleOptions) (XMLClientGetSimpleResponse, error) {
	req, err := client.getSimpleCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetSimpleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetSimpleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetSimpleResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSimpleHandleResponse(resp)
}

// getSimpleCreateRequest creates the GetSimple request.
func (client *XMLClient) getSimpleCreateRequest(ctx context.Context, options *XMLClientGetSimpleOptions) (*policy.Request, error) {
	urlPath := "/xml/simple"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getSimpleHandleResponse handles the GetSimple response.
func (client *XMLClient) getSimpleHandleResponse(resp *http.Response) (XMLClientGetSimpleResponse, error) {
	result := XMLClientGetSimpleResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.Slideshow); err != nil {
		return XMLClientGetSimpleResponse{}, err
	}
	return result, nil
}

// GetURI - Get an XML document with uri property
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetURIOptions contains the optional parameters for the XMLClient.GetURI method.
func (client *XMLClient) GetURI(ctx context.Context, options *XMLClientGetURIOptions) (XMLClientGetURIResponse, error) {
	req, err := client.getURICreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetURIResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetURIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetURIResponse{}, runtime.NewResponseError(resp)
	}
	return client.getURIHandleResponse(resp)
}

// getURICreateRequest creates the GetURI request.
func (client *XMLClient) getURICreateRequest(ctx context.Context, options *XMLClientGetURIOptions) (*policy.Request, error) {
	urlPath := "/xml/url"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getURIHandleResponse handles the GetURI response.
func (client *XMLClient) getURIHandleResponse(resp *http.Response) (XMLClientGetURIResponse, error) {
	result := XMLClientGetURIResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ModelWithURLProperty); err != nil {
		return XMLClientGetURIResponse{}, err
	}
	return result, nil
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetWrappedListsOptions contains the optional parameters for the XMLClient.GetWrappedLists method.
func (client *XMLClient) GetWrappedLists(ctx context.Context, options *XMLClientGetWrappedListsOptions) (XMLClientGetWrappedListsResponse, error) {
	req, err := client.getWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetWrappedListsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetWrappedListsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetWrappedListsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getWrappedListsHandleResponse(resp)
}

// getWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *XMLClient) getWrappedListsCreateRequest(ctx context.Context, options *XMLClientGetWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *XMLClient) getWrappedListsHandleResponse(resp *http.Response) (XMLClientGetWrappedListsResponse, error) {
	result := XMLClientGetWrappedListsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.AppleBarrel); err != nil {
		return XMLClientGetWrappedListsResponse{}, err
	}
	return result, nil
}

// GetXMsText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language'
// property being 'english' and its 'content' property being 'I am text'
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientGetXMsTextOptions contains the optional parameters for the XMLClient.GetXMsText method.
func (client *XMLClient) GetXMsText(ctx context.Context, options *XMLClientGetXMsTextOptions) (XMLClientGetXMsTextResponse, error) {
	req, err := client.getXMsTextCreateRequest(ctx, options)
	if err != nil {
		return XMLClientGetXMsTextResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientGetXMsTextResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientGetXMsTextResponse{}, runtime.NewResponseError(resp)
	}
	return client.getXMsTextHandleResponse(resp)
}

// getXMsTextCreateRequest creates the GetXMsText request.
func (client *XMLClient) getXMsTextCreateRequest(ctx context.Context, options *XMLClientGetXMsTextOptions) (*policy.Request, error) {
	urlPath := "/xml/x-ms-text"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getXMsTextHandleResponse handles the GetXMsText response.
func (client *XMLClient) getXMsTextHandleResponse(resp *http.Response) (XMLClientGetXMsTextResponse, error) {
	result := XMLClientGetXMsTextResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ObjectWithXMsTextProperty); err != nil {
		return XMLClientGetXMsTextResponse{}, err
	}
	return result, nil
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientJSONInputOptions contains the optional parameters for the XMLClient.JSONInput method.
func (client *XMLClient) JSONInput(ctx context.Context, properties JSONInput, options *XMLClientJSONInputOptions) (XMLClientJSONInputResponse, error) {
	req, err := client.jsonInputCreateRequest(ctx, properties, options)
	if err != nil {
		return XMLClientJSONInputResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientJSONInputResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientJSONInputResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientJSONInputResponse{}, nil
}

// jsonInputCreateRequest creates the JSONInput request.
func (client *XMLClient) jsonInputCreateRequest(ctx context.Context, properties JSONInput, options *XMLClientJSONInputOptions) (*policy.Request, error) {
	urlPath := "/xml/jsoninput"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, properties)
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientJSONOutputOptions contains the optional parameters for the XMLClient.JSONOutput method.
func (client *XMLClient) JSONOutput(ctx context.Context, options *XMLClientJSONOutputOptions) (XMLClientJSONOutputResponse, error) {
	req, err := client.jsonOutputCreateRequest(ctx, options)
	if err != nil {
		return XMLClientJSONOutputResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientJSONOutputResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientJSONOutputResponse{}, runtime.NewResponseError(resp)
	}
	return client.jsonOutputHandleResponse(resp)
}

// jsonOutputCreateRequest creates the JSONOutput request.
func (client *XMLClient) jsonOutputCreateRequest(ctx context.Context, options *XMLClientJSONOutputOptions) (*policy.Request, error) {
	urlPath := "/xml/jsonoutput"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// jsonOutputHandleResponse handles the JSONOutput response.
func (client *XMLClient) jsonOutputHandleResponse(resp *http.Response) (XMLClientJSONOutputResponse, error) {
	result := XMLClientJSONOutputResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.JSONOutput); err != nil {
		return XMLClientJSONOutputResponse{}, err
	}
	return result, nil
}

// ListBlobs - Lists blobs in a storage container.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientListBlobsOptions contains the optional parameters for the XMLClient.ListBlobs method.
func (client *XMLClient) ListBlobs(ctx context.Context, options *XMLClientListBlobsOptions) (XMLClientListBlobsResponse, error) {
	req, err := client.listBlobsCreateRequest(ctx, options)
	if err != nil {
		return XMLClientListBlobsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientListBlobsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientListBlobsResponse{}, runtime.NewResponseError(resp)
	}
	return client.listBlobsHandleResponse(resp)
}

// listBlobsCreateRequest creates the ListBlobs request.
func (client *XMLClient) listBlobsCreateRequest(ctx context.Context, options *XMLClientListBlobsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "list")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listBlobsHandleResponse handles the ListBlobs response.
func (client *XMLClient) listBlobsHandleResponse(resp *http.Response) (XMLClientListBlobsResponse, error) {
	result := XMLClientListBlobsResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ListBlobsResponse); err != nil {
		return XMLClientListBlobsResponse{}, err
	}
	return result, nil
}

// ListContainers - Lists containers in a storage account.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientListContainersOptions contains the optional parameters for the XMLClient.ListContainers method.
func (client *XMLClient) ListContainers(ctx context.Context, options *XMLClientListContainersOptions) (XMLClientListContainersResponse, error) {
	req, err := client.listContainersCreateRequest(ctx, options)
	if err != nil {
		return XMLClientListContainersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientListContainersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return XMLClientListContainersResponse{}, runtime.NewResponseError(resp)
	}
	return client.listContainersHandleResponse(resp)
}

// listContainersCreateRequest creates the ListContainers request.
func (client *XMLClient) listContainersCreateRequest(ctx context.Context, options *XMLClientListContainersOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "list")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listContainersHandleResponse handles the ListContainers response.
func (client *XMLClient) listContainersHandleResponse(resp *http.Response) (XMLClientListContainersResponse, error) {
	result := XMLClientListContainersResponse{}
	if err := runtime.UnmarshalAsXML(resp, &result.ListContainersResponse); err != nil {
		return XMLClientListContainersResponse{}, err
	}
	return result, nil
}

// PutACLs - Puts storage ACLs for a container.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutACLsOptions contains the optional parameters for the XMLClient.PutACLs method.
func (client *XMLClient) PutACLs(ctx context.Context, properties []*SignedIdentifier, options *XMLClientPutACLsOptions) (XMLClientPutACLsResponse, error) {
	req, err := client.putACLsCreateRequest(ctx, properties, options)
	if err != nil {
		return XMLClientPutACLsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutACLsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutACLsResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutACLsResponse{}, nil
}

// putACLsCreateRequest creates the PutACLs request.
func (client *XMLClient) putACLsCreateRequest(ctx context.Context, properties []*SignedIdentifier, options *XMLClientPutACLsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	type wrapper struct {
		XMLName    xml.Name             `xml:"SignedIdentifiers"`
		Properties *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Properties: &properties})
}

// PutBinary - Put an XML document with binary property
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutBinaryOptions contains the optional parameters for the XMLClient.PutBinary method.
func (client *XMLClient) PutBinary(ctx context.Context, slideshow ModelWithByteProperty, options *XMLClientPutBinaryOptions) (XMLClientPutBinaryResponse, error) {
	req, err := client.putBinaryCreateRequest(ctx, slideshow, options)
	if err != nil {
		return XMLClientPutBinaryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutBinaryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutBinaryResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutBinaryResponse{}, nil
}

// putBinaryCreateRequest creates the PutBinary request.
func (client *XMLClient) putBinaryCreateRequest(ctx context.Context, slideshow ModelWithByteProperty, options *XMLClientPutBinaryOptions) (*policy.Request, error) {
	urlPath := "/xml/bytes"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, slideshow)
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutComplexTypeRefNoMetaOptions contains the optional parameters for the XMLClient.PutComplexTypeRefNoMeta
// method.
func (client *XMLClient) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta, options *XMLClientPutComplexTypeRefNoMetaOptions) (XMLClientPutComplexTypeRefNoMetaResponse, error) {
	req, err := client.putComplexTypeRefNoMetaCreateRequest(ctx, model, options)
	if err != nil {
		return XMLClientPutComplexTypeRefNoMetaResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutComplexTypeRefNoMetaResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutComplexTypeRefNoMetaResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutComplexTypeRefNoMetaResponse{}, nil
}

// putComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *XMLClient) putComplexTypeRefNoMetaCreateRequest(ctx context.Context, model RootWithRefAndNoMeta, options *XMLClientPutComplexTypeRefNoMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, model)
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutComplexTypeRefWithMetaOptions contains the optional parameters for the XMLClient.PutComplexTypeRefWithMeta
// method.
func (client *XMLClient) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta, options *XMLClientPutComplexTypeRefWithMetaOptions) (XMLClientPutComplexTypeRefWithMetaResponse, error) {
	req, err := client.putComplexTypeRefWithMetaCreateRequest(ctx, model, options)
	if err != nil {
		return XMLClientPutComplexTypeRefWithMetaResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutComplexTypeRefWithMetaResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutComplexTypeRefWithMetaResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutComplexTypeRefWithMetaResponse{}, nil
}

// putComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *XMLClient) putComplexTypeRefWithMetaCreateRequest(ctx context.Context, model RootWithRefAndMeta, options *XMLClientPutComplexTypeRefWithMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, model)
}

// PutEmptyChildElement - Puts a value with an empty child element.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutEmptyChildElementOptions contains the optional parameters for the XMLClient.PutEmptyChildElement
// method.
func (client *XMLClient) PutEmptyChildElement(ctx context.Context, banana Banana, options *XMLClientPutEmptyChildElementOptions) (XMLClientPutEmptyChildElementResponse, error) {
	req, err := client.putEmptyChildElementCreateRequest(ctx, banana, options)
	if err != nil {
		return XMLClientPutEmptyChildElementResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutEmptyChildElementResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutEmptyChildElementResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutEmptyChildElementResponse{}, nil
}

// putEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *XMLClient) putEmptyChildElementCreateRequest(ctx context.Context, banana Banana, options *XMLClientPutEmptyChildElementOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, banana)
}

// PutEmptyList - Puts an empty list.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutEmptyListOptions contains the optional parameters for the XMLClient.PutEmptyList method.
func (client *XMLClient) PutEmptyList(ctx context.Context, slideshow Slideshow, options *XMLClientPutEmptyListOptions) (XMLClientPutEmptyListResponse, error) {
	req, err := client.putEmptyListCreateRequest(ctx, slideshow, options)
	if err != nil {
		return XMLClientPutEmptyListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutEmptyListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutEmptyListResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutEmptyListResponse{}, nil
}

// putEmptyListCreateRequest creates the PutEmptyList request.
func (client *XMLClient) putEmptyListCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLClientPutEmptyListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, slideshow)
}

// PutEmptyRootList - Puts an empty list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutEmptyRootListOptions contains the optional parameters for the XMLClient.PutEmptyRootList method.
func (client *XMLClient) PutEmptyRootList(ctx context.Context, bananas []*Banana, options *XMLClientPutEmptyRootListOptions) (XMLClientPutEmptyRootListResponse, error) {
	req, err := client.putEmptyRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return XMLClientPutEmptyRootListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutEmptyRootListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutEmptyRootListResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutEmptyRootListResponse{}, nil
}

// putEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *XMLClient) putEmptyRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutEmptyRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Bananas: &bananas})
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutEmptyWrappedListsOptions contains the optional parameters for the XMLClient.PutEmptyWrappedLists
// method.
func (client *XMLClient) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel, options *XMLClientPutEmptyWrappedListsOptions) (XMLClientPutEmptyWrappedListsResponse, error) {
	req, err := client.putEmptyWrappedListsCreateRequest(ctx, appleBarrel, options)
	if err != nil {
		return XMLClientPutEmptyWrappedListsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutEmptyWrappedListsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutEmptyWrappedListsResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutEmptyWrappedListsResponse{}, nil
}

// putEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *XMLClient) putEmptyWrappedListsCreateRequest(ctx context.Context, appleBarrel AppleBarrel, options *XMLClientPutEmptyWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, appleBarrel)
}

// PutRootList - Puts a list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutRootListOptions contains the optional parameters for the XMLClient.PutRootList method.
func (client *XMLClient) PutRootList(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListOptions) (XMLClientPutRootListResponse, error) {
	req, err := client.putRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return XMLClientPutRootListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutRootListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutRootListResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutRootListResponse{}, nil
}

// putRootListCreateRequest creates the PutRootList request.
func (client *XMLClient) putRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Bananas: &bananas})
}

// PutRootListSingleItem - Puts a list with a single item.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutRootListSingleItemOptions contains the optional parameters for the XMLClient.PutRootListSingleItem
// method.
func (client *XMLClient) PutRootListSingleItem(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListSingleItemOptions) (XMLClientPutRootListSingleItemResponse, error) {
	req, err := client.putRootListSingleItemCreateRequest(ctx, bananas, options)
	if err != nil {
		return XMLClientPutRootListSingleItemResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutRootListSingleItemResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutRootListSingleItemResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutRootListSingleItemResponse{}, nil
}

// putRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *XMLClient) putRootListSingleItemCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListSingleItemOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Bananas: &bananas})
}

// PutServiceProperties - Puts storage service properties.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutServicePropertiesOptions contains the optional parameters for the XMLClient.PutServiceProperties
// method.
func (client *XMLClient) PutServiceProperties(ctx context.Context, properties StorageServiceProperties, options *XMLClientPutServicePropertiesOptions) (XMLClientPutServicePropertiesResponse, error) {
	req, err := client.putServicePropertiesCreateRequest(ctx, properties, options)
	if err != nil {
		return XMLClientPutServicePropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutServicePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutServicePropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutServicePropertiesResponse{}, nil
}

// putServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *XMLClient) putServicePropertiesCreateRequest(ctx context.Context, properties StorageServiceProperties, options *XMLClientPutServicePropertiesOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsXML(req, properties)
}

// PutSimple - Put a simple XML document
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutSimpleOptions contains the optional parameters for the XMLClient.PutSimple method.
func (client *XMLClient) PutSimple(ctx context.Context, slideshow Slideshow, options *XMLClientPutSimpleOptions) (XMLClientPutSimpleResponse, error) {
	req, err := client.putSimpleCreateRequest(ctx, slideshow, options)
	if err != nil {
		return XMLClientPutSimpleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutSimpleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutSimpleResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutSimpleResponse{}, nil
}

// putSimpleCreateRequest creates the PutSimple request.
func (client *XMLClient) putSimpleCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLClientPutSimpleOptions) (*policy.Request, error) {
	urlPath := "/xml/simple"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, slideshow)
}

// PutURI - Put an XML document with uri property
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutURIOptions contains the optional parameters for the XMLClient.PutURI method.
func (client *XMLClient) PutURI(ctx context.Context, model ModelWithURLProperty, options *XMLClientPutURIOptions) (XMLClientPutURIResponse, error) {
	req, err := client.putURICreateRequest(ctx, model, options)
	if err != nil {
		return XMLClientPutURIResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutURIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutURIResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutURIResponse{}, nil
}

// putURICreateRequest creates the PutURI request.
func (client *XMLClient) putURICreateRequest(ctx context.Context, model ModelWithURLProperty, options *XMLClientPutURIOptions) (*policy.Request, error) {
	urlPath := "/xml/url"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, model)
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 1.0.0
// options - XMLClientPutWrappedListsOptions contains the optional parameters for the XMLClient.PutWrappedLists method.
func (client *XMLClient) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel, options *XMLClientPutWrappedListsOptions) (XMLClientPutWrappedListsResponse, error) {
	req, err := client.putWrappedListsCreateRequest(ctx, wrappedLists, options)
	if err != nil {
		return XMLClientPutWrappedListsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return XMLClientPutWrappedListsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return XMLClientPutWrappedListsResponse{}, runtime.NewResponseError(resp)
	}
	return XMLClientPutWrappedListsResponse{}, nil
}

// putWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *XMLClient) putWrappedListsCreateRequest(ctx context.Context, wrappedLists AppleBarrel, options *XMLClientPutWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, wrappedLists)
}
