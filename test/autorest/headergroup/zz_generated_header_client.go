// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package headergroup

import (
	"context"
	"encoding/base64"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"strconv"
	"time"
)

// HeaderClient contains the methods for the Header group.
// Don't use this type directly, use NewHeaderClient() instead.
type HeaderClient struct {
	con *Connection
}

// NewHeaderClient creates a new instance of HeaderClient with the specified values.
func NewHeaderClient(con *Connection) *HeaderClient {
	return &HeaderClient{con: con}
}

// CustomRequestID - Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) CustomRequestID(ctx context.Context, options *HeaderCustomRequestIDOptions) (HeaderCustomRequestIDResponse, error) {
	req, err := client.customRequestIDCreateRequest(ctx, options)
	if err != nil {
		return HeaderCustomRequestIDResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderCustomRequestIDResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderCustomRequestIDResponse{}, client.customRequestIDHandleError(resp)
	}
	return HeaderCustomRequestIDResponse{RawResponse: resp.Response}, nil
}

// customRequestIDCreateRequest creates the CustomRequestID request.
func (client *HeaderClient) customRequestIDCreateRequest(ctx context.Context, options *HeaderCustomRequestIDOptions) (*azcore.Request, error) {
	urlPath := "/header/custom/x-ms-client-request-id/9C4D50EE-2D56-4CD3-8152-34347DC9F2B0"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// customRequestIDHandleError handles the CustomRequestID error response.
func (client *HeaderClient) customRequestIDHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamBool - Send a post request with header values "scenario": "true", "value": true or "scenario": "false", "value": false
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamBool(ctx context.Context, scenario string, value bool, options *HeaderParamBoolOptions) (HeaderParamBoolResponse, error) {
	req, err := client.paramBoolCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamBoolResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamBoolResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamBoolResponse{}, client.paramBoolHandleError(resp)
	}
	return HeaderParamBoolResponse{RawResponse: resp.Response}, nil
}

// paramBoolCreateRequest creates the ParamBool request.
func (client *HeaderClient) paramBoolCreateRequest(ctx context.Context, scenario string, value bool, options *HeaderParamBoolOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/bool"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatBool(value))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramBoolHandleError handles the ParamBool error response.
func (client *HeaderClient) paramBoolHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamByte - Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamByte(ctx context.Context, scenario string, value []byte, options *HeaderParamByteOptions) (HeaderParamByteResponse, error) {
	req, err := client.paramByteCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamByteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamByteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamByteResponse{}, client.paramByteHandleError(resp)
	}
	return HeaderParamByteResponse{RawResponse: resp.Response}, nil
}

// paramByteCreateRequest creates the ParamByte request.
func (client *HeaderClient) paramByteCreateRequest(ctx context.Context, scenario string, value []byte, options *HeaderParamByteOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/byte"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", base64.StdEncoding.EncodeToString(value))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramByteHandleError handles the ParamByte error response.
func (client *HeaderClient) paramByteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamDate - Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario": "min", "value": "0001-01-01"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamDate(ctx context.Context, scenario string, value time.Time, options *HeaderParamDateOptions) (HeaderParamDateResponse, error) {
	req, err := client.paramDateCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamDateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamDateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamDateResponse{}, client.paramDateHandleError(resp)
	}
	return HeaderParamDateResponse{RawResponse: resp.Response}, nil
}

// paramDateCreateRequest creates the ParamDate request.
func (client *HeaderClient) paramDateCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderParamDateOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/date"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", value.Format("2006-01-02"))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramDateHandleError handles the ParamDate error response.
func (client *HeaderClient) paramDateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamDatetime - Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or "scenario": "min", "value": "0001-01-01T00:00:00Z"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamDatetime(ctx context.Context, scenario string, value time.Time, options *HeaderParamDatetimeOptions) (HeaderParamDatetimeResponse, error) {
	req, err := client.paramDatetimeCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamDatetimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamDatetimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamDatetimeResponse{}, client.paramDatetimeHandleError(resp)
	}
	return HeaderParamDatetimeResponse{RawResponse: resp.Response}, nil
}

// paramDatetimeCreateRequest creates the ParamDatetime request.
func (client *HeaderClient) paramDatetimeCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderParamDatetimeOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/datetime"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", value.Format(time.RFC3339Nano))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramDatetimeHandleError handles the ParamDatetime error response.
func (client *HeaderClient) paramDatetimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamDatetimeRFC1123 - Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56 GMT" or "scenario": "min", "value":
// "Mon, 01 Jan 0001 00:00:00 GMT"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderParamDatetimeRFC1123Options) (HeaderParamDatetimeRFC1123Response, error) {
	req, err := client.paramDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderParamDatetimeRFC1123Response{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamDatetimeRFC1123Response{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamDatetimeRFC1123Response{}, client.paramDatetimeRFC1123HandleError(resp)
	}
	return HeaderParamDatetimeRFC1123Response{RawResponse: resp.Response}, nil
}

// paramDatetimeRFC1123CreateRequest creates the ParamDatetimeRFC1123 request.
func (client *HeaderClient) paramDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderParamDatetimeRFC1123Options) (*azcore.Request, error) {
	urlPath := "/header/param/prim/datetimerfc1123"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	if options != nil && options.Value != nil {
		req.Header.Set("value", options.Value.Format(time.RFC1123))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramDatetimeRFC1123HandleError handles the ParamDatetimeRFC1123 error response.
func (client *HeaderClient) paramDatetimeRFC1123HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamDouble - Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario": "negative", "value": -3.0
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamDouble(ctx context.Context, scenario string, value float64, options *HeaderParamDoubleOptions) (HeaderParamDoubleResponse, error) {
	req, err := client.paramDoubleCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamDoubleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamDoubleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamDoubleResponse{}, client.paramDoubleHandleError(resp)
	}
	return HeaderParamDoubleResponse{RawResponse: resp.Response}, nil
}

// paramDoubleCreateRequest creates the ParamDouble request.
func (client *HeaderClient) paramDoubleCreateRequest(ctx context.Context, scenario string, value float64, options *HeaderParamDoubleOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/double"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatFloat(value, 'f', -1, 64))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramDoubleHandleError handles the ParamDouble error response.
func (client *HeaderClient) paramDoubleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamDuration - Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamDuration(ctx context.Context, scenario string, value string, options *HeaderParamDurationOptions) (HeaderParamDurationResponse, error) {
	req, err := client.paramDurationCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamDurationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamDurationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamDurationResponse{}, client.paramDurationHandleError(resp)
	}
	return HeaderParamDurationResponse{RawResponse: resp.Response}, nil
}

// paramDurationCreateRequest creates the ParamDuration request.
func (client *HeaderClient) paramDurationCreateRequest(ctx context.Context, scenario string, value string, options *HeaderParamDurationOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/duration"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", value)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramDurationHandleError handles the ParamDuration error response.
func (client *HeaderClient) paramDurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamEnum - Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario": "null", "value": null
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamEnum(ctx context.Context, scenario string, options *HeaderParamEnumOptions) (HeaderParamEnumResponse, error) {
	req, err := client.paramEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderParamEnumResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamEnumResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamEnumResponse{}, client.paramEnumHandleError(resp)
	}
	return HeaderParamEnumResponse{RawResponse: resp.Response}, nil
}

// paramEnumCreateRequest creates the ParamEnum request.
func (client *HeaderClient) paramEnumCreateRequest(ctx context.Context, scenario string, options *HeaderParamEnumOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/enum"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	if options != nil && options.Value != nil {
		req.Header.Set("value", string(*options.Value))
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramEnumHandleError handles the ParamEnum error response.
func (client *HeaderClient) paramEnumHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamExistingKey - Send a post request with header value "User-Agent": "overwrite"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamExistingKey(ctx context.Context, userAgent string, options *HeaderParamExistingKeyOptions) (HeaderParamExistingKeyResponse, error) {
	req, err := client.paramExistingKeyCreateRequest(ctx, userAgent, options)
	if err != nil {
		return HeaderParamExistingKeyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamExistingKeyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamExistingKeyResponse{}, client.paramExistingKeyHandleError(resp)
	}
	return HeaderParamExistingKeyResponse{RawResponse: resp.Response}, nil
}

// paramExistingKeyCreateRequest creates the ParamExistingKey request.
func (client *HeaderClient) paramExistingKeyCreateRequest(ctx context.Context, userAgent string, options *HeaderParamExistingKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/param/existingkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("User-Agent", userAgent)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramExistingKeyHandleError handles the ParamExistingKey error response.
func (client *HeaderClient) paramExistingKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamFloat - Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario": "negative", "value": -3.0
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamFloat(ctx context.Context, scenario string, value float32, options *HeaderParamFloatOptions) (HeaderParamFloatResponse, error) {
	req, err := client.paramFloatCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamFloatResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamFloatResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamFloatResponse{}, client.paramFloatHandleError(resp)
	}
	return HeaderParamFloatResponse{RawResponse: resp.Response}, nil
}

// paramFloatCreateRequest creates the ParamFloat request.
func (client *HeaderClient) paramFloatCreateRequest(ctx context.Context, scenario string, value float32, options *HeaderParamFloatOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/float"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatFloat(float64(value), 'f', -1, 32))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramFloatHandleError handles the ParamFloat error response.
func (client *HeaderClient) paramFloatHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamInteger - Send a post request with header values "scenario": "positive", "value": 1 or "scenario": "negative", "value": -2
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamInteger(ctx context.Context, scenario string, value int32, options *HeaderParamIntegerOptions) (HeaderParamIntegerResponse, error) {
	req, err := client.paramIntegerCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamIntegerResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamIntegerResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamIntegerResponse{}, client.paramIntegerHandleError(resp)
	}
	return HeaderParamIntegerResponse{RawResponse: resp.Response}, nil
}

// paramIntegerCreateRequest creates the ParamInteger request.
func (client *HeaderClient) paramIntegerCreateRequest(ctx context.Context, scenario string, value int32, options *HeaderParamIntegerOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/integer"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatInt(int64(value), 10))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramIntegerHandleError handles the ParamInteger error response.
func (client *HeaderClient) paramIntegerHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamLong - Send a post request with header values "scenario": "positive", "value": 105 or "scenario": "negative", "value": -2
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamLong(ctx context.Context, scenario string, value int64, options *HeaderParamLongOptions) (HeaderParamLongResponse, error) {
	req, err := client.paramLongCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return HeaderParamLongResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamLongResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamLongResponse{}, client.paramLongHandleError(resp)
	}
	return HeaderParamLongResponse{RawResponse: resp.Response}, nil
}

// paramLongCreateRequest creates the ParamLong request.
func (client *HeaderClient) paramLongCreateRequest(ctx context.Context, scenario string, value int64, options *HeaderParamLongOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/long"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("value", strconv.FormatInt(value, 10))
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramLongHandleError handles the ParamLong error response.
func (client *HeaderClient) paramLongHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamProtectedKey - Send a post request with header value "Content-Type": "text/html"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamProtectedKey(ctx context.Context, contentType string, options *HeaderParamProtectedKeyOptions) (HeaderParamProtectedKeyResponse, error) {
	req, err := client.paramProtectedKeyCreateRequest(ctx, contentType, options)
	if err != nil {
		return HeaderParamProtectedKeyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamProtectedKeyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamProtectedKeyResponse{}, client.paramProtectedKeyHandleError(resp)
	}
	return HeaderParamProtectedKeyResponse{RawResponse: resp.Response}, nil
}

// paramProtectedKeyCreateRequest creates the ParamProtectedKey request.
func (client *HeaderClient) paramProtectedKeyCreateRequest(ctx context.Context, contentType string, options *HeaderParamProtectedKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/param/protectedkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramProtectedKeyHandleError handles the ParamProtectedKey error response.
func (client *HeaderClient) paramProtectedKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ParamString - Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps over the lazy dog" or "scenario": "null",
// "value": null or "scenario": "empty", "value": ""
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ParamString(ctx context.Context, scenario string, options *HeaderParamStringOptions) (HeaderParamStringResponse, error) {
	req, err := client.paramStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderParamStringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderParamStringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderParamStringResponse{}, client.paramStringHandleError(resp)
	}
	return HeaderParamStringResponse{RawResponse: resp.Response}, nil
}

// paramStringCreateRequest creates the ParamString request.
func (client *HeaderClient) paramStringCreateRequest(ctx context.Context, scenario string, options *HeaderParamStringOptions) (*azcore.Request, error) {
	urlPath := "/header/param/prim/string"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	if options != nil && options.Value != nil {
		req.Header.Set("value", *options.Value)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// paramStringHandleError handles the ParamString error response.
func (client *HeaderClient) paramStringHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseBool - Get a response with header value "value": true or false
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseBool(ctx context.Context, scenario string, options *HeaderResponseBoolOptions) (HeaderResponseBoolResponse, error) {
	req, err := client.responseBoolCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseBoolResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseBoolResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseBoolResponse{}, client.responseBoolHandleError(resp)
	}
	return client.responseBoolHandleResponse(resp)
}

// responseBoolCreateRequest creates the ResponseBool request.
func (client *HeaderClient) responseBoolCreateRequest(ctx context.Context, scenario string, options *HeaderResponseBoolOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/bool"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseBoolHandleResponse handles the ResponseBool response.
func (client *HeaderClient) responseBoolHandleResponse(resp *azcore.Response) (HeaderResponseBoolResponse, error) {
	result := HeaderResponseBoolResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseBool(val)
		if err != nil {
			return HeaderResponseBoolResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseBoolHandleError handles the ResponseBool error response.
func (client *HeaderClient) responseBoolHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseByte - Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseByte(ctx context.Context, scenario string, options *HeaderResponseByteOptions) (HeaderResponseByteResponse, error) {
	req, err := client.responseByteCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseByteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseByteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseByteResponse{}, client.responseByteHandleError(resp)
	}
	return client.responseByteHandleResponse(resp)
}

// responseByteCreateRequest creates the ResponseByte request.
func (client *HeaderClient) responseByteCreateRequest(ctx context.Context, scenario string, options *HeaderResponseByteOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/byte"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseByteHandleResponse handles the ResponseByte response.
func (client *HeaderClient) responseByteHandleResponse(resp *azcore.Response) (HeaderResponseByteResponse, error) {
	result := HeaderResponseByteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return HeaderResponseByteResponse{}, err
		}
		result.Value = value
	}
	return result, nil
}

// responseByteHandleError handles the ResponseByte error response.
func (client *HeaderClient) responseByteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseDate - Get a response with header values "2010-01-01" or "0001-01-01"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseDate(ctx context.Context, scenario string, options *HeaderResponseDateOptions) (HeaderResponseDateResponse, error) {
	req, err := client.responseDateCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseDateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseDateResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseDateResponse{}, client.responseDateHandleError(resp)
	}
	return client.responseDateHandleResponse(resp)
}

// responseDateCreateRequest creates the ResponseDate request.
func (client *HeaderClient) responseDateCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDateOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/date"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseDateHandleResponse handles the ResponseDate response.
func (client *HeaderClient) responseDateHandleResponse(resp *azcore.Response) (HeaderResponseDateResponse, error) {
	result := HeaderResponseDateResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse("2006-01-02", val)
		if err != nil {
			return HeaderResponseDateResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseDateHandleError handles the ResponseDate error response.
func (client *HeaderClient) responseDateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseDatetime - Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseDatetime(ctx context.Context, scenario string, options *HeaderResponseDatetimeOptions) (HeaderResponseDatetimeResponse, error) {
	req, err := client.responseDatetimeCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseDatetimeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseDatetimeResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseDatetimeResponse{}, client.responseDatetimeHandleError(resp)
	}
	return client.responseDatetimeHandleResponse(resp)
}

// responseDatetimeCreateRequest creates the ResponseDatetime request.
func (client *HeaderClient) responseDatetimeCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDatetimeOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/datetime"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseDatetimeHandleResponse handles the ResponseDatetime response.
func (client *HeaderClient) responseDatetimeHandleResponse(resp *azcore.Response) (HeaderResponseDatetimeResponse, error) {
	result := HeaderResponseDatetimeResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC3339Nano, val)
		if err != nil {
			return HeaderResponseDatetimeResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseDatetimeHandleError handles the ResponseDatetime error response.
func (client *HeaderClient) responseDatetimeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseDatetimeRFC1123 - Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00 GMT"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderResponseDatetimeRFC1123Options) (HeaderResponseDatetimeRFC1123Response, error) {
	req, err := client.responseDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseDatetimeRFC1123Response{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseDatetimeRFC1123Response{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseDatetimeRFC1123Response{}, client.responseDatetimeRFC1123HandleError(resp)
	}
	return client.responseDatetimeRFC1123HandleResponse(resp)
}

// responseDatetimeRFC1123CreateRequest creates the ResponseDatetimeRFC1123 request.
func (client *HeaderClient) responseDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderResponseDatetimeRFC1123Options) (*azcore.Request, error) {
	urlPath := "/header/response/prim/datetimerfc1123"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseDatetimeRFC1123HandleResponse handles the ResponseDatetimeRFC1123 response.
func (client *HeaderClient) responseDatetimeRFC1123HandleResponse(resp *azcore.Response) (HeaderResponseDatetimeRFC1123Response, error) {
	result := HeaderResponseDatetimeRFC1123Response{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return HeaderResponseDatetimeRFC1123Response{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseDatetimeRFC1123HandleError handles the ResponseDatetimeRFC1123 error response.
func (client *HeaderClient) responseDatetimeRFC1123HandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseDouble - Get a response with header value "value": 7e120 or -3.0
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseDouble(ctx context.Context, scenario string, options *HeaderResponseDoubleOptions) (HeaderResponseDoubleResponse, error) {
	req, err := client.responseDoubleCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseDoubleResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseDoubleResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseDoubleResponse{}, client.responseDoubleHandleError(resp)
	}
	return client.responseDoubleHandleResponse(resp)
}

// responseDoubleCreateRequest creates the ResponseDouble request.
func (client *HeaderClient) responseDoubleCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDoubleOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/double"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseDoubleHandleResponse handles the ResponseDouble response.
func (client *HeaderClient) responseDoubleHandleResponse(resp *azcore.Response) (HeaderResponseDoubleResponse, error) {
	result := HeaderResponseDoubleResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseFloat(val, 64)
		if err != nil {
			return HeaderResponseDoubleResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseDoubleHandleError handles the ResponseDouble error response.
func (client *HeaderClient) responseDoubleHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseDuration - Get a response with header values "P123DT22H14M12.011S"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseDuration(ctx context.Context, scenario string, options *HeaderResponseDurationOptions) (HeaderResponseDurationResponse, error) {
	req, err := client.responseDurationCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseDurationResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseDurationResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseDurationResponse{}, client.responseDurationHandleError(resp)
	}
	return client.responseDurationHandleResponse(resp)
}

// responseDurationCreateRequest creates the ResponseDuration request.
func (client *HeaderClient) responseDurationCreateRequest(ctx context.Context, scenario string, options *HeaderResponseDurationOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/duration"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseDurationHandleResponse handles the ResponseDuration response.
func (client *HeaderClient) responseDurationHandleResponse(resp *azcore.Response) (HeaderResponseDurationResponse, error) {
	result := HeaderResponseDurationResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return result, nil
}

// responseDurationHandleError handles the ResponseDuration error response.
func (client *HeaderClient) responseDurationHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseEnum - Get a response with header values "GREY" or null
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseEnum(ctx context.Context, scenario string, options *HeaderResponseEnumOptions) (HeaderResponseEnumResponse, error) {
	req, err := client.responseEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseEnumResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseEnumResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseEnumResponse{}, client.responseEnumHandleError(resp)
	}
	return client.responseEnumHandleResponse(resp)
}

// responseEnumCreateRequest creates the ResponseEnum request.
func (client *HeaderClient) responseEnumCreateRequest(ctx context.Context, scenario string, options *HeaderResponseEnumOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/enum"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseEnumHandleResponse handles the ResponseEnum response.
func (client *HeaderClient) responseEnumHandleResponse(resp *azcore.Response) (HeaderResponseEnumResponse, error) {
	result := HeaderResponseEnumResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = (*GreyscaleColors)(&val)
	}
	return result, nil
}

// responseEnumHandleError handles the ResponseEnum error response.
func (client *HeaderClient) responseEnumHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseExistingKey - Get a response with header value "User-Agent": "overwrite"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseExistingKey(ctx context.Context, options *HeaderResponseExistingKeyOptions) (HeaderResponseExistingKeyResponse, error) {
	req, err := client.responseExistingKeyCreateRequest(ctx, options)
	if err != nil {
		return HeaderResponseExistingKeyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseExistingKeyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseExistingKeyResponse{}, client.responseExistingKeyHandleError(resp)
	}
	return client.responseExistingKeyHandleResponse(resp)
}

// responseExistingKeyCreateRequest creates the ResponseExistingKey request.
func (client *HeaderClient) responseExistingKeyCreateRequest(ctx context.Context, options *HeaderResponseExistingKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/response/existingkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseExistingKeyHandleResponse handles the ResponseExistingKey response.
func (client *HeaderClient) responseExistingKeyHandleResponse(resp *azcore.Response) (HeaderResponseExistingKeyResponse, error) {
	result := HeaderResponseExistingKeyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("User-Agent"); val != "" {
		result.UserAgent = &val
	}
	return result, nil
}

// responseExistingKeyHandleError handles the ResponseExistingKey error response.
func (client *HeaderClient) responseExistingKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseFloat - Get a response with header value "value": 0.07 or -3.0
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseFloat(ctx context.Context, scenario string, options *HeaderResponseFloatOptions) (HeaderResponseFloatResponse, error) {
	req, err := client.responseFloatCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseFloatResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseFloatResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseFloatResponse{}, client.responseFloatHandleError(resp)
	}
	return client.responseFloatHandleResponse(resp)
}

// responseFloatCreateRequest creates the ResponseFloat request.
func (client *HeaderClient) responseFloatCreateRequest(ctx context.Context, scenario string, options *HeaderResponseFloatOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/float"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseFloatHandleResponse handles the ResponseFloat response.
func (client *HeaderClient) responseFloatHandleResponse(resp *azcore.Response) (HeaderResponseFloatResponse, error) {
	result := HeaderResponseFloatResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseFloat(val, 32)
		value := float32(value32)
		if err != nil {
			return HeaderResponseFloatResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseFloatHandleError handles the ResponseFloat error response.
func (client *HeaderClient) responseFloatHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseInteger - Get a response with header value "value": 1 or -2
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseInteger(ctx context.Context, scenario string, options *HeaderResponseIntegerOptions) (HeaderResponseIntegerResponse, error) {
	req, err := client.responseIntegerCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseIntegerResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseIntegerResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseIntegerResponse{}, client.responseIntegerHandleError(resp)
	}
	return client.responseIntegerHandleResponse(resp)
}

// responseIntegerCreateRequest creates the ResponseInteger request.
func (client *HeaderClient) responseIntegerCreateRequest(ctx context.Context, scenario string, options *HeaderResponseIntegerOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/integer"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseIntegerHandleResponse handles the ResponseInteger response.
func (client *HeaderClient) responseIntegerHandleResponse(resp *azcore.Response) (HeaderResponseIntegerResponse, error) {
	result := HeaderResponseIntegerResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseInt(val, 10, 32)
		value := int32(value32)
		if err != nil {
			return HeaderResponseIntegerResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseIntegerHandleError handles the ResponseInteger error response.
func (client *HeaderClient) responseIntegerHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseLong - Get a response with header value "value": 105 or -2
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseLong(ctx context.Context, scenario string, options *HeaderResponseLongOptions) (HeaderResponseLongResponse, error) {
	req, err := client.responseLongCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseLongResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseLongResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseLongResponse{}, client.responseLongHandleError(resp)
	}
	return client.responseLongHandleResponse(resp)
}

// responseLongCreateRequest creates the ResponseLong request.
func (client *HeaderClient) responseLongCreateRequest(ctx context.Context, scenario string, options *HeaderResponseLongOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/long"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseLongHandleResponse handles the ResponseLong response.
func (client *HeaderClient) responseLongHandleResponse(resp *azcore.Response) (HeaderResponseLongResponse, error) {
	result := HeaderResponseLongResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return HeaderResponseLongResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// responseLongHandleError handles the ResponseLong error response.
func (client *HeaderClient) responseLongHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseProtectedKey - Get a response with header value "Content-Type": "text/html"
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseProtectedKey(ctx context.Context, options *HeaderResponseProtectedKeyOptions) (HeaderResponseProtectedKeyResponse, error) {
	req, err := client.responseProtectedKeyCreateRequest(ctx, options)
	if err != nil {
		return HeaderResponseProtectedKeyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseProtectedKeyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseProtectedKeyResponse{}, client.responseProtectedKeyHandleError(resp)
	}
	return client.responseProtectedKeyHandleResponse(resp)
}

// responseProtectedKeyCreateRequest creates the ResponseProtectedKey request.
func (client *HeaderClient) responseProtectedKeyCreateRequest(ctx context.Context, options *HeaderResponseProtectedKeyOptions) (*azcore.Request, error) {
	urlPath := "/header/response/protectedkey"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseProtectedKeyHandleResponse handles the ResponseProtectedKey response.
func (client *HeaderClient) responseProtectedKeyHandleResponse(resp *azcore.Response) (HeaderResponseProtectedKeyResponse, error) {
	result := HeaderResponseProtectedKeyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// responseProtectedKeyHandleError handles the ResponseProtectedKey error response.
func (client *HeaderClient) responseProtectedKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ResponseString - Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
// If the operation fails it returns the *Error error type.
func (client *HeaderClient) ResponseString(ctx context.Context, scenario string, options *HeaderResponseStringOptions) (HeaderResponseStringResponse, error) {
	req, err := client.responseStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return HeaderResponseStringResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HeaderResponseStringResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HeaderResponseStringResponse{}, client.responseStringHandleError(resp)
	}
	return client.responseStringHandleResponse(resp)
}

// responseStringCreateRequest creates the ResponseString request.
func (client *HeaderClient) responseStringCreateRequest(ctx context.Context, scenario string, options *HeaderResponseStringOptions) (*azcore.Request, error) {
	urlPath := "/header/response/prim/string"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("scenario", scenario)
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// responseStringHandleResponse handles the ResponseString response.
func (client *HeaderClient) responseStringHandleResponse(resp *azcore.Response) (HeaderResponseStringResponse, error) {
	result := HeaderResponseStringResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return result, nil
}

// responseStringHandleError handles the ResponseString error response.
func (client *HeaderClient) responseStringHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := Error{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
